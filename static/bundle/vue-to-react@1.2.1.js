!(function(e) {
  if ("object" == typeof exports && "undefined" != typeof module)
    module.exports = e();
  else if ("function" == typeof define && define.amd) define([], e);
  else {
    ("undefined" != typeof window
      ? window
      : "undefined" != typeof global
      ? global
      : "undefined" != typeof self
      ? self
      : this
    )._w3cub_vueToReact = e();
  }
})(function() {
  return (function() {
    return function e(t, r, n) {
      function i(a, o) {
        if (!r[a]) {
          if (!t[a]) {
            var u = "function" == typeof require && require;
            if (!o && u) return u(a, !0);
            if (s) return s(a, !0);
            var l = new Error("Cannot find module '" + a + "'");
            throw ((l.code = "MODULE_NOT_FOUND"), l);
          }
          var c = (r[a] = { exports: {} });
          t[a][0].call(
            c.exports,
            function(e) {
              return i(t[a][1][e] || e);
            },
            c,
            c.exports,
            e,
            t,
            r,
            n
          );
        }
        return r[a].exports;
      }
      for (
        var s = "function" == typeof require && require, a = 0;
        a < n.length;
        a++
      )
        i(n[a]);
      return i;
    };
  })()(
    {
      1: [
        function(e, t, r) {
          (function(t) {
            "use strict";
            function n() {
              const t = (function(e) {
                if (e && e.__esModule) return e;
                var t = {};
                if (null != e)
                  for (var r in e)
                    if (Object.prototype.hasOwnProperty.call(e, r)) {
                      var n =
                        Object.defineProperty && Object.getOwnPropertyDescriptor
                          ? Object.getOwnPropertyDescriptor(e, r)
                          : {};
                      n.get || n.set
                        ? Object.defineProperty(t, r, n)
                        : (t[r] = e[r]);
                    }
                return (t.default = e), t;
              })(e("@babel/highlight"));
              return (
                (n = function() {
                  return t;
                }),
                t
              );
            }
            Object.defineProperty(r, "__esModule", { value: !0 }),
              (r.codeFrameColumns = a),
              (r.default = function(e, r, n, s = {}) {
                if (!i) {
                  i = !0;
                  const e =
                    "Passing lineNumber and colNumber is deprecated to @babel/code-frame. Please use `codeFrameColumns`.";
                  if (t.emitWarning) t.emitWarning(e, "DeprecationWarning");
                  else {
                    const t = new Error(e);
                    (t.name = "DeprecationWarning"), console.warn(new Error(e));
                  }
                }
                return (
                  (n = Math.max(n, 0)),
                  a(e, { start: { column: n, line: r } }, s)
                );
              });
            let i = !1;
            const s = /\r\n|[\n\r\u2028\u2029]/;
            function a(e, t, r = {}) {
              const i =
                  (r.highlightCode || r.forceColor) &&
                  (0, n().shouldHighlight)(r),
                a = (0, n().getChalk)(r),
                o = (function(e) {
                  return {
                    gutter: e.grey,
                    marker: e.red.bold,
                    message: e.red.bold
                  };
                })(a),
                u = (e, t) => (i ? e(t) : t),
                l = e.split(s),
                { start: c, end: p, markerLines: d } = (function(e, t, r) {
                  const n = Object.assign({ column: 0, line: -1 }, e.start),
                    i = Object.assign({}, n, e.end),
                    { linesAbove: s = 2, linesBelow: a = 3 } = r || {},
                    o = n.line,
                    u = n.column,
                    l = i.line,
                    c = i.column;
                  let p = Math.max(o - (s + 1), 0),
                    d = Math.min(t.length, l + a);
                  -1 === o && (p = 0), -1 === l && (d = t.length);
                  const h = l - o,
                    f = {};
                  if (h)
                    for (let e = 0; e <= h; e++) {
                      const r = e + o;
                      if (u)
                        if (0 === e) {
                          const e = t[r - 1].length;
                          f[r] = [u, e - u + 1];
                        } else if (e === h) f[r] = [0, c];
                        else {
                          const n = t[r - e].length;
                          f[r] = [0, n];
                        }
                      else f[r] = !0;
                    }
                  else f[o] = u === c ? !u || [u, 0] : [u, c - u];
                  return { start: p, end: d, markerLines: f };
                })(t, l, r),
                h = t.start && "number" == typeof t.start.column,
                f = String(p).length;
              let m = (i ? (0, n().default)(e, r) : e)
                .split(s)
                .slice(c, p)
                .map((e, t) => {
                  const n = c + 1 + t,
                    i = ` ${` ${n}`.slice(-f)} | `,
                    s = d[n],
                    a = !d[n + 1];
                  if (s) {
                    let t = "";
                    if (Array.isArray(s)) {
                      const n = e
                          .slice(0, Math.max(s[0] - 1, 0))
                          .replace(/[^\t]/g, " "),
                        l = s[1] || 1;
                      (t = [
                        "\n ",
                        u(o.gutter, i.replace(/\d/g, " ")),
                        n,
                        u(o.marker, "^").repeat(l)
                      ].join("")),
                        a && r.message && (t += " " + u(o.message, r.message));
                    }
                    return [u(o.marker, ">"), u(o.gutter, i), e, t].join("");
                  }
                  return ` ${u(o.gutter, i)}${e}`;
                })
                .join("\n");
              return (
                r.message &&
                  !h &&
                  (m = `${" ".repeat(f + 1)}${r.message}\n${m}`),
                i ? a.reset(m) : m
              );
            }
          }.call(this, e("_process")));
        },
        { "@babel/highlight": 24, _process: 331 }
      ],
      2: [
        function(e, t, r) {
          "use strict";
          function n() {
            const t =
              (r = e("trim-right")) && r.__esModule ? r : { default: r };
            var r;
            return (
              (n = function() {
                return t;
              }),
              t
            );
          }
          Object.defineProperty(r, "__esModule", { value: !0 }),
            (r.default = void 0);
          const i = /^[ \t]+$/;
          r.default = class {
            constructor(e) {
              (this._map = null),
                (this._buf = []),
                (this._last = ""),
                (this._queue = []),
                (this._position = { line: 1, column: 0 }),
                (this._sourcePosition = {
                  identifierName: null,
                  line: null,
                  column: null,
                  filename: null
                }),
                (this._disallowedPop = null),
                (this._map = e);
            }
            get() {
              this._flush();
              const e = this._map,
                t = {
                  code: (0, n().default)(this._buf.join("")),
                  map: null,
                  rawMappings: e && e.getRawMappings()
                };
              return (
                e &&
                  Object.defineProperty(t, "map", {
                    configurable: !0,
                    enumerable: !0,
                    get() {
                      return (this.map = e.get());
                    },
                    set(e) {
                      Object.defineProperty(this, "map", {
                        value: e,
                        writable: !0
                      });
                    }
                  }),
                t
              );
            }
            append(e) {
              this._flush();
              const {
                line: t,
                column: r,
                filename: n,
                identifierName: i,
                force: s
              } = this._sourcePosition;
              this._append(e, t, r, i, n, s);
            }
            queue(e) {
              if ("\n" === e)
                for (; this._queue.length > 0 && i.test(this._queue[0][0]); )
                  this._queue.shift();
              const {
                line: t,
                column: r,
                filename: n,
                identifierName: s,
                force: a
              } = this._sourcePosition;
              this._queue.unshift([e, t, r, s, n, a]);
            }
            _flush() {
              let e;
              for (; (e = this._queue.pop()); ) this._append(...e);
            }
            _append(e, t, r, n, i, s) {
              this._map &&
                "\n" !== e[0] &&
                this._map.mark(
                  this._position.line,
                  this._position.column,
                  t,
                  r,
                  n,
                  i,
                  s
                ),
                this._buf.push(e),
                (this._last = e[e.length - 1]);
              for (let t = 0; t < e.length; t++)
                "\n" === e[t]
                  ? (this._position.line++, (this._position.column = 0))
                  : this._position.column++;
            }
            removeTrailingNewline() {
              this._queue.length > 0 &&
                "\n" === this._queue[0][0] &&
                this._queue.shift();
            }
            removeLastSemicolon() {
              this._queue.length > 0 &&
                ";" === this._queue[0][0] &&
                this._queue.shift();
            }
            endsWith(e) {
              if (1 === e.length) {
                let t;
                if (this._queue.length > 0) {
                  const e = this._queue[0][0];
                  t = e[e.length - 1];
                } else t = this._last;
                return t === e;
              }
              const t = this._last + this._queue.reduce((e, t) => t[0] + e, "");
              return e.length <= t.length && t.slice(-e.length) === e;
            }
            hasContent() {
              return this._queue.length > 0 || !!this._last;
            }
            exactSource(e, t) {
              this.source("start", e, !0),
                t(),
                this.source("end", e),
                this._disallowPop("start", e);
            }
            source(e, t, r) {
              (e && !t) ||
                this._normalizePosition(e, t, this._sourcePosition, r);
            }
            withSource(e, t, r) {
              if (!this._map) return r();
              const n = this._sourcePosition.line,
                i = this._sourcePosition.column,
                s = this._sourcePosition.filename,
                a = this._sourcePosition.identifierName;
              this.source(e, t),
                r(),
                (this._sourcePosition.force &&
                  this._sourcePosition.line === n &&
                  this._sourcePosition.column === i &&
                  this._sourcePosition.filename === s) ||
                  (this._disallowedPop &&
                    this._disallowedPop.line === n &&
                    this._disallowedPop.column === i &&
                    this._disallowedPop.filename === s) ||
                  ((this._sourcePosition.line = n),
                  (this._sourcePosition.column = i),
                  (this._sourcePosition.filename = s),
                  (this._sourcePosition.identifierName = a),
                  (this._sourcePosition.force = !1),
                  (this._disallowedPop = null));
            }
            _disallowPop(e, t) {
              (e && !t) ||
                (this._disallowedPop = this._normalizePosition(e, t));
            }
            _normalizePosition(e, t, r, n) {
              const i = t ? t[e] : null;
              void 0 === r &&
                (r = {
                  identifierName: null,
                  line: null,
                  column: null,
                  filename: null,
                  force: !1
                });
              const s = r.line,
                a = r.column,
                o = r.filename;
              return (
                (r.identifierName =
                  ("start" === e && t && t.identifierName) || null),
                (r.line = i ? i.line : null),
                (r.column = i ? i.column : null),
                (r.filename = (t && t.filename) || null),
                (n || r.line !== s || r.column !== a || r.filename !== o) &&
                  (r.force = n),
                r
              );
            }
            getCurrentColumn() {
              const e = this._queue.reduce((e, t) => t[0] + e, ""),
                t = e.lastIndexOf("\n");
              return -1 === t
                ? this._position.column + e.length
                : e.length - 1 - t;
            }
            getCurrentLine() {
              const e = this._queue.reduce((e, t) => t[0] + e, "");
              let t = 0;
              for (let r = 0; r < e.length; r++) "\n" === e[r] && t++;
              return this._position.line + t;
            }
          };
        },
        { "trim-right": 317 }
      ],
      3: [
        function(e, t, r) {
          "use strict";
          Object.defineProperty(r, "__esModule", { value: !0 }),
            (r.File = function(e) {
              e.program && this.print(e.program.interpreter, e);
              this.print(e.program, e);
            }),
            (r.Program = function(e) {
              this.printInnerComments(e, !1),
                this.printSequence(e.directives, e),
                e.directives && e.directives.length && this.newline();
              this.printSequence(e.body, e);
            }),
            (r.BlockStatement = function(e) {
              this.token("{"), this.printInnerComments(e);
              const t = e.directives && e.directives.length;
              e.body.length || t
                ? (this.newline(),
                  this.printSequence(e.directives, e, { indent: !0 }),
                  t && this.newline(),
                  this.printSequence(e.body, e, { indent: !0 }),
                  this.removeTrailingNewline(),
                  this.source("end", e.loc),
                  this.endsWith("\n") || this.newline(),
                  this.rightBrace())
                : (this.source("end", e.loc), this.token("}"));
            }),
            (r.Noop = function() {}),
            (r.Directive = function(e) {
              this.print(e.value, e), this.semicolon();
            }),
            (r.DirectiveLiteral = function(e) {
              const t = this.getPossibleRaw(e);
              if (null != t) return void this.token(t);
              const { value: r } = e;
              if (i.test(r)) {
                if (n.test(r))
                  throw new Error(
                    "Malformed AST: it is not possible to print a directive containing both unescaped single and double quotes."
                  );
                this.token(`'${r}'`);
              } else this.token(`"${r}"`);
            }),
            (r.InterpreterDirective = function(e) {
              this.token(`#!${e.value}\n`);
            }),
            (r.Placeholder = function(e) {
              this.token("%%"),
                this.print(e.name),
                this.token("%%"),
                "Statement" === e.expectedNode && this.semicolon();
            });
          const n = /(?:^|[^\\])(?:\\\\)*'/,
            i = /(?:^|[^\\])(?:\\\\)*"/;
        },
        {}
      ],
      4: [
        function(e, t, r) {
          "use strict";
          function n() {
            const t = (function(e) {
              if (e && e.__esModule) return e;
              var t = {};
              if (null != e)
                for (var r in e)
                  if (Object.prototype.hasOwnProperty.call(e, r)) {
                    var n =
                      Object.defineProperty && Object.getOwnPropertyDescriptor
                        ? Object.getOwnPropertyDescriptor(e, r)
                        : {};
                    n.get || n.set
                      ? Object.defineProperty(t, r, n)
                      : (t[r] = e[r]);
                  }
              return (t.default = e), t;
            })(e("@babel/types"));
            return (
              (n = function() {
                return t;
              }),
              t
            );
          }
          Object.defineProperty(r, "__esModule", { value: !0 }),
            (r.ClassExpression = r.ClassDeclaration = function(e, t) {
              (this.format.decoratorsBeforeExport &&
                (n().isExportDefaultDeclaration(t) ||
                  n().isExportNamedDeclaration(t))) ||
                this.printJoin(e.decorators, e);
              e.declare && (this.word("declare"), this.space());
              e.abstract && (this.word("abstract"), this.space());
              this.word("class"), e.id && (this.space(), this.print(e.id, e));
              this.print(e.typeParameters, e),
                e.superClass &&
                  (this.space(),
                  this.word("extends"),
                  this.space(),
                  this.print(e.superClass, e),
                  this.print(e.superTypeParameters, e));
              e.implements &&
                (this.space(),
                this.word("implements"),
                this.space(),
                this.printList(e.implements, e));
              this.space(), this.print(e.body, e);
            }),
            (r.ClassBody = function(e) {
              this.token("{"),
                this.printInnerComments(e),
                0 === e.body.length
                  ? this.token("}")
                  : (this.newline(),
                    this.indent(),
                    this.printSequence(e.body, e),
                    this.dedent(),
                    this.endsWith("\n") || this.newline(),
                    this.rightBrace());
            }),
            (r.ClassProperty = function(e) {
              this.printJoin(e.decorators, e),
                e.accessibility && (this.word(e.accessibility), this.space());
              e.static && (this.word("static"), this.space());
              e.abstract && (this.word("abstract"), this.space());
              e.readonly && (this.word("readonly"), this.space());
              e.computed
                ? (this.token("["), this.print(e.key, e), this.token("]"))
                : (this._variance(e), this.print(e.key, e));
              e.optional && this.token("?");
              e.definite && this.token("!");
              this.print(e.typeAnnotation, e),
                e.value &&
                  (this.space(),
                  this.token("="),
                  this.space(),
                  this.print(e.value, e));
              this.semicolon();
            }),
            (r.ClassPrivateProperty = function(e) {
              e.static && (this.word("static"), this.space());
              this.print(e.key, e),
                this.print(e.typeAnnotation, e),
                e.value &&
                  (this.space(),
                  this.token("="),
                  this.space(),
                  this.print(e.value, e));
              this.semicolon();
            }),
            (r.ClassMethod = function(e) {
              this._classMethodHead(e), this.space(), this.print(e.body, e);
            }),
            (r.ClassPrivateMethod = function(e) {
              this._classMethodHead(e), this.space(), this.print(e.body, e);
            }),
            (r._classMethodHead = function(e) {
              this.printJoin(e.decorators, e),
                e.accessibility && (this.word(e.accessibility), this.space());
              e.abstract && (this.word("abstract"), this.space());
              e.static && (this.word("static"), this.space());
              this._methodHead(e);
            });
        },
        { "@babel/types": 100 }
      ],
      5: [
        function(e, t, r) {
          "use strict";
          function n() {
            const t = s(e("@babel/types"));
            return (
              (n = function() {
                return t;
              }),
              t
            );
          }
          Object.defineProperty(r, "__esModule", { value: !0 }),
            (r.UnaryExpression = function(e) {
              "void" === e.operator ||
              "delete" === e.operator ||
              "typeof" === e.operator ||
              "throw" === e.operator
                ? (this.word(e.operator), this.space())
                : this.token(e.operator);
              this.print(e.argument, e);
            }),
            (r.DoExpression = function(e) {
              this.word("do"), this.space(), this.print(e.body, e);
            }),
            (r.ParenthesizedExpression = function(e) {
              this.token("("), this.print(e.expression, e), this.token(")");
            }),
            (r.UpdateExpression = function(e) {
              e.prefix
                ? (this.token(e.operator), this.print(e.argument, e))
                : (this.startTerminatorless(!0),
                  this.print(e.argument, e),
                  this.endTerminatorless(),
                  this.token(e.operator));
            }),
            (r.ConditionalExpression = function(e) {
              this.print(e.test, e),
                this.space(),
                this.token("?"),
                this.space(),
                this.print(e.consequent, e),
                this.space(),
                this.token(":"),
                this.space(),
                this.print(e.alternate, e);
            }),
            (r.NewExpression = function(e, t) {
              if (
                (this.word("new"),
                this.space(),
                this.print(e.callee, e),
                this.format.minified &&
                  0 === e.arguments.length &&
                  !e.optional &&
                  !n().isCallExpression(t, { callee: e }) &&
                  !n().isMemberExpression(t) &&
                  !n().isNewExpression(t))
              )
                return;
              this.print(e.typeArguments, e),
                this.print(e.typeParameters, e),
                e.optional && this.token("?.");
              this.token("("), this.printList(e.arguments, e), this.token(")");
            }),
            (r.SequenceExpression = function(e) {
              this.printList(e.expressions, e);
            }),
            (r.ThisExpression = function() {
              this.word("this");
            }),
            (r.Super = function() {
              this.word("super");
            }),
            (r.Decorator = function(e) {
              this.token("@"), this.print(e.expression, e), this.newline();
            }),
            (r.OptionalMemberExpression = function(e) {
              if (
                (this.print(e.object, e),
                !e.computed && n().isMemberExpression(e.property))
              )
                throw new TypeError(
                  "Got a MemberExpression for MemberExpression property"
                );
              let t = e.computed;
              n().isLiteral(e.property) &&
                "number" == typeof e.property.value &&
                (t = !0);
              e.optional && this.token("?.");
              t
                ? (this.token("["), this.print(e.property, e), this.token("]"))
                : (e.optional || this.token("."), this.print(e.property, e));
            }),
            (r.OptionalCallExpression = function(e) {
              this.print(e.callee, e),
                this.print(e.typeArguments, e),
                this.print(e.typeParameters, e),
                e.optional && this.token("?.");
              this.token("("), this.printList(e.arguments, e), this.token(")");
            }),
            (r.CallExpression = function(e) {
              this.print(e.callee, e),
                this.print(e.typeArguments, e),
                this.print(e.typeParameters, e),
                this.token("("),
                this.printList(e.arguments, e),
                this.token(")");
            }),
            (r.Import = function() {
              this.word("import");
            }),
            (r.EmptyStatement = function() {
              this.semicolon(!0);
            }),
            (r.ExpressionStatement = function(e) {
              this.print(e.expression, e), this.semicolon();
            }),
            (r.AssignmentPattern = function(e) {
              this.print(e.left, e), e.left.optional && this.token("?");
              this.print(e.left.typeAnnotation, e),
                this.space(),
                this.token("="),
                this.space(),
                this.print(e.right, e);
            }),
            (r.LogicalExpression = r.BinaryExpression = r.AssignmentExpression = function(
              e,
              t
            ) {
              const r =
                this.inForStatementInitCounter &&
                "in" === e.operator &&
                !i.needsParens(e, t);
              r && this.token("(");
              this.print(e.left, e),
                this.space(),
                "in" === e.operator || "instanceof" === e.operator
                  ? this.word(e.operator)
                  : this.token(e.operator);
              this.space(), this.print(e.right, e), r && this.token(")");
            }),
            (r.BindExpression = function(e) {
              this.print(e.object, e),
                this.token("::"),
                this.print(e.callee, e);
            }),
            (r.MemberExpression = function(e) {
              if (
                (this.print(e.object, e),
                !e.computed && n().isMemberExpression(e.property))
              )
                throw new TypeError(
                  "Got a MemberExpression for MemberExpression property"
                );
              let t = e.computed;
              n().isLiteral(e.property) &&
                "number" == typeof e.property.value &&
                (t = !0);
              t
                ? (this.token("["), this.print(e.property, e), this.token("]"))
                : (this.token("."), this.print(e.property, e));
            }),
            (r.MetaProperty = function(e) {
              this.print(e.meta, e), this.token("."), this.print(e.property, e);
            }),
            (r.PrivateName = function(e) {
              this.token("#"), this.print(e.id, e);
            }),
            (r.AwaitExpression = r.YieldExpression = void 0);
          var i = s(e("../node"));
          function s(e) {
            if (e && e.__esModule) return e;
            var t = {};
            if (null != e)
              for (var r in e)
                if (Object.prototype.hasOwnProperty.call(e, r)) {
                  var n =
                    Object.defineProperty && Object.getOwnPropertyDescriptor
                      ? Object.getOwnPropertyDescriptor(e, r)
                      : {};
                  n.get || n.set
                    ? Object.defineProperty(t, r, n)
                    : (t[r] = e[r]);
                }
            return (t.default = e), t;
          }
          function a(e) {
            return function(t) {
              if ((this.word(e), t.delegate && this.token("*"), t.argument)) {
                this.space();
                const e = this.startTerminatorless();
                this.print(t.argument, t), this.endTerminatorless(e);
              }
            };
          }
          const o = a("yield");
          r.YieldExpression = o;
          const u = a("await");
          r.AwaitExpression = u;
        },
        { "../node": 16, "@babel/types": 100 }
      ],
      6: [
        function(e, t, r) {
          "use strict";
          function n() {
            const t = (function(e) {
              if (e && e.__esModule) return e;
              var t = {};
              if (null != e)
                for (var r in e)
                  if (Object.prototype.hasOwnProperty.call(e, r)) {
                    var n =
                      Object.defineProperty && Object.getOwnPropertyDescriptor
                        ? Object.getOwnPropertyDescriptor(e, r)
                        : {};
                    n.get || n.set
                      ? Object.defineProperty(t, r, n)
                      : (t[r] = e[r]);
                  }
              return (t.default = e), t;
            })(e("@babel/types"));
            return (
              (n = function() {
                return t;
              }),
              t
            );
          }
          Object.defineProperty(r, "__esModule", { value: !0 }),
            (r.AnyTypeAnnotation = function() {
              this.word("any");
            }),
            (r.ArrayTypeAnnotation = function(e) {
              this.print(e.elementType, e), this.token("["), this.token("]");
            }),
            (r.BooleanTypeAnnotation = function() {
              this.word("boolean");
            }),
            (r.BooleanLiteralTypeAnnotation = function(e) {
              this.word(e.value ? "true" : "false");
            }),
            (r.NullLiteralTypeAnnotation = function() {
              this.word("null");
            }),
            (r.DeclareClass = function(e, t) {
              n().isDeclareExportDeclaration(t) ||
                (this.word("declare"), this.space());
              this.word("class"), this.space(), this._interfaceish(e);
            }),
            (r.DeclareFunction = function(e, t) {
              n().isDeclareExportDeclaration(t) ||
                (this.word("declare"), this.space());
              this.word("function"),
                this.space(),
                this.print(e.id, e),
                this.print(e.id.typeAnnotation.typeAnnotation, e),
                e.predicate && (this.space(), this.print(e.predicate, e));
              this.semicolon();
            }),
            (r.InferredPredicate = function() {
              this.token("%"), this.word("checks");
            }),
            (r.DeclaredPredicate = function(e) {
              this.token("%"),
                this.word("checks"),
                this.token("("),
                this.print(e.value, e),
                this.token(")");
            }),
            (r.DeclareInterface = function(e) {
              this.word("declare"), this.space(), this.InterfaceDeclaration(e);
            }),
            (r.DeclareModule = function(e) {
              this.word("declare"),
                this.space(),
                this.word("module"),
                this.space(),
                this.print(e.id, e),
                this.space(),
                this.print(e.body, e);
            }),
            (r.DeclareModuleExports = function(e) {
              this.word("declare"),
                this.space(),
                this.word("module"),
                this.token("."),
                this.word("exports"),
                this.print(e.typeAnnotation, e);
            }),
            (r.DeclareTypeAlias = function(e) {
              this.word("declare"), this.space(), this.TypeAlias(e);
            }),
            (r.DeclareOpaqueType = function(e, t) {
              n().isDeclareExportDeclaration(t) ||
                (this.word("declare"), this.space());
              this.OpaqueType(e);
            }),
            (r.DeclareVariable = function(e, t) {
              n().isDeclareExportDeclaration(t) ||
                (this.word("declare"), this.space());
              this.word("var"),
                this.space(),
                this.print(e.id, e),
                this.print(e.id.typeAnnotation, e),
                this.semicolon();
            }),
            (r.DeclareExportDeclaration = function(e) {
              this.word("declare"),
                this.space(),
                this.word("export"),
                this.space(),
                e.default && (this.word("default"), this.space());
              (function(e) {
                if (e.declaration) {
                  const t = e.declaration;
                  this.print(t, e), n().isStatement(t) || this.semicolon();
                } else
                  this.token("{"),
                    e.specifiers.length &&
                      (this.space(),
                      this.printList(e.specifiers, e),
                      this.space()),
                    this.token("}"),
                    e.source &&
                      (this.space(),
                      this.word("from"),
                      this.space(),
                      this.print(e.source, e)),
                    this.semicolon();
              }.apply(this, arguments));
            }),
            (r.DeclareExportAllDeclaration = function() {
              this.word("declare"),
                this.space(),
                i.ExportAllDeclaration.apply(this, arguments);
            }),
            (r.ExistsTypeAnnotation = function() {
              this.token("*");
            }),
            (r.FunctionTypeAnnotation = function(e, t) {
              this.print(e.typeParameters, e),
                this.token("("),
                this.printList(e.params, e),
                e.rest &&
                  (e.params.length && (this.token(","), this.space()),
                  this.token("..."),
                  this.print(e.rest, e));
              this.token(")"),
                "ObjectTypeCallProperty" === t.type ||
                "DeclareFunction" === t.type ||
                ("ObjectTypeProperty" === t.type && t.method)
                  ? this.token(":")
                  : (this.space(), this.token("=>"));
              this.space(), this.print(e.returnType, e);
            }),
            (r.FunctionTypeParam = function(e) {
              this.print(e.name, e), e.optional && this.token("?");
              e.name && (this.token(":"), this.space());
              this.print(e.typeAnnotation, e);
            }),
            (r.GenericTypeAnnotation = r.ClassImplements = r.InterfaceExtends = function(
              e
            ) {
              this.print(e.id, e), this.print(e.typeParameters, e);
            }),
            (r._interfaceish = function(e) {
              this.print(e.id, e),
                this.print(e.typeParameters, e),
                e.extends.length &&
                  (this.space(),
                  this.word("extends"),
                  this.space(),
                  this.printList(e.extends, e));
              e.mixins &&
                e.mixins.length &&
                (this.space(),
                this.word("mixins"),
                this.space(),
                this.printList(e.mixins, e));
              e.implements &&
                e.implements.length &&
                (this.space(),
                this.word("implements"),
                this.space(),
                this.printList(e.implements, e));
              this.space(), this.print(e.body, e);
            }),
            (r._variance = function(e) {
              e.variance &&
                ("plus" === e.variance.kind
                  ? this.token("+")
                  : "minus" === e.variance.kind && this.token("-"));
            }),
            (r.InterfaceDeclaration = function(e) {
              this.word("interface"), this.space(), this._interfaceish(e);
            }),
            (r.InterfaceTypeAnnotation = function(e) {
              this.word("interface"),
                e.extends &&
                  e.extends.length &&
                  (this.space(),
                  this.word("extends"),
                  this.space(),
                  this.printList(e.extends, e));
              this.space(), this.print(e.body, e);
            }),
            (r.IntersectionTypeAnnotation = function(e) {
              this.printJoin(e.types, e, { separator: a });
            }),
            (r.MixedTypeAnnotation = function() {
              this.word("mixed");
            }),
            (r.EmptyTypeAnnotation = function() {
              this.word("empty");
            }),
            (r.NullableTypeAnnotation = function(e) {
              this.token("?"), this.print(e.typeAnnotation, e);
            }),
            (r.NumberTypeAnnotation = function() {
              this.word("number");
            }),
            (r.StringTypeAnnotation = function() {
              this.word("string");
            }),
            (r.ThisTypeAnnotation = function() {
              this.word("this");
            }),
            (r.TupleTypeAnnotation = function(e) {
              this.token("["), this.printList(e.types, e), this.token("]");
            }),
            (r.TypeofTypeAnnotation = function(e) {
              this.word("typeof"), this.space(), this.print(e.argument, e);
            }),
            (r.TypeAlias = function(e) {
              this.word("type"),
                this.space(),
                this.print(e.id, e),
                this.print(e.typeParameters, e),
                this.space(),
                this.token("="),
                this.space(),
                this.print(e.right, e),
                this.semicolon();
            }),
            (r.TypeAnnotation = function(e) {
              this.token(":"), this.space(), e.optional && this.token("?");
              this.print(e.typeAnnotation, e);
            }),
            (r.TypeParameterDeclaration = r.TypeParameterInstantiation = function(
              e
            ) {
              this.token("<"), this.printList(e.params, e, {}), this.token(">");
            }),
            (r.TypeParameter = function(e) {
              this._variance(e),
                this.word(e.name),
                e.bound && this.print(e.bound, e);
              e.default &&
                (this.space(),
                this.token("="),
                this.space(),
                this.print(e.default, e));
            }),
            (r.OpaqueType = function(e) {
              this.word("opaque"),
                this.space(),
                this.word("type"),
                this.space(),
                this.print(e.id, e),
                this.print(e.typeParameters, e),
                e.supertype &&
                  (this.token(":"), this.space(), this.print(e.supertype, e));
              e.impltype &&
                (this.space(),
                this.token("="),
                this.space(),
                this.print(e.impltype, e));
              this.semicolon();
            }),
            (r.ObjectTypeAnnotation = function(e) {
              e.exact ? this.token("{|") : this.token("{");
              const t = e.properties.concat(
                e.callProperties || [],
                e.indexers || [],
                e.internalSlots || []
              );
              t.length &&
                (this.space(),
                this.printJoin(t, e, {
                  addNewlines(e) {
                    if (e && !t[0]) return 1;
                  },
                  indent: !0,
                  statement: !0,
                  iterator: () => {
                    (1 !== t.length || e.inexact) &&
                      (this.token(","), this.space());
                  }
                }),
                this.space());
              e.inexact &&
                (this.indent(),
                this.token("..."),
                t.length && this.newline(),
                this.dedent());
              e.exact ? this.token("|}") : this.token("}");
            }),
            (r.ObjectTypeInternalSlot = function(e) {
              e.static && (this.word("static"), this.space());
              this.token("["),
                this.token("["),
                this.print(e.id, e),
                this.token("]"),
                this.token("]"),
                e.optional && this.token("?");
              e.method || (this.token(":"), this.space());
              this.print(e.value, e);
            }),
            (r.ObjectTypeCallProperty = function(e) {
              e.static && (this.word("static"), this.space());
              this.print(e.value, e);
            }),
            (r.ObjectTypeIndexer = function(e) {
              e.static && (this.word("static"), this.space());
              this._variance(e),
                this.token("["),
                e.id && (this.print(e.id, e), this.token(":"), this.space());
              this.print(e.key, e),
                this.token("]"),
                this.token(":"),
                this.space(),
                this.print(e.value, e);
            }),
            (r.ObjectTypeProperty = function(e) {
              e.proto && (this.word("proto"), this.space());
              e.static && (this.word("static"), this.space());
              this._variance(e),
                this.print(e.key, e),
                e.optional && this.token("?");
              e.method || (this.token(":"), this.space());
              this.print(e.value, e);
            }),
            (r.ObjectTypeSpreadProperty = function(e) {
              this.token("..."), this.print(e.argument, e);
            }),
            (r.QualifiedTypeIdentifier = function(e) {
              this.print(e.qualification, e),
                this.token("."),
                this.print(e.id, e);
            }),
            (r.UnionTypeAnnotation = function(e) {
              this.printJoin(e.types, e, { separator: o });
            }),
            (r.TypeCastExpression = function(e) {
              this.token("("),
                this.print(e.expression, e),
                this.print(e.typeAnnotation, e),
                this.token(")");
            }),
            (r.Variance = function(e) {
              "plus" === e.kind ? this.token("+") : this.token("-");
            }),
            (r.VoidTypeAnnotation = function() {
              this.word("void");
            }),
            Object.defineProperty(r, "NumberLiteralTypeAnnotation", {
              enumerable: !0,
              get: function() {
                return s.NumericLiteral;
              }
            }),
            Object.defineProperty(r, "StringLiteralTypeAnnotation", {
              enumerable: !0,
              get: function() {
                return s.StringLiteral;
              }
            });
          var i = e("./modules"),
            s = e("./types");
          function a() {
            this.space(), this.token("&"), this.space();
          }
          function o() {
            this.space(), this.token("|"), this.space();
          }
        },
        { "./modules": 10, "./types": 13, "@babel/types": 100 }
      ],
      7: [
        function(e, t, r) {
          "use strict";
          Object.defineProperty(r, "__esModule", { value: !0 });
          var n = e("./template-literals");
          Object.keys(n).forEach(function(e) {
            "default" !== e &&
              "__esModule" !== e &&
              Object.defineProperty(r, e, {
                enumerable: !0,
                get: function() {
                  return n[e];
                }
              });
          });
          var i = e("./expressions");
          Object.keys(i).forEach(function(e) {
            "default" !== e &&
              "__esModule" !== e &&
              Object.defineProperty(r, e, {
                enumerable: !0,
                get: function() {
                  return i[e];
                }
              });
          });
          var s = e("./statements");
          Object.keys(s).forEach(function(e) {
            "default" !== e &&
              "__esModule" !== e &&
              Object.defineProperty(r, e, {
                enumerable: !0,
                get: function() {
                  return s[e];
                }
              });
          });
          var a = e("./classes");
          Object.keys(a).forEach(function(e) {
            "default" !== e &&
              "__esModule" !== e &&
              Object.defineProperty(r, e, {
                enumerable: !0,
                get: function() {
                  return a[e];
                }
              });
          });
          var o = e("./methods");
          Object.keys(o).forEach(function(e) {
            "default" !== e &&
              "__esModule" !== e &&
              Object.defineProperty(r, e, {
                enumerable: !0,
                get: function() {
                  return o[e];
                }
              });
          });
          var u = e("./modules");
          Object.keys(u).forEach(function(e) {
            "default" !== e &&
              "__esModule" !== e &&
              Object.defineProperty(r, e, {
                enumerable: !0,
                get: function() {
                  return u[e];
                }
              });
          });
          var l = e("./types");
          Object.keys(l).forEach(function(e) {
            "default" !== e &&
              "__esModule" !== e &&
              Object.defineProperty(r, e, {
                enumerable: !0,
                get: function() {
                  return l[e];
                }
              });
          });
          var c = e("./flow");
          Object.keys(c).forEach(function(e) {
            "default" !== e &&
              "__esModule" !== e &&
              Object.defineProperty(r, e, {
                enumerable: !0,
                get: function() {
                  return c[e];
                }
              });
          });
          var p = e("./base");
          Object.keys(p).forEach(function(e) {
            "default" !== e &&
              "__esModule" !== e &&
              Object.defineProperty(r, e, {
                enumerable: !0,
                get: function() {
                  return p[e];
                }
              });
          });
          var d = e("./jsx");
          Object.keys(d).forEach(function(e) {
            "default" !== e &&
              "__esModule" !== e &&
              Object.defineProperty(r, e, {
                enumerable: !0,
                get: function() {
                  return d[e];
                }
              });
          });
          var h = e("./typescript");
          Object.keys(h).forEach(function(e) {
            "default" !== e &&
              "__esModule" !== e &&
              Object.defineProperty(r, e, {
                enumerable: !0,
                get: function() {
                  return h[e];
                }
              });
          });
        },
        {
          "./base": 3,
          "./classes": 4,
          "./expressions": 5,
          "./flow": 6,
          "./jsx": 8,
          "./methods": 9,
          "./modules": 10,
          "./statements": 11,
          "./template-literals": 12,
          "./types": 13,
          "./typescript": 14
        }
      ],
      8: [
        function(e, t, r) {
          "use strict";
          function n() {
            this.space();
          }
          Object.defineProperty(r, "__esModule", { value: !0 }),
            (r.JSXAttribute = function(e) {
              this.print(e.name, e),
                e.value && (this.token("="), this.print(e.value, e));
            }),
            (r.JSXIdentifier = function(e) {
              this.word(e.name);
            }),
            (r.JSXNamespacedName = function(e) {
              this.print(e.namespace, e),
                this.token(":"),
                this.print(e.name, e);
            }),
            (r.JSXMemberExpression = function(e) {
              this.print(e.object, e),
                this.token("."),
                this.print(e.property, e);
            }),
            (r.JSXSpreadAttribute = function(e) {
              this.token("{"),
                this.token("..."),
                this.print(e.argument, e),
                this.token("}");
            }),
            (r.JSXExpressionContainer = function(e) {
              this.token("{"), this.print(e.expression, e), this.token("}");
            }),
            (r.JSXSpreadChild = function(e) {
              this.token("{"),
                this.token("..."),
                this.print(e.expression, e),
                this.token("}");
            }),
            (r.JSXText = function(e) {
              const t = this.getPossibleRaw(e);
              null != t ? this.token(t) : this.token(e.value);
            }),
            (r.JSXElement = function(e) {
              const t = e.openingElement;
              if ((this.print(t, e), t.selfClosing)) return;
              this.indent();
              for (const t of e.children) this.print(t, e);
              this.dedent(), this.print(e.closingElement, e);
            }),
            (r.JSXOpeningElement = function(e) {
              this.token("<"),
                this.print(e.name, e),
                this.print(e.typeParameters, e),
                e.attributes.length > 0 &&
                  (this.space(),
                  this.printJoin(e.attributes, e, { separator: n }));
              e.selfClosing
                ? (this.space(), this.token("/>"))
                : this.token(">");
            }),
            (r.JSXClosingElement = function(e) {
              this.token("</"), this.print(e.name, e), this.token(">");
            }),
            (r.JSXEmptyExpression = function(e) {
              this.printInnerComments(e);
            }),
            (r.JSXFragment = function(e) {
              this.print(e.openingFragment, e), this.indent();
              for (const t of e.children) this.print(t, e);
              this.dedent(), this.print(e.closingFragment, e);
            }),
            (r.JSXOpeningFragment = function() {
              this.token("<"), this.token(">");
            }),
            (r.JSXClosingFragment = function() {
              this.token("</"), this.token(">");
            });
        },
        {}
      ],
      9: [
        function(e, t, r) {
          "use strict";
          function n() {
            const t = (function(e) {
              if (e && e.__esModule) return e;
              var t = {};
              if (null != e)
                for (var r in e)
                  if (Object.prototype.hasOwnProperty.call(e, r)) {
                    var n =
                      Object.defineProperty && Object.getOwnPropertyDescriptor
                        ? Object.getOwnPropertyDescriptor(e, r)
                        : {};
                    n.get || n.set
                      ? Object.defineProperty(t, r, n)
                      : (t[r] = e[r]);
                  }
              return (t.default = e), t;
            })(e("@babel/types"));
            return (
              (n = function() {
                return t;
              }),
              t
            );
          }
          Object.defineProperty(r, "__esModule", { value: !0 }),
            (r._params = function(e) {
              this.print(e.typeParameters, e),
                this.token("("),
                this._parameters(e.params, e),
                this.token(")"),
                this.print(e.returnType, e);
            }),
            (r._parameters = function(e, t) {
              for (let r = 0; r < e.length; r++)
                this._param(e[r], t),
                  r < e.length - 1 && (this.token(","), this.space());
            }),
            (r._param = function(e, t) {
              this.printJoin(e.decorators, e),
                this.print(e, t),
                e.optional && this.token("?");
              this.print(e.typeAnnotation, e);
            }),
            (r._methodHead = function(e) {
              const t = e.kind,
                r = e.key;
              ("get" !== t && "set" !== t) || (this.word(t), this.space());
              e.async && (this.word("async"), this.space());
              ("method" !== t && "init" !== t) ||
                (e.generator && this.token("*"));
              e.computed
                ? (this.token("["), this.print(r, e), this.token("]"))
                : this.print(r, e);
              e.optional && this.token("?");
              this._params(e);
            }),
            (r._predicate = function(e) {
              e.predicate &&
                (e.returnType || this.token(":"),
                this.space(),
                this.print(e.predicate, e));
            }),
            (r._functionHead = function(e) {
              e.async && (this.word("async"), this.space());
              this.word("function"), e.generator && this.token("*");
              this.space(), e.id && this.print(e.id, e);
              this._params(e), this._predicate(e);
            }),
            (r.FunctionDeclaration = r.FunctionExpression = function(e) {
              this._functionHead(e), this.space(), this.print(e.body, e);
            }),
            (r.ArrowFunctionExpression = function(e) {
              e.async && (this.word("async"), this.space());
              const t = e.params[0];
              1 === e.params.length &&
              n().isIdentifier(t) &&
              !(function(e, t) {
                return (
                  e.typeParameters ||
                  e.returnType ||
                  t.typeAnnotation ||
                  t.optional ||
                  t.trailingComments
                );
              })(e, t)
                ? this.format.retainLines &&
                  e.loc &&
                  e.body.loc &&
                  e.loc.start.line < e.body.loc.start.line
                  ? (this.token("("),
                    t.loc && t.loc.start.line > e.loc.start.line
                      ? (this.indent(),
                        this.print(t, e),
                        this.dedent(),
                        this._catchUp("start", e.body.loc))
                      : this.print(t, e),
                    this.token(")"))
                  : this.print(t, e)
                : this._params(e);
              this._predicate(e),
                this.space(),
                this.token("=>"),
                this.space(),
                this.print(e.body, e);
            });
        },
        { "@babel/types": 100 }
      ],
      10: [
        function(e, t, r) {
          "use strict";
          function n() {
            const t = (function(e) {
              if (e && e.__esModule) return e;
              var t = {};
              if (null != e)
                for (var r in e)
                  if (Object.prototype.hasOwnProperty.call(e, r)) {
                    var n =
                      Object.defineProperty && Object.getOwnPropertyDescriptor
                        ? Object.getOwnPropertyDescriptor(e, r)
                        : {};
                    n.get || n.set
                      ? Object.defineProperty(t, r, n)
                      : (t[r] = e[r]);
                  }
              return (t.default = e), t;
            })(e("@babel/types"));
            return (
              (n = function() {
                return t;
              }),
              t
            );
          }
          function i(e) {
            if (e.declaration) {
              const t = e.declaration;
              this.print(t, e), n().isStatement(t) || this.semicolon();
            } else {
              "type" === e.exportKind && (this.word("type"), this.space());
              const t = e.specifiers.slice(0);
              let r = !1;
              for (;;) {
                const i = t[0];
                if (
                  !n().isExportDefaultSpecifier(i) &&
                  !n().isExportNamespaceSpecifier(i)
                )
                  break;
                (r = !0),
                  this.print(t.shift(), e),
                  t.length && (this.token(","), this.space());
              }
              (t.length || (!t.length && !r)) &&
                (this.token("{"),
                t.length && (this.space(), this.printList(t, e), this.space()),
                this.token("}")),
                e.source &&
                  (this.space(),
                  this.word("from"),
                  this.space(),
                  this.print(e.source, e)),
                this.semicolon();
            }
          }
          Object.defineProperty(r, "__esModule", { value: !0 }),
            (r.ImportSpecifier = function(e) {
              ("type" !== e.importKind && "typeof" !== e.importKind) ||
                (this.word(e.importKind), this.space());
              this.print(e.imported, e),
                e.local &&
                  e.local.name !== e.imported.name &&
                  (this.space(),
                  this.word("as"),
                  this.space(),
                  this.print(e.local, e));
            }),
            (r.ImportDefaultSpecifier = function(e) {
              this.print(e.local, e);
            }),
            (r.ExportDefaultSpecifier = function(e) {
              this.print(e.exported, e);
            }),
            (r.ExportSpecifier = function(e) {
              this.print(e.local, e),
                e.exported &&
                  e.local.name !== e.exported.name &&
                  (this.space(),
                  this.word("as"),
                  this.space(),
                  this.print(e.exported, e));
            }),
            (r.ExportNamespaceSpecifier = function(e) {
              this.token("*"),
                this.space(),
                this.word("as"),
                this.space(),
                this.print(e.exported, e);
            }),
            (r.ExportAllDeclaration = function(e) {
              this.word("export"),
                this.space(),
                "type" === e.exportKind && (this.word("type"), this.space());
              this.token("*"),
                this.space(),
                this.word("from"),
                this.space(),
                this.print(e.source, e),
                this.semicolon();
            }),
            (r.ExportNamedDeclaration = function(e) {
              this.format.decoratorsBeforeExport &&
                n().isClassDeclaration(e.declaration) &&
                this.printJoin(e.declaration.decorators, e);
              this.word("export"), this.space(), i.apply(this, arguments);
            }),
            (r.ExportDefaultDeclaration = function(e) {
              this.format.decoratorsBeforeExport &&
                n().isClassDeclaration(e.declaration) &&
                this.printJoin(e.declaration.decorators, e);
              this.word("export"),
                this.space(),
                this.word("default"),
                this.space(),
                i.apply(this, arguments);
            }),
            (r.ImportDeclaration = function(e) {
              this.word("import"),
                this.space(),
                ("type" === e.importKind || "typeof" === e.importKind) &&
                  (this.word(e.importKind), this.space());
              const t = e.specifiers.slice(0);
              if (t && t.length) {
                for (;;) {
                  const r = t[0];
                  if (
                    !n().isImportDefaultSpecifier(r) &&
                    !n().isImportNamespaceSpecifier(r)
                  )
                    break;
                  this.print(t.shift(), e),
                    t.length && (this.token(","), this.space());
                }
                t.length &&
                  (this.token("{"),
                  this.space(),
                  this.printList(t, e),
                  this.space(),
                  this.token("}")),
                  this.space(),
                  this.word("from"),
                  this.space();
              }
              this.print(e.source, e), this.semicolon();
            }),
            (r.ImportNamespaceSpecifier = function(e) {
              this.token("*"),
                this.space(),
                this.word("as"),
                this.space(),
                this.print(e.local, e);
            });
        },
        { "@babel/types": 100 }
      ],
      11: [
        function(e, t, r) {
          "use strict";
          function n() {
            const t = (function(e) {
              if (e && e.__esModule) return e;
              var t = {};
              if (null != e)
                for (var r in e)
                  if (Object.prototype.hasOwnProperty.call(e, r)) {
                    var n =
                      Object.defineProperty && Object.getOwnPropertyDescriptor
                        ? Object.getOwnPropertyDescriptor(e, r)
                        : {};
                    n.get || n.set
                      ? Object.defineProperty(t, r, n)
                      : (t[r] = e[r]);
                  }
              return (t.default = e), t;
            })(e("@babel/types"));
            return (
              (n = function() {
                return t;
              }),
              t
            );
          }
          Object.defineProperty(r, "__esModule", { value: !0 }),
            (r.WithStatement = function(e) {
              this.word("with"),
                this.space(),
                this.token("("),
                this.print(e.object, e),
                this.token(")"),
                this.printBlock(e);
            }),
            (r.IfStatement = function(e) {
              this.word("if"),
                this.space(),
                this.token("("),
                this.print(e.test, e),
                this.token(")"),
                this.space();
              const t =
                e.alternate &&
                n().isIfStatement(
                  (function e(t) {
                    if (!n().isStatement(t.body)) return t;
                    return e(t.body);
                  })(e.consequent)
                );
              t && (this.token("{"), this.newline(), this.indent());
              this.printAndIndentOnComments(e.consequent, e),
                t && (this.dedent(), this.newline(), this.token("}"));
              e.alternate &&
                (this.endsWith("}") && this.space(),
                this.word("else"),
                this.space(),
                this.printAndIndentOnComments(e.alternate, e));
            }),
            (r.ForStatement = function(e) {
              this.word("for"),
                this.space(),
                this.token("("),
                this.inForStatementInitCounter++,
                this.print(e.init, e),
                this.inForStatementInitCounter--,
                this.token(";"),
                e.test && (this.space(), this.print(e.test, e));
              this.token(";"),
                e.update && (this.space(), this.print(e.update, e));
              this.token(")"), this.printBlock(e);
            }),
            (r.WhileStatement = function(e) {
              this.word("while"),
                this.space(),
                this.token("("),
                this.print(e.test, e),
                this.token(")"),
                this.printBlock(e);
            }),
            (r.DoWhileStatement = function(e) {
              this.word("do"),
                this.space(),
                this.print(e.body, e),
                this.space(),
                this.word("while"),
                this.space(),
                this.token("("),
                this.print(e.test, e),
                this.token(")"),
                this.semicolon();
            }),
            (r.LabeledStatement = function(e) {
              this.print(e.label, e),
                this.token(":"),
                this.space(),
                this.print(e.body, e);
            }),
            (r.TryStatement = function(e) {
              this.word("try"),
                this.space(),
                this.print(e.block, e),
                this.space(),
                e.handlers
                  ? this.print(e.handlers[0], e)
                  : this.print(e.handler, e);
              e.finalizer &&
                (this.space(),
                this.word("finally"),
                this.space(),
                this.print(e.finalizer, e));
            }),
            (r.CatchClause = function(e) {
              this.word("catch"),
                this.space(),
                e.param &&
                  (this.token("("),
                  this.print(e.param, e),
                  this.token(")"),
                  this.space());
              this.print(e.body, e);
            }),
            (r.SwitchStatement = function(e) {
              this.word("switch"),
                this.space(),
                this.token("("),
                this.print(e.discriminant, e),
                this.token(")"),
                this.space(),
                this.token("{"),
                this.printSequence(e.cases, e, {
                  indent: !0,
                  addNewlines(t, r) {
                    if (!t && e.cases[e.cases.length - 1] === r) return -1;
                  }
                }),
                this.token("}");
            }),
            (r.SwitchCase = function(e) {
              e.test
                ? (this.word("case"),
                  this.space(),
                  this.print(e.test, e),
                  this.token(":"))
                : (this.word("default"), this.token(":"));
              e.consequent.length &&
                (this.newline(),
                this.printSequence(e.consequent, e, { indent: !0 }));
            }),
            (r.DebuggerStatement = function() {
              this.word("debugger"), this.semicolon();
            }),
            (r.VariableDeclaration = function(e, t) {
              e.declare && (this.word("declare"), this.space());
              this.word(e.kind), this.space();
              let r,
                i = !1;
              if (!n().isFor(t))
                for (const t of e.declarations) t.init && (i = !0);
              i && (r = "const" === e.kind ? h : d);
              if (
                (this.printList(e.declarations, e, { separator: r }),
                n().isFor(t) && (t.left === e || t.init === e))
              )
                return;
              this.semicolon();
            }),
            (r.VariableDeclarator = function(e) {
              this.print(e.id, e), e.definite && this.token("!");
              this.print(e.id.typeAnnotation, e),
                e.init &&
                  (this.space(),
                  this.token("="),
                  this.space(),
                  this.print(e.init, e));
            }),
            (r.ThrowStatement = r.BreakStatement = r.ReturnStatement = r.ContinueStatement = r.ForOfStatement = r.ForInStatement = void 0);
          const i = function(e) {
              return function(t) {
                this.word("for"),
                  this.space(),
                  "of" === e && t.await && (this.word("await"), this.space()),
                  this.token("("),
                  this.print(t.left, t),
                  this.space(),
                  this.word(e),
                  this.space(),
                  this.print(t.right, t),
                  this.token(")"),
                  this.printBlock(t);
              };
            },
            s = i("in");
          r.ForInStatement = s;
          const a = i("of");
          function o(e, t = "label") {
            return function(r) {
              this.word(e);
              const n = r[t];
              if (n) {
                this.space();
                const e = "label" == t,
                  i = this.startTerminatorless(e);
                this.print(n, r), this.endTerminatorless(i);
              }
              this.semicolon();
            };
          }
          r.ForOfStatement = a;
          const u = o("continue");
          r.ContinueStatement = u;
          const l = o("return", "argument");
          r.ReturnStatement = l;
          const c = o("break");
          r.BreakStatement = c;
          const p = o("throw", "argument");
          function d() {
            if ((this.token(","), this.newline(), this.endsWith("\n")))
              for (let e = 0; e < 4; e++) this.space(!0);
          }
          function h() {
            if ((this.token(","), this.newline(), this.endsWith("\n")))
              for (let e = 0; e < 6; e++) this.space(!0);
          }
          r.ThrowStatement = p;
        },
        { "@babel/types": 100 }
      ],
      12: [
        function(e, t, r) {
          "use strict";
          Object.defineProperty(r, "__esModule", { value: !0 }),
            (r.TaggedTemplateExpression = function(e) {
              this.print(e.tag, e),
                this.print(e.typeParameters, e),
                this.print(e.quasi, e);
            }),
            (r.TemplateElement = function(e, t) {
              const r = t.quasis[0] === e,
                n = t.quasis[t.quasis.length - 1] === e,
                i = (r ? "`" : "}") + e.value.raw + (n ? "`" : "${");
              this.token(i);
            }),
            (r.TemplateLiteral = function(e) {
              const t = e.quasis;
              for (let r = 0; r < t.length; r++)
                this.print(t[r], e),
                  r + 1 < t.length && this.print(e.expressions[r], e);
            });
        },
        {}
      ],
      13: [
        function(e, t, r) {
          "use strict";
          function n() {
            const t = (function(e) {
              if (e && e.__esModule) return e;
              var t = {};
              if (null != e)
                for (var r in e)
                  if (Object.prototype.hasOwnProperty.call(e, r)) {
                    var n =
                      Object.defineProperty && Object.getOwnPropertyDescriptor
                        ? Object.getOwnPropertyDescriptor(e, r)
                        : {};
                    n.get || n.set
                      ? Object.defineProperty(t, r, n)
                      : (t[r] = e[r]);
                  }
              return (t.default = e), t;
            })(e("@babel/types"));
            return (
              (n = function() {
                return t;
              }),
              t
            );
          }
          function i() {
            const t = (r = e("jsesc")) && r.__esModule ? r : { default: r };
            var r;
            return (
              (i = function() {
                return t;
              }),
              t
            );
          }
          Object.defineProperty(r, "__esModule", { value: !0 }),
            (r.Identifier = function(e) {
              this.exactSource(e.loc, () => {
                this.word(e.name);
              });
            }),
            (r.ArgumentPlaceholder = function() {
              this.token("?");
            }),
            (r.SpreadElement = r.RestElement = function(e) {
              this.token("..."), this.print(e.argument, e);
            }),
            (r.ObjectPattern = r.ObjectExpression = function(e) {
              const t = e.properties;
              this.token("{"),
                this.printInnerComments(e),
                t.length &&
                  (this.space(),
                  this.printList(t, e, { indent: !0, statement: !0 }),
                  this.space());
              this.token("}");
            }),
            (r.ObjectMethod = function(e) {
              this.printJoin(e.decorators, e),
                this._methodHead(e),
                this.space(),
                this.print(e.body, e);
            }),
            (r.ObjectProperty = function(e) {
              if ((this.printJoin(e.decorators, e), e.computed))
                this.token("["), this.print(e.key, e), this.token("]");
              else {
                if (
                  n().isAssignmentPattern(e.value) &&
                  n().isIdentifier(e.key) &&
                  e.key.name === e.value.left.name
                )
                  return void this.print(e.value, e);
                if (
                  (this.print(e.key, e),
                  e.shorthand &&
                    n().isIdentifier(e.key) &&
                    n().isIdentifier(e.value) &&
                    e.key.name === e.value.name)
                )
                  return;
              }
              this.token(":"), this.space(), this.print(e.value, e);
            }),
            (r.ArrayPattern = r.ArrayExpression = function(e) {
              const t = e.elements,
                r = t.length;
              this.token("["), this.printInnerComments(e);
              for (let n = 0; n < t.length; n++) {
                const i = t[n];
                i
                  ? (n > 0 && this.space(),
                    this.print(i, e),
                    n < r - 1 && this.token(","))
                  : this.token(",");
              }
              this.token("]");
            }),
            (r.RegExpLiteral = function(e) {
              this.word(`/${e.pattern}/${e.flags}`);
            }),
            (r.BooleanLiteral = function(e) {
              this.word(e.value ? "true" : "false");
            }),
            (r.NullLiteral = function() {
              this.word("null");
            }),
            (r.NumericLiteral = function(e) {
              const t = this.getPossibleRaw(e),
                r = e.value + "";
              null == t
                ? this.number(r)
                : this.format.minified
                ? this.number(t.length < r.length ? t : r)
                : this.number(t);
            }),
            (r.StringLiteral = function(e) {
              const t = this.getPossibleRaw(e);
              if (!this.format.minified && null != t) return void this.token(t);
              const r = this.format.jsescOption;
              this.format.jsonCompatibleStrings && (r.json = !0);
              const n = (0, i().default)(e.value, r);
              return this.token(n);
            }),
            (r.BigIntLiteral = function(e) {
              const t = this.getPossibleRaw(e);
              if (!this.format.minified && null != t) return void this.token(t);
              this.token(e.value);
            }),
            (r.PipelineTopicExpression = function(e) {
              this.print(e.expression, e);
            }),
            (r.PipelineBareFunction = function(e) {
              this.print(e.callee, e);
            }),
            (r.PipelinePrimaryTopicReference = function() {
              this.token("#");
            });
        },
        { "@babel/types": 100, jsesc: 152 }
      ],
      14: [
        function(e, t, r) {
          "use strict";
          function n(e, t) {
            !0 !== t && e.token(t);
          }
          Object.defineProperty(r, "__esModule", { value: !0 }),
            (r.TSTypeAnnotation = function(e) {
              this.token(":"), this.space(), e.optional && this.token("?");
              this.print(e.typeAnnotation, e);
            }),
            (r.TSTypeParameterDeclaration = r.TSTypeParameterInstantiation = function(
              e
            ) {
              this.token("<"), this.printList(e.params, e, {}), this.token(">");
            }),
            (r.TSTypeParameter = function(e) {
              this.word(e.name),
                e.constraint &&
                  (this.space(),
                  this.word("extends"),
                  this.space(),
                  this.print(e.constraint, e));
              e.default &&
                (this.space(),
                this.token("="),
                this.space(),
                this.print(e.default, e));
            }),
            (r.TSParameterProperty = function(e) {
              e.accessibility && (this.word(e.accessibility), this.space());
              e.readonly && (this.word("readonly"), this.space());
              this._param(e.parameter);
            }),
            (r.TSDeclareFunction = function(e) {
              e.declare && (this.word("declare"), this.space());
              this._functionHead(e), this.token(";");
            }),
            (r.TSDeclareMethod = function(e) {
              this._classMethodHead(e), this.token(";");
            }),
            (r.TSQualifiedName = function(e) {
              this.print(e.left, e), this.token("."), this.print(e.right, e);
            }),
            (r.TSCallSignatureDeclaration = function(e) {
              this.tsPrintSignatureDeclarationBase(e);
            }),
            (r.TSConstructSignatureDeclaration = function(e) {
              this.word("new"),
                this.space(),
                this.tsPrintSignatureDeclarationBase(e);
            }),
            (r.TSPropertySignature = function(e) {
              const { readonly: t, initializer: r } = e;
              t && (this.word("readonly"), this.space());
              this.tsPrintPropertyOrMethodName(e),
                this.print(e.typeAnnotation, e),
                r &&
                  (this.space(),
                  this.token("="),
                  this.space(),
                  this.print(r, e));
              this.token(";");
            }),
            (r.tsPrintPropertyOrMethodName = function(e) {
              e.computed && this.token("[");
              this.print(e.key, e), e.computed && this.token("]");
              e.optional && this.token("?");
            }),
            (r.TSMethodSignature = function(e) {
              this.tsPrintPropertyOrMethodName(e),
                this.tsPrintSignatureDeclarationBase(e),
                this.token(";");
            }),
            (r.TSIndexSignature = function(e) {
              const { readonly: t } = e;
              t && (this.word("readonly"), this.space());
              this.token("["),
                this._parameters(e.parameters, e),
                this.token("]"),
                this.print(e.typeAnnotation, e),
                this.token(";");
            }),
            (r.TSAnyKeyword = function() {
              this.word("any");
            }),
            (r.TSUnknownKeyword = function() {
              this.word("unknown");
            }),
            (r.TSNumberKeyword = function() {
              this.word("number");
            }),
            (r.TSObjectKeyword = function() {
              this.word("object");
            }),
            (r.TSBooleanKeyword = function() {
              this.word("boolean");
            }),
            (r.TSStringKeyword = function() {
              this.word("string");
            }),
            (r.TSSymbolKeyword = function() {
              this.word("symbol");
            }),
            (r.TSVoidKeyword = function() {
              this.word("void");
            }),
            (r.TSUndefinedKeyword = function() {
              this.word("undefined");
            }),
            (r.TSNullKeyword = function() {
              this.word("null");
            }),
            (r.TSNeverKeyword = function() {
              this.word("never");
            }),
            (r.TSThisType = function() {
              this.word("this");
            }),
            (r.TSFunctionType = function(e) {
              this.tsPrintFunctionOrConstructorType(e);
            }),
            (r.TSConstructorType = function(e) {
              this.word("new"),
                this.space(),
                this.tsPrintFunctionOrConstructorType(e);
            }),
            (r.tsPrintFunctionOrConstructorType = function(e) {
              const { typeParameters: t, parameters: r } = e;
              this.print(t, e),
                this.token("("),
                this._parameters(r, e),
                this.token(")"),
                this.space(),
                this.token("=>"),
                this.space(),
                this.print(e.typeAnnotation.typeAnnotation, e);
            }),
            (r.TSTypeReference = function(e) {
              this.print(e.typeName, e), this.print(e.typeParameters, e);
            }),
            (r.TSTypePredicate = function(e) {
              this.print(e.parameterName),
                this.space(),
                this.word("is"),
                this.space(),
                this.print(e.typeAnnotation.typeAnnotation);
            }),
            (r.TSTypeQuery = function(e) {
              this.word("typeof"), this.space(), this.print(e.exprName);
            }),
            (r.TSTypeLiteral = function(e) {
              this.tsPrintTypeLiteralOrInterfaceBody(e.members, e);
            }),
            (r.tsPrintTypeLiteralOrInterfaceBody = function(e, t) {
              this.tsPrintBraced(e, t);
            }),
            (r.tsPrintBraced = function(e, t) {
              if ((this.token("{"), e.length)) {
                this.indent(), this.newline();
                for (const r of e) this.print(r, t), this.newline();
                this.dedent(), this.rightBrace();
              } else this.token("}");
            }),
            (r.TSArrayType = function(e) {
              this.print(e.elementType, e), this.token("[]");
            }),
            (r.TSTupleType = function(e) {
              this.token("["),
                this.printList(e.elementTypes, e),
                this.token("]");
            }),
            (r.TSOptionalType = function(e) {
              this.print(e.typeAnnotation, e), this.token("?");
            }),
            (r.TSRestType = function(e) {
              this.token("..."), this.print(e.typeAnnotation, e);
            }),
            (r.TSUnionType = function(e) {
              this.tsPrintUnionOrIntersectionType(e, "|");
            }),
            (r.TSIntersectionType = function(e) {
              this.tsPrintUnionOrIntersectionType(e, "&");
            }),
            (r.tsPrintUnionOrIntersectionType = function(e, t) {
              this.printJoin(e.types, e, {
                separator() {
                  this.space(), this.token(t), this.space();
                }
              });
            }),
            (r.TSConditionalType = function(e) {
              this.print(e.checkType),
                this.space(),
                this.word("extends"),
                this.space(),
                this.print(e.extendsType),
                this.space(),
                this.token("?"),
                this.space(),
                this.print(e.trueType),
                this.space(),
                this.token(":"),
                this.space(),
                this.print(e.falseType);
            }),
            (r.TSInferType = function(e) {
              this.token("infer"), this.space(), this.print(e.typeParameter);
            }),
            (r.TSParenthesizedType = function(e) {
              this.token("("), this.print(e.typeAnnotation, e), this.token(")");
            }),
            (r.TSTypeOperator = function(e) {
              this.token(e.operator),
                this.space(),
                this.print(e.typeAnnotation, e);
            }),
            (r.TSIndexedAccessType = function(e) {
              this.print(e.objectType, e),
                this.token("["),
                this.print(e.indexType, e),
                this.token("]");
            }),
            (r.TSMappedType = function(e) {
              const { readonly: t, typeParameter: r, optional: i } = e;
              this.token("{"),
                this.space(),
                t && (n(this, t), this.word("readonly"), this.space());
              this.token("["),
                this.word(r.name),
                this.space(),
                this.word("in"),
                this.space(),
                this.print(r.constraint, r),
                this.token("]"),
                i && (n(this, i), this.token("?"));
              this.token(":"),
                this.space(),
                this.print(e.typeAnnotation, e),
                this.space(),
                this.token("}");
            }),
            (r.TSLiteralType = function(e) {
              this.print(e.literal, e);
            }),
            (r.TSExpressionWithTypeArguments = function(e) {
              this.print(e.expression, e), this.print(e.typeParameters, e);
            }),
            (r.TSInterfaceDeclaration = function(e) {
              const {
                declare: t,
                id: r,
                typeParameters: n,
                extends: i,
                body: s
              } = e;
              t && (this.word("declare"), this.space());
              this.word("interface"),
                this.space(),
                this.print(r, e),
                this.print(n, e),
                i &&
                  (this.space(),
                  this.word("extends"),
                  this.space(),
                  this.printList(i, e));
              this.space(), this.print(s, e);
            }),
            (r.TSInterfaceBody = function(e) {
              this.tsPrintTypeLiteralOrInterfaceBody(e.body, e);
            }),
            (r.TSTypeAliasDeclaration = function(e) {
              const {
                declare: t,
                id: r,
                typeParameters: n,
                typeAnnotation: i
              } = e;
              t && (this.word("declare"), this.space());
              this.word("type"),
                this.space(),
                this.print(r, e),
                this.print(n, e),
                this.space(),
                this.token("="),
                this.space(),
                this.print(i, e),
                this.token(";");
            }),
            (r.TSAsExpression = function(e) {
              const { expression: t, typeAnnotation: r } = e;
              this.print(t, e),
                this.space(),
                this.word("as"),
                this.space(),
                this.print(r, e);
            }),
            (r.TSTypeAssertion = function(e) {
              const { typeAnnotation: t, expression: r } = e;
              this.token("<"),
                this.print(t, e),
                this.token(">"),
                this.space(),
                this.print(r, e);
            }),
            (r.TSEnumDeclaration = function(e) {
              const { declare: t, const: r, id: n, members: i } = e;
              t && (this.word("declare"), this.space());
              r && (this.word("const"), this.space());
              this.word("enum"),
                this.space(),
                this.print(n, e),
                this.space(),
                this.tsPrintBraced(i, e);
            }),
            (r.TSEnumMember = function(e) {
              const { id: t, initializer: r } = e;
              this.print(t, e),
                r &&
                  (this.space(),
                  this.token("="),
                  this.space(),
                  this.print(r, e));
              this.token(",");
            }),
            (r.TSModuleDeclaration = function(e) {
              const { declare: t, id: r } = e;
              t && (this.word("declare"), this.space());
              e.global ||
                (this.word("Identifier" === r.type ? "namespace" : "module"),
                this.space());
              if ((this.print(r, e), !e.body)) return void this.token(";");
              let n = e.body;
              for (; "TSModuleDeclaration" === n.type; )
                this.token("."), this.print(n.id, n), (n = n.body);
              this.space(), this.print(n, e);
            }),
            (r.TSModuleBlock = function(e) {
              this.tsPrintBraced(e.body, e);
            }),
            (r.TSImportType = function(e) {
              const { argument: t, qualifier: r, typeParameters: n } = e;
              this.word("import"),
                this.token("("),
                this.print(t, e),
                this.token(")"),
                r && (this.token("."), this.print(r, e));
              n && this.print(n, e);
            }),
            (r.TSImportEqualsDeclaration = function(e) {
              const { isExport: t, id: r, moduleReference: n } = e;
              t && (this.word("export"), this.space());
              this.word("import"),
                this.space(),
                this.print(r, e),
                this.space(),
                this.token("="),
                this.space(),
                this.print(n, e),
                this.token(";");
            }),
            (r.TSExternalModuleReference = function(e) {
              this.token("require("),
                this.print(e.expression, e),
                this.token(")");
            }),
            (r.TSNonNullExpression = function(e) {
              this.print(e.expression, e), this.token("!");
            }),
            (r.TSExportAssignment = function(e) {
              this.word("export"),
                this.space(),
                this.token("="),
                this.space(),
                this.print(e.expression, e),
                this.token(";");
            }),
            (r.TSNamespaceExportDeclaration = function(e) {
              this.word("export"),
                this.space(),
                this.word("as"),
                this.space(),
                this.word("namespace"),
                this.space(),
                this.print(e.id, e);
            }),
            (r.tsPrintSignatureDeclarationBase = function(e) {
              const { typeParameters: t, parameters: r } = e;
              this.print(t, e),
                this.token("("),
                this._parameters(r, e),
                this.token(")"),
                this.print(e.typeAnnotation, e);
            });
        },
        {}
      ],
      15: [
        function(e, t, r) {
          "use strict";
          Object.defineProperty(r, "__esModule", { value: !0 }),
            (r.default = function(e, t, r) {
              return new a(e, t, r).generate();
            }),
            (r.CodeGenerator = void 0);
          var n = s(e("./source-map")),
            i = s(e("./printer"));
          function s(e) {
            return e && e.__esModule ? e : { default: e };
          }
          class a extends i.default {
            constructor(e, t = {}, r) {
              super(
                (function(e, t) {
                  const r = {
                    auxiliaryCommentBefore: t.auxiliaryCommentBefore,
                    auxiliaryCommentAfter: t.auxiliaryCommentAfter,
                    shouldPrintComment: t.shouldPrintComment,
                    retainLines: t.retainLines,
                    retainFunctionParens: t.retainFunctionParens,
                    comments: null == t.comments || t.comments,
                    compact: t.compact,
                    minified: t.minified,
                    concise: t.concise,
                    jsonCompatibleStrings: t.jsonCompatibleStrings,
                    indent: {
                      adjustMultilineComment: !0,
                      style: "  ",
                      base: 0
                    },
                    decoratorsBeforeExport: !!t.decoratorsBeforeExport,
                    jsescOption: Object.assign(
                      { quotes: "double", wrap: !0 },
                      t.jsescOption
                    )
                  };
                  r.minified
                    ? ((r.compact = !0),
                      (r.shouldPrintComment =
                        r.shouldPrintComment || (() => r.comments)))
                    : (r.shouldPrintComment =
                        r.shouldPrintComment ||
                        (e =>
                          r.comments ||
                          e.indexOf("@license") >= 0 ||
                          e.indexOf("@preserve") >= 0));
                  "auto" === r.compact &&
                    ((r.compact = e.length > 5e5),
                    r.compact &&
                      console.error(
                        "[BABEL] Note: The code generator has deoptimised the styling of " +
                          `${t.filename} as it exceeds the max of 500KB.`
                      ));
                  r.compact && (r.indent.adjustMultilineComment = !1);
                  return r;
                })(r, t),
                t.sourceMaps ? new n.default(t, r) : null
              ),
                (this.ast = e);
            }
            generate() {
              return super.generate(this.ast);
            }
          }
          r.CodeGenerator = class {
            constructor(e, t, r) {
              this._generator = new a(e, t, r);
            }
            generate() {
              return this._generator.generate();
            }
          };
        },
        { "./printer": 19, "./source-map": 20 }
      ],
      16: [
        function(e, t, r) {
          "use strict";
          Object.defineProperty(r, "__esModule", { value: !0 }),
            (r.needsWhitespace = p),
            (r.needsWhitespaceBefore = function(e, t) {
              return p(e, t, "before");
            }),
            (r.needsWhitespaceAfter = function(e, t) {
              return p(e, t, "after");
            }),
            (r.needsParens = function(e, t, r) {
              if (!t) return !1;
              if (
                i().isNewExpression(t) &&
                t.callee === e &&
                (function e(t) {
                  if (i().isCallExpression(t)) return !0;
                  return (
                    !!i().isMemberExpression(t) &&
                    (e(t.object) || (!t.computed && e(t.property)))
                  );
                })(e)
              )
                return !0;
              return c(o, e, t, r);
            });
          var n = s(e("./whitespace"));
          function i() {
            const t = s(e("@babel/types"));
            return (
              (i = function() {
                return t;
              }),
              t
            );
          }
          function s(e) {
            if (e && e.__esModule) return e;
            var t = {};
            if (null != e)
              for (var r in e)
                if (Object.prototype.hasOwnProperty.call(e, r)) {
                  var n =
                    Object.defineProperty && Object.getOwnPropertyDescriptor
                      ? Object.getOwnPropertyDescriptor(e, r)
                      : {};
                  n.get || n.set
                    ? Object.defineProperty(t, r, n)
                    : (t[r] = e[r]);
                }
            return (t.default = e), t;
          }
          function a(e) {
            const t = {};
            function r(e, r) {
              const n = t[e];
              t[e] = n
                ? function(e, t, i) {
                    const s = n(e, t, i);
                    return null == s ? r(e, t, i) : s;
                  }
                : r;
            }
            for (const t of Object.keys(e)) {
              const n = i().FLIPPED_ALIAS_KEYS[t];
              if (n) for (const i of n) r(i, e[t]);
              else r(t, e[t]);
            }
            return t;
          }
          const o = a(s(e("./parentheses"))),
            u = a(n.nodes),
            l = a(n.list);
          function c(e, t, r, n) {
            const i = e[t.type];
            return i ? i(t, r, n) : null;
          }
          function p(e, t, r) {
            if (!e) return 0;
            i().isExpressionStatement(e) && (e = e.expression);
            let n = c(u, e, t);
            if (!n) {
              const i = c(l, e, t);
              if (i) for (let t = 0; t < i.length && !(n = p(i[t], e, r)); t++);
            }
            return ("object" == typeof n && null !== n && n[r]) || 0;
          }
        },
        { "./parentheses": 17, "./whitespace": 18, "@babel/types": 100 }
      ],
      17: [
        function(e, t, r) {
          "use strict";
          function n() {
            const t = (function(e) {
              if (e && e.__esModule) return e;
              var t = {};
              if (null != e)
                for (var r in e)
                  if (Object.prototype.hasOwnProperty.call(e, r)) {
                    var n =
                      Object.defineProperty && Object.getOwnPropertyDescriptor
                        ? Object.getOwnPropertyDescriptor(e, r)
                        : {};
                    n.get || n.set
                      ? Object.defineProperty(t, r, n)
                      : (t[r] = e[r]);
                  }
              return (t.default = e), t;
            })(e("@babel/types"));
            return (
              (n = function() {
                return t;
              }),
              t
            );
          }
          Object.defineProperty(r, "__esModule", { value: !0 }),
            (r.NullableTypeAnnotation = function(e, t) {
              return n().isArrayTypeAnnotation(t);
            }),
            (r.FunctionTypeAnnotation = function(e, t) {
              return (
                n().isUnionTypeAnnotation(t) ||
                n().isIntersectionTypeAnnotation(t) ||
                n().isArrayTypeAnnotation(t)
              );
            }),
            (r.UpdateExpression = function(e, t) {
              return (
                n().isMemberExpression(t, { object: e }) ||
                n().isCallExpression(t, { callee: e }) ||
                n().isNewExpression(t, { callee: e }) ||
                s(e, t)
              );
            }),
            (r.ObjectExpression = function(e, t, r) {
              return u(r, { considerArrow: !0 });
            }),
            (r.DoExpression = function(e, t, r) {
              return u(r);
            }),
            (r.Binary = function(e, t) {
              if (
                "**" === e.operator &&
                n().isBinaryExpression(t, { operator: "**" })
              )
                return t.left === e;
              if (s(e, t)) return !0;
              if (
                ((n().isCallExpression(t) || n().isNewExpression(t)) &&
                  t.callee === e) ||
                n().isUnaryLike(t) ||
                (n().isMemberExpression(t) && t.object === e) ||
                n().isAwaitExpression(t)
              )
                return !0;
              if (n().isBinary(t)) {
                const r = t.operator,
                  s = i[r],
                  a = e.operator,
                  o = i[a];
                if (
                  (s === o && t.right === e && !n().isLogicalExpression(t)) ||
                  s > o
                )
                  return !0;
              }
              return !1;
            }),
            (r.IntersectionTypeAnnotation = r.UnionTypeAnnotation = function(
              e,
              t
            ) {
              return (
                n().isArrayTypeAnnotation(t) ||
                n().isNullableTypeAnnotation(t) ||
                n().isIntersectionTypeAnnotation(t) ||
                n().isUnionTypeAnnotation(t)
              );
            }),
            (r.TSAsExpression = function() {
              return !0;
            }),
            (r.TSTypeAssertion = function() {
              return !0;
            }),
            (r.TSIntersectionType = r.TSUnionType = function(e, t) {
              return (
                n().isTSArrayType(t) ||
                n().isTSOptionalType(t) ||
                n().isTSIntersectionType(t) ||
                n().isTSUnionType(t) ||
                n().isTSRestType(t)
              );
            }),
            (r.BinaryExpression = function(e, t) {
              return (
                "in" === e.operator &&
                (n().isVariableDeclarator(t) || n().isFor(t))
              );
            }),
            (r.SequenceExpression = function(e, t) {
              if (
                n().isForStatement(t) ||
                n().isThrowStatement(t) ||
                n().isReturnStatement(t) ||
                (n().isIfStatement(t) && t.test === e) ||
                (n().isWhileStatement(t) && t.test === e) ||
                (n().isForInStatement(t) && t.right === e) ||
                (n().isSwitchStatement(t) && t.discriminant === e) ||
                (n().isExpressionStatement(t) && t.expression === e)
              )
                return !1;
              return !0;
            }),
            (r.AwaitExpression = r.YieldExpression = function(e, t) {
              return (
                n().isBinary(t) ||
                n().isUnaryLike(t) ||
                n().isCallExpression(t) ||
                n().isMemberExpression(t) ||
                n().isNewExpression(t) ||
                (n().isAwaitExpression(t) && n().isYieldExpression(e)) ||
                (n().isConditionalExpression(t) && e === t.test) ||
                s(e, t)
              );
            }),
            (r.ClassExpression = function(e, t, r) {
              return u(r, { considerDefaultExports: !0 });
            }),
            (r.UnaryLike = a),
            (r.FunctionExpression = function(e, t, r) {
              return u(r, { considerDefaultExports: !0 });
            }),
            (r.ArrowFunctionExpression = function(e, t) {
              return n().isExportDeclaration(t) || o(e, t);
            }),
            (r.ConditionalExpression = o),
            (r.OptionalMemberExpression = function(e, t) {
              return n().isCallExpression(t) || n().isMemberExpression(t);
            }),
            (r.AssignmentExpression = function(e) {
              return !!n().isObjectPattern(e.left) || o(...arguments);
            }),
            (r.NewExpression = function(e, t) {
              return s(e, t);
            });
          const i = {
              "||": 0,
              "&&": 1,
              "|": 2,
              "^": 3,
              "&": 4,
              "==": 5,
              "===": 5,
              "!=": 5,
              "!==": 5,
              "<": 6,
              ">": 6,
              "<=": 6,
              ">=": 6,
              in: 6,
              instanceof: 6,
              ">>": 7,
              "<<": 7,
              ">>>": 7,
              "+": 8,
              "-": 8,
              "*": 9,
              "/": 9,
              "%": 9,
              "**": 10
            },
            s = (e, t) =>
              (n().isClassDeclaration(t) || n().isClassExpression(t)) &&
              t.superClass === e;
          function a(e, t) {
            return (
              n().isMemberExpression(t, { object: e }) ||
              n().isCallExpression(t, { callee: e }) ||
              n().isNewExpression(t, { callee: e }) ||
              n().isBinaryExpression(t, { operator: "**", left: e }) ||
              s(e, t)
            );
          }
          function o(e, t) {
            return (
              !!(
                n().isUnaryLike(t) ||
                n().isBinary(t) ||
                n().isConditionalExpression(t, { test: e }) ||
                n().isAwaitExpression(t) ||
                n().isOptionalMemberExpression(t) ||
                n().isTaggedTemplateExpression(t) ||
                n().isTSTypeAssertion(t) ||
                n().isTSAsExpression(t)
              ) || a(e, t)
            );
          }
          function u(
            e,
            { considerArrow: t = !1, considerDefaultExports: r = !1 } = {}
          ) {
            let i = e.length - 1,
              s = e[i],
              a = e[--i];
            for (; i > 0; ) {
              if (
                n().isExpressionStatement(a, { expression: s }) ||
                n().isTaggedTemplateExpression(a) ||
                (r && n().isExportDefaultDeclaration(a, { declaration: s })) ||
                (t && n().isArrowFunctionExpression(a, { body: s }))
              )
                return !0;
              if (
                !(
                  n().isCallExpression(a, { callee: s }) ||
                  (n().isSequenceExpression(a) && a.expressions[0] === s) ||
                  n().isMemberExpression(a, { object: s }) ||
                  n().isConditional(a, { test: s }) ||
                  n().isBinary(a, { left: s }) ||
                  n().isAssignmentExpression(a, { left: s })
                )
              )
                return !1;
              (s = a), (a = e[--i]);
            }
            return !1;
          }
        },
        { "@babel/types": 100 }
      ],
      18: [
        function(e, t, r) {
          "use strict";
          function n() {
            const t = (function(e) {
              if (e && e.__esModule) return e;
              var t = {};
              if (null != e)
                for (var r in e)
                  if (Object.prototype.hasOwnProperty.call(e, r)) {
                    var n =
                      Object.defineProperty && Object.getOwnPropertyDescriptor
                        ? Object.getOwnPropertyDescriptor(e, r)
                        : {};
                    n.get || n.set
                      ? Object.defineProperty(t, r, n)
                      : (t[r] = e[r]);
                  }
              return (t.default = e), t;
            })(e("@babel/types"));
            return (
              (n = function() {
                return t;
              }),
              t
            );
          }
          function i(e, t = {}) {
            return (
              n().isMemberExpression(e)
                ? (i(e.object, t), e.computed && i(e.property, t))
                : n().isBinary(e) || n().isAssignmentExpression(e)
                ? (i(e.left, t), i(e.right, t))
                : n().isCallExpression(e)
                ? ((t.hasCall = !0), i(e.callee, t))
                : n().isFunction(e)
                ? (t.hasFunction = !0)
                : n().isIdentifier(e) &&
                  (t.hasHelper = t.hasHelper || s(e.callee)),
              t
            );
          }
          function s(e) {
            return n().isMemberExpression(e)
              ? s(e.object) || s(e.property)
              : n().isIdentifier(e)
              ? "require" === e.name || "_" === e.name[0]
              : n().isCallExpression(e)
              ? s(e.callee)
              : !(!n().isBinary(e) && !n().isAssignmentExpression(e)) &&
                ((n().isIdentifier(e.left) && s(e.left)) || s(e.right));
          }
          function a(e) {
            return (
              n().isLiteral(e) ||
              n().isObjectExpression(e) ||
              n().isArrayExpression(e) ||
              n().isIdentifier(e) ||
              n().isMemberExpression(e)
            );
          }
          Object.defineProperty(r, "__esModule", { value: !0 }),
            (r.list = r.nodes = void 0);
          const o = {
            AssignmentExpression(e) {
              const t = i(e.right);
              if ((t.hasCall && t.hasHelper) || t.hasFunction)
                return { before: t.hasFunction, after: !0 };
            },
            SwitchCase: (e, t) => ({
              before: e.consequent.length || t.cases[0] === e,
              after: !e.consequent.length && t.cases[t.cases.length - 1] === e
            }),
            LogicalExpression(e) {
              if (n().isFunction(e.left) || n().isFunction(e.right))
                return { after: !0 };
            },
            Literal(e) {
              if ("use strict" === e.value) return { after: !0 };
            },
            CallExpression(e) {
              if (n().isFunction(e.callee) || s(e))
                return { before: !0, after: !0 };
            },
            VariableDeclaration(e) {
              for (let t = 0; t < e.declarations.length; t++) {
                const r = e.declarations[t];
                let n = s(r.id) && !a(r.init);
                if (!n) {
                  const e = i(r.init);
                  n = (s(r.init) && e.hasCall) || e.hasFunction;
                }
                if (n) return { before: !0, after: !0 };
              }
            },
            IfStatement(e) {
              if (n().isBlockStatement(e.consequent))
                return { before: !0, after: !0 };
            }
          };
          (r.nodes = o),
            (o.ObjectProperty = o.ObjectTypeProperty = o.ObjectMethod = function(
              e,
              t
            ) {
              if (t.properties[0] === e) return { before: !0 };
            }),
            (o.ObjectTypeCallProperty = function(e, t) {
              if (
                !(
                  t.callProperties[0] !== e ||
                  (t.properties && t.properties.length)
                )
              )
                return { before: !0 };
            }),
            (o.ObjectTypeIndexer = function(e, t) {
              if (
                !(
                  t.indexers[0] !== e ||
                  (t.properties && t.properties.length) ||
                  (t.callProperties && t.callProperties.length)
                )
              )
                return { before: !0 };
            }),
            (o.ObjectTypeInternalSlot = function(e, t) {
              if (
                !(
                  t.internalSlots[0] !== e ||
                  (t.properties && t.properties.length) ||
                  (t.callProperties && t.callProperties.length) ||
                  (t.indexers && t.indexers.length)
                )
              )
                return { before: !0 };
            });
          const u = {
            VariableDeclaration: e => e.declarations.map(e => e.init),
            ArrayExpression: e => e.elements,
            ObjectExpression: e => e.properties
          };
          (r.list = u),
            [
              ["Function", !0],
              ["Class", !0],
              ["Loop", !0],
              ["LabeledStatement", !0],
              ["SwitchStatement", !0],
              ["TryStatement", !0]
            ].forEach(function([e, t]) {
              "boolean" == typeof t && (t = { after: t, before: t }),
                [e]
                  .concat(n().FLIPPED_ALIAS_KEYS[e] || [])
                  .forEach(function(e) {
                    o[e] = function() {
                      return t;
                    };
                  });
            });
        },
        { "@babel/types": 100 }
      ],
      19: [
        function(e, t, r) {
          "use strict";
          function n() {
            const t = c(e("lodash/isInteger"));
            return (
              (n = function() {
                return t;
              }),
              t
            );
          }
          function i() {
            const t = c(e("lodash/repeat"));
            return (
              (i = function() {
                return t;
              }),
              t
            );
          }
          Object.defineProperty(r, "__esModule", { value: !0 }),
            (r.default = void 0);
          var s = c(e("./buffer")),
            a = l(e("./node"));
          function o() {
            const t = l(e("@babel/types"));
            return (
              (o = function() {
                return t;
              }),
              t
            );
          }
          var u = l(e("./generators"));
          function l(e) {
            if (e && e.__esModule) return e;
            var t = {};
            if (null != e)
              for (var r in e)
                if (Object.prototype.hasOwnProperty.call(e, r)) {
                  var n =
                    Object.defineProperty && Object.getOwnPropertyDescriptor
                      ? Object.getOwnPropertyDescriptor(e, r)
                      : {};
                  n.get || n.set
                    ? Object.defineProperty(t, r, n)
                    : (t[r] = e[r]);
                }
            return (t.default = e), t;
          }
          function c(e) {
            return e && e.__esModule ? e : { default: e };
          }
          const p = /e/i,
            d = /\.0+$/,
            h = /^0[box]/;
          class f {
            constructor(e, t) {
              (this.inForStatementInitCounter = 0),
                (this._printStack = []),
                (this._indent = 0),
                (this._insideAux = !1),
                (this._printedCommentStarts = {}),
                (this._parenPushNewlineState = null),
                (this._noLineTerminator = !1),
                (this._printAuxAfterOnNextUserNode = !1),
                (this._printedComments = new WeakSet()),
                (this._endsWithInteger = !1),
                (this._endsWithWord = !1),
                (this.format = e || {}),
                (this._buf = new s.default(t));
            }
            generate(e) {
              return this.print(e), this._maybeAddAuxComment(), this._buf.get();
            }
            indent() {
              this.format.compact || this.format.concise || this._indent++;
            }
            dedent() {
              this.format.compact || this.format.concise || this._indent--;
            }
            semicolon(e = !1) {
              this._maybeAddAuxComment(), this._append(";", !e);
            }
            rightBrace() {
              this.format.minified && this._buf.removeLastSemicolon(),
                this.token("}");
            }
            space(e = !1) {
              this.format.compact ||
                (((this._buf.hasContent() &&
                  !this.endsWith(" ") &&
                  !this.endsWith("\n")) ||
                  e) &&
                  this._space());
            }
            word(e) {
              (this._endsWithWord ||
                (this.endsWith("/") && 0 === e.indexOf("/"))) &&
                this._space(),
                this._maybeAddAuxComment(),
                this._append(e),
                (this._endsWithWord = !0);
            }
            number(e) {
              this.word(e),
                (this._endsWithInteger =
                  (0, n().default)(+e) &&
                  !h.test(e) &&
                  !p.test(e) &&
                  !d.test(e) &&
                  "." !== e[e.length - 1]);
            }
            token(e) {
              (("--" === e && this.endsWith("!")) ||
                ("+" === e[0] && this.endsWith("+")) ||
                ("-" === e[0] && this.endsWith("-")) ||
                ("." === e[0] && this._endsWithInteger)) &&
                this._space(),
                this._maybeAddAuxComment(),
                this._append(e);
            }
            newline(e) {
              if (!this.format.retainLines && !this.format.compact)
                if (this.format.concise) this.space();
                else if (
                  !(
                    this.endsWith("\n\n") ||
                    ("number" != typeof e && (e = 1),
                    (e = Math.min(2, e)),
                    (this.endsWith("{\n") || this.endsWith(":\n")) && e--,
                    e <= 0)
                  )
                )
                  for (let t = 0; t < e; t++) this._newline();
            }
            endsWith(e) {
              return this._buf.endsWith(e);
            }
            removeTrailingNewline() {
              this._buf.removeTrailingNewline();
            }
            exactSource(e, t) {
              this._catchUp("start", e), this._buf.exactSource(e, t);
            }
            source(e, t) {
              this._catchUp(e, t), this._buf.source(e, t);
            }
            withSource(e, t, r) {
              this._catchUp(e, t), this._buf.withSource(e, t, r);
            }
            _space() {
              this._append(" ", !0);
            }
            _newline() {
              this._append("\n", !0);
            }
            _append(e, t = !1) {
              this._maybeAddParen(e),
                this._maybeIndent(e),
                t ? this._buf.queue(e) : this._buf.append(e),
                (this._endsWithWord = !1),
                (this._endsWithInteger = !1);
            }
            _maybeIndent(e) {
              this._indent &&
                this.endsWith("\n") &&
                "\n" !== e[0] &&
                this._buf.queue(this._getIndent());
            }
            _maybeAddParen(e) {
              const t = this._parenPushNewlineState;
              if (!t) return;
              let r;
              for (
                this._parenPushNewlineState = null, r = 0;
                r < e.length && " " === e[r];
                r++
              )
                continue;
              if (r === e.length) return;
              const n = e[r];
              if ("\n" !== n) {
                if ("/" !== n) return;
                if (r + 1 === e.length) return;
                const t = e[r + 1];
                if ("/" !== t && "*" !== t) return;
              }
              this.token("("), this.indent(), (t.printed = !0);
            }
            _catchUp(e, t) {
              if (!this.format.retainLines) return;
              const r = t ? t[e] : null;
              if (r && null !== r.line) {
                const e = r.line - this._buf.getCurrentLine();
                for (let t = 0; t < e; t++) this._newline();
              }
            }
            _getIndent() {
              return (0, i().default)(this.format.indent.style, this._indent);
            }
            startTerminatorless(e = !1) {
              return e
                ? ((this._noLineTerminator = !0), null)
                : (this._parenPushNewlineState = { printed: !1 });
            }
            endTerminatorless(e) {
              (this._noLineTerminator = !1),
                e &&
                  e.printed &&
                  (this.dedent(), this.newline(), this.token(")"));
            }
            print(e, t) {
              if (!e) return;
              const r = this.format.concise;
              e._compact && (this.format.concise = !0);
              const n = this[e.type];
              if (!n)
                throw new ReferenceError(
                  `unknown node of type ${JSON.stringify(
                    e.type
                  )} with constructor ${JSON.stringify(
                    e && e.constructor.name
                  )}`
                );
              this._printStack.push(e);
              const i = this._insideAux;
              (this._insideAux = !e.loc),
                this._maybeAddAuxComment(this._insideAux && !i);
              let s = a.needsParens(e, t, this._printStack);
              this.format.retainFunctionParens &&
                "FunctionExpression" === e.type &&
                e.extra &&
                e.extra.parenthesized &&
                (s = !0),
                s && this.token("("),
                this._printLeadingComments(e);
              const u = o().isProgram(e) || o().isFile(e) ? null : e.loc;
              this.withSource("start", u, () => {
                n.call(this, e, t);
              }),
                this._printTrailingComments(e),
                s && this.token(")"),
                this._printStack.pop(),
                (this.format.concise = r),
                (this._insideAux = i);
            }
            _maybeAddAuxComment(e) {
              e && this._printAuxBeforeComment(),
                this._insideAux || this._printAuxAfterComment();
            }
            _printAuxBeforeComment() {
              if (this._printAuxAfterOnNextUserNode) return;
              this._printAuxAfterOnNextUserNode = !0;
              const e = this.format.auxiliaryCommentBefore;
              e && this._printComment({ type: "CommentBlock", value: e });
            }
            _printAuxAfterComment() {
              if (!this._printAuxAfterOnNextUserNode) return;
              this._printAuxAfterOnNextUserNode = !1;
              const e = this.format.auxiliaryCommentAfter;
              e && this._printComment({ type: "CommentBlock", value: e });
            }
            getPossibleRaw(e) {
              const t = e.extra;
              if (
                t &&
                null != t.raw &&
                null != t.rawValue &&
                e.value === t.rawValue
              )
                return t.raw;
            }
            printJoin(e, t, r = {}) {
              if (!e || !e.length) return;
              r.indent && this.indent();
              const n = { addNewlines: r.addNewlines };
              for (let i = 0; i < e.length; i++) {
                const s = e[i];
                s &&
                  (r.statement && this._printNewline(!0, s, t, n),
                  this.print(s, t),
                  r.iterator && r.iterator(s, i),
                  r.separator && i < e.length - 1 && r.separator.call(this),
                  r.statement && this._printNewline(!1, s, t, n));
              }
              r.indent && this.dedent();
            }
            printAndIndentOnComments(e, t) {
              const r = e.leadingComments && e.leadingComments.length > 0;
              r && this.indent(), this.print(e, t), r && this.dedent();
            }
            printBlock(e) {
              const t = e.body;
              o().isEmptyStatement(t) || this.space(), this.print(t, e);
            }
            _printTrailingComments(e) {
              this._printComments(this._getComments(!1, e));
            }
            _printLeadingComments(e) {
              this._printComments(this._getComments(!0, e));
            }
            printInnerComments(e, t = !0) {
              e.innerComments &&
                e.innerComments.length &&
                (t && this.indent(),
                this._printComments(e.innerComments),
                t && this.dedent());
            }
            printSequence(e, t, r = {}) {
              return (r.statement = !0), this.printJoin(e, t, r);
            }
            printList(e, t, r = {}) {
              return (
                null == r.separator && (r.separator = m),
                this.printJoin(e, t, r)
              );
            }
            _printNewline(e, t, r, n) {
              if (this.format.retainLines || this.format.compact) return;
              if (this.format.concise) return void this.space();
              let i = 0;
              if (this._buf.hasContent()) {
                e || i++,
                  n.addNewlines && (i += n.addNewlines(e, t) || 0),
                  (e ? a.needsWhitespaceBefore : a.needsWhitespaceAfter)(
                    t,
                    r
                  ) && i++;
              }
              this.newline(i);
            }
            _getComments(e, t) {
              return (t && (e ? t.leadingComments : t.trailingComments)) || [];
            }
            _printComment(e) {
              if (!this.format.shouldPrintComment(e.value)) return;
              if (e.ignore) return;
              if (this._printedComments.has(e)) return;
              if ((this._printedComments.add(e), null != e.start)) {
                if (this._printedCommentStarts[e.start]) return;
                this._printedCommentStarts[e.start] = !0;
              }
              const t = "CommentBlock" === e.type;
              this.newline(
                this._buf.hasContent() && !this._noLineTerminator && t ? 1 : 0
              ),
                this.endsWith("[") || this.endsWith("{") || this.space();
              let r =
                t || this._noLineTerminator
                  ? `/*${e.value}*/`
                  : `//${e.value}\n`;
              if (t && this.format.indent.adjustMultilineComment) {
                const t = e.loc && e.loc.start.column;
                if (t) {
                  const e = new RegExp("\\n\\s{1," + t + "}", "g");
                  r = r.replace(e, "\n");
                }
                const n = Math.max(
                  this._getIndent().length,
                  this._buf.getCurrentColumn()
                );
                r = r.replace(/\n(?!$)/g, `\n${(0, i().default)(" ", n)}`);
              }
              this.endsWith("/") && this._space(),
                this.withSource("start", e.loc, () => {
                  this._append(r);
                }),
                this.newline(t && !this._noLineTerminator ? 1 : 0);
            }
            _printComments(e) {
              if (e && e.length) for (const t of e) this._printComment(t);
            }
          }
          function m() {
            this.token(","), this.space();
          }
          (r.default = f), Object.assign(f.prototype, u);
        },
        {
          "./buffer": 2,
          "./generators": 7,
          "./node": 16,
          "@babel/types": 100,
          "lodash/isInteger": 280,
          "lodash/repeat": 294
        }
      ],
      20: [
        function(e, t, r) {
          "use strict";
          function n() {
            const t =
              (r = e("source-map")) && r.__esModule ? r : { default: r };
            var r;
            return (
              (n = function() {
                return t;
              }),
              t
            );
          }
          Object.defineProperty(r, "__esModule", { value: !0 }),
            (r.default = void 0);
          r.default = class {
            constructor(e, t) {
              (this._cachedMap = null),
                (this._code = t),
                (this._opts = e),
                (this._rawMappings = []);
            }
            get() {
              if (!this._cachedMap) {
                const e = (this._cachedMap = new (n()).default.SourceMapGenerator(
                    { sourceRoot: this._opts.sourceRoot }
                  )),
                  t = this._code;
                "string" == typeof t
                  ? e.setSourceContent(this._opts.sourceFileName, t)
                  : "object" == typeof t &&
                    Object.keys(t).forEach(r => {
                      e.setSourceContent(r, t[r]);
                    }),
                  this._rawMappings.forEach(e.addMapping, e);
              }
              return this._cachedMap.toJSON();
            }
            getRawMappings() {
              return this._rawMappings.slice();
            }
            mark(e, t, r, n, i, s, a) {
              (this._lastGenLine !== e && null === r) ||
                ((a ||
                  this._lastGenLine !== e ||
                  this._lastSourceLine !== r ||
                  this._lastSourceColumn !== n) &&
                  ((this._cachedMap = null),
                  (this._lastGenLine = e),
                  (this._lastSourceLine = r),
                  (this._lastSourceColumn = n),
                  this._rawMappings.push({
                    name: i || void 0,
                    generated: { line: e, column: t },
                    source: null == r ? void 0 : s || this._opts.sourceFileName,
                    original: null == r ? void 0 : { line: r, column: n }
                  })));
            }
          };
        },
        { "source-map": 314 }
      ],
      21: [
        function(e, t, r) {
          "use strict";
          function n() {
            const t = a(e("@babel/helper-get-function-arity"));
            return (
              (n = function() {
                return t;
              }),
              t
            );
          }
          function i() {
            const t = a(e("@babel/template"));
            return (
              (i = function() {
                return t;
              }),
              t
            );
          }
          function s() {
            const t = (function(e) {
              if (e && e.__esModule) return e;
              var t = {};
              if (null != e)
                for (var r in e)
                  if (Object.prototype.hasOwnProperty.call(e, r)) {
                    var n =
                      Object.defineProperty && Object.getOwnPropertyDescriptor
                        ? Object.getOwnPropertyDescriptor(e, r)
                        : {};
                    n.get || n.set
                      ? Object.defineProperty(t, r, n)
                      : (t[r] = e[r]);
                  }
              return (t.default = e), t;
            })(e("@babel/types"));
            return (
              (s = function() {
                return t;
              }),
              t
            );
          }
          function a(e) {
            return e && e.__esModule ? e : { default: e };
          }
          Object.defineProperty(r, "__esModule", { value: !0 }),
            (r.default = function(
              { node: e, parent: t, scope: r, id: i },
              a = !1
            ) {
              if (e.id) return;
              if (
                (!s().isObjectProperty(t) &&
                  !s().isObjectMethod(t, { kind: "method" })) ||
                (t.computed && !s().isLiteral(t.key))
              ) {
                if (s().isVariableDeclarator(t)) {
                  if (((i = t.id), s().isIdentifier(i) && !a)) {
                    const t = r.parent.getBinding(i.name);
                    if (t && t.constant && r.getBinding(i.name) === t)
                      return (
                        (e.id = s().cloneNode(i)),
                        void (e.id[s().NOT_LOCAL_BINDING] = !0)
                      );
                  }
                } else if (s().isAssignmentExpression(t)) i = t.left;
                else if (!i) return;
              } else i = t.key;
              let c;
              i && s().isLiteral(i)
                ? (c = (function(e) {
                    if (s().isNullLiteral(e)) return "null";
                    if (s().isRegExpLiteral(e))
                      return `_${e.pattern}_${e.flags}`;
                    if (s().isTemplateLiteral(e))
                      return e.quasis.map(e => e.value.raw).join("");
                    if (void 0 !== e.value) return e.value + "";
                    return "";
                  })(i))
                : i && s().isIdentifier(i) && (c = i.name);
              if (void 0 === c) return;
              return (
                (c = s().toBindingIdentifierName(c)),
                ((i = s().identifier(c))[s().NOT_LOCAL_BINDING] = !0),
                (function(e, t, r, i) {
                  if (e.selfReference) {
                    if (!i.hasBinding(r.name) || i.hasGlobal(r.name)) {
                      if (!s().isFunction(t)) return;
                      let e = o;
                      t.generator && (e = u);
                      const a = e({
                          FUNCTION: t,
                          FUNCTION_ID: r,
                          FUNCTION_KEY: i.generateUidIdentifier(r.name)
                        }).expression,
                        l = a.callee.body.body[0].params;
                      for (let e = 0, r = (0, n().default)(t); e < r; e++)
                        l.push(i.generateUidIdentifier("x"));
                      return a;
                    }
                    i.rename(r.name);
                  }
                  (t.id = r), (i.getProgramParent().references[r.name] = !0);
                })(
                  (function(e, t, r) {
                    const n = {
                        selfAssignment: !1,
                        selfReference: !1,
                        outerDeclar: r.getBindingIdentifier(t),
                        references: [],
                        name: t
                      },
                      i = r.getOwnBinding(t);
                    return (
                      i
                        ? "param" === i.kind && (n.selfReference = !0)
                        : (n.outerDeclar || r.hasGlobal(t)) &&
                          r.traverse(e, l, n),
                      n
                    );
                  })(e, c, r),
                  e,
                  i,
                  r
                ) || e
              );
            });
          const o = (0, i().default)(
              "\n  (function (FUNCTION_KEY) {\n    function FUNCTION_ID() {\n      return FUNCTION_KEY.apply(this, arguments);\n    }\n\n    FUNCTION_ID.toString = function () {\n      return FUNCTION_KEY.toString();\n    }\n\n    return FUNCTION_ID;\n  })(FUNCTION)\n"
            ),
            u = (0, i().default)(
              "\n  (function (FUNCTION_KEY) {\n    function* FUNCTION_ID() {\n      return yield* FUNCTION_KEY.apply(this, arguments);\n    }\n\n    FUNCTION_ID.toString = function () {\n      return FUNCTION_KEY.toString();\n    };\n\n    return FUNCTION_ID;\n  })(FUNCTION)\n"
            ),
            l = {
              "ReferencedIdentifier|BindingIdentifier"(e, t) {
                if (e.node.name !== t.name) return;
                e.scope.getBindingIdentifier(t.name) === t.outerDeclar &&
                  ((t.selfReference = !0), e.stop());
              }
            };
        },
        {
          "@babel/helper-get-function-arity": 22,
          "@babel/template": 28,
          "@babel/types": 100
        }
      ],
      22: [
        function(e, t, r) {
          "use strict";
          function n() {
            const t = (function(e) {
              if (e && e.__esModule) return e;
              var t = {};
              if (null != e)
                for (var r in e)
                  if (Object.prototype.hasOwnProperty.call(e, r)) {
                    var n =
                      Object.defineProperty && Object.getOwnPropertyDescriptor
                        ? Object.getOwnPropertyDescriptor(e, r)
                        : {};
                    n.get || n.set
                      ? Object.defineProperty(t, r, n)
                      : (t[r] = e[r]);
                  }
              return (t.default = e), t;
            })(e("@babel/types"));
            return (
              (n = function() {
                return t;
              }),
              t
            );
          }
          Object.defineProperty(r, "__esModule", { value: !0 }),
            (r.default = function(e) {
              const t = e.params;
              for (let e = 0; e < t.length; e++) {
                const r = t[e];
                if (n().isAssignmentPattern(r) || n().isRestElement(r))
                  return e;
              }
              return t.length;
            });
        },
        { "@babel/types": 100 }
      ],
      23: [
        function(e, t, r) {
          "use strict";
          function n() {
            const t = (function(e) {
              if (e && e.__esModule) return e;
              var t = {};
              if (null != e)
                for (var r in e)
                  if (Object.prototype.hasOwnProperty.call(e, r)) {
                    var n =
                      Object.defineProperty && Object.getOwnPropertyDescriptor
                        ? Object.getOwnPropertyDescriptor(e, r)
                        : {};
                    n.get || n.set
                      ? Object.defineProperty(t, r, n)
                      : (t[r] = e[r]);
                  }
              return (t.default = e), t;
            })(e("@babel/types"));
            return (
              (n = function() {
                return t;
              }),
              t
            );
          }
          Object.defineProperty(r, "__esModule", { value: !0 }),
            (r.default = function(e) {
              if (!e.isExportDeclaration())
                throw new Error("Only export declarations can be splitted.");
              const t = e.isExportDefaultDeclaration(),
                r = e.get("declaration"),
                i = r.isClassDeclaration();
              if (t) {
                const t = r.isFunctionDeclaration() || i,
                  s = r.isScope() ? r.scope.parent : r.scope;
                let a = r.node.id,
                  o = !1;
                a ||
                  ((o = !0),
                  (a = s.generateUidIdentifier("default")),
                  (t || r.isFunctionExpression() || r.isClassExpression()) &&
                    (r.node.id = n().cloneNode(a)));
                const u = t
                    ? r
                    : n().variableDeclaration("var", [
                        n().variableDeclarator(n().cloneNode(a), r.node)
                      ]),
                  l = n().exportNamedDeclaration(null, [
                    n().exportSpecifier(
                      n().cloneNode(a),
                      n().identifier("default")
                    )
                  ]);
                return (
                  e.insertAfter(l),
                  e.replaceWith(u),
                  o && s.registerDeclaration(e),
                  e
                );
              }
              if (e.get("specifiers").length > 0)
                throw new Error(
                  "It doesn't make sense to split exported specifiers."
                );
              const s = r.getOuterBindingIdentifiers(),
                a = Object.keys(s).map(e =>
                  n().exportSpecifier(n().identifier(e), n().identifier(e))
                ),
                o = n().exportNamedDeclaration(null, a);
              return e.insertAfter(o), e.replaceWith(r.node), e;
            });
        },
        { "@babel/types": 100 }
      ],
      24: [
        function(e, t, r) {
          "use strict";
          function n() {
            const t = (function(e) {
              if (e && e.__esModule) return e;
              var t = {};
              if (null != e)
                for (var r in e)
                  if (Object.prototype.hasOwnProperty.call(e, r)) {
                    var n =
                      Object.defineProperty && Object.getOwnPropertyDescriptor
                        ? Object.getOwnPropertyDescriptor(e, r)
                        : {};
                    n.get || n.set
                      ? Object.defineProperty(t, r, n)
                      : (t[r] = e[r]);
                  }
              return (t.default = e), t;
            })(e("js-tokens"));
            return (
              (n = function() {
                return t;
              }),
              t
            );
          }
          function i() {
            const t = a(e("esutils"));
            return (
              (i = function() {
                return t;
              }),
              t
            );
          }
          function s() {
            const t = a(e("chalk"));
            return (
              (s = function() {
                return t;
              }),
              t
            );
          }
          function a(e) {
            return e && e.__esModule ? e : { default: e };
          }
          Object.defineProperty(r, "__esModule", { value: !0 }),
            (r.shouldHighlight = c),
            (r.getChalk = p),
            (r.default = function(e, t = {}) {
              if (c(t)) {
                const r = p(t),
                  s = (function(e) {
                    return {
                      keyword: e.cyan,
                      capitalized: e.yellow,
                      jsx_tag: e.yellow,
                      punctuator: e.yellow,
                      number: e.magenta,
                      string: e.green,
                      regex: e.magenta,
                      comment: e.grey,
                      invalid: e.white.bgRed.bold
                    };
                  })(r);
                return (function(e, t) {
                  return t.replace(n().default, function(...t) {
                    const r = (function(e) {
                        const [t, r] = e.slice(-2),
                          s = (0, n().matchToToken)(e);
                        if ("name" === s.type) {
                          if (i().default.keyword.isReservedWordES6(s.value))
                            return "keyword";
                          if (
                            u.test(s.value) &&
                            ("<" === r[t - 1] || "</" == r.substr(t - 2, 2))
                          )
                            return "jsx_tag";
                          if (s.value[0] !== s.value[0].toLowerCase())
                            return "capitalized";
                        }
                        if ("punctuator" === s.type && l.test(s.value))
                          return "bracket";
                        if (
                          "invalid" === s.type &&
                          ("@" === s.value || "#" === s.value)
                        )
                          return "punctuator";
                        return s.type;
                      })(t),
                      s = e[r];
                    return s
                      ? t[0]
                          .split(o)
                          .map(e => s(e))
                          .join("\n")
                      : t[0];
                  });
                })(s, e);
              }
              return e;
            });
          const o = /\r\n|[\n\r\u2028\u2029]/,
            u = /^[a-z][\w-]*$/i,
            l = /^[()[\]{}]$/;
          function c(e) {
            return s().default.supportsColor || e.forceColor;
          }
          function p(e) {
            let t = s().default;
            return (
              e.forceColor &&
                (t = new (s()).default.constructor({ enabled: !0, level: 1 })),
              t
            );
          }
        },
        { chalk: 136, esutils: 148, "js-tokens": 151 }
      ],
      25: [
        function(e, t, r) {
          "use strict";
          Object.defineProperty(r, "__esModule", { value: !0 });
          const n = !0;
          class i {
            constructor(e, t = {}) {
              (this.label = e),
                (this.keyword = t.keyword),
                (this.beforeExpr = !!t.beforeExpr),
                (this.startsExpr = !!t.startsExpr),
                (this.rightAssociative = !!t.rightAssociative),
                (this.isLoop = !!t.isLoop),
                (this.isAssign = !!t.isAssign),
                (this.prefix = !!t.prefix),
                (this.postfix = !!t.postfix),
                (this.binop = null != t.binop ? t.binop : null),
                (this.updateContext = null);
            }
          }
          const s = new Map();
          function a(e, t = {}) {
            t.keyword = e;
            const r = new i(e, t);
            return s.set(e, r), r;
          }
          function o(e, t) {
            return new i(e, { beforeExpr: n, binop: t });
          }
          const u = {
              num: new i("num", { startsExpr: !0 }),
              bigint: new i("bigint", { startsExpr: !0 }),
              regexp: new i("regexp", { startsExpr: !0 }),
              string: new i("string", { startsExpr: !0 }),
              name: new i("name", { startsExpr: !0 }),
              eof: new i("eof"),
              bracketL: new i("[", { beforeExpr: n, startsExpr: !0 }),
              bracketR: new i("]"),
              braceL: new i("{", { beforeExpr: n, startsExpr: !0 }),
              braceBarL: new i("{|", { beforeExpr: n, startsExpr: !0 }),
              braceR: new i("}"),
              braceBarR: new i("|}"),
              parenL: new i("(", { beforeExpr: n, startsExpr: !0 }),
              parenR: new i(")"),
              comma: new i(",", { beforeExpr: n }),
              semi: new i(";", { beforeExpr: n }),
              colon: new i(":", { beforeExpr: n }),
              doubleColon: new i("::", { beforeExpr: n }),
              dot: new i("."),
              question: new i("?", { beforeExpr: n }),
              questionDot: new i("?."),
              arrow: new i("=>", { beforeExpr: n }),
              template: new i("template"),
              ellipsis: new i("...", { beforeExpr: n }),
              backQuote: new i("`", { startsExpr: !0 }),
              dollarBraceL: new i("${", { beforeExpr: n, startsExpr: !0 }),
              at: new i("@"),
              hash: new i("#", { startsExpr: !0 }),
              interpreterDirective: new i("#!..."),
              eq: new i("=", { beforeExpr: n, isAssign: !0 }),
              assign: new i("_=", { beforeExpr: n, isAssign: !0 }),
              incDec: new i("++/--", {
                prefix: !0,
                postfix: !0,
                startsExpr: !0
              }),
              bang: new i("!", { beforeExpr: n, prefix: !0, startsExpr: !0 }),
              tilde: new i("~", { beforeExpr: n, prefix: !0, startsExpr: !0 }),
              pipeline: o("|>", 0),
              nullishCoalescing: o("??", 1),
              logicalOR: o("||", 1),
              logicalAND: o("&&", 2),
              bitwiseOR: o("|", 3),
              bitwiseXOR: o("^", 4),
              bitwiseAND: o("&", 5),
              equality: o("==/!=/===/!==", 6),
              relational: o("</>/<=/>=", 7),
              bitShift: o("<</>>/>>>", 8),
              plusMin: new i("+/-", {
                beforeExpr: n,
                binop: 9,
                prefix: !0,
                startsExpr: !0
              }),
              modulo: o("%", 10),
              star: o("*", 10),
              slash: o("/", 10),
              exponent: new i("**", {
                beforeExpr: n,
                binop: 11,
                rightAssociative: !0
              }),
              _break: a("break"),
              _case: a("case", { beforeExpr: n }),
              _catch: a("catch"),
              _continue: a("continue"),
              _debugger: a("debugger"),
              _default: a("default", { beforeExpr: n }),
              _do: a("do", { isLoop: !0, beforeExpr: n }),
              _else: a("else", { beforeExpr: n }),
              _finally: a("finally"),
              _for: a("for", { isLoop: !0 }),
              _function: a("function", { startsExpr: !0 }),
              _if: a("if"),
              _return: a("return", { beforeExpr: n }),
              _switch: a("switch"),
              _throw: a("throw", { beforeExpr: n, prefix: !0, startsExpr: !0 }),
              _try: a("try"),
              _var: a("var"),
              _const: a("const"),
              _while: a("while", { isLoop: !0 }),
              _with: a("with"),
              _new: a("new", { beforeExpr: n, startsExpr: !0 }),
              _this: a("this", { startsExpr: !0 }),
              _super: a("super", { startsExpr: !0 }),
              _class: a("class", { startsExpr: !0 }),
              _extends: a("extends", { beforeExpr: n }),
              _export: a("export"),
              _import: a("import", { startsExpr: !0 }),
              _null: a("null", { startsExpr: !0 }),
              _true: a("true", { startsExpr: !0 }),
              _false: a("false", { startsExpr: !0 }),
              _in: a("in", { beforeExpr: n, binop: 7 }),
              _instanceof: a("instanceof", { beforeExpr: n, binop: 7 }),
              _typeof: a("typeof", {
                beforeExpr: n,
                prefix: !0,
                startsExpr: !0
              }),
              _void: a("void", { beforeExpr: n, prefix: !0, startsExpr: !0 }),
              _delete: a("delete", {
                beforeExpr: n,
                prefix: !0,
                startsExpr: !0
              })
            },
            l = 0,
            c = 1,
            p = 2,
            d = 4,
            h = 8,
            f = 16,
            m = 32,
            y = 64,
            g = 128,
            b = 256,
            v = c | p;
          function E(e, t) {
            return p | (e ? d : 0) | (t ? h : 0);
          }
          const T = 1,
            x = 2,
            A = 4,
            S = 8,
            D = 16,
            P = 128,
            C = 256,
            w = 512,
            F = 1024,
            _ = T | x | S | P,
            O = 0 | T | S | 0,
            k = 0 | T | A | 0,
            I = 0 | T | D | 0,
            N = 0 | x | P,
            L = 0 | x,
            B = T | x | S | C,
            M = 0 | F,
            j = 64,
            R = 64 | T,
            q = B | w,
            V = M;
          function U(e) {
            return (
              null != e &&
              "Property" === e.type &&
              "init" === e.kind &&
              !1 === e.method
            );
          }
          const K = /\r\n?|[\n\u2028\u2029]/,
            G = new RegExp(K.source, "g");
          function W(e) {
            switch (e) {
              case 10:
              case 13:
              case 8232:
              case 8233:
                return !0;
              default:
                return !1;
            }
          }
          const J = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;
          function X(e) {
            switch (e) {
              case 9:
              case 11:
              case 12:
              case 32:
              case 160:
              case 5760:
              case 8192:
              case 8193:
              case 8194:
              case 8195:
              case 8196:
              case 8197:
              case 8198:
              case 8199:
              case 8200:
              case 8201:
              case 8202:
              case 8239:
              case 8287:
              case 12288:
              case 65279:
                return !0;
              default:
                return !1;
            }
          }
          class $ {
            constructor(e, t, r, n) {
              (this.token = e),
                (this.isExpr = !!t),
                (this.preserveSpace = !!r),
                (this.override = n);
            }
          }
          const H = {
            braceStatement: new $("{", !1),
            braceExpression: new $("{", !0),
            templateQuasi: new $("${", !1),
            parenStatement: new $("(", !1),
            parenExpression: new $("(", !0),
            template: new $("`", !0, !0, e => e.readTmplToken()),
            functionExpression: new $("function", !0),
            functionStatement: new $("function", !1)
          };
          (u.parenR.updateContext = u.braceR.updateContext = function() {
            if (1 === this.state.context.length)
              return void (this.state.exprAllowed = !0);
            let e = this.state.context.pop();
            e === H.braceStatement &&
              "function" === this.curContext().token &&
              (e = this.state.context.pop()),
              (this.state.exprAllowed = !e.isExpr);
          }),
            (u.name.updateContext = function(e) {
              let t = !1;
              e !== u.dot &&
                (("of" === this.state.value && !this.state.exprAllowed) ||
                  ("yield" === this.state.value && this.scope.inGenerator)) &&
                (t = !0),
                (this.state.exprAllowed = t),
                this.state.isIterator && (this.state.isIterator = !1);
            }),
            (u.braceL.updateContext = function(e) {
              this.state.context.push(
                this.braceIsBlock(e) ? H.braceStatement : H.braceExpression
              ),
                (this.state.exprAllowed = !0);
            }),
            (u.dollarBraceL.updateContext = function() {
              this.state.context.push(H.templateQuasi),
                (this.state.exprAllowed = !0);
            }),
            (u.parenL.updateContext = function(e) {
              const t =
                e === u._if || e === u._for || e === u._with || e === u._while;
              this.state.context.push(t ? H.parenStatement : H.parenExpression),
                (this.state.exprAllowed = !0);
            }),
            (u.incDec.updateContext = function() {}),
            (u._function.updateContext = u._class.updateContext = function(e) {
              !e.beforeExpr ||
              e === u.semi ||
              e === u._else ||
              (e === u._return &&
                K.test(
                  this.input.slice(this.state.lastTokEnd, this.state.start)
                )) ||
              ((e === u.colon || e === u.braceL) &&
                this.curContext() === H.b_stat)
                ? this.state.context.push(H.functionStatement)
                : this.state.context.push(H.functionExpression),
                (this.state.exprAllowed = !1);
            }),
            (u.backQuote.updateContext = function() {
              this.curContext() === H.template
                ? this.state.context.pop()
                : this.state.context.push(H.template),
                (this.state.exprAllowed = !1);
            });
          const Y = {
              strict: [
                "implements",
                "interface",
                "let",
                "package",
                "private",
                "protected",
                "public",
                "static",
                "yield"
              ],
              strictBind: ["eval", "arguments"]
            },
            z = new Set(Y.strict),
            Q = new Set(Y.strict.concat(Y.strictBind)),
            Z = (e, t) => (t && "await" === e) || "enum" === e;
          function ee(e, t) {
            return Z(e, t) || z.has(e);
          }
          function te(e, t) {
            return Z(e, t) || Q.has(e);
          }
          const re = /^in(stanceof)?$/;
          let ne =
              "ªµºÀ-ÖØ-öø-ˁˆ-ˑˠ-ˤˬˮͰ-ʹͶͷͺ-ͽͿΆΈ-ΊΌΎ-ΡΣ-ϵϷ-ҁҊ-ԯԱ-Ֆՙՠ-ֈא-תׯ-ײؠ-يٮٯٱ-ۓەۥۦۮۯۺ-ۼۿܐܒ-ܯݍ-ޥޱߊ-ߪߴߵߺࠀ-ࠕࠚࠤࠨࡀ-ࡘࡠ-ࡪࢠ-ࢴࢶ-ࢽऄ-हऽॐक़-ॡॱ-ঀঅ-ঌএঐও-নপ-রলশ-হঽৎড়ঢ়য়-ৡৰৱৼਅ-ਊਏਐਓ-ਨਪ-ਰਲਲ਼ਵਸ਼ਸਹਖ਼-ੜਫ਼ੲ-ੴઅ-ઍએ-ઑઓ-નપ-રલળવ-હઽૐૠૡૹଅ-ଌଏଐଓ-ନପ-ରଲଳଵ-ହଽଡ଼ଢ଼ୟ-ୡୱஃஅ-ஊஎ-ஐஒ-கஙசஜஞடணதந-பம-ஹௐఅ-ఌఎ-ఐఒ-నప-హఽౘ-ౚౠౡಀಅ-ಌಎ-ಐಒ-ನಪ-ಳವ-ಹಽೞೠೡೱೲഅ-ഌഎ-ഐഒ-ഺഽൎൔ-ൖൟ-ൡൺ-ൿඅ-ඖක-නඳ-රලව-ෆก-ะาำเ-ๆກຂຄຆ-ຊຌ-ຣລວ-ະາຳຽເ-ໄໆໜ-ໟༀཀ-ཇཉ-ཬྈ-ྌက-ဪဿၐ-ၕၚ-ၝၡၥၦၮ-ၰၵ-ႁႎႠ-ჅჇჍა-ჺჼ-ቈቊ-ቍቐ-ቖቘቚ-ቝበ-ኈኊ-ኍነ-ኰኲ-ኵኸ-ኾዀዂ-ዅወ-ዖዘ-ጐጒ-ጕጘ-ፚᎀ-ᎏᎠ-Ᏽᏸ-ᏽᐁ-ᙬᙯ-ᙿᚁ-ᚚᚠ-ᛪᛮ-ᛸᜀ-ᜌᜎ-ᜑᜠ-ᜱᝀ-ᝑᝠ-ᝬᝮ-ᝰក-ឳៗៜᠠ-ᡸᢀ-ᢨᢪᢰ-ᣵᤀ-ᤞᥐ-ᥭᥰ-ᥴᦀ-ᦫᦰ-ᧉᨀ-ᨖᨠ-ᩔᪧᬅ-ᬳᭅ-ᭋᮃ-ᮠᮮᮯᮺ-ᯥᰀ-ᰣᱍ-ᱏᱚ-ᱽᲀ-ᲈᲐ-ᲺᲽ-Ჿᳩ-ᳬᳮ-ᳳᳵᳶᳺᴀ-ᶿḀ-ἕἘ-Ἕἠ-ὅὈ-Ὅὐ-ὗὙὛὝὟ-ώᾀ-ᾴᾶ-ᾼιῂ-ῄῆ-ῌῐ-ΐῖ-Ίῠ-Ῥῲ-ῴῶ-ῼⁱⁿₐ-ₜℂℇℊ-ℓℕ℘-ℝℤΩℨK-ℹℼ-ℿⅅ-ⅉⅎⅠ-ↈⰀ-Ⱞⰰ-ⱞⱠ-ⳤⳫ-ⳮⳲⳳⴀ-ⴥⴧⴭⴰ-ⵧⵯⶀ-ⶖⶠ-ⶦⶨ-ⶮⶰ-ⶶⶸ-ⶾⷀ-ⷆⷈ-ⷎⷐ-ⷖⷘ-ⷞ々-〇〡-〩〱-〵〸-〼ぁ-ゖ゛-ゟァ-ヺー-ヿㄅ-ㄯㄱ-ㆎㆠ-ㆺㇰ-ㇿ㐀-䶵一-鿯ꀀ-ꒌꓐ-ꓽꔀ-ꘌꘐ-ꘟꘪꘫꙀ-ꙮꙿ-ꚝꚠ-ꛯꜗ-ꜟꜢ-ꞈꞋ-ꞿꟂ-Ᶎꟷ-ꠁꠃ-ꠅꠇ-ꠊꠌ-ꠢꡀ-ꡳꢂ-ꢳꣲ-ꣷꣻꣽꣾꤊ-ꤥꤰ-ꥆꥠ-ꥼꦄ-ꦲꧏꧠ-ꧤꧦ-ꧯꧺ-ꧾꨀ-ꨨꩀ-ꩂꩄ-ꩋꩠ-ꩶꩺꩾ-ꪯꪱꪵꪶꪹ-ꪽꫀꫂꫛ-ꫝꫠ-ꫪꫲ-ꫴꬁ-ꬆꬉ-ꬎꬑ-ꬖꬠ-ꬦꬨ-ꬮꬰ-ꭚꭜ-ꭧꭰ-ꯢ가-힣ힰ-ퟆퟋ-ퟻ豈-舘並-龎ﬀ-ﬆﬓ-ﬗיִײַ-ﬨשׁ-זּטּ-לּמּנּסּףּפּצּ-ﮱﯓ-ﴽﵐ-ﶏﶒ-ﷇﷰ-ﷻﹰ-ﹴﹶ-ﻼＡ-Ｚａ-ｚｦ-ﾾￂ-ￇￊ-ￏￒ-ￗￚ-ￜ",
            ie =
              "‌‍·̀-ͯ·҃-֑҇-ׇֽֿׁׂׅׄؐ-ًؚ-٩ٰۖ-ۜ۟-۪ۤۧۨ-ۭ۰-۹ܑܰ-݊ަ-ް߀-߉߫-߽߳ࠖ-࠙ࠛ-ࠣࠥ-ࠧࠩ-࡙࠭-࡛࣓-ࣣ࣡-ःऺ-़ा-ॏ॑-ॗॢॣ०-९ঁ-ঃ়া-ৄেৈো-্ৗৢৣ০-৯৾ਁ-ਃ਼ਾ-ੂੇੈੋ-੍ੑ੦-ੱੵઁ-ઃ઼ા-ૅે-ૉો-્ૢૣ૦-૯ૺ-૿ଁ-ଃ଼ା-ୄେୈୋ-୍ୖୗୢୣ୦-୯ஂா-ூெ-ைொ-்ௗ௦-௯ఀ-ఄా-ౄె-ైొ-్ౕౖౢౣ౦-౯ಁ-ಃ಼ಾ-ೄೆ-ೈೊ-್ೕೖೢೣ೦-೯ഀ-ഃ഻഼ാ-ൄെ-ൈൊ-്ൗൢൣ൦-൯ංඃ්ා-ුූෘ-ෟ෦-෯ෲෳัิ-ฺ็-๎๐-๙ັິ-ຼ່-ໍ໐-໙༘༙༠-༩༹༵༷༾༿ཱ-྄྆྇ྍ-ྗྙ-ྼ࿆ါ-ှ၀-၉ၖ-ၙၞ-ၠၢ-ၤၧ-ၭၱ-ၴႂ-ႍႏ-ႝ፝-፟፩-፱ᜒ-᜔ᜲ-᜴ᝒᝓᝲᝳ឴-៓៝០-៩᠋-᠍᠐-᠙ᢩᤠ-ᤫᤰ-᤻᥆-᥏᧐-᧚ᨗ-ᨛᩕ-ᩞ᩠-᩿᩼-᪉᪐-᪙᪰-᪽ᬀ-ᬄ᬴-᭄᭐-᭙᭫-᭳ᮀ-ᮂᮡ-ᮭ᮰-᮹᯦-᯳ᰤ-᰷᱀-᱉᱐-᱙᳐-᳔᳒-᳨᳭᳴᳷-᳹᷀-᷹᷻-᷿‿⁀⁔⃐-⃥⃜⃡-⃰⳯-⵿⳱ⷠ-〪ⷿ-゙゚〯꘠-꘩꙯ꙴ-꙽ꚞꚟ꛰꛱ꠂ꠆ꠋꠣ-ꠧꢀꢁꢴ-ꣅ꣐-꣙꣠-꣱ꣿ-꤉ꤦ-꤭ꥇ-꥓ꦀ-ꦃ꦳-꧀꧐-꧙ꧥ꧰-꧹ꨩ-ꨶꩃꩌꩍ꩐-꩙ꩻ-ꩽꪰꪲ-ꪴꪷꪸꪾ꪿꫁ꫫ-ꫯꫵ꫶ꯣ-ꯪ꯬꯭꯰-꯹ﬞ︀-️︠-︯︳︴﹍-﹏０-９＿";
          const se = new RegExp("[" + ne + "]"),
            ae = new RegExp("[" + ne + ie + "]");
          ne = ie = null;
          const oe = [
              0,
              11,
              2,
              25,
              2,
              18,
              2,
              1,
              2,
              14,
              3,
              13,
              35,
              122,
              70,
              52,
              268,
              28,
              4,
              48,
              48,
              31,
              14,
              29,
              6,
              37,
              11,
              29,
              3,
              35,
              5,
              7,
              2,
              4,
              43,
              157,
              19,
              35,
              5,
              35,
              5,
              39,
              9,
              51,
              157,
              310,
              10,
              21,
              11,
              7,
              153,
              5,
              3,
              0,
              2,
              43,
              2,
              1,
              4,
              0,
              3,
              22,
              11,
              22,
              10,
              30,
              66,
              18,
              2,
              1,
              11,
              21,
              11,
              25,
              71,
              55,
              7,
              1,
              65,
              0,
              16,
              3,
              2,
              2,
              2,
              28,
              43,
              28,
              4,
              28,
              36,
              7,
              2,
              27,
              28,
              53,
              11,
              21,
              11,
              18,
              14,
              17,
              111,
              72,
              56,
              50,
              14,
              50,
              14,
              35,
              477,
              28,
              11,
              0,
              9,
              21,
              155,
              22,
              13,
              52,
              76,
              44,
              33,
              24,
              27,
              35,
              30,
              0,
              12,
              34,
              4,
              0,
              13,
              47,
              15,
              3,
              22,
              0,
              2,
              0,
              36,
              17,
              2,
              24,
              85,
              6,
              2,
              0,
              2,
              3,
              2,
              14,
              2,
              9,
              8,
              46,
              39,
              7,
              3,
              1,
              3,
              21,
              2,
              6,
              2,
              1,
              2,
              4,
              4,
              0,
              19,
              0,
              13,
              4,
              159,
              52,
              19,
              3,
              21,
              0,
              33,
              47,
              21,
              1,
              2,
              0,
              185,
              46,
              42,
              3,
              37,
              47,
              21,
              0,
              60,
              42,
              14,
              0,
              72,
              26,
              230,
              43,
              117,
              63,
              32,
              0,
              161,
              7,
              3,
              38,
              17,
              0,
              2,
              0,
              29,
              0,
              11,
              39,
              8,
              0,
              22,
              0,
              12,
              45,
              20,
              0,
              35,
              56,
              264,
              8,
              2,
              36,
              18,
              0,
              50,
              29,
              113,
              6,
              2,
              1,
              2,
              37,
              22,
              0,
              26,
              5,
              2,
              1,
              2,
              31,
              15,
              0,
              328,
              18,
              270,
              921,
              103,
              110,
              18,
              195,
              2749,
              1070,
              4050,
              582,
              8634,
              568,
              8,
              30,
              114,
              29,
              19,
              47,
              17,
              3,
              32,
              20,
              6,
              18,
              689,
              63,
              129,
              74,
              6,
              0,
              67,
              12,
              65,
              1,
              2,
              0,
              29,
              6135,
              9,
              754,
              9486,
              286,
              50,
              2,
              18,
              3,
              9,
              395,
              2309,
              106,
              6,
              12,
              4,
              8,
              8,
              9,
              5991,
              84,
              2,
              70,
              2,
              1,
              3,
              0,
              3,
              1,
              3,
              3,
              2,
              11,
              2,
              0,
              2,
              6,
              2,
              64,
              2,
              3,
              3,
              7,
              2,
              6,
              2,
              27,
              2,
              3,
              2,
              4,
              2,
              0,
              4,
              6,
              2,
              339,
              3,
              24,
              2,
              24,
              2,
              30,
              2,
              24,
              2,
              30,
              2,
              24,
              2,
              30,
              2,
              24,
              2,
              30,
              2,
              24,
              2,
              7,
              2357,
              44,
              11,
              6,
              17,
              0,
              370,
              43,
              1301,
              196,
              60,
              67,
              8,
              0,
              1205,
              3,
              2,
              26,
              2,
              1,
              2,
              0,
              3,
              0,
              2,
              9,
              2,
              3,
              2,
              0,
              2,
              0,
              7,
              0,
              5,
              0,
              2,
              0,
              2,
              0,
              2,
              2,
              2,
              1,
              2,
              0,
              3,
              0,
              2,
              0,
              2,
              0,
              2,
              0,
              2,
              0,
              2,
              1,
              2,
              0,
              3,
              3,
              2,
              6,
              2,
              3,
              2,
              3,
              2,
              0,
              2,
              9,
              2,
              16,
              6,
              2,
              2,
              4,
              2,
              16,
              4421,
              42710,
              42,
              4148,
              12,
              221,
              3,
              5761,
              15,
              7472,
              3104,
              541
            ],
            ue = [
              509,
              0,
              227,
              0,
              150,
              4,
              294,
              9,
              1368,
              2,
              2,
              1,
              6,
              3,
              41,
              2,
              5,
              0,
              166,
              1,
              574,
              3,
              9,
              9,
              525,
              10,
              176,
              2,
              54,
              14,
              32,
              9,
              16,
              3,
              46,
              10,
              54,
              9,
              7,
              2,
              37,
              13,
              2,
              9,
              6,
              1,
              45,
              0,
              13,
              2,
              49,
              13,
              9,
              3,
              4,
              9,
              83,
              11,
              7,
              0,
              161,
              11,
              6,
              9,
              7,
              3,
              56,
              1,
              2,
              6,
              3,
              1,
              3,
              2,
              10,
              0,
              11,
              1,
              3,
              6,
              4,
              4,
              193,
              17,
              10,
              9,
              5,
              0,
              82,
              19,
              13,
              9,
              214,
              6,
              3,
              8,
              28,
              1,
              83,
              16,
              16,
              9,
              82,
              12,
              9,
              9,
              84,
              14,
              5,
              9,
              243,
              14,
              166,
              9,
              232,
              6,
              3,
              6,
              4,
              0,
              29,
              9,
              41,
              6,
              2,
              3,
              9,
              0,
              10,
              10,
              47,
              15,
              406,
              7,
              2,
              7,
              17,
              9,
              57,
              21,
              2,
              13,
              123,
              5,
              4,
              0,
              2,
              1,
              2,
              6,
              2,
              0,
              9,
              9,
              49,
              4,
              2,
              1,
              2,
              4,
              9,
              9,
              330,
              3,
              19306,
              9,
              135,
              4,
              60,
              6,
              26,
              9,
              1014,
              0,
              2,
              54,
              8,
              3,
              19723,
              1,
              5319,
              4,
              4,
              5,
              9,
              7,
              3,
              6,
              31,
              3,
              149,
              2,
              1418,
              49,
              513,
              54,
              5,
              49,
              9,
              0,
              15,
              0,
              23,
              4,
              2,
              14,
              1361,
              6,
              2,
              16,
              3,
              6,
              2,
              1,
              2,
              4,
              262,
              6,
              10,
              9,
              419,
              13,
              1495,
              6,
              110,
              6,
              6,
              9,
              792487,
              239
            ];
          function le(e, t) {
            let r = 65536;
            for (let n = 0, i = t.length; n < i; n += 2) {
              if ((r += t[n]) > e) return !1;
              if ((r += t[n + 1]) >= e) return !0;
            }
            return !1;
          }
          function ce(e) {
            return e < 65
              ? 36 === e
              : e <= 90 ||
                  (e < 97
                    ? 95 === e
                    : e <= 122 ||
                      (e <= 65535
                        ? e >= 170 && se.test(String.fromCharCode(e))
                        : le(e, oe)));
          }
          function pe(e) {
            return e < 48
              ? 36 === e
              : e < 58 ||
                  (!(e < 65) &&
                    (e <= 90 ||
                      (e < 97
                        ? 95 === e
                        : e <= 122 ||
                          (e <= 65535
                            ? e >= 170 && ae.test(String.fromCharCode(e))
                            : le(e, oe) || le(e, ue)))));
          }
          const de = [
            "any",
            "bool",
            "boolean",
            "empty",
            "false",
            "mixed",
            "null",
            "number",
            "static",
            "string",
            "true",
            "typeof",
            "void",
            "interface",
            "extends",
            "_"
          ];
          function he(e) {
            return "type" === e.importKind || "typeof" === e.importKind;
          }
          function fe(e) {
            return (
              (e.type === u.name || !!e.type.keyword) && "from" !== e.value
            );
          }
          const me = {
            const: "declare export var",
            let: "declare export var",
            type: "export type",
            interface: "export interface"
          };
          const ye = /\*?\s*@((?:no)?flow)\b/;
          const ge = {
              quot: '"',
              amp: "&",
              apos: "'",
              lt: "<",
              gt: ">",
              nbsp: " ",
              iexcl: "¡",
              cent: "¢",
              pound: "£",
              curren: "¤",
              yen: "¥",
              brvbar: "¦",
              sect: "§",
              uml: "¨",
              copy: "©",
              ordf: "ª",
              laquo: "«",
              not: "¬",
              shy: "­",
              reg: "®",
              macr: "¯",
              deg: "°",
              plusmn: "±",
              sup2: "²",
              sup3: "³",
              acute: "´",
              micro: "µ",
              para: "¶",
              middot: "·",
              cedil: "¸",
              sup1: "¹",
              ordm: "º",
              raquo: "»",
              frac14: "¼",
              frac12: "½",
              frac34: "¾",
              iquest: "¿",
              Agrave: "À",
              Aacute: "Á",
              Acirc: "Â",
              Atilde: "Ã",
              Auml: "Ä",
              Aring: "Å",
              AElig: "Æ",
              Ccedil: "Ç",
              Egrave: "È",
              Eacute: "É",
              Ecirc: "Ê",
              Euml: "Ë",
              Igrave: "Ì",
              Iacute: "Í",
              Icirc: "Î",
              Iuml: "Ï",
              ETH: "Ð",
              Ntilde: "Ñ",
              Ograve: "Ò",
              Oacute: "Ó",
              Ocirc: "Ô",
              Otilde: "Õ",
              Ouml: "Ö",
              times: "×",
              Oslash: "Ø",
              Ugrave: "Ù",
              Uacute: "Ú",
              Ucirc: "Û",
              Uuml: "Ü",
              Yacute: "Ý",
              THORN: "Þ",
              szlig: "ß",
              agrave: "à",
              aacute: "á",
              acirc: "â",
              atilde: "ã",
              auml: "ä",
              aring: "å",
              aelig: "æ",
              ccedil: "ç",
              egrave: "è",
              eacute: "é",
              ecirc: "ê",
              euml: "ë",
              igrave: "ì",
              iacute: "í",
              icirc: "î",
              iuml: "ï",
              eth: "ð",
              ntilde: "ñ",
              ograve: "ò",
              oacute: "ó",
              ocirc: "ô",
              otilde: "õ",
              ouml: "ö",
              divide: "÷",
              oslash: "ø",
              ugrave: "ù",
              uacute: "ú",
              ucirc: "û",
              uuml: "ü",
              yacute: "ý",
              thorn: "þ",
              yuml: "ÿ",
              OElig: "Œ",
              oelig: "œ",
              Scaron: "Š",
              scaron: "š",
              Yuml: "Ÿ",
              fnof: "ƒ",
              circ: "ˆ",
              tilde: "˜",
              Alpha: "Α",
              Beta: "Β",
              Gamma: "Γ",
              Delta: "Δ",
              Epsilon: "Ε",
              Zeta: "Ζ",
              Eta: "Η",
              Theta: "Θ",
              Iota: "Ι",
              Kappa: "Κ",
              Lambda: "Λ",
              Mu: "Μ",
              Nu: "Ν",
              Xi: "Ξ",
              Omicron: "Ο",
              Pi: "Π",
              Rho: "Ρ",
              Sigma: "Σ",
              Tau: "Τ",
              Upsilon: "Υ",
              Phi: "Φ",
              Chi: "Χ",
              Psi: "Ψ",
              Omega: "Ω",
              alpha: "α",
              beta: "β",
              gamma: "γ",
              delta: "δ",
              epsilon: "ε",
              zeta: "ζ",
              eta: "η",
              theta: "θ",
              iota: "ι",
              kappa: "κ",
              lambda: "λ",
              mu: "μ",
              nu: "ν",
              xi: "ξ",
              omicron: "ο",
              pi: "π",
              rho: "ρ",
              sigmaf: "ς",
              sigma: "σ",
              tau: "τ",
              upsilon: "υ",
              phi: "φ",
              chi: "χ",
              psi: "ψ",
              omega: "ω",
              thetasym: "ϑ",
              upsih: "ϒ",
              piv: "ϖ",
              ensp: " ",
              emsp: " ",
              thinsp: " ",
              zwnj: "‌",
              zwj: "‍",
              lrm: "‎",
              rlm: "‏",
              ndash: "–",
              mdash: "—",
              lsquo: "‘",
              rsquo: "’",
              sbquo: "‚",
              ldquo: "“",
              rdquo: "”",
              bdquo: "„",
              dagger: "†",
              Dagger: "‡",
              bull: "•",
              hellip: "…",
              permil: "‰",
              prime: "′",
              Prime: "″",
              lsaquo: "‹",
              rsaquo: "›",
              oline: "‾",
              frasl: "⁄",
              euro: "€",
              image: "ℑ",
              weierp: "℘",
              real: "ℜ",
              trade: "™",
              alefsym: "ℵ",
              larr: "←",
              uarr: "↑",
              rarr: "→",
              darr: "↓",
              harr: "↔",
              crarr: "↵",
              lArr: "⇐",
              uArr: "⇑",
              rArr: "⇒",
              dArr: "⇓",
              hArr: "⇔",
              forall: "∀",
              part: "∂",
              exist: "∃",
              empty: "∅",
              nabla: "∇",
              isin: "∈",
              notin: "∉",
              ni: "∋",
              prod: "∏",
              sum: "∑",
              minus: "−",
              lowast: "∗",
              radic: "√",
              prop: "∝",
              infin: "∞",
              ang: "∠",
              and: "∧",
              or: "∨",
              cap: "∩",
              cup: "∪",
              int: "∫",
              there4: "∴",
              sim: "∼",
              cong: "≅",
              asymp: "≈",
              ne: "≠",
              equiv: "≡",
              le: "≤",
              ge: "≥",
              sub: "⊂",
              sup: "⊃",
              nsub: "⊄",
              sube: "⊆",
              supe: "⊇",
              oplus: "⊕",
              otimes: "⊗",
              perp: "⊥",
              sdot: "⋅",
              lceil: "⌈",
              rceil: "⌉",
              lfloor: "⌊",
              rfloor: "⌋",
              lang: "〈",
              rang: "〉",
              loz: "◊",
              spades: "♠",
              clubs: "♣",
              hearts: "♥",
              diams: "♦"
            },
            be = /^[\da-fA-F]+$/,
            ve = /^\d+$/;
          function Ee(e) {
            return (
              !!e &&
              ("JSXOpeningFragment" === e.type ||
                "JSXClosingFragment" === e.type)
            );
          }
          function Te(e) {
            if ("JSXIdentifier" === e.type) return e.name;
            if ("JSXNamespacedName" === e.type)
              return e.namespace.name + ":" + e.name.name;
            if ("JSXMemberExpression" === e.type)
              return Te(e.object) + "." + Te(e.property);
            throw new Error("Node had unexpected type: " + e.type);
          }
          (H.j_oTag = new $("<tag", !1)),
            (H.j_cTag = new $("</tag", !1)),
            (H.j_expr = new $("<tag>...</tag>", !0, !0)),
            (u.jsxName = new i("jsxName")),
            (u.jsxText = new i("jsxText", { beforeExpr: !0 })),
            (u.jsxTagStart = new i("jsxTagStart", { startsExpr: !0 })),
            (u.jsxTagEnd = new i("jsxTagEnd")),
            (u.jsxTagStart.updateContext = function() {
              this.state.context.push(H.j_expr),
                this.state.context.push(H.j_oTag),
                (this.state.exprAllowed = !1);
            }),
            (u.jsxTagEnd.updateContext = function(e) {
              const t = this.state.context.pop();
              (t === H.j_oTag && e === u.slash) || t === H.j_cTag
                ? (this.state.context.pop(),
                  (this.state.exprAllowed = this.curContext() === H.j_expr))
                : (this.state.exprAllowed = !0);
            });
          class xe {
            constructor(e) {
              (this.var = []),
                (this.lexical = []),
                (this.functions = []),
                (this.flags = e);
            }
          }
          class Ae {
            constructor(e, t) {
              (this.scopeStack = []),
                (this.undefinedExports = new Map()),
                (this.raise = e),
                (this.inModule = t);
            }
            get inFunction() {
              return (this.currentVarScope().flags & p) > 0;
            }
            get inGenerator() {
              return (this.currentVarScope().flags & h) > 0;
            }
            get inAsync() {
              return (this.currentVarScope().flags & d) > 0;
            }
            get allowSuper() {
              return (this.currentThisScope().flags & y) > 0;
            }
            get allowDirectSuper() {
              return (this.currentThisScope().flags & g) > 0;
            }
            get inNonArrowFunction() {
              return (this.currentThisScope().flags & p) > 0;
            }
            get treatFunctionsAsVar() {
              return this.treatFunctionsAsVarInScope(this.currentScope());
            }
            createScope(e) {
              return new xe(e);
            }
            enter(e) {
              this.scopeStack.push(this.createScope(e));
            }
            exit() {
              this.scopeStack.pop();
            }
            treatFunctionsAsVarInScope(e) {
              return !!(e.flags & p || (!this.inModule && e.flags & c));
            }
            declareName(e, t, r) {
              let n = this.currentScope();
              if (t & S || t & D)
                this.checkRedeclarationInScope(n, e, t, r),
                  t & D ? n.functions.push(e) : n.lexical.push(e),
                  t & S && this.maybeExportDefined(n, e);
              else if (t & A)
                for (
                  let i = this.scopeStack.length - 1;
                  i >= 0 &&
                  ((n = this.scopeStack[i]),
                  this.checkRedeclarationInScope(n, e, t, r),
                  n.var.push(e),
                  this.maybeExportDefined(n, e),
                  !(n.flags & v));
                  --i
                );
              this.inModule && n.flags & c && this.undefinedExports.delete(e);
            }
            maybeExportDefined(e, t) {
              this.inModule && e.flags & c && this.undefinedExports.delete(t);
            }
            checkRedeclarationInScope(e, t, r, n) {
              this.isRedeclaredInScope(e, t, r) &&
                this.raise(n, `Identifier '${t}' has already been declared`);
            }
            isRedeclaredInScope(e, t, r) {
              return (
                !!(r & T) &&
                (r & S
                  ? e.lexical.indexOf(t) > -1 ||
                    e.functions.indexOf(t) > -1 ||
                    e.var.indexOf(t) > -1
                  : r & D
                  ? e.lexical.indexOf(t) > -1 ||
                    (!this.treatFunctionsAsVarInScope(e) &&
                      e.var.indexOf(t) > -1)
                  : (e.lexical.indexOf(t) > -1 &&
                      !(e.flags & m && e.lexical[0] === t)) ||
                    (!this.treatFunctionsAsVarInScope(e) &&
                      e.functions.indexOf(t) > -1))
              );
            }
            checkLocalExport(e) {
              -1 === this.scopeStack[0].lexical.indexOf(e.name) &&
                -1 === this.scopeStack[0].var.indexOf(e.name) &&
                -1 === this.scopeStack[0].functions.indexOf(e.name) &&
                this.undefinedExports.set(e.name, e.start);
            }
            currentScope() {
              return this.scopeStack[this.scopeStack.length - 1];
            }
            currentVarScope() {
              for (let e = this.scopeStack.length - 1; ; e--) {
                const t = this.scopeStack[e];
                if (t.flags & v) return t;
              }
            }
            currentThisScope() {
              for (let e = this.scopeStack.length - 1; ; e--) {
                const t = this.scopeStack[e];
                if ((t.flags & v || t.flags & b) && !(t.flags & f)) return t;
              }
            }
          }
          class Se extends xe {
            constructor(...e) {
              super(...e),
                (this.types = []),
                (this.enums = []),
                (this.constEnums = []),
                (this.classes = []),
                (this.exportOnlyBindings = []);
            }
          }
          class De extends Ae {
            createScope(e) {
              return new Se(e);
            }
            declareName(e, t, r) {
              const n = this.currentScope();
              if (t & F)
                return (
                  this.maybeExportDefined(n, e),
                  void n.exportOnlyBindings.push(e)
                );
              super.declareName(...arguments),
                t & x &&
                  (t & T ||
                    (this.checkRedeclarationInScope(n, e, t, r),
                    this.maybeExportDefined(n, e)),
                  n.types.push(e)),
                t & C && n.enums.push(e),
                t & w && n.constEnums.push(e),
                t & P && n.classes.push(e);
            }
            isRedeclaredInScope(e, t, r) {
              if (e.enums.indexOf(t) > -1) {
                if (r & C) {
                  return !!(r & w) !== e.constEnums.indexOf(t) > -1;
                }
                return !0;
              }
              return r & P && e.classes.indexOf(t) > -1
                ? e.lexical.indexOf(t) > -1 && !!(r & T)
                : !!(r & x && e.types.indexOf(t) > -1) ||
                    super.isRedeclaredInScope(...arguments);
            }
            checkLocalExport(e) {
              -1 === this.scopeStack[0].types.indexOf(e.name) &&
                -1 === this.scopeStack[0].exportOnlyBindings.indexOf(e.name) &&
                super.checkLocalExport(e);
            }
          }
          function Pe(e) {
            if (null == e) throw new Error(`Unexpected ${e} value.`);
            return e;
          }
          function Ce(e) {
            if (!e) throw new Error("Assert fail");
          }
          u.placeholder = new i("%%", { startsExpr: !0 });
          function we(e, t) {
            return e.some(e => (Array.isArray(e) ? e[0] === t : e === t));
          }
          function Fe(e, t, r) {
            const n = e.find(e => (Array.isArray(e) ? e[0] === t : e === t));
            return n && Array.isArray(n) ? n[1][r] : null;
          }
          const _e = ["minimal", "smart", "fsharp"];
          const Oe = {
              estree: e =>
                class extends e {
                  estreeParseRegExpLiteral({ pattern: e, flags: t }) {
                    let r = null;
                    try {
                      r = new RegExp(e, t);
                    } catch (e) {}
                    const n = this.estreeParseLiteral(r);
                    return (n.regex = { pattern: e, flags: t }), n;
                  }
                  estreeParseLiteral(e) {
                    return this.parseLiteral(e, "Literal");
                  }
                  directiveToStmt(e) {
                    const t = e.value,
                      r = this.startNodeAt(e.start, e.loc.start),
                      n = this.startNodeAt(t.start, t.loc.start);
                    return (
                      (n.value = t.value),
                      (n.raw = t.extra.raw),
                      (r.expression = this.finishNodeAt(
                        n,
                        "Literal",
                        t.end,
                        t.loc.end
                      )),
                      (r.directive = t.extra.raw.slice(1, -1)),
                      this.finishNodeAt(
                        r,
                        "ExpressionStatement",
                        e.end,
                        e.loc.end
                      )
                    );
                  }
                  initFunction(e, t) {
                    super.initFunction(e, t), (e.expression = !1);
                  }
                  checkDeclaration(e) {
                    U(e)
                      ? this.checkDeclaration(e.value)
                      : super.checkDeclaration(e);
                  }
                  checkGetterSetterParams(e) {
                    const t = e,
                      r = "get" === t.kind ? 0 : 1,
                      n = t.start;
                    t.value.params.length !== r &&
                      ("get" === t.kind
                        ? this.raise(
                            n,
                            "getter must not have any formal parameters"
                          )
                        : this.raise(
                            n,
                            "setter must have exactly one formal parameter"
                          )),
                      "set" === t.kind &&
                        "RestElement" === t.value.params[0].type &&
                        this.raise(
                          n,
                          "setter function argument must not be a rest parameter"
                        );
                  }
                  checkLVal(e, t = j, r, n) {
                    switch (e.type) {
                      case "ObjectPattern":
                        e.properties.forEach(e => {
                          this.checkLVal(
                            "Property" === e.type ? e.value : e,
                            t,
                            r,
                            "object destructuring pattern"
                          );
                        });
                        break;
                      default:
                        super.checkLVal(e, t, r, n);
                    }
                  }
                  checkPropClash(e, t) {
                    if (
                      "SpreadElement" === e.type ||
                      e.computed ||
                      e.method ||
                      e.shorthand
                    )
                      return;
                    const r = e.key;
                    "__proto__" ===
                      ("Identifier" === r.type ? r.name : String(r.value)) &&
                      "init" === e.kind &&
                      (t.proto &&
                        this.raise(
                          r.start,
                          "Redefinition of __proto__ property"
                        ),
                      (t.proto = !0));
                  }
                  isStrictBody(e) {
                    if (
                      "BlockStatement" === e.body.type &&
                      e.body.body.length > 0
                    )
                      for (let t = 0, r = e.body.body; t < r.length; t++) {
                        const e = r[t];
                        if (
                          "ExpressionStatement" !== e.type ||
                          "Literal" !== e.expression.type
                        )
                          break;
                        if ("use strict" === e.expression.value) return !0;
                      }
                    return !1;
                  }
                  isValidDirective(e) {
                    return !(
                      "ExpressionStatement" !== e.type ||
                      "Literal" !== e.expression.type ||
                      "string" != typeof e.expression.value ||
                      (e.expression.extra && e.expression.extra.parenthesized)
                    );
                  }
                  stmtToDirective(e) {
                    const t = super.stmtToDirective(e),
                      r = e.expression.value;
                    return (t.value.value = r), t;
                  }
                  parseBlockBody(e, t, r, n) {
                    super.parseBlockBody(e, t, r, n);
                    const i = e.directives.map(e => this.directiveToStmt(e));
                    (e.body = i.concat(e.body)), delete e.directives;
                  }
                  pushClassMethod(e, t, r, n, i, s) {
                    this.parseMethod(t, r, n, i, s, "ClassMethod", !0),
                      t.typeParameters &&
                        ((t.value.typeParameters = t.typeParameters),
                        delete t.typeParameters),
                      e.body.push(t);
                  }
                  parseExprAtom(e) {
                    switch (this.state.type) {
                      case u.regexp:
                        return this.estreeParseRegExpLiteral(this.state.value);
                      case u.num:
                      case u.string:
                        return this.estreeParseLiteral(this.state.value);
                      case u._null:
                        return this.estreeParseLiteral(null);
                      case u._true:
                        return this.estreeParseLiteral(!0);
                      case u._false:
                        return this.estreeParseLiteral(!1);
                      default:
                        return super.parseExprAtom(e);
                    }
                  }
                  parseLiteral(e, t, r, n) {
                    const i = super.parseLiteral(e, t, r, n);
                    return (i.raw = i.extra.raw), delete i.extra, i;
                  }
                  parseFunctionBody(e, t, r = !1) {
                    super.parseFunctionBody(e, t, r),
                      (e.expression = "BlockStatement" !== e.body.type);
                  }
                  parseMethod(e, t, r, n, i, s, a = !1) {
                    let o = this.startNode();
                    return (
                      (o.kind = e.kind),
                      ((o = super.parseMethod(o, t, r, n, i, s, a)).type =
                        "FunctionExpression"),
                      delete o.kind,
                      (e.value = o),
                      (s = "ClassMethod" === s ? "MethodDefinition" : s),
                      this.finishNode(e, s)
                    );
                  }
                  parseObjectMethod(e, t, r, n, i) {
                    const s = super.parseObjectMethod(e, t, r, n, i);
                    return (
                      s &&
                        ((s.type = "Property"),
                        "method" === s.kind && (s.kind = "init"),
                        (s.shorthand = !1)),
                      s
                    );
                  }
                  parseObjectProperty(e, t, r, n, i) {
                    const s = super.parseObjectProperty(e, t, r, n, i);
                    return s && ((s.kind = "init"), (s.type = "Property")), s;
                  }
                  toAssignable(e, t, r) {
                    return U(e)
                      ? (this.toAssignable(e.value, t, r), e)
                      : super.toAssignable(e, t, r);
                  }
                  toAssignableObjectExpressionProp(e, t, r) {
                    "get" === e.kind || "set" === e.kind
                      ? this.raise(
                          e.key.start,
                          "Object pattern can't contain getter or setter"
                        )
                      : e.method
                      ? this.raise(
                          e.key.start,
                          "Object pattern can't contain methods"
                        )
                      : super.toAssignableObjectExpressionProp(e, t, r);
                  }
                },
              jsx: e =>
                class extends e {
                  jsxReadToken() {
                    let e = "",
                      t = this.state.pos;
                    for (;;) {
                      this.state.pos >= this.length &&
                        this.raise(
                          this.state.start,
                          "Unterminated JSX contents"
                        );
                      const r = this.input.charCodeAt(this.state.pos);
                      switch (r) {
                        case 60:
                        case 123:
                          return this.state.pos === this.state.start
                            ? 60 === r && this.state.exprAllowed
                              ? (++this.state.pos,
                                this.finishToken(u.jsxTagStart))
                              : super.getTokenFromCode(r)
                            : ((e += this.input.slice(t, this.state.pos)),
                              this.finishToken(u.jsxText, e));
                        case 38:
                          (e += this.input.slice(t, this.state.pos)),
                            (e += this.jsxReadEntity()),
                            (t = this.state.pos);
                          break;
                        default:
                          W(r)
                            ? ((e += this.input.slice(t, this.state.pos)),
                              (e += this.jsxReadNewLine(!0)),
                              (t = this.state.pos))
                            : ++this.state.pos;
                      }
                    }
                  }
                  jsxReadNewLine(e) {
                    const t = this.input.charCodeAt(this.state.pos);
                    let r;
                    return (
                      ++this.state.pos,
                      13 === t && 10 === this.input.charCodeAt(this.state.pos)
                        ? (++this.state.pos, (r = e ? "\n" : "\r\n"))
                        : (r = String.fromCharCode(t)),
                      ++this.state.curLine,
                      (this.state.lineStart = this.state.pos),
                      r
                    );
                  }
                  jsxReadString(e) {
                    let t = "",
                      r = ++this.state.pos;
                    for (;;) {
                      this.state.pos >= this.length &&
                        this.raise(
                          this.state.start,
                          "Unterminated string constant"
                        );
                      const n = this.input.charCodeAt(this.state.pos);
                      if (n === e) break;
                      38 === n
                        ? ((t += this.input.slice(r, this.state.pos)),
                          (t += this.jsxReadEntity()),
                          (r = this.state.pos))
                        : W(n)
                        ? ((t += this.input.slice(r, this.state.pos)),
                          (t += this.jsxReadNewLine(!1)),
                          (r = this.state.pos))
                        : ++this.state.pos;
                    }
                    return (
                      (t += this.input.slice(r, this.state.pos++)),
                      this.finishToken(u.string, t)
                    );
                  }
                  jsxReadEntity() {
                    let e,
                      t = "",
                      r = 0,
                      n = this.input[this.state.pos];
                    const i = ++this.state.pos;
                    for (; this.state.pos < this.length && r++ < 10; ) {
                      if (";" === (n = this.input[this.state.pos++])) {
                        "#" === t[0]
                          ? "x" === t[1]
                            ? ((t = t.substr(2)),
                              be.test(t) &&
                                (e = String.fromCodePoint(parseInt(t, 16))))
                            : ((t = t.substr(1)),
                              ve.test(t) &&
                                (e = String.fromCodePoint(parseInt(t, 10))))
                          : (e = ge[t]);
                        break;
                      }
                      t += n;
                    }
                    return e || ((this.state.pos = i), "&");
                  }
                  jsxReadWord() {
                    let e;
                    const t = this.state.pos;
                    do {
                      e = this.input.charCodeAt(++this.state.pos);
                    } while (pe(e) || 45 === e);
                    return this.finishToken(
                      u.jsxName,
                      this.input.slice(t, this.state.pos)
                    );
                  }
                  jsxParseIdentifier() {
                    const e = this.startNode();
                    return (
                      this.match(u.jsxName)
                        ? (e.name = this.state.value)
                        : this.state.type.keyword
                        ? (e.name = this.state.type.keyword)
                        : this.unexpected(),
                      this.next(),
                      this.finishNode(e, "JSXIdentifier")
                    );
                  }
                  jsxParseNamespacedName() {
                    const e = this.state.start,
                      t = this.state.startLoc,
                      r = this.jsxParseIdentifier();
                    if (!this.eat(u.colon)) return r;
                    const n = this.startNodeAt(e, t);
                    return (
                      (n.namespace = r),
                      (n.name = this.jsxParseIdentifier()),
                      this.finishNode(n, "JSXNamespacedName")
                    );
                  }
                  jsxParseElementName() {
                    const e = this.state.start,
                      t = this.state.startLoc;
                    let r = this.jsxParseNamespacedName();
                    for (; this.eat(u.dot); ) {
                      const n = this.startNodeAt(e, t);
                      (n.object = r),
                        (n.property = this.jsxParseIdentifier()),
                        (r = this.finishNode(n, "JSXMemberExpression"));
                    }
                    return r;
                  }
                  jsxParseAttributeValue() {
                    let e;
                    switch (this.state.type) {
                      case u.braceL:
                        if (
                          ((e = this.startNode()),
                          this.next(),
                          "JSXEmptyExpression" ===
                            (e = this.jsxParseExpressionContainer(e)).expression
                              .type)
                        )
                          throw this.raise(
                            e.start,
                            "JSX attributes must only be assigned a non-empty expression"
                          );
                        return e;
                      case u.jsxTagStart:
                      case u.string:
                        return this.parseExprAtom();
                      default:
                        throw this.raise(
                          this.state.start,
                          "JSX value should be either an expression or a quoted JSX text"
                        );
                    }
                  }
                  jsxParseEmptyExpression() {
                    const e = this.startNodeAt(
                      this.state.lastTokEnd,
                      this.state.lastTokEndLoc
                    );
                    return this.finishNodeAt(
                      e,
                      "JSXEmptyExpression",
                      this.state.start,
                      this.state.startLoc
                    );
                  }
                  jsxParseSpreadChild(e) {
                    return (
                      this.next(),
                      (e.expression = this.parseExpression()),
                      this.expect(u.braceR),
                      this.finishNode(e, "JSXSpreadChild")
                    );
                  }
                  jsxParseExpressionContainer(e) {
                    return (
                      this.match(u.braceR)
                        ? (e.expression = this.jsxParseEmptyExpression())
                        : (e.expression = this.parseExpression()),
                      this.expect(u.braceR),
                      this.finishNode(e, "JSXExpressionContainer")
                    );
                  }
                  jsxParseAttribute() {
                    const e = this.startNode();
                    return this.eat(u.braceL)
                      ? (this.expect(u.ellipsis),
                        (e.argument = this.parseMaybeAssign()),
                        this.expect(u.braceR),
                        this.finishNode(e, "JSXSpreadAttribute"))
                      : ((e.name = this.jsxParseNamespacedName()),
                        (e.value = this.eat(u.eq)
                          ? this.jsxParseAttributeValue()
                          : null),
                        this.finishNode(e, "JSXAttribute"));
                  }
                  jsxParseOpeningElementAt(e, t) {
                    const r = this.startNodeAt(e, t);
                    return this.match(u.jsxTagEnd)
                      ? (this.expect(u.jsxTagEnd),
                        this.finishNode(r, "JSXOpeningFragment"))
                      : ((r.name = this.jsxParseElementName()),
                        this.jsxParseOpeningElementAfterName(r));
                  }
                  jsxParseOpeningElementAfterName(e) {
                    const t = [];
                    for (; !this.match(u.slash) && !this.match(u.jsxTagEnd); )
                      t.push(this.jsxParseAttribute());
                    return (
                      (e.attributes = t),
                      (e.selfClosing = this.eat(u.slash)),
                      this.expect(u.jsxTagEnd),
                      this.finishNode(e, "JSXOpeningElement")
                    );
                  }
                  jsxParseClosingElementAt(e, t) {
                    const r = this.startNodeAt(e, t);
                    return this.match(u.jsxTagEnd)
                      ? (this.expect(u.jsxTagEnd),
                        this.finishNode(r, "JSXClosingFragment"))
                      : ((r.name = this.jsxParseElementName()),
                        this.expect(u.jsxTagEnd),
                        this.finishNode(r, "JSXClosingElement"));
                  }
                  jsxParseElementAt(e, t) {
                    const r = this.startNodeAt(e, t),
                      n = [],
                      i = this.jsxParseOpeningElementAt(e, t);
                    let s = null;
                    if (!i.selfClosing) {
                      e: for (;;)
                        switch (this.state.type) {
                          case u.jsxTagStart:
                            if (
                              ((e = this.state.start),
                              (t = this.state.startLoc),
                              this.next(),
                              this.eat(u.slash))
                            ) {
                              s = this.jsxParseClosingElementAt(e, t);
                              break e;
                            }
                            n.push(this.jsxParseElementAt(e, t));
                            break;
                          case u.jsxText:
                            n.push(this.parseExprAtom());
                            break;
                          case u.braceL: {
                            const e = this.startNode();
                            this.next(),
                              this.match(u.ellipsis)
                                ? n.push(this.jsxParseSpreadChild(e))
                                : n.push(this.jsxParseExpressionContainer(e));
                            break;
                          }
                          default:
                            throw this.unexpected();
                        }
                      Ee(i) && !Ee(s)
                        ? this.raise(
                            s.start,
                            "Expected corresponding JSX closing tag for <>"
                          )
                        : !Ee(i) && Ee(s)
                        ? this.raise(
                            s.start,
                            "Expected corresponding JSX closing tag for <" +
                              Te(i.name) +
                              ">"
                          )
                        : Ee(i) ||
                          Ee(s) ||
                          (Te(s.name) !== Te(i.name) &&
                            this.raise(
                              s.start,
                              "Expected corresponding JSX closing tag for <" +
                                Te(i.name) +
                                ">"
                            ));
                    }
                    return (
                      Ee(i)
                        ? ((r.openingFragment = i), (r.closingFragment = s))
                        : ((r.openingElement = i), (r.closingElement = s)),
                      (r.children = n),
                      this.match(u.relational) &&
                        "<" === this.state.value &&
                        this.raise(
                          this.state.start,
                          "Adjacent JSX elements must be wrapped in an enclosing tag. Did you want a JSX fragment <>...</>?"
                        ),
                      Ee(i)
                        ? this.finishNode(r, "JSXFragment")
                        : this.finishNode(r, "JSXElement")
                    );
                  }
                  jsxParseElement() {
                    const e = this.state.start,
                      t = this.state.startLoc;
                    return this.next(), this.jsxParseElementAt(e, t);
                  }
                  parseExprAtom(e) {
                    return this.match(u.jsxText)
                      ? this.parseLiteral(this.state.value, "JSXText")
                      : this.match(u.jsxTagStart)
                      ? this.jsxParseElement()
                      : this.isRelational("<") &&
                        33 !== this.input.charCodeAt(this.state.pos)
                      ? (this.finishToken(u.jsxTagStart),
                        this.jsxParseElement())
                      : super.parseExprAtom(e);
                  }
                  getTokenFromCode(e) {
                    if (this.state.inPropertyName)
                      return super.getTokenFromCode(e);
                    const t = this.curContext();
                    if (t === H.j_expr) return this.jsxReadToken();
                    if (t === H.j_oTag || t === H.j_cTag) {
                      if (ce(e)) return this.jsxReadWord();
                      if (62 === e)
                        return ++this.state.pos, this.finishToken(u.jsxTagEnd);
                      if ((34 === e || 39 === e) && t === H.j_oTag)
                        return this.jsxReadString(e);
                    }
                    return 60 === e &&
                      this.state.exprAllowed &&
                      33 !== this.input.charCodeAt(this.state.pos + 1)
                      ? (++this.state.pos, this.finishToken(u.jsxTagStart))
                      : super.getTokenFromCode(e);
                  }
                  updateContext(e) {
                    if (this.match(u.braceL)) {
                      const t = this.curContext();
                      t === H.j_oTag
                        ? this.state.context.push(H.braceExpression)
                        : t === H.j_expr
                        ? this.state.context.push(H.templateQuasi)
                        : super.updateContext(e),
                        (this.state.exprAllowed = !0);
                    } else {
                      if (!this.match(u.slash) || e !== u.jsxTagStart)
                        return super.updateContext(e);
                      (this.state.context.length -= 2),
                        this.state.context.push(H.j_cTag),
                        (this.state.exprAllowed = !1);
                    }
                  }
                },
              flow: e =>
                class extends e {
                  constructor(e, t) {
                    super(e, t), (this.flowPragma = void 0);
                  }
                  shouldParseTypes() {
                    return (
                      this.getPluginOption("flow", "all") ||
                      "flow" === this.flowPragma
                    );
                  }
                  finishToken(e, t) {
                    return (
                      e !== u.string &&
                        e !== u.semi &&
                        e !== u.interpreterDirective &&
                        void 0 === this.flowPragma &&
                        (this.flowPragma = null),
                      super.finishToken(e, t)
                    );
                  }
                  addComment(e) {
                    if (void 0 === this.flowPragma) {
                      const t = ye.exec(e.value);
                      if (t)
                        if ("flow" === t[1]) this.flowPragma = "flow";
                        else {
                          if ("noflow" !== t[1])
                            throw new Error("Unexpected flow pragma");
                          this.flowPragma = "noflow";
                        }
                    }
                    return super.addComment(e);
                  }
                  flowParseTypeInitialiser(e) {
                    const t = this.state.inType;
                    (this.state.inType = !0), this.expect(e || u.colon);
                    const r = this.flowParseType();
                    return (this.state.inType = t), r;
                  }
                  flowParsePredicate() {
                    const e = this.startNode(),
                      t = this.state.startLoc,
                      r = this.state.start;
                    this.expect(u.modulo);
                    const n = this.state.startLoc;
                    return (
                      this.expectContextual("checks"),
                      (t.line === n.line && t.column === n.column - 1) ||
                        this.raise(
                          r,
                          "Spaces between ´%´ and ´checks´ are not allowed here."
                        ),
                      this.eat(u.parenL)
                        ? ((e.value = this.parseExpression()),
                          this.expect(u.parenR),
                          this.finishNode(e, "DeclaredPredicate"))
                        : this.finishNode(e, "InferredPredicate")
                    );
                  }
                  flowParseTypeAndPredicateInitialiser() {
                    const e = this.state.inType;
                    (this.state.inType = !0), this.expect(u.colon);
                    let t = null,
                      r = null;
                    return (
                      this.match(u.modulo)
                        ? ((this.state.inType = e),
                          (r = this.flowParsePredicate()))
                        : ((t = this.flowParseType()),
                          (this.state.inType = e),
                          this.match(u.modulo) &&
                            (r = this.flowParsePredicate())),
                      [t, r]
                    );
                  }
                  flowParseDeclareClass(e) {
                    return (
                      this.next(),
                      this.flowParseInterfaceish(e, !0),
                      this.finishNode(e, "DeclareClass")
                    );
                  }
                  flowParseDeclareFunction(e) {
                    this.next();
                    const t = (e.id = this.parseIdentifier()),
                      r = this.startNode(),
                      n = this.startNode();
                    this.isRelational("<")
                      ? (r.typeParameters = this.flowParseTypeParameterDeclaration())
                      : (r.typeParameters = null),
                      this.expect(u.parenL);
                    const i = this.flowParseFunctionTypeParams();
                    return (
                      (r.params = i.params),
                      (r.rest = i.rest),
                      this.expect(u.parenR),
                      ([
                        r.returnType,
                        e.predicate
                      ] = this.flowParseTypeAndPredicateInitialiser()),
                      (n.typeAnnotation = this.finishNode(
                        r,
                        "FunctionTypeAnnotation"
                      )),
                      (t.typeAnnotation = this.finishNode(n, "TypeAnnotation")),
                      this.resetEndLocation(t),
                      this.semicolon(),
                      this.finishNode(e, "DeclareFunction")
                    );
                  }
                  flowParseDeclare(e, t) {
                    if (this.match(u._class))
                      return this.flowParseDeclareClass(e);
                    if (this.match(u._function))
                      return this.flowParseDeclareFunction(e);
                    if (this.match(u._var))
                      return this.flowParseDeclareVariable(e);
                    if (this.eatContextual("module"))
                      return this.match(u.dot)
                        ? this.flowParseDeclareModuleExports(e)
                        : (t &&
                            this.unexpected(
                              this.state.lastTokStart,
                              "`declare module` cannot be used inside another `declare module`"
                            ),
                          this.flowParseDeclareModule(e));
                    if (this.isContextual("type"))
                      return this.flowParseDeclareTypeAlias(e);
                    if (this.isContextual("opaque"))
                      return this.flowParseDeclareOpaqueType(e);
                    if (this.isContextual("interface"))
                      return this.flowParseDeclareInterface(e);
                    if (this.match(u._export))
                      return this.flowParseDeclareExportDeclaration(e, t);
                    throw this.unexpected();
                  }
                  flowParseDeclareVariable(e) {
                    return (
                      this.next(),
                      (e.id = this.flowParseTypeAnnotatableIdentifier(!0)),
                      this.semicolon(),
                      this.finishNode(e, "DeclareVariable")
                    );
                  }
                  flowParseDeclareModule(e) {
                    this.scope.enter(l),
                      this.match(u.string)
                        ? (e.id = this.parseExprAtom())
                        : (e.id = this.parseIdentifier());
                    const t = (e.body = this.startNode()),
                      r = (t.body = []);
                    for (this.expect(u.braceL); !this.match(u.braceR); ) {
                      let e = this.startNode();
                      this.match(u._import)
                        ? (this.next(),
                          this.isContextual("type") ||
                            this.match(u._typeof) ||
                            this.unexpected(
                              this.state.lastTokStart,
                              "Imports within a `declare module` body must always be `import type` or `import typeof`"
                            ),
                          this.parseImport(e))
                        : (this.expectContextual(
                            "declare",
                            "Only declares and type imports are allowed inside declare module"
                          ),
                          (e = this.flowParseDeclare(e, !0))),
                        r.push(e);
                    }
                    this.scope.exit(),
                      this.expect(u.braceR),
                      this.finishNode(t, "BlockStatement");
                    let n = null,
                      i = !1;
                    const s =
                      "Found both `declare module.exports` and `declare export` in the same module. Modules can only have 1 since they are either an ES module or they are a CommonJS module";
                    return (
                      r.forEach(e => {
                        !(function(e) {
                          return (
                            "DeclareExportAllDeclaration" === e.type ||
                            ("DeclareExportDeclaration" === e.type &&
                              (!e.declaration ||
                                ("TypeAlias" !== e.declaration.type &&
                                  "InterfaceDeclaration" !==
                                    e.declaration.type)))
                          );
                        })(e)
                          ? "DeclareModuleExports" === e.type &&
                            (i &&
                              this.unexpected(
                                e.start,
                                "Duplicate `declare module.exports` statement"
                              ),
                            "ES" === n && this.unexpected(e.start, s),
                            (n = "CommonJS"),
                            (i = !0))
                          : ("CommonJS" === n && this.unexpected(e.start, s),
                            (n = "ES"));
                      }),
                      (e.kind = n || "CommonJS"),
                      this.finishNode(e, "DeclareModule")
                    );
                  }
                  flowParseDeclareExportDeclaration(e, t) {
                    if ((this.expect(u._export), this.eat(u._default)))
                      return (
                        this.match(u._function) || this.match(u._class)
                          ? (e.declaration = this.flowParseDeclare(
                              this.startNode()
                            ))
                          : ((e.declaration = this.flowParseType()),
                            this.semicolon()),
                        (e.default = !0),
                        this.finishNode(e, "DeclareExportDeclaration")
                      );
                    if (
                      this.match(u._const) ||
                      this.isLet() ||
                      ((this.isContextual("type") ||
                        this.isContextual("interface")) &&
                        !t)
                    ) {
                      const e = this.state.value,
                        t = me[e];
                      this.unexpected(
                        this.state.start,
                        `\`declare export ${e}\` is not supported. Use \`${t}\` instead`
                      );
                    }
                    if (
                      this.match(u._var) ||
                      this.match(u._function) ||
                      this.match(u._class) ||
                      this.isContextual("opaque")
                    )
                      return (
                        (e.declaration = this.flowParseDeclare(
                          this.startNode()
                        )),
                        (e.default = !1),
                        this.finishNode(e, "DeclareExportDeclaration")
                      );
                    if (
                      this.match(u.star) ||
                      this.match(u.braceL) ||
                      this.isContextual("interface") ||
                      this.isContextual("type") ||
                      this.isContextual("opaque")
                    )
                      return (
                        "ExportNamedDeclaration" ===
                          (e = this.parseExport(e)).type &&
                          ((e.type = "ExportDeclaration"),
                          (e.default = !1),
                          delete e.exportKind),
                        (e.type = "Declare" + e.type),
                        e
                      );
                    throw this.unexpected();
                  }
                  flowParseDeclareModuleExports(e) {
                    return (
                      this.next(),
                      this.expectContextual("exports"),
                      (e.typeAnnotation = this.flowParseTypeAnnotation()),
                      this.semicolon(),
                      this.finishNode(e, "DeclareModuleExports")
                    );
                  }
                  flowParseDeclareTypeAlias(e) {
                    return (
                      this.next(),
                      this.flowParseTypeAlias(e),
                      (e.type = "DeclareTypeAlias"),
                      e
                    );
                  }
                  flowParseDeclareOpaqueType(e) {
                    return (
                      this.next(),
                      this.flowParseOpaqueType(e, !0),
                      (e.type = "DeclareOpaqueType"),
                      e
                    );
                  }
                  flowParseDeclareInterface(e) {
                    return (
                      this.next(),
                      this.flowParseInterfaceish(e),
                      this.finishNode(e, "DeclareInterface")
                    );
                  }
                  flowParseInterfaceish(e, t = !1) {
                    if (
                      ((e.id = this.flowParseRestrictedIdentifier(!t)),
                      this.isRelational("<")
                        ? (e.typeParameters = this.flowParseTypeParameterDeclaration())
                        : (e.typeParameters = null),
                      (e.extends = []),
                      (e.implements = []),
                      (e.mixins = []),
                      this.eat(u._extends))
                    )
                      do {
                        e.extends.push(this.flowParseInterfaceExtends());
                      } while (!t && this.eat(u.comma));
                    if (this.isContextual("mixins")) {
                      this.next();
                      do {
                        e.mixins.push(this.flowParseInterfaceExtends());
                      } while (this.eat(u.comma));
                    }
                    if (this.isContextual("implements")) {
                      this.next();
                      do {
                        e.implements.push(this.flowParseInterfaceExtends());
                      } while (this.eat(u.comma));
                    }
                    e.body = this.flowParseObjectType({
                      allowStatic: t,
                      allowExact: !1,
                      allowSpread: !1,
                      allowProto: t,
                      allowInexact: !1
                    });
                  }
                  flowParseInterfaceExtends() {
                    const e = this.startNode();
                    return (
                      (e.id = this.flowParseQualifiedTypeIdentifier()),
                      this.isRelational("<")
                        ? (e.typeParameters = this.flowParseTypeParameterInstantiation())
                        : (e.typeParameters = null),
                      this.finishNode(e, "InterfaceExtends")
                    );
                  }
                  flowParseInterface(e) {
                    return (
                      this.flowParseInterfaceish(e),
                      this.finishNode(e, "InterfaceDeclaration")
                    );
                  }
                  checkNotUnderscore(e) {
                    if ("_" === e)
                      throw this.unexpected(
                        null,
                        "`_` is only allowed as a type argument to call or new"
                      );
                  }
                  checkReservedType(e, t) {
                    de.indexOf(e) > -1 &&
                      this.raise(t, `Cannot overwrite reserved type ${e}`);
                  }
                  flowParseRestrictedIdentifier(e) {
                    return (
                      this.checkReservedType(
                        this.state.value,
                        this.state.start
                      ),
                      this.parseIdentifier(e)
                    );
                  }
                  flowParseTypeAlias(e) {
                    return (
                      (e.id = this.flowParseRestrictedIdentifier()),
                      this.scope.declareName(e.id.name, O, e.id.start),
                      this.isRelational("<")
                        ? (e.typeParameters = this.flowParseTypeParameterDeclaration())
                        : (e.typeParameters = null),
                      (e.right = this.flowParseTypeInitialiser(u.eq)),
                      this.semicolon(),
                      this.finishNode(e, "TypeAlias")
                    );
                  }
                  flowParseOpaqueType(e, t) {
                    return (
                      this.expectContextual("type"),
                      (e.id = this.flowParseRestrictedIdentifier(!0)),
                      this.scope.declareName(e.id.name, O, e.id.start),
                      this.isRelational("<")
                        ? (e.typeParameters = this.flowParseTypeParameterDeclaration())
                        : (e.typeParameters = null),
                      (e.supertype = null),
                      this.match(u.colon) &&
                        (e.supertype = this.flowParseTypeInitialiser(u.colon)),
                      (e.impltype = null),
                      t || (e.impltype = this.flowParseTypeInitialiser(u.eq)),
                      this.semicolon(),
                      this.finishNode(e, "OpaqueType")
                    );
                  }
                  flowParseTypeParameter(e = !1) {
                    const t = this.state.start,
                      r = this.startNode(),
                      n = this.flowParseVariance(),
                      i = this.flowParseTypeAnnotatableIdentifier();
                    return (
                      (r.name = i.name),
                      (r.variance = n),
                      (r.bound = i.typeAnnotation),
                      this.match(u.eq)
                        ? (this.eat(u.eq), (r.default = this.flowParseType()))
                        : e &&
                          this.unexpected(
                            t,
                            "Type parameter declaration needs a default, since a preceding type parameter declaration has a default."
                          ),
                      this.finishNode(r, "TypeParameter")
                    );
                  }
                  flowParseTypeParameterDeclaration() {
                    const e = this.state.inType,
                      t = this.startNode();
                    (t.params = []),
                      (this.state.inType = !0),
                      this.isRelational("<") || this.match(u.jsxTagStart)
                        ? this.next()
                        : this.unexpected();
                    let r = !1;
                    do {
                      const e = this.flowParseTypeParameter(r);
                      t.params.push(e),
                        e.default && (r = !0),
                        this.isRelational(">") || this.expect(u.comma);
                    } while (!this.isRelational(">"));
                    return (
                      this.expectRelational(">"),
                      (this.state.inType = e),
                      this.finishNode(t, "TypeParameterDeclaration")
                    );
                  }
                  flowParseTypeParameterInstantiation() {
                    const e = this.startNode(),
                      t = this.state.inType;
                    (e.params = []),
                      (this.state.inType = !0),
                      this.expectRelational("<");
                    const r = this.state.noAnonFunctionType;
                    for (
                      this.state.noAnonFunctionType = !1;
                      !this.isRelational(">");

                    )
                      e.params.push(this.flowParseType()),
                        this.isRelational(">") || this.expect(u.comma);
                    return (
                      (this.state.noAnonFunctionType = r),
                      this.expectRelational(">"),
                      (this.state.inType = t),
                      this.finishNode(e, "TypeParameterInstantiation")
                    );
                  }
                  flowParseTypeParameterInstantiationCallOrNew() {
                    const e = this.startNode(),
                      t = this.state.inType;
                    for (
                      e.params = [],
                        this.state.inType = !0,
                        this.expectRelational("<");
                      !this.isRelational(">");

                    )
                      e.params.push(
                        this.flowParseTypeOrImplicitInstantiation()
                      ),
                        this.isRelational(">") || this.expect(u.comma);
                    return (
                      this.expectRelational(">"),
                      (this.state.inType = t),
                      this.finishNode(e, "TypeParameterInstantiation")
                    );
                  }
                  flowParseInterfaceType() {
                    const e = this.startNode();
                    if (
                      (this.expectContextual("interface"),
                      (e.extends = []),
                      this.eat(u._extends))
                    )
                      do {
                        e.extends.push(this.flowParseInterfaceExtends());
                      } while (this.eat(u.comma));
                    return (
                      (e.body = this.flowParseObjectType({
                        allowStatic: !1,
                        allowExact: !1,
                        allowSpread: !1,
                        allowProto: !1,
                        allowInexact: !1
                      })),
                      this.finishNode(e, "InterfaceTypeAnnotation")
                    );
                  }
                  flowParseObjectPropertyKey() {
                    return this.match(u.num) || this.match(u.string)
                      ? this.parseExprAtom()
                      : this.parseIdentifier(!0);
                  }
                  flowParseObjectTypeIndexer(e, t, r) {
                    return (
                      (e.static = t),
                      this.lookahead().type === u.colon
                        ? ((e.id = this.flowParseObjectPropertyKey()),
                          (e.key = this.flowParseTypeInitialiser()))
                        : ((e.id = null), (e.key = this.flowParseType())),
                      this.expect(u.bracketR),
                      (e.value = this.flowParseTypeInitialiser()),
                      (e.variance = r),
                      this.finishNode(e, "ObjectTypeIndexer")
                    );
                  }
                  flowParseObjectTypeInternalSlot(e, t) {
                    return (
                      (e.static = t),
                      (e.id = this.flowParseObjectPropertyKey()),
                      this.expect(u.bracketR),
                      this.expect(u.bracketR),
                      this.isRelational("<") || this.match(u.parenL)
                        ? ((e.method = !0),
                          (e.optional = !1),
                          (e.value = this.flowParseObjectTypeMethodish(
                            this.startNodeAt(e.start, e.loc.start)
                          )))
                        : ((e.method = !1),
                          this.eat(u.question) && (e.optional = !0),
                          (e.value = this.flowParseTypeInitialiser())),
                      this.finishNode(e, "ObjectTypeInternalSlot")
                    );
                  }
                  flowParseObjectTypeMethodish(e) {
                    for (
                      e.params = [],
                        e.rest = null,
                        e.typeParameters = null,
                        this.isRelational("<") &&
                          (e.typeParameters = this.flowParseTypeParameterDeclaration()),
                        this.expect(u.parenL);
                      !this.match(u.parenR) && !this.match(u.ellipsis);

                    )
                      e.params.push(this.flowParseFunctionTypeParam()),
                        this.match(u.parenR) || this.expect(u.comma);
                    return (
                      this.eat(u.ellipsis) &&
                        (e.rest = this.flowParseFunctionTypeParam()),
                      this.expect(u.parenR),
                      (e.returnType = this.flowParseTypeInitialiser()),
                      this.finishNode(e, "FunctionTypeAnnotation")
                    );
                  }
                  flowParseObjectTypeCallProperty(e, t) {
                    const r = this.startNode();
                    return (
                      (e.static = t),
                      (e.value = this.flowParseObjectTypeMethodish(r)),
                      this.finishNode(e, "ObjectTypeCallProperty")
                    );
                  }
                  flowParseObjectType({
                    allowStatic: e,
                    allowExact: t,
                    allowSpread: r,
                    allowProto: n,
                    allowInexact: i
                  }) {
                    const s = this.state.inType;
                    this.state.inType = !0;
                    const a = this.startNode();
                    let o, l;
                    (a.callProperties = []),
                      (a.properties = []),
                      (a.indexers = []),
                      (a.internalSlots = []);
                    let c = !1;
                    for (
                      t && this.match(u.braceBarL)
                        ? (this.expect(u.braceBarL),
                          (o = u.braceBarR),
                          (l = !0))
                        : (this.expect(u.braceL), (o = u.braceR), (l = !1)),
                        a.exact = l;
                      !this.match(o);

                    ) {
                      let t = !1,
                        s = null;
                      const o = this.startNode();
                      if (n && this.isContextual("proto")) {
                        const t = this.lookahead();
                        t.type !== u.colon &&
                          t.type !== u.question &&
                          (this.next(), (s = this.state.start), (e = !1));
                      }
                      if (e && this.isContextual("static")) {
                        const e = this.lookahead();
                        e.type !== u.colon &&
                          e.type !== u.question &&
                          (this.next(), (t = !0));
                      }
                      const l = this.flowParseVariance();
                      if (this.eat(u.bracketL))
                        null != s && this.unexpected(s),
                          this.eat(u.bracketL)
                            ? (l && this.unexpected(l.start),
                              a.internalSlots.push(
                                this.flowParseObjectTypeInternalSlot(o, t)
                              ))
                            : a.indexers.push(
                                this.flowParseObjectTypeIndexer(o, t, l)
                              );
                      else if (this.match(u.parenL) || this.isRelational("<"))
                        null != s && this.unexpected(s),
                          l && this.unexpected(l.start),
                          a.callProperties.push(
                            this.flowParseObjectTypeCallProperty(o, t)
                          );
                      else {
                        let e = "init";
                        if (
                          this.isContextual("get") ||
                          this.isContextual("set")
                        ) {
                          const t = this.lookahead();
                          (t.type !== u.name &&
                            t.type !== u.string &&
                            t.type !== u.num) ||
                            ((e = this.state.value), this.next());
                        }
                        const n = this.flowParseObjectTypeProperty(
                          o,
                          t,
                          s,
                          l,
                          e,
                          r,
                          i
                        );
                        null === n ? (c = !0) : a.properties.push(n);
                      }
                      this.flowObjectTypeSemicolon();
                    }
                    this.expect(o), r && (a.inexact = c);
                    const p = this.finishNode(a, "ObjectTypeAnnotation");
                    return (this.state.inType = s), p;
                  }
                  flowParseObjectTypeProperty(e, t, r, n, i, s, a) {
                    if (this.match(u.ellipsis)) {
                      s ||
                        this.unexpected(
                          null,
                          "Spread operator cannot appear in class or interface definitions"
                        ),
                        null != r && this.unexpected(r),
                        n &&
                          this.unexpected(
                            n.start,
                            "Spread properties cannot have variance"
                          ),
                        this.expect(u.ellipsis);
                      const t = this.eat(u.comma) || this.eat(u.semi);
                      if (this.match(u.braceR)) {
                        if (a) return null;
                        this.unexpected(
                          null,
                          "Explicit inexact syntax is only allowed inside inexact objects"
                        );
                      }
                      return (
                        this.match(u.braceBarR) &&
                          this.unexpected(
                            null,
                            "Explicit inexact syntax cannot appear inside an explicit exact object type"
                          ),
                        t &&
                          this.unexpected(
                            null,
                            "Explicit inexact syntax must appear at the end of an inexact object"
                          ),
                        (e.argument = this.flowParseType()),
                        this.finishNode(e, "ObjectTypeSpreadProperty")
                      );
                    }
                    {
                      (e.key = this.flowParseObjectPropertyKey()),
                        (e.static = t),
                        (e.proto = null != r),
                        (e.kind = i);
                      let s = !1;
                      return (
                        this.isRelational("<") || this.match(u.parenL)
                          ? ((e.method = !0),
                            null != r && this.unexpected(r),
                            n && this.unexpected(n.start),
                            (e.value = this.flowParseObjectTypeMethodish(
                              this.startNodeAt(e.start, e.loc.start)
                            )),
                            ("get" !== i && "set" !== i) ||
                              this.flowCheckGetterSetterParams(e))
                          : ("init" !== i && this.unexpected(),
                            (e.method = !1),
                            this.eat(u.question) && (s = !0),
                            (e.value = this.flowParseTypeInitialiser()),
                            (e.variance = n)),
                        (e.optional = s),
                        this.finishNode(e, "ObjectTypeProperty")
                      );
                    }
                  }
                  flowCheckGetterSetterParams(e) {
                    const t = "get" === e.kind ? 0 : 1,
                      r = e.start;
                    e.value.params.length + (e.value.rest ? 1 : 0) !== t &&
                      ("get" === e.kind
                        ? this.raise(
                            r,
                            "getter must not have any formal parameters"
                          )
                        : this.raise(
                            r,
                            "setter must have exactly one formal parameter"
                          )),
                      "set" === e.kind &&
                        e.value.rest &&
                        this.raise(
                          r,
                          "setter function argument must not be a rest parameter"
                        );
                  }
                  flowObjectTypeSemicolon() {
                    this.eat(u.semi) ||
                      this.eat(u.comma) ||
                      this.match(u.braceR) ||
                      this.match(u.braceBarR) ||
                      this.unexpected();
                  }
                  flowParseQualifiedTypeIdentifier(e, t, r) {
                    (e = e || this.state.start), (t = t || this.state.startLoc);
                    let n = r || this.parseIdentifier();
                    for (; this.eat(u.dot); ) {
                      const r = this.startNodeAt(e, t);
                      (r.qualification = n),
                        (r.id = this.parseIdentifier()),
                        (n = this.finishNode(r, "QualifiedTypeIdentifier"));
                    }
                    return n;
                  }
                  flowParseGenericType(e, t, r) {
                    const n = this.startNodeAt(e, t);
                    return (
                      (n.typeParameters = null),
                      (n.id = this.flowParseQualifiedTypeIdentifier(e, t, r)),
                      this.isRelational("<") &&
                        (n.typeParameters = this.flowParseTypeParameterInstantiation()),
                      this.finishNode(n, "GenericTypeAnnotation")
                    );
                  }
                  flowParseTypeofType() {
                    const e = this.startNode();
                    return (
                      this.expect(u._typeof),
                      (e.argument = this.flowParsePrimaryType()),
                      this.finishNode(e, "TypeofTypeAnnotation")
                    );
                  }
                  flowParseTupleType() {
                    const e = this.startNode();
                    for (
                      e.types = [], this.expect(u.bracketL);
                      this.state.pos < this.length &&
                      !this.match(u.bracketR) &&
                      (e.types.push(this.flowParseType()),
                      !this.match(u.bracketR));

                    )
                      this.expect(u.comma);
                    return (
                      this.expect(u.bracketR),
                      this.finishNode(e, "TupleTypeAnnotation")
                    );
                  }
                  flowParseFunctionTypeParam() {
                    let e = null,
                      t = !1,
                      r = null;
                    const n = this.startNode(),
                      i = this.lookahead();
                    return (
                      i.type === u.colon || i.type === u.question
                        ? ((e = this.parseIdentifier()),
                          this.eat(u.question) && (t = !0),
                          (r = this.flowParseTypeInitialiser()))
                        : (r = this.flowParseType()),
                      (n.name = e),
                      (n.optional = t),
                      (n.typeAnnotation = r),
                      this.finishNode(n, "FunctionTypeParam")
                    );
                  }
                  reinterpretTypeAsFunctionTypeParam(e) {
                    const t = this.startNodeAt(e.start, e.loc.start);
                    return (
                      (t.name = null),
                      (t.optional = !1),
                      (t.typeAnnotation = e),
                      this.finishNode(t, "FunctionTypeParam")
                    );
                  }
                  flowParseFunctionTypeParams(e = []) {
                    let t = null;
                    for (; !this.match(u.parenR) && !this.match(u.ellipsis); )
                      e.push(this.flowParseFunctionTypeParam()),
                        this.match(u.parenR) || this.expect(u.comma);
                    return (
                      this.eat(u.ellipsis) &&
                        (t = this.flowParseFunctionTypeParam()),
                      { params: e, rest: t }
                    );
                  }
                  flowIdentToTypeAnnotation(e, t, r, n) {
                    switch (n.name) {
                      case "any":
                        return this.finishNode(r, "AnyTypeAnnotation");
                      case "bool":
                      case "boolean":
                        return this.finishNode(r, "BooleanTypeAnnotation");
                      case "mixed":
                        return this.finishNode(r, "MixedTypeAnnotation");
                      case "empty":
                        return this.finishNode(r, "EmptyTypeAnnotation");
                      case "number":
                        return this.finishNode(r, "NumberTypeAnnotation");
                      case "string":
                        return this.finishNode(r, "StringTypeAnnotation");
                      default:
                        return (
                          this.checkNotUnderscore(n.name),
                          this.flowParseGenericType(e, t, n)
                        );
                    }
                  }
                  flowParsePrimaryType() {
                    const e = this.state.start,
                      t = this.state.startLoc,
                      r = this.startNode();
                    let n,
                      i,
                      s = !1;
                    const a = this.state.noAnonFunctionType;
                    switch (this.state.type) {
                      case u.name:
                        return this.isContextual("interface")
                          ? this.flowParseInterfaceType()
                          : this.flowIdentToTypeAnnotation(
                              e,
                              t,
                              r,
                              this.parseIdentifier()
                            );
                      case u.braceL:
                        return this.flowParseObjectType({
                          allowStatic: !1,
                          allowExact: !1,
                          allowSpread: !0,
                          allowProto: !1,
                          allowInexact: !0
                        });
                      case u.braceBarL:
                        return this.flowParseObjectType({
                          allowStatic: !1,
                          allowExact: !0,
                          allowSpread: !0,
                          allowProto: !1,
                          allowInexact: !1
                        });
                      case u.bracketL:
                        return (
                          (this.state.noAnonFunctionType = !1),
                          (i = this.flowParseTupleType()),
                          (this.state.noAnonFunctionType = a),
                          i
                        );
                      case u.relational:
                        if ("<" === this.state.value)
                          return (
                            (r.typeParameters = this.flowParseTypeParameterDeclaration()),
                            this.expect(u.parenL),
                            (n = this.flowParseFunctionTypeParams()),
                            (r.params = n.params),
                            (r.rest = n.rest),
                            this.expect(u.parenR),
                            this.expect(u.arrow),
                            (r.returnType = this.flowParseType()),
                            this.finishNode(r, "FunctionTypeAnnotation")
                          );
                        break;
                      case u.parenL:
                        if (
                          (this.next(),
                          !this.match(u.parenR) && !this.match(u.ellipsis))
                        )
                          if (this.match(u.name)) {
                            const e = this.lookahead().type;
                            s = e !== u.question && e !== u.colon;
                          } else s = !0;
                        if (s) {
                          if (
                            ((this.state.noAnonFunctionType = !1),
                            (i = this.flowParseType()),
                            (this.state.noAnonFunctionType = a),
                            this.state.noAnonFunctionType ||
                              !(
                                this.match(u.comma) ||
                                (this.match(u.parenR) &&
                                  this.lookahead().type === u.arrow)
                              ))
                          )
                            return this.expect(u.parenR), i;
                          this.eat(u.comma);
                        }
                        return (
                          (n = i
                            ? this.flowParseFunctionTypeParams([
                                this.reinterpretTypeAsFunctionTypeParam(i)
                              ])
                            : this.flowParseFunctionTypeParams()),
                          (r.params = n.params),
                          (r.rest = n.rest),
                          this.expect(u.parenR),
                          this.expect(u.arrow),
                          (r.returnType = this.flowParseType()),
                          (r.typeParameters = null),
                          this.finishNode(r, "FunctionTypeAnnotation")
                        );
                      case u.string:
                        return this.parseLiteral(
                          this.state.value,
                          "StringLiteralTypeAnnotation"
                        );
                      case u._true:
                      case u._false:
                        return (
                          (r.value = this.match(u._true)),
                          this.next(),
                          this.finishNode(r, "BooleanLiteralTypeAnnotation")
                        );
                      case u.plusMin:
                        if ("-" === this.state.value) {
                          if ((this.next(), this.match(u.num)))
                            return this.parseLiteral(
                              -this.state.value,
                              "NumberLiteralTypeAnnotation",
                              r.start,
                              r.loc.start
                            );
                          if (this.match(u.bigint))
                            return this.parseLiteral(
                              -this.state.value,
                              "BigIntLiteralTypeAnnotation",
                              r.start,
                              r.loc.start
                            );
                          this.unexpected(
                            null,
                            'Unexpected token, expected "number" or "bigint"'
                          );
                        }
                        this.unexpected();
                      case u.num:
                        return this.parseLiteral(
                          this.state.value,
                          "NumberLiteralTypeAnnotation"
                        );
                      case u.bigint:
                        return this.parseLiteral(
                          this.state.value,
                          "BigIntLiteralTypeAnnotation"
                        );
                      case u._void:
                        return (
                          this.next(), this.finishNode(r, "VoidTypeAnnotation")
                        );
                      case u._null:
                        return (
                          this.next(),
                          this.finishNode(r, "NullLiteralTypeAnnotation")
                        );
                      case u._this:
                        return (
                          this.next(), this.finishNode(r, "ThisTypeAnnotation")
                        );
                      case u.star:
                        return (
                          this.next(),
                          this.finishNode(r, "ExistsTypeAnnotation")
                        );
                      default:
                        if ("typeof" === this.state.type.keyword)
                          return this.flowParseTypeofType();
                        if (this.state.type.keyword) {
                          const e = this.state.type.label;
                          return this.next(), super.createIdentifier(r, e);
                        }
                    }
                    throw this.unexpected();
                  }
                  flowParsePostfixType() {
                    const e = this.state.start,
                      t = this.state.startLoc;
                    let r = this.flowParsePrimaryType();
                    for (
                      ;
                      this.match(u.bracketL) && !this.canInsertSemicolon();

                    ) {
                      const n = this.startNodeAt(e, t);
                      (n.elementType = r),
                        this.expect(u.bracketL),
                        this.expect(u.bracketR),
                        (r = this.finishNode(n, "ArrayTypeAnnotation"));
                    }
                    return r;
                  }
                  flowParsePrefixType() {
                    const e = this.startNode();
                    return this.eat(u.question)
                      ? ((e.typeAnnotation = this.flowParsePrefixType()),
                        this.finishNode(e, "NullableTypeAnnotation"))
                      : this.flowParsePostfixType();
                  }
                  flowParseAnonFunctionWithoutParens() {
                    const e = this.flowParsePrefixType();
                    if (!this.state.noAnonFunctionType && this.eat(u.arrow)) {
                      const t = this.startNodeAt(e.start, e.loc.start);
                      return (
                        (t.params = [
                          this.reinterpretTypeAsFunctionTypeParam(e)
                        ]),
                        (t.rest = null),
                        (t.returnType = this.flowParseType()),
                        (t.typeParameters = null),
                        this.finishNode(t, "FunctionTypeAnnotation")
                      );
                    }
                    return e;
                  }
                  flowParseIntersectionType() {
                    const e = this.startNode();
                    this.eat(u.bitwiseAND);
                    const t = this.flowParseAnonFunctionWithoutParens();
                    for (e.types = [t]; this.eat(u.bitwiseAND); )
                      e.types.push(this.flowParseAnonFunctionWithoutParens());
                    return 1 === e.types.length
                      ? t
                      : this.finishNode(e, "IntersectionTypeAnnotation");
                  }
                  flowParseUnionType() {
                    const e = this.startNode();
                    this.eat(u.bitwiseOR);
                    const t = this.flowParseIntersectionType();
                    for (e.types = [t]; this.eat(u.bitwiseOR); )
                      e.types.push(this.flowParseIntersectionType());
                    return 1 === e.types.length
                      ? t
                      : this.finishNode(e, "UnionTypeAnnotation");
                  }
                  flowParseType() {
                    const e = this.state.inType;
                    this.state.inType = !0;
                    const t = this.flowParseUnionType();
                    return (
                      (this.state.inType = e),
                      (this.state.exprAllowed =
                        this.state.exprAllowed ||
                        this.state.noAnonFunctionType),
                      t
                    );
                  }
                  flowParseTypeOrImplicitInstantiation() {
                    if (
                      this.state.type === u.name &&
                      "_" === this.state.value
                    ) {
                      const e = this.state.start,
                        t = this.state.startLoc,
                        r = this.parseIdentifier();
                      return this.flowParseGenericType(e, t, r);
                    }
                    return this.flowParseType();
                  }
                  flowParseTypeAnnotation() {
                    const e = this.startNode();
                    return (
                      (e.typeAnnotation = this.flowParseTypeInitialiser()),
                      this.finishNode(e, "TypeAnnotation")
                    );
                  }
                  flowParseTypeAnnotatableIdentifier(e) {
                    const t = e
                      ? this.parseIdentifier()
                      : this.flowParseRestrictedIdentifier();
                    return (
                      this.match(u.colon) &&
                        ((t.typeAnnotation = this.flowParseTypeAnnotation()),
                        this.resetEndLocation(t)),
                      t
                    );
                  }
                  typeCastToParameter(e) {
                    return (
                      (e.expression.typeAnnotation = e.typeAnnotation),
                      this.resetEndLocation(
                        e.expression,
                        e.typeAnnotation.end,
                        e.typeAnnotation.loc.end
                      ),
                      e.expression
                    );
                  }
                  flowParseVariance() {
                    let e = null;
                    return (
                      this.match(u.plusMin) &&
                        ((e = this.startNode()),
                        "+" === this.state.value
                          ? (e.kind = "plus")
                          : (e.kind = "minus"),
                        this.next(),
                        this.finishNode(e, "Variance")),
                      e
                    );
                  }
                  parseFunctionBody(e, t, r = !1) {
                    return t
                      ? this.forwardNoArrowParamsConversionAt(e, () =>
                          super.parseFunctionBody(e, !0, r)
                        )
                      : super.parseFunctionBody(e, !1, r);
                  }
                  parseFunctionBodyAndFinish(e, t, r = !1) {
                    if (this.match(u.colon)) {
                      const t = this.startNode();
                      ([
                        t.typeAnnotation,
                        e.predicate
                      ] = this.flowParseTypeAndPredicateInitialiser()),
                        (e.returnType = t.typeAnnotation
                          ? this.finishNode(t, "TypeAnnotation")
                          : null);
                    }
                    super.parseFunctionBodyAndFinish(e, t, r);
                  }
                  parseStatement(e, t) {
                    if (
                      this.state.strict &&
                      this.match(u.name) &&
                      "interface" === this.state.value
                    ) {
                      const e = this.startNode();
                      return this.next(), this.flowParseInterface(e);
                    }
                    {
                      const r = super.parseStatement(e, t);
                      return (
                        void 0 !== this.flowPragma ||
                          this.isValidDirective(r) ||
                          (this.flowPragma = null),
                        r
                      );
                    }
                  }
                  parseExpressionStatement(e, t) {
                    if ("Identifier" === t.type)
                      if ("declare" === t.name) {
                        if (
                          this.match(u._class) ||
                          this.match(u.name) ||
                          this.match(u._function) ||
                          this.match(u._var) ||
                          this.match(u._export)
                        )
                          return this.flowParseDeclare(e);
                      } else if (this.match(u.name)) {
                        if ("interface" === t.name)
                          return this.flowParseInterface(e);
                        if ("type" === t.name)
                          return this.flowParseTypeAlias(e);
                        if ("opaque" === t.name)
                          return this.flowParseOpaqueType(e, !1);
                      }
                    return super.parseExpressionStatement(e, t);
                  }
                  shouldParseExportDeclaration() {
                    return (
                      this.isContextual("type") ||
                      this.isContextual("interface") ||
                      this.isContextual("opaque") ||
                      super.shouldParseExportDeclaration()
                    );
                  }
                  isExportDefaultSpecifier() {
                    return (
                      (!this.match(u.name) ||
                        ("type" !== this.state.value &&
                          "interface" !== this.state.value &&
                          "opaque" !== this.state.value)) &&
                      super.isExportDefaultSpecifier()
                    );
                  }
                  parseConditional(e, t, r, n, i) {
                    if (!this.match(u.question)) return e;
                    if (i) {
                      const s = this.state.clone();
                      try {
                        return super.parseConditional(e, t, r, n);
                      } catch (t) {
                        if (t instanceof SyntaxError)
                          return (
                            (this.state = s),
                            (i.start = t.pos || this.state.start),
                            e
                          );
                        throw t;
                      }
                    }
                    this.expect(u.question);
                    const s = this.state.clone(),
                      a = this.state.noArrowAt,
                      o = this.startNodeAt(r, n);
                    let {
                        consequent: l,
                        failed: c
                      } = this.tryParseConditionalConsequent(),
                      [p, d] = this.getArrowLikeExpressions(l);
                    if (c || d.length > 0) {
                      const e = [...a];
                      if (d.length > 0) {
                        (this.state = s), (this.state.noArrowAt = e);
                        for (let t = 0; t < d.length; t++) e.push(d[t].start);
                        ({
                          consequent: l,
                          failed: c
                        } = this.tryParseConditionalConsequent()),
                          ([p, d] = this.getArrowLikeExpressions(l));
                      }
                      c &&
                        p.length > 1 &&
                        this.raise(
                          s.start,
                          "Ambiguous expression: wrap the arrow functions in parentheses to disambiguate."
                        ),
                        c &&
                          1 === p.length &&
                          ((this.state = s),
                          (this.state.noArrowAt = e.concat(p[0].start)),
                          ({
                            consequent: l,
                            failed: c
                          } = this.tryParseConditionalConsequent())),
                        this.getArrowLikeExpressions(l, !0);
                    }
                    return (
                      (this.state.noArrowAt = a),
                      this.expect(u.colon),
                      (o.test = e),
                      (o.consequent = l),
                      (o.alternate = this.forwardNoArrowParamsConversionAt(
                        o,
                        () => this.parseMaybeAssign(t, void 0, void 0, void 0)
                      )),
                      this.finishNode(o, "ConditionalExpression")
                    );
                  }
                  tryParseConditionalConsequent() {
                    this.state.noArrowParamsConversionAt.push(this.state.start);
                    const e = this.parseMaybeAssign(),
                      t = !this.match(u.colon);
                    return (
                      this.state.noArrowParamsConversionAt.pop(),
                      { consequent: e, failed: t }
                    );
                  }
                  getArrowLikeExpressions(e, t) {
                    const r = [e],
                      n = [];
                    for (; 0 !== r.length; ) {
                      const e = r.pop();
                      "ArrowFunctionExpression" === e.type
                        ? (e.typeParameters || !e.returnType
                            ? (this.toAssignableList(
                                e.params,
                                !0,
                                "arrow function parameters"
                              ),
                              this.scope.enter(E(!1, !1) | f),
                              super.checkParams(e, !1, !0),
                              this.scope.exit())
                            : n.push(e),
                          r.push(e.body))
                        : "ConditionalExpression" === e.type &&
                          (r.push(e.consequent), r.push(e.alternate));
                    }
                    if (t) {
                      for (let t = 0; t < n.length; t++)
                        this.toAssignableList(
                          e.params,
                          !0,
                          "arrow function parameters"
                        );
                      return [n, []];
                    }
                    return (function(e, t) {
                      const r = [],
                        n = [];
                      for (let i = 0; i < e.length; i++)
                        (t(e[i], i, e) ? r : n).push(e[i]);
                      return [r, n];
                    })(n, e => {
                      try {
                        return (
                          this.toAssignableList(
                            e.params,
                            !0,
                            "arrow function parameters"
                          ),
                          !0
                        );
                      } catch (e) {
                        return !1;
                      }
                    });
                  }
                  forwardNoArrowParamsConversionAt(e, t) {
                    let r;
                    return (
                      -1 !==
                      this.state.noArrowParamsConversionAt.indexOf(e.start)
                        ? (this.state.noArrowParamsConversionAt.push(
                            this.state.start
                          ),
                          (r = t()),
                          this.state.noArrowParamsConversionAt.pop())
                        : (r = t()),
                      r
                    );
                  }
                  parseParenItem(e, t, r) {
                    if (
                      ((e = super.parseParenItem(e, t, r)),
                      this.eat(u.question) &&
                        ((e.optional = !0), this.resetEndLocation(e)),
                      this.match(u.colon))
                    ) {
                      const n = this.startNodeAt(t, r);
                      return (
                        (n.expression = e),
                        (n.typeAnnotation = this.flowParseTypeAnnotation()),
                        this.finishNode(n, "TypeCastExpression")
                      );
                    }
                    return e;
                  }
                  assertModuleNodeAllowed(e) {
                    ("ImportDeclaration" === e.type &&
                      ("type" === e.importKind || "typeof" === e.importKind)) ||
                      ("ExportNamedDeclaration" === e.type &&
                        "type" === e.exportKind) ||
                      ("ExportAllDeclaration" === e.type &&
                        "type" === e.exportKind) ||
                      super.assertModuleNodeAllowed(e);
                  }
                  parseExport(e) {
                    const t = super.parseExport(e);
                    return (
                      ("ExportNamedDeclaration" !== t.type &&
                        "ExportAllDeclaration" !== t.type) ||
                        (t.exportKind = t.exportKind || "value"),
                      t
                    );
                  }
                  parseExportDeclaration(e) {
                    if (this.isContextual("type")) {
                      e.exportKind = "type";
                      const t = this.startNode();
                      return (
                        this.next(),
                        this.match(u.braceL)
                          ? ((e.specifiers = this.parseExportSpecifiers()),
                            this.parseExportFrom(e),
                            null)
                          : this.flowParseTypeAlias(t)
                      );
                    }
                    if (this.isContextual("opaque")) {
                      e.exportKind = "type";
                      const t = this.startNode();
                      return this.next(), this.flowParseOpaqueType(t, !1);
                    }
                    if (this.isContextual("interface")) {
                      e.exportKind = "type";
                      const t = this.startNode();
                      return this.next(), this.flowParseInterface(t);
                    }
                    return super.parseExportDeclaration(e);
                  }
                  eatExportStar(e) {
                    return (
                      !!super.eatExportStar(...arguments) ||
                      (!(
                        !this.isContextual("type") ||
                        this.lookahead().type !== u.star
                      ) &&
                        ((e.exportKind = "type"), this.next(), this.next(), !0))
                    );
                  }
                  maybeParseExportNamespaceSpecifier(e) {
                    const t = this.state.start,
                      r = super.maybeParseExportNamespaceSpecifier(e);
                    return (
                      r && "type" === e.exportKind && this.unexpected(t), r
                    );
                  }
                  parseClassId(e, t, r) {
                    super.parseClassId(e, t, r),
                      this.isRelational("<") &&
                        (e.typeParameters = this.flowParseTypeParameterDeclaration());
                  }
                  getTokenFromCode(e) {
                    const t = this.input.charCodeAt(this.state.pos + 1);
                    return 123 === e && 124 === t
                      ? this.finishOp(u.braceBarL, 2)
                      : !this.state.inType || (62 !== e && 60 !== e)
                      ? (function(e, t) {
                          return 64 === e && 64 === t;
                        })(e, t)
                        ? ((this.state.isIterator = !0), super.readWord())
                        : super.getTokenFromCode(e)
                      : this.finishOp(u.relational, 1);
                  }
                  toAssignable(e, t, r) {
                    return "TypeCastExpression" === e.type
                      ? super.toAssignable(this.typeCastToParameter(e), t, r)
                      : super.toAssignable(e, t, r);
                  }
                  toAssignableList(e, t, r) {
                    for (let t = 0; t < e.length; t++) {
                      const r = e[t];
                      r &&
                        "TypeCastExpression" === r.type &&
                        (e[t] = this.typeCastToParameter(r));
                    }
                    return super.toAssignableList(e, t, r);
                  }
                  toReferencedList(e, t) {
                    for (let r = 0; r < e.length; r++) {
                      const n = e[r];
                      !n ||
                        "TypeCastExpression" !== n.type ||
                        (n.extra && n.extra.parenthesized) ||
                        (!(e.length > 1) && t) ||
                        this.raise(
                          n.typeAnnotation.start,
                          "The type cast expression is expected to be wrapped with parenthesis"
                        );
                    }
                    return e;
                  }
                  checkLVal(e, t = j, r, n) {
                    if ("TypeCastExpression" !== e.type)
                      return super.checkLVal(e, t, r, n);
                  }
                  parseClassProperty(e) {
                    return (
                      this.match(u.colon) &&
                        (e.typeAnnotation = this.flowParseTypeAnnotation()),
                      super.parseClassProperty(e)
                    );
                  }
                  parseClassPrivateProperty(e) {
                    return (
                      this.match(u.colon) &&
                        (e.typeAnnotation = this.flowParseTypeAnnotation()),
                      super.parseClassPrivateProperty(e)
                    );
                  }
                  isClassMethod() {
                    return this.isRelational("<") || super.isClassMethod();
                  }
                  isClassProperty() {
                    return this.match(u.colon) || super.isClassProperty();
                  }
                  isNonstaticConstructor(e) {
                    return (
                      !this.match(u.colon) && super.isNonstaticConstructor(e)
                    );
                  }
                  pushClassMethod(e, t, r, n, i, s) {
                    t.variance && this.unexpected(t.variance.start),
                      delete t.variance,
                      this.isRelational("<") &&
                        (t.typeParameters = this.flowParseTypeParameterDeclaration()),
                      super.pushClassMethod(e, t, r, n, i, s);
                  }
                  pushClassPrivateMethod(e, t, r, n) {
                    t.variance && this.unexpected(t.variance.start),
                      delete t.variance,
                      this.isRelational("<") &&
                        (t.typeParameters = this.flowParseTypeParameterDeclaration()),
                      super.pushClassPrivateMethod(e, t, r, n);
                  }
                  parseClassSuper(e) {
                    if (
                      (super.parseClassSuper(e),
                      e.superClass &&
                        this.isRelational("<") &&
                        (e.superTypeParameters = this.flowParseTypeParameterInstantiation()),
                      this.isContextual("implements"))
                    ) {
                      this.next();
                      const t = (e.implements = []);
                      do {
                        const e = this.startNode();
                        (e.id = this.flowParseRestrictedIdentifier(!0)),
                          this.isRelational("<")
                            ? (e.typeParameters = this.flowParseTypeParameterInstantiation())
                            : (e.typeParameters = null),
                          t.push(this.finishNode(e, "ClassImplements"));
                      } while (this.eat(u.comma));
                    }
                  }
                  parsePropertyName(e) {
                    const t = this.flowParseVariance(),
                      r = super.parsePropertyName(e);
                    return (e.variance = t), r;
                  }
                  parseObjPropValue(e, t, r, n, i, s, a, o) {
                    let l;
                    e.variance && this.unexpected(e.variance.start),
                      delete e.variance,
                      this.isRelational("<") &&
                        ((l = this.flowParseTypeParameterDeclaration()),
                        this.match(u.parenL) || this.unexpected()),
                      super.parseObjPropValue(e, t, r, n, i, s, a, o),
                      l && ((e.value || e).typeParameters = l);
                  }
                  parseAssignableListItemTypes(e) {
                    if (this.eat(u.question)) {
                      if ("Identifier" !== e.type)
                        throw this.raise(
                          e.start,
                          "A binding pattern parameter cannot be optional in an implementation signature."
                        );
                      e.optional = !0;
                    }
                    return (
                      this.match(u.colon) &&
                        (e.typeAnnotation = this.flowParseTypeAnnotation()),
                      this.resetEndLocation(e),
                      e
                    );
                  }
                  parseMaybeDefault(e, t, r) {
                    const n = super.parseMaybeDefault(e, t, r);
                    return (
                      "AssignmentPattern" === n.type &&
                        n.typeAnnotation &&
                        n.right.start < n.typeAnnotation.start &&
                        this.raise(
                          n.typeAnnotation.start,
                          "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`"
                        ),
                      n
                    );
                  }
                  shouldParseDefaultImport(e) {
                    return he(e)
                      ? fe(this.state)
                      : super.shouldParseDefaultImport(e);
                  }
                  parseImportSpecifierLocal(e, t, r, n) {
                    (t.local = he(e)
                      ? this.flowParseRestrictedIdentifier(!0)
                      : this.parseIdentifier()),
                      this.checkLVal(t.local, O, void 0, n),
                      e.specifiers.push(this.finishNode(t, r));
                  }
                  maybeParseDefaultImportSpecifier(e) {
                    e.importKind = "value";
                    let t = null;
                    if (
                      (this.match(u._typeof)
                        ? (t = "typeof")
                        : this.isContextual("type") && (t = "type"),
                      t)
                    ) {
                      const r = this.lookahead();
                      "type" === t &&
                        r.type === u.star &&
                        this.unexpected(r.start),
                        (fe(r) || r.type === u.braceL || r.type === u.star) &&
                          (this.next(), (e.importKind = t));
                    }
                    return super.maybeParseDefaultImportSpecifier(e);
                  }
                  parseImportSpecifier(e) {
                    const t = this.startNode(),
                      r = this.state.start,
                      n = this.parseIdentifier(!0);
                    let i = null;
                    "type" === n.name
                      ? (i = "type")
                      : "typeof" === n.name && (i = "typeof");
                    let s = !1;
                    if (
                      this.isContextual("as") &&
                      !this.isLookaheadContextual("as")
                    ) {
                      const e = this.parseIdentifier(!0);
                      null === i ||
                      this.match(u.name) ||
                      this.state.type.keyword
                        ? ((t.imported = n),
                          (t.importKind = null),
                          (t.local = this.parseIdentifier()))
                        : ((t.imported = e),
                          (t.importKind = i),
                          (t.local = e.__clone()));
                    } else
                      null !== i &&
                      (this.match(u.name) || this.state.type.keyword)
                        ? ((t.imported = this.parseIdentifier(!0)),
                          (t.importKind = i),
                          this.eatContextual("as")
                            ? (t.local = this.parseIdentifier())
                            : ((s = !0), (t.local = t.imported.__clone())))
                        : ((s = !0),
                          (t.imported = n),
                          (t.importKind = null),
                          (t.local = t.imported.__clone()));
                    const a = he(e),
                      o = he(t);
                    a &&
                      o &&
                      this.raise(
                        r,
                        "The `type` and `typeof` keywords on named imports can only be used on regular `import` statements. It cannot be used with `import type` or `import typeof` statements"
                      ),
                      (a || o) &&
                        this.checkReservedType(t.local.name, t.local.start),
                      !s ||
                        a ||
                        o ||
                        this.checkReservedWord(t.local.name, t.start, !0, !0),
                      this.checkLVal(t.local, O, void 0, "import specifier"),
                      e.specifiers.push(this.finishNode(t, "ImportSpecifier"));
                  }
                  parseFunctionParams(e, t) {
                    const r = e.kind;
                    "get" !== r &&
                      "set" !== r &&
                      this.isRelational("<") &&
                      (e.typeParameters = this.flowParseTypeParameterDeclaration()),
                      super.parseFunctionParams(e, t);
                  }
                  parseVarId(e, t) {
                    super.parseVarId(e, t),
                      this.match(u.colon) &&
                        ((e.id.typeAnnotation = this.flowParseTypeAnnotation()),
                        this.resetEndLocation(e.id));
                  }
                  parseAsyncArrowFromCallExpression(e, t) {
                    if (this.match(u.colon)) {
                      const t = this.state.noAnonFunctionType;
                      (this.state.noAnonFunctionType = !0),
                        (e.returnType = this.flowParseTypeAnnotation()),
                        (this.state.noAnonFunctionType = t);
                    }
                    return super.parseAsyncArrowFromCallExpression(e, t);
                  }
                  shouldParseAsyncArrow() {
                    return this.match(u.colon) || super.shouldParseAsyncArrow();
                  }
                  parseMaybeAssign(e, t, r, n) {
                    let i = null;
                    if (
                      this.hasPlugin("jsx") &&
                      (this.match(u.jsxTagStart) || this.isRelational("<"))
                    ) {
                      const s = this.state.clone();
                      try {
                        return super.parseMaybeAssign(e, t, r, n);
                      } catch (e) {
                        if (!(e instanceof SyntaxError)) throw e;
                        {
                          this.state = s;
                          const t = this.state.context.length;
                          this.state.context[t - 1] === H.j_oTag &&
                            (this.state.context.length -= 2),
                            (i = e);
                        }
                      }
                    }
                    if (null != i || this.isRelational("<")) {
                      let s, a;
                      try {
                        (a = this.flowParseTypeParameterDeclaration()),
                          ((s = this.forwardNoArrowParamsConversionAt(a, () =>
                            super.parseMaybeAssign(e, t, r, n)
                          )).typeParameters = a),
                          this.resetStartLocationFromNode(s, a);
                      } catch (e) {
                        throw i || e;
                      }
                      if ("ArrowFunctionExpression" === s.type) return s;
                      if (null != i) throw i;
                      this.raise(
                        a.start,
                        "Expected an arrow function after this type parameter declaration"
                      );
                    }
                    return super.parseMaybeAssign(e, t, r, n);
                  }
                  parseArrow(e) {
                    if (this.match(u.colon)) {
                      const t = this.state.clone();
                      try {
                        const r = this.state.noAnonFunctionType;
                        this.state.noAnonFunctionType = !0;
                        const n = this.startNode();
                        ([
                          n.typeAnnotation,
                          e.predicate
                        ] = this.flowParseTypeAndPredicateInitialiser()),
                          (this.state.noAnonFunctionType = r),
                          this.canInsertSemicolon() && this.unexpected(),
                          this.match(u.arrow) || this.unexpected(),
                          (e.returnType = n.typeAnnotation
                            ? this.finishNode(n, "TypeAnnotation")
                            : null);
                      } catch (e) {
                        if (!(e instanceof SyntaxError)) throw e;
                        this.state = t;
                      }
                    }
                    return super.parseArrow(e);
                  }
                  shouldParseArrow() {
                    return this.match(u.colon) || super.shouldParseArrow();
                  }
                  setArrowFunctionParameters(e, t) {
                    -1 !== this.state.noArrowParamsConversionAt.indexOf(e.start)
                      ? (e.params = t)
                      : super.setArrowFunctionParameters(e, t);
                  }
                  checkParams(e, t, r) {
                    if (
                      !r ||
                      -1 ===
                        this.state.noArrowParamsConversionAt.indexOf(e.start)
                    )
                      return super.checkParams(e, t, r);
                  }
                  parseParenAndDistinguishExpression(e) {
                    return super.parseParenAndDistinguishExpression(
                      e && -1 === this.state.noArrowAt.indexOf(this.state.start)
                    );
                  }
                  parseSubscripts(e, t, r, n) {
                    if (
                      "Identifier" === e.type &&
                      "async" === e.name &&
                      -1 !== this.state.noArrowAt.indexOf(t)
                    ) {
                      this.next();
                      const n = this.startNodeAt(t, r);
                      (n.callee = e),
                        (n.arguments = this.parseCallExpressionArguments(
                          u.parenR,
                          !1
                        )),
                        (e = this.finishNode(n, "CallExpression"));
                    } else if (
                      "Identifier" === e.type &&
                      "async" === e.name &&
                      this.isRelational("<")
                    ) {
                      const i = this.state.clone();
                      let s;
                      try {
                        const e = this.parseAsyncArrowWithTypeParameters(t, r);
                        if (e) return e;
                      } catch (e) {
                        s = e;
                      }
                      this.state = i;
                      try {
                        return super.parseSubscripts(e, t, r, n);
                      } catch (e) {
                        throw s || e;
                      }
                    }
                    return super.parseSubscripts(e, t, r, n);
                  }
                  parseSubscript(e, t, r, n, i, s) {
                    if (
                      this.match(u.questionDot) &&
                      this.isLookaheadRelational("<")
                    ) {
                      if (
                        (this.expectPlugin("optionalChaining"),
                        (i.optionalChainMember = !0),
                        n)
                      )
                        return (i.stop = !0), e;
                      this.next();
                      const s = this.startNodeAt(t, r);
                      return (
                        (s.callee = e),
                        (s.typeArguments = this.flowParseTypeParameterInstantiation()),
                        this.expect(u.parenL),
                        (s.arguments = this.parseCallExpressionArguments(
                          u.parenR,
                          !1
                        )),
                        (s.optional = !0),
                        this.finishNode(s, "OptionalCallExpression")
                      );
                    }
                    if (
                      !n &&
                      this.shouldParseTypes() &&
                      this.isRelational("<")
                    ) {
                      const n = this.startNodeAt(t, r);
                      n.callee = e;
                      const s = this.state.clone();
                      try {
                        return (
                          (n.typeArguments = this.flowParseTypeParameterInstantiationCallOrNew()),
                          this.expect(u.parenL),
                          (n.arguments = this.parseCallExpressionArguments(
                            u.parenR,
                            !1
                          )),
                          i.optionalChainMember
                            ? ((n.optional = !1),
                              this.finishNode(n, "OptionalCallExpression"))
                            : this.finishNode(n, "CallExpression")
                        );
                      } catch (e) {
                        if (!(e instanceof SyntaxError)) throw e;
                        this.state = s;
                      }
                    }
                    return super.parseSubscript(e, t, r, n, i, s);
                  }
                  parseNewArguments(e) {
                    let t = null;
                    if (this.shouldParseTypes() && this.isRelational("<")) {
                      const e = this.state.clone();
                      try {
                        t = this.flowParseTypeParameterInstantiationCallOrNew();
                      } catch (t) {
                        if (!(t instanceof SyntaxError)) throw t;
                        this.state = e;
                      }
                    }
                    (e.typeArguments = t), super.parseNewArguments(e);
                  }
                  parseAsyncArrowWithTypeParameters(e, t) {
                    const r = this.startNodeAt(e, t);
                    if ((this.parseFunctionParams(r), this.parseArrow(r)))
                      return this.parseArrowExpression(r, void 0, !0);
                  }
                  readToken_mult_modulo(e) {
                    const t = this.input.charCodeAt(this.state.pos + 1);
                    if (42 === e && 47 === t && this.state.hasFlowComment)
                      return (
                        (this.state.hasFlowComment = !1),
                        (this.state.pos += 2),
                        void this.nextToken()
                      );
                    super.readToken_mult_modulo(e);
                  }
                  readToken_pipe_amp(e) {
                    const t = this.input.charCodeAt(this.state.pos + 1);
                    124 !== e || 125 !== t
                      ? super.readToken_pipe_amp(e)
                      : this.finishOp(u.braceBarR, 2);
                  }
                  parseTopLevel(e, t) {
                    const r = super.parseTopLevel(e, t);
                    return (
                      this.state.hasFlowComment &&
                        this.unexpected(null, "Unterminated flow-comment"),
                      r
                    );
                  }
                  skipBlockComment() {
                    if (
                      this.hasPlugin("flowComments") &&
                      this.skipFlowComment()
                    )
                      return (
                        this.state.hasFlowComment &&
                          this.unexpected(
                            null,
                            "Cannot have a flow comment inside another flow comment"
                          ),
                        this.hasFlowCommentCompletion(),
                        (this.state.pos += this.skipFlowComment()),
                        void (this.state.hasFlowComment = !0)
                      );
                    if (this.state.hasFlowComment) {
                      const e = this.input.indexOf(
                        "*-/",
                        (this.state.pos += 2)
                      );
                      return (
                        -1 === e &&
                          this.raise(
                            this.state.pos - 2,
                            "Unterminated comment"
                          ),
                        void (this.state.pos = e + 3)
                      );
                    }
                    super.skipBlockComment();
                  }
                  skipFlowComment() {
                    const { pos: e } = this.state;
                    let t = 2;
                    for (; [32, 9].includes(this.input.charCodeAt(e + t)); )
                      t++;
                    const r = this.input.charCodeAt(t + e),
                      n = this.input.charCodeAt(t + e + 1);
                    return 58 === r && 58 === n
                      ? t + 2
                      : "flow-include" === this.input.slice(t + e, t + e + 12)
                      ? t + 12
                      : 58 === r && 58 !== n && t;
                  }
                  hasFlowCommentCompletion() {
                    -1 === this.input.indexOf("*/", this.state.pos) &&
                      this.raise(this.state.pos, "Unterminated comment");
                  }
                },
              typescript: e =>
                class extends e {
                  getScopeHandler() {
                    return De;
                  }
                  tsIsIdentifier() {
                    return this.match(u.name);
                  }
                  tsNextTokenCanFollowModifier() {
                    return (
                      this.next(),
                      !(
                        this.hasPrecedingLineBreak() ||
                        this.match(u.parenL) ||
                        this.match(u.parenR) ||
                        this.match(u.colon) ||
                        this.match(u.eq) ||
                        this.match(u.question) ||
                        this.match(u.bang)
                      )
                    );
                  }
                  tsParseModifier(e) {
                    if (!this.match(u.name)) return;
                    const t = this.state.value;
                    return -1 !== e.indexOf(t) &&
                      this.tsTryParse(
                        this.tsNextTokenCanFollowModifier.bind(this)
                      )
                      ? t
                      : void 0;
                  }
                  tsIsListTerminator(e) {
                    switch (e) {
                      case "EnumMembers":
                      case "TypeMembers":
                        return this.match(u.braceR);
                      case "HeritageClauseElement":
                        return this.match(u.braceL);
                      case "TupleElementTypes":
                        return this.match(u.bracketR);
                      case "TypeParametersOrArguments":
                        return this.isRelational(">");
                    }
                    throw new Error("Unreachable");
                  }
                  tsParseList(e, t) {
                    const r = [];
                    for (; !this.tsIsListTerminator(e); ) r.push(t());
                    return r;
                  }
                  tsParseDelimitedList(e, t) {
                    return Pe(this.tsParseDelimitedListWorker(e, t, !0));
                  }
                  tsParseDelimitedListWorker(e, t, r) {
                    const n = [];
                    for (; !this.tsIsListTerminator(e); ) {
                      const i = t();
                      if (null == i) return;
                      if ((n.push(i), !this.eat(u.comma))) {
                        if (this.tsIsListTerminator(e)) break;
                        return void (r && this.expect(u.comma));
                      }
                    }
                    return n;
                  }
                  tsParseBracketedList(e, t, r, n) {
                    n ||
                      (r
                        ? this.expect(u.bracketL)
                        : this.expectRelational("<"));
                    const i = this.tsParseDelimitedList(e, t);
                    return (
                      r ? this.expect(u.bracketR) : this.expectRelational(">"),
                      i
                    );
                  }
                  tsParseImportType() {
                    const e = this.startNode();
                    if (
                      (this.expect(u._import),
                      this.expect(u.parenL),
                      !this.match(u.string))
                    )
                      throw this.unexpected(
                        null,
                        "Argument in a type import must be a string literal"
                      );
                    return (
                      (e.argument = this.parseExprAtom()),
                      this.expect(u.parenR),
                      this.eat(u.dot) &&
                        (e.qualifier = this.tsParseEntityName(!0)),
                      this.isRelational("<") &&
                        (e.typeParameters = this.tsParseTypeArguments()),
                      this.finishNode(e, "TSImportType")
                    );
                  }
                  tsParseEntityName(e) {
                    let t = this.parseIdentifier();
                    for (; this.eat(u.dot); ) {
                      const r = this.startNodeAtNode(t);
                      (r.left = t),
                        (r.right = this.parseIdentifier(e)),
                        (t = this.finishNode(r, "TSQualifiedName"));
                    }
                    return t;
                  }
                  tsParseTypeReference() {
                    const e = this.startNode();
                    return (
                      (e.typeName = this.tsParseEntityName(!1)),
                      !this.hasPrecedingLineBreak() &&
                        this.isRelational("<") &&
                        (e.typeParameters = this.tsParseTypeArguments()),
                      this.finishNode(e, "TSTypeReference")
                    );
                  }
                  tsParseThisTypePredicate(e) {
                    this.next();
                    const t = this.startNodeAtNode(e);
                    return (
                      (t.parameterName = e),
                      (t.typeAnnotation = this.tsParseTypeAnnotation(!1)),
                      this.finishNode(t, "TSTypePredicate")
                    );
                  }
                  tsParseThisTypeNode() {
                    const e = this.startNode();
                    return this.next(), this.finishNode(e, "TSThisType");
                  }
                  tsParseTypeQuery() {
                    const e = this.startNode();
                    return (
                      this.expect(u._typeof),
                      this.match(u._import)
                        ? (e.exprName = this.tsParseImportType())
                        : (e.exprName = this.tsParseEntityName(!0)),
                      this.finishNode(e, "TSTypeQuery")
                    );
                  }
                  tsParseTypeParameter() {
                    const e = this.startNode();
                    return (
                      (e.name = this.parseIdentifierName(e.start)),
                      (e.constraint = this.tsEatThenParseType(u._extends)),
                      (e.default = this.tsEatThenParseType(u.eq)),
                      this.finishNode(e, "TSTypeParameter")
                    );
                  }
                  tsTryParseTypeParameters() {
                    if (this.isRelational("<"))
                      return this.tsParseTypeParameters();
                  }
                  tsParseTypeParameters() {
                    const e = this.startNode();
                    return (
                      this.isRelational("<") || this.match(u.jsxTagStart)
                        ? this.next()
                        : this.unexpected(),
                      (e.params = this.tsParseBracketedList(
                        "TypeParametersOrArguments",
                        this.tsParseTypeParameter.bind(this),
                        !1,
                        !0
                      )),
                      this.finishNode(e, "TSTypeParameterDeclaration")
                    );
                  }
                  tsTryNextParseConstantContext() {
                    return this.lookahead().type === u._const
                      ? (this.next(), this.tsParseTypeReference())
                      : null;
                  }
                  tsFillSignature(e, t) {
                    const r = e === u.arrow;
                    (t.typeParameters = this.tsTryParseTypeParameters()),
                      this.expect(u.parenL),
                      (t.parameters = this.tsParseBindingListForSignature()),
                      r
                        ? (t.typeAnnotation = this.tsParseTypeOrTypePredicateAnnotation(
                            e
                          ))
                        : this.match(e) &&
                          (t.typeAnnotation = this.tsParseTypeOrTypePredicateAnnotation(
                            e
                          ));
                  }
                  tsParseBindingListForSignature() {
                    return this.parseBindingList(u.parenR).map(e => {
                      if (
                        "Identifier" !== e.type &&
                        "RestElement" !== e.type &&
                        "ObjectPattern" !== e.type &&
                        "ArrayPattern" !== e.type
                      )
                        throw this.unexpected(
                          e.start,
                          `Name in a signature must be an Identifier, ObjectPattern or ArrayPattern, instead got ${e.type}`
                        );
                      return e;
                    });
                  }
                  tsParseTypeMemberSemicolon() {
                    this.eat(u.comma) || this.semicolon();
                  }
                  tsParseSignatureMember(e, t) {
                    return (
                      this.tsFillSignature(u.colon, t),
                      this.tsParseTypeMemberSemicolon(),
                      this.finishNode(t, e)
                    );
                  }
                  tsIsUnambiguouslyIndexSignature() {
                    return this.next(), this.eat(u.name) && this.match(u.colon);
                  }
                  tsTryParseIndexSignature(e) {
                    if (
                      !this.match(u.bracketL) ||
                      !this.tsLookAhead(
                        this.tsIsUnambiguouslyIndexSignature.bind(this)
                      )
                    )
                      return;
                    this.expect(u.bracketL);
                    const t = this.parseIdentifier();
                    (t.typeAnnotation = this.tsParseTypeAnnotation()),
                      this.resetEndLocation(t),
                      this.expect(u.bracketR),
                      (e.parameters = [t]);
                    const r = this.tsTryParseTypeAnnotation();
                    return (
                      r && (e.typeAnnotation = r),
                      this.tsParseTypeMemberSemicolon(),
                      this.finishNode(e, "TSIndexSignature")
                    );
                  }
                  tsParsePropertyOrMethodSignature(e, t) {
                    this.eat(u.question) && (e.optional = !0);
                    const r = e;
                    if (
                      t ||
                      (!this.match(u.parenL) && !this.isRelational("<"))
                    ) {
                      const e = r;
                      t && (e.readonly = !0);
                      const n = this.tsTryParseTypeAnnotation();
                      return (
                        n && (e.typeAnnotation = n),
                        this.tsParseTypeMemberSemicolon(),
                        this.finishNode(e, "TSPropertySignature")
                      );
                    }
                    {
                      const e = r;
                      return (
                        this.tsFillSignature(u.colon, e),
                        this.tsParseTypeMemberSemicolon(),
                        this.finishNode(e, "TSMethodSignature")
                      );
                    }
                  }
                  tsParseTypeMember() {
                    const e = this.startNode();
                    if (this.match(u.parenL) || this.isRelational("<"))
                      return this.tsParseSignatureMember(
                        "TSCallSignatureDeclaration",
                        e
                      );
                    if (this.match(u._new)) {
                      const t = this.startNode();
                      return (
                        this.next(),
                        this.match(u.parenL) || this.isRelational("<")
                          ? this.tsParseSignatureMember(
                              "TSConstructSignatureDeclaration",
                              e
                            )
                          : ((e.key = this.createIdentifier(t, "new")),
                            this.tsParsePropertyOrMethodSignature(e, !1))
                      );
                    }
                    const t = !!this.tsParseModifier(["readonly"]),
                      r = this.tsTryParseIndexSignature(e);
                    return r
                      ? (t && (e.readonly = !0), r)
                      : (this.parsePropertyName(e),
                        this.tsParsePropertyOrMethodSignature(e, t));
                  }
                  tsParseTypeLiteral() {
                    const e = this.startNode();
                    return (
                      (e.members = this.tsParseObjectTypeMembers()),
                      this.finishNode(e, "TSTypeLiteral")
                    );
                  }
                  tsParseObjectTypeMembers() {
                    this.expect(u.braceL);
                    const e = this.tsParseList(
                      "TypeMembers",
                      this.tsParseTypeMember.bind(this)
                    );
                    return this.expect(u.braceR), e;
                  }
                  tsIsStartOfMappedType() {
                    return (
                      this.next(),
                      this.eat(u.plusMin)
                        ? this.isContextual("readonly")
                        : (this.isContextual("readonly") && this.next(),
                          !!this.match(u.bracketL) &&
                            (this.next(),
                            !!this.tsIsIdentifier() &&
                              (this.next(), this.match(u._in))))
                    );
                  }
                  tsParseMappedTypeParameter() {
                    const e = this.startNode();
                    return (
                      (e.name = this.parseIdentifierName(e.start)),
                      (e.constraint = this.tsExpectThenParseType(u._in)),
                      this.finishNode(e, "TSTypeParameter")
                    );
                  }
                  tsParseMappedType() {
                    const e = this.startNode();
                    return (
                      this.expect(u.braceL),
                      this.match(u.plusMin)
                        ? ((e.readonly = this.state.value),
                          this.next(),
                          this.expectContextual("readonly"))
                        : this.eatContextual("readonly") && (e.readonly = !0),
                      this.expect(u.bracketL),
                      (e.typeParameter = this.tsParseMappedTypeParameter()),
                      this.expect(u.bracketR),
                      this.match(u.plusMin)
                        ? ((e.optional = this.state.value),
                          this.next(),
                          this.expect(u.question))
                        : this.eat(u.question) && (e.optional = !0),
                      (e.typeAnnotation = this.tsTryParseType()),
                      this.semicolon(),
                      this.expect(u.braceR),
                      this.finishNode(e, "TSMappedType")
                    );
                  }
                  tsParseTupleType() {
                    const e = this.startNode();
                    e.elementTypes = this.tsParseBracketedList(
                      "TupleElementTypes",
                      this.tsParseTupleElementType.bind(this),
                      !0,
                      !1
                    );
                    let t = !1;
                    return (
                      e.elementTypes.forEach(e => {
                        "TSOptionalType" === e.type
                          ? (t = !0)
                          : t &&
                            "TSRestType" !== e.type &&
                            this.raise(
                              e.start,
                              "A required element cannot follow an optional element."
                            );
                      }),
                      this.finishNode(e, "TSTupleType")
                    );
                  }
                  tsParseTupleElementType() {
                    if (this.match(u.ellipsis)) {
                      const e = this.startNode();
                      return (
                        this.next(),
                        (e.typeAnnotation = this.tsParseType()),
                        this.checkCommaAfterRest(),
                        this.finishNode(e, "TSRestType")
                      );
                    }
                    const e = this.tsParseType();
                    if (this.eat(u.question)) {
                      const t = this.startNodeAtNode(e);
                      return (
                        (t.typeAnnotation = e),
                        this.finishNode(t, "TSOptionalType")
                      );
                    }
                    return e;
                  }
                  tsParseParenthesizedType() {
                    const e = this.startNode();
                    return (
                      this.expect(u.parenL),
                      (e.typeAnnotation = this.tsParseType()),
                      this.expect(u.parenR),
                      this.finishNode(e, "TSParenthesizedType")
                    );
                  }
                  tsParseFunctionOrConstructorType(e) {
                    const t = this.startNode();
                    return (
                      "TSConstructorType" === e && this.expect(u._new),
                      this.tsFillSignature(u.arrow, t),
                      this.finishNode(t, e)
                    );
                  }
                  tsParseLiteralTypeNode() {
                    const e = this.startNode();
                    return (
                      (e.literal = (() => {
                        switch (this.state.type) {
                          case u.num:
                          case u.string:
                          case u._true:
                          case u._false:
                            return this.parseExprAtom();
                          default:
                            throw this.unexpected();
                        }
                      })()),
                      this.finishNode(e, "TSLiteralType")
                    );
                  }
                  tsParseTemplateLiteralType() {
                    const e = this.startNode(),
                      t = this.parseTemplate(!1);
                    if (t.expressions.length > 0)
                      throw this.raise(
                        t.expressions[0].start,
                        "Template literal types cannot have any substitution"
                      );
                    return (e.literal = t), this.finishNode(e, "TSLiteralType");
                  }
                  tsParseNonArrayType() {
                    switch (this.state.type) {
                      case u.name:
                      case u._void:
                      case u._null: {
                        const e = this.match(u._void)
                          ? "TSVoidKeyword"
                          : this.match(u._null)
                          ? "TSNullKeyword"
                          : (function(e) {
                              switch (e) {
                                case "any":
                                  return "TSAnyKeyword";
                                case "boolean":
                                  return "TSBooleanKeyword";
                                case "bigint":
                                  return "TSBigIntKeyword";
                                case "never":
                                  return "TSNeverKeyword";
                                case "number":
                                  return "TSNumberKeyword";
                                case "object":
                                  return "TSObjectKeyword";
                                case "string":
                                  return "TSStringKeyword";
                                case "symbol":
                                  return "TSSymbolKeyword";
                                case "undefined":
                                  return "TSUndefinedKeyword";
                                case "unknown":
                                  return "TSUnknownKeyword";
                                default:
                                  return;
                              }
                            })(this.state.value);
                        if (void 0 !== e && this.lookahead().type !== u.dot) {
                          const t = this.startNode();
                          return this.next(), this.finishNode(t, e);
                        }
                        return this.tsParseTypeReference();
                      }
                      case u.string:
                      case u.num:
                      case u._true:
                      case u._false:
                        return this.tsParseLiteralTypeNode();
                      case u.plusMin:
                        if ("-" === this.state.value) {
                          const e = this.startNode();
                          if (this.lookahead().type !== u.num)
                            throw this.unexpected();
                          return (
                            (e.literal = this.parseMaybeUnary()),
                            this.finishNode(e, "TSLiteralType")
                          );
                        }
                        break;
                      case u._this: {
                        const e = this.tsParseThisTypeNode();
                        return this.isContextual("is") &&
                          !this.hasPrecedingLineBreak()
                          ? this.tsParseThisTypePredicate(e)
                          : e;
                      }
                      case u._typeof:
                        return this.tsParseTypeQuery();
                      case u._import:
                        return this.tsParseImportType();
                      case u.braceL:
                        return this.tsLookAhead(
                          this.tsIsStartOfMappedType.bind(this)
                        )
                          ? this.tsParseMappedType()
                          : this.tsParseTypeLiteral();
                      case u.bracketL:
                        return this.tsParseTupleType();
                      case u.parenL:
                        return this.tsParseParenthesizedType();
                      case u.backQuote:
                        return this.tsParseTemplateLiteralType();
                    }
                    throw this.unexpected();
                  }
                  tsParseArrayTypeOrHigher() {
                    let e = this.tsParseNonArrayType();
                    for (
                      ;
                      !this.hasPrecedingLineBreak() && this.eat(u.bracketL);

                    )
                      if (this.match(u.bracketR)) {
                        const t = this.startNodeAtNode(e);
                        (t.elementType = e),
                          this.expect(u.bracketR),
                          (e = this.finishNode(t, "TSArrayType"));
                      } else {
                        const t = this.startNodeAtNode(e);
                        (t.objectType = e),
                          (t.indexType = this.tsParseType()),
                          this.expect(u.bracketR),
                          (e = this.finishNode(t, "TSIndexedAccessType"));
                      }
                    return e;
                  }
                  tsParseTypeOperator(e) {
                    const t = this.startNode();
                    return (
                      this.expectContextual(e),
                      (t.operator = e),
                      (t.typeAnnotation = this.tsParseTypeOperatorOrHigher()),
                      "readonly" === e &&
                        this.tsCheckTypeAnnotationForReadOnly(t),
                      this.finishNode(t, "TSTypeOperator")
                    );
                  }
                  tsCheckTypeAnnotationForReadOnly(e) {
                    switch (e.typeAnnotation.type) {
                      case "TSTupleType":
                      case "TSArrayType":
                        return;
                      default:
                        this.raise(
                          e.start,
                          "'readonly' type modifier is only permitted on array and tuple literal types."
                        );
                    }
                  }
                  tsParseInferType() {
                    const e = this.startNode();
                    this.expectContextual("infer");
                    const t = this.startNode();
                    return (
                      (t.name = this.parseIdentifierName(t.start)),
                      (e.typeParameter = this.finishNode(t, "TSTypeParameter")),
                      this.finishNode(e, "TSInferType")
                    );
                  }
                  tsParseTypeOperatorOrHigher() {
                    const e = ["keyof", "unique", "readonly"].find(e =>
                      this.isContextual(e)
                    );
                    return e
                      ? this.tsParseTypeOperator(e)
                      : this.isContextual("infer")
                      ? this.tsParseInferType()
                      : this.tsParseArrayTypeOrHigher();
                  }
                  tsParseUnionOrIntersectionType(e, t, r) {
                    this.eat(r);
                    let n = t();
                    if (this.match(r)) {
                      const i = [n];
                      for (; this.eat(r); ) i.push(t());
                      const s = this.startNodeAtNode(n);
                      (s.types = i), (n = this.finishNode(s, e));
                    }
                    return n;
                  }
                  tsParseIntersectionTypeOrHigher() {
                    return this.tsParseUnionOrIntersectionType(
                      "TSIntersectionType",
                      this.tsParseTypeOperatorOrHigher.bind(this),
                      u.bitwiseAND
                    );
                  }
                  tsParseUnionTypeOrHigher() {
                    return this.tsParseUnionOrIntersectionType(
                      "TSUnionType",
                      this.tsParseIntersectionTypeOrHigher.bind(this),
                      u.bitwiseOR
                    );
                  }
                  tsIsStartOfFunctionType() {
                    return (
                      !!this.isRelational("<") ||
                      (this.match(u.parenL) &&
                        this.tsLookAhead(
                          this.tsIsUnambiguouslyStartOfFunctionType.bind(this)
                        ))
                    );
                  }
                  tsSkipParameterStart() {
                    if (this.match(u.name) || this.match(u._this))
                      return this.next(), !0;
                    if (this.match(u.braceL)) {
                      let e = 1;
                      for (this.next(); e > 0; )
                        this.match(u.braceL)
                          ? ++e
                          : this.match(u.braceR) && --e,
                          this.next();
                      return !0;
                    }
                    if (this.match(u.bracketL)) {
                      let e = 1;
                      for (this.next(); e > 0; )
                        this.match(u.bracketL)
                          ? ++e
                          : this.match(u.bracketR) && --e,
                          this.next();
                      return !0;
                    }
                    return !1;
                  }
                  tsIsUnambiguouslyStartOfFunctionType() {
                    if (
                      (this.next(),
                      this.match(u.parenR) || this.match(u.ellipsis))
                    )
                      return !0;
                    if (this.tsSkipParameterStart()) {
                      if (
                        this.match(u.colon) ||
                        this.match(u.comma) ||
                        this.match(u.question) ||
                        this.match(u.eq)
                      )
                        return !0;
                      if (
                        this.match(u.parenR) &&
                        (this.next(), this.match(u.arrow))
                      )
                        return !0;
                    }
                    return !1;
                  }
                  tsParseTypeOrTypePredicateAnnotation(e) {
                    return this.tsInType(() => {
                      const t = this.startNode();
                      this.expect(e);
                      const r =
                        this.tsIsIdentifier() &&
                        this.tsTryParse(
                          this.tsParseTypePredicatePrefix.bind(this)
                        );
                      if (!r) return this.tsParseTypeAnnotation(!1, t);
                      const n = this.tsParseTypeAnnotation(!1),
                        i = this.startNodeAtNode(r);
                      return (
                        (i.parameterName = r),
                        (i.typeAnnotation = n),
                        (t.typeAnnotation = this.finishNode(
                          i,
                          "TSTypePredicate"
                        )),
                        this.finishNode(t, "TSTypeAnnotation")
                      );
                    });
                  }
                  tsTryParseTypeOrTypePredicateAnnotation() {
                    return this.match(u.colon)
                      ? this.tsParseTypeOrTypePredicateAnnotation(u.colon)
                      : void 0;
                  }
                  tsTryParseTypeAnnotation() {
                    return this.match(u.colon)
                      ? this.tsParseTypeAnnotation()
                      : void 0;
                  }
                  tsTryParseType() {
                    return this.tsEatThenParseType(u.colon);
                  }
                  tsParseTypePredicatePrefix() {
                    const e = this.parseIdentifier();
                    if (
                      this.isContextual("is") &&
                      !this.hasPrecedingLineBreak()
                    )
                      return this.next(), e;
                  }
                  tsParseTypeAnnotation(e = !0, t = this.startNode()) {
                    return (
                      this.tsInType(() => {
                        e && this.expect(u.colon),
                          (t.typeAnnotation = this.tsParseType());
                      }),
                      this.finishNode(t, "TSTypeAnnotation")
                    );
                  }
                  tsParseType() {
                    Ce(this.state.inType);
                    const e = this.tsParseNonConditionalType();
                    if (this.hasPrecedingLineBreak() || !this.eat(u._extends))
                      return e;
                    const t = this.startNodeAtNode(e);
                    return (
                      (t.checkType = e),
                      (t.extendsType = this.tsParseNonConditionalType()),
                      this.expect(u.question),
                      (t.trueType = this.tsParseType()),
                      this.expect(u.colon),
                      (t.falseType = this.tsParseType()),
                      this.finishNode(t, "TSConditionalType")
                    );
                  }
                  tsParseNonConditionalType() {
                    return this.tsIsStartOfFunctionType()
                      ? this.tsParseFunctionOrConstructorType("TSFunctionType")
                      : this.match(u._new)
                      ? this.tsParseFunctionOrConstructorType(
                          "TSConstructorType"
                        )
                      : this.tsParseUnionTypeOrHigher();
                  }
                  tsParseTypeAssertion() {
                    const e = this.startNode(),
                      t = this.tsTryNextParseConstantContext();
                    return (
                      (e.typeAnnotation = t || this.tsNextThenParseType()),
                      this.expectRelational(">"),
                      (e.expression = this.parseMaybeUnary()),
                      this.finishNode(e, "TSTypeAssertion")
                    );
                  }
                  tsParseHeritageClause(e) {
                    const t = this.state.start,
                      r = this.tsParseDelimitedList(
                        "HeritageClauseElement",
                        this.tsParseExpressionWithTypeArguments.bind(this)
                      );
                    return (
                      r.length || this.raise(t, `'${e}' list cannot be empty.`),
                      r
                    );
                  }
                  tsParseExpressionWithTypeArguments() {
                    const e = this.startNode();
                    return (
                      (e.expression = this.tsParseEntityName(!1)),
                      this.isRelational("<") &&
                        (e.typeParameters = this.tsParseTypeArguments()),
                      this.finishNode(e, "TSExpressionWithTypeArguments")
                    );
                  }
                  tsParseInterfaceDeclaration(e) {
                    (e.id = this.parseIdentifier()),
                      this.checkLVal(
                        e.id,
                        N,
                        void 0,
                        "typescript interface declaration"
                      ),
                      (e.typeParameters = this.tsTryParseTypeParameters()),
                      this.eat(u._extends) &&
                        (e.extends = this.tsParseHeritageClause("extends"));
                    const t = this.startNode();
                    return (
                      (t.body = this.tsInType(
                        this.tsParseObjectTypeMembers.bind(this)
                      )),
                      (e.body = this.finishNode(t, "TSInterfaceBody")),
                      this.finishNode(e, "TSInterfaceDeclaration")
                    );
                  }
                  tsParseTypeAliasDeclaration(e) {
                    return (
                      (e.id = this.parseIdentifier()),
                      this.checkLVal(e.id, L, void 0, "typescript type alias"),
                      (e.typeParameters = this.tsTryParseTypeParameters()),
                      (e.typeAnnotation = this.tsExpectThenParseType(u.eq)),
                      this.semicolon(),
                      this.finishNode(e, "TSTypeAliasDeclaration")
                    );
                  }
                  tsInNoContext(e) {
                    const t = this.state.context;
                    this.state.context = [t[0]];
                    try {
                      return e();
                    } finally {
                      this.state.context = t;
                    }
                  }
                  tsInType(e) {
                    const t = this.state.inType;
                    this.state.inType = !0;
                    try {
                      return e();
                    } finally {
                      this.state.inType = t;
                    }
                  }
                  tsEatThenParseType(e) {
                    return this.match(e) ? this.tsNextThenParseType() : void 0;
                  }
                  tsExpectThenParseType(e) {
                    return this.tsDoThenParseType(() => this.expect(e));
                  }
                  tsNextThenParseType() {
                    return this.tsDoThenParseType(() => this.next());
                  }
                  tsDoThenParseType(e) {
                    return this.tsInType(() => (e(), this.tsParseType()));
                  }
                  tsParseEnumMember() {
                    const e = this.startNode();
                    return (
                      (e.id = this.match(u.string)
                        ? this.parseExprAtom()
                        : this.parseIdentifier(!0)),
                      this.eat(u.eq) &&
                        (e.initializer = this.parseMaybeAssign()),
                      this.finishNode(e, "TSEnumMember")
                    );
                  }
                  tsParseEnumDeclaration(e, t) {
                    return (
                      t && (e.const = !0),
                      (e.id = this.parseIdentifier()),
                      this.checkLVal(
                        e.id,
                        t ? q : B,
                        void 0,
                        "typescript enum declaration"
                      ),
                      this.expect(u.braceL),
                      (e.members = this.tsParseDelimitedList(
                        "EnumMembers",
                        this.tsParseEnumMember.bind(this)
                      )),
                      this.expect(u.braceR),
                      this.finishNode(e, "TSEnumDeclaration")
                    );
                  }
                  tsParseModuleBlock() {
                    const e = this.startNode();
                    return (
                      this.scope.enter(l),
                      this.expect(u.braceL),
                      this.parseBlockOrModuleBlockBody(
                        (e.body = []),
                        void 0,
                        !0,
                        u.braceR
                      ),
                      this.scope.exit(),
                      this.finishNode(e, "TSModuleBlock")
                    );
                  }
                  tsParseModuleOrNamespaceDeclaration(e, t = !1) {
                    if (
                      ((e.id = this.parseIdentifier()),
                      t ||
                        this.checkLVal(
                          e.id,
                          V,
                          null,
                          "module or namespace declaration"
                        ),
                      this.eat(u.dot))
                    ) {
                      const t = this.startNode();
                      this.tsParseModuleOrNamespaceDeclaration(t, !0),
                        (e.body = t);
                    } else e.body = this.tsParseModuleBlock();
                    return this.finishNode(e, "TSModuleDeclaration");
                  }
                  tsParseAmbientExternalModuleDeclaration(e) {
                    return (
                      this.isContextual("global")
                        ? ((e.global = !0), (e.id = this.parseIdentifier()))
                        : this.match(u.string)
                        ? (e.id = this.parseExprAtom())
                        : this.unexpected(),
                      this.match(u.braceL)
                        ? (e.body = this.tsParseModuleBlock())
                        : this.semicolon(),
                      this.finishNode(e, "TSModuleDeclaration")
                    );
                  }
                  tsParseImportEqualsDeclaration(e, t) {
                    return (
                      (e.isExport = t || !1),
                      (e.id = this.parseIdentifier()),
                      this.expect(u.eq),
                      (e.moduleReference = this.tsParseModuleReference()),
                      this.semicolon(),
                      this.finishNode(e, "TSImportEqualsDeclaration")
                    );
                  }
                  tsIsExternalModuleReference() {
                    return (
                      this.isContextual("require") &&
                      this.lookahead().type === u.parenL
                    );
                  }
                  tsParseModuleReference() {
                    return this.tsIsExternalModuleReference()
                      ? this.tsParseExternalModuleReference()
                      : this.tsParseEntityName(!1);
                  }
                  tsParseExternalModuleReference() {
                    const e = this.startNode();
                    if (
                      (this.expectContextual("require"),
                      this.expect(u.parenL),
                      !this.match(u.string))
                    )
                      throw this.unexpected();
                    return (
                      (e.expression = this.parseExprAtom()),
                      this.expect(u.parenR),
                      this.finishNode(e, "TSExternalModuleReference")
                    );
                  }
                  tsLookAhead(e) {
                    const t = this.state.clone(),
                      r = e();
                    return (this.state = t), r;
                  }
                  tsTryParseAndCatch(e) {
                    const t = this.state.clone();
                    try {
                      return e();
                    } catch (e) {
                      if (e instanceof SyntaxError)
                        return void (this.state = t);
                      throw e;
                    }
                  }
                  tsTryParse(e) {
                    const t = this.state.clone(),
                      r = e();
                    return void 0 !== r && !1 !== r ? r : void (this.state = t);
                  }
                  tsTryParseDeclare(e) {
                    if (this.isLineTerminator()) return;
                    let t,
                      r = this.state.type;
                    switch (
                      (this.isContextual("let") && ((r = u._var), (t = "let")),
                      r)
                    ) {
                      case u._function:
                        return this.parseFunctionStatement(e, !1, !0);
                      case u._class:
                        return this.parseClass(e, !0, !1);
                      case u._const:
                        if (
                          this.match(u._const) &&
                          this.isLookaheadContextual("enum")
                        )
                          return (
                            this.expect(u._const),
                            this.expectContextual("enum"),
                            this.tsParseEnumDeclaration(e, !0)
                          );
                      case u._var:
                        return (
                          (t = t || this.state.value),
                          this.parseVarStatement(e, t)
                        );
                      case u.name: {
                        const t = this.state.value;
                        return "global" === t
                          ? this.tsParseAmbientExternalModuleDeclaration(e)
                          : this.tsParseDeclaration(e, t, !0);
                      }
                    }
                  }
                  tsTryParseExportDeclaration() {
                    return this.tsParseDeclaration(
                      this.startNode(),
                      this.state.value,
                      !0
                    );
                  }
                  tsParseExpressionStatement(e, t) {
                    switch (t.name) {
                      case "declare": {
                        const t = this.tsTryParseDeclare(e);
                        if (t) return (t.declare = !0), t;
                        break;
                      }
                      case "global":
                        if (this.match(u.braceL)) {
                          const r = e;
                          return (
                            (r.global = !0),
                            (r.id = t),
                            (r.body = this.tsParseModuleBlock()),
                            this.finishNode(r, "TSModuleDeclaration")
                          );
                        }
                        break;
                      default:
                        return this.tsParseDeclaration(e, t.name, !1);
                    }
                  }
                  tsParseDeclaration(e, t, r) {
                    switch (t) {
                      case "abstract":
                        if (this.tsCheckLineTerminatorAndMatch(u._class, r)) {
                          const t = e;
                          return (
                            (t.abstract = !0),
                            r &&
                              (this.next(),
                              this.match(u._class) ||
                                this.unexpected(null, u._class)),
                            this.parseClass(t, !0, !1)
                          );
                        }
                        break;
                      case "enum":
                        if (r || this.match(u.name))
                          return (
                            r && this.next(), this.tsParseEnumDeclaration(e, !1)
                          );
                        break;
                      case "interface":
                        if (this.tsCheckLineTerminatorAndMatch(u.name, r))
                          return (
                            r && this.next(),
                            this.tsParseInterfaceDeclaration(e)
                          );
                        break;
                      case "module":
                        if ((r && this.next(), this.match(u.string)))
                          return this.tsParseAmbientExternalModuleDeclaration(
                            e
                          );
                        if (this.tsCheckLineTerminatorAndMatch(u.name, r))
                          return this.tsParseModuleOrNamespaceDeclaration(e);
                        break;
                      case "namespace":
                        if (this.tsCheckLineTerminatorAndMatch(u.name, r))
                          return (
                            r && this.next(),
                            this.tsParseModuleOrNamespaceDeclaration(e)
                          );
                        break;
                      case "type":
                        if (this.tsCheckLineTerminatorAndMatch(u.name, r))
                          return (
                            r && this.next(),
                            this.tsParseTypeAliasDeclaration(e)
                          );
                    }
                  }
                  tsCheckLineTerminatorAndMatch(e, t) {
                    return (t || this.match(e)) && !this.isLineTerminator();
                  }
                  tsTryParseGenericAsyncArrowFunction(e, t) {
                    if (!this.isRelational("<")) return;
                    const r = this.tsTryParseAndCatch(() => {
                      const r = this.startNodeAt(e, t);
                      return (
                        (r.typeParameters = this.tsParseTypeParameters()),
                        super.parseFunctionParams(r),
                        (r.returnType = this.tsTryParseTypeOrTypePredicateAnnotation()),
                        this.expect(u.arrow),
                        r
                      );
                    });
                    return r ? this.parseArrowExpression(r, null, !0) : void 0;
                  }
                  tsParseTypeArguments() {
                    const e = this.startNode();
                    return (
                      (e.params = this.tsInType(() =>
                        this.tsInNoContext(
                          () => (
                            this.expectRelational("<"),
                            this.tsParseDelimitedList(
                              "TypeParametersOrArguments",
                              this.tsParseType.bind(this)
                            )
                          )
                        )
                      )),
                      (this.state.exprAllowed = !1),
                      this.expectRelational(">"),
                      this.finishNode(e, "TSTypeParameterInstantiation")
                    );
                  }
                  tsIsDeclarationStart() {
                    if (this.match(u.name))
                      switch (this.state.value) {
                        case "abstract":
                        case "declare":
                        case "enum":
                        case "interface":
                        case "module":
                        case "namespace":
                        case "type":
                          return !0;
                      }
                    return !1;
                  }
                  isExportDefaultSpecifier() {
                    return (
                      !this.tsIsDeclarationStart() &&
                      super.isExportDefaultSpecifier()
                    );
                  }
                  parseAssignableListItem(e, t) {
                    const r = this.state.start,
                      n = this.state.startLoc;
                    let i,
                      s = !1;
                    e &&
                      ((i = this.parseAccessModifier()),
                      (s = !!this.tsParseModifier(["readonly"])));
                    const a = this.parseMaybeDefault();
                    this.parseAssignableListItemTypes(a);
                    const o = this.parseMaybeDefault(a.start, a.loc.start, a);
                    if (i || s) {
                      const e = this.startNodeAt(r, n);
                      if (
                        (t.length && (e.decorators = t),
                        i && (e.accessibility = i),
                        s && (e.readonly = s),
                        "Identifier" !== o.type &&
                          "AssignmentPattern" !== o.type)
                      )
                        throw this.raise(
                          e.start,
                          "A parameter property may not be declared using a binding pattern."
                        );
                      return (
                        (e.parameter = o),
                        this.finishNode(e, "TSParameterProperty")
                      );
                    }
                    return t.length && (a.decorators = t), o;
                  }
                  parseFunctionBodyAndFinish(e, t, r = !1) {
                    this.match(u.colon) &&
                      (e.returnType = this.tsParseTypeOrTypePredicateAnnotation(
                        u.colon
                      ));
                    const n =
                      "FunctionDeclaration" === t
                        ? "TSDeclareFunction"
                        : "ClassMethod" === t
                        ? "TSDeclareMethod"
                        : void 0;
                    n && !this.match(u.braceL) && this.isLineTerminator()
                      ? this.finishNode(e, n)
                      : super.parseFunctionBodyAndFinish(e, t, r);
                  }
                  checkFunctionStatementId(e) {
                    !e.body && e.id
                      ? this.checkLVal(e.id, M, null, "function name")
                      : super.checkFunctionStatementId(...arguments);
                  }
                  parseSubscript(e, t, r, n, i, s) {
                    if (!this.hasPrecedingLineBreak() && this.match(u.bang)) {
                      (this.state.exprAllowed = !1), this.next();
                      const n = this.startNodeAt(t, r);
                      return (
                        (n.expression = e),
                        this.finishNode(n, "TSNonNullExpression")
                      );
                    }
                    if (this.isRelational("<")) {
                      const s = this.tsTryParseAndCatch(() => {
                        if (!n && this.atPossibleAsync(e)) {
                          const e = this.tsTryParseGenericAsyncArrowFunction(
                            t,
                            r
                          );
                          if (e) return e;
                        }
                        const s = this.startNodeAt(t, r);
                        s.callee = e;
                        const a = this.tsParseTypeArguments();
                        if (a) {
                          if (!n && this.eat(u.parenL))
                            return (
                              (s.arguments = this.parseCallExpressionArguments(
                                u.parenR,
                                !1
                              )),
                              (s.typeParameters = a),
                              this.finishCallExpression(s)
                            );
                          if (this.match(u.backQuote))
                            return this.parseTaggedTemplateExpression(
                              t,
                              r,
                              e,
                              i,
                              a
                            );
                        }
                        this.unexpected();
                      });
                      if (s) return s;
                    }
                    return super.parseSubscript(e, t, r, n, i, s);
                  }
                  parseNewArguments(e) {
                    if (this.isRelational("<")) {
                      const t = this.tsTryParseAndCatch(() => {
                        const e = this.tsParseTypeArguments();
                        return this.match(u.parenL) || this.unexpected(), e;
                      });
                      t && (e.typeParameters = t);
                    }
                    super.parseNewArguments(e);
                  }
                  parseExprOp(e, t, r, n, i) {
                    if (
                      Pe(u._in.binop) > n &&
                      !this.hasPrecedingLineBreak() &&
                      this.isContextual("as")
                    ) {
                      const s = this.startNodeAt(t, r);
                      s.expression = e;
                      const a = this.tsTryNextParseConstantContext();
                      return (
                        (s.typeAnnotation = a || this.tsNextThenParseType()),
                        this.finishNode(s, "TSAsExpression"),
                        this.parseExprOp(s, t, r, n, i)
                      );
                    }
                    return super.parseExprOp(e, t, r, n, i);
                  }
                  checkReservedWord(e, t, r, n) {}
                  checkDuplicateExports() {}
                  parseImport(e) {
                    return this.match(u.name) && this.lookahead().type === u.eq
                      ? this.tsParseImportEqualsDeclaration(e)
                      : super.parseImport(e);
                  }
                  parseExport(e) {
                    if (this.match(u._import))
                      return (
                        this.expect(u._import),
                        this.tsParseImportEqualsDeclaration(e, !0)
                      );
                    if (this.eat(u.eq)) {
                      const t = e;
                      return (
                        (t.expression = this.parseExpression()),
                        this.semicolon(),
                        this.finishNode(t, "TSExportAssignment")
                      );
                    }
                    if (this.eatContextual("as")) {
                      const t = e;
                      return (
                        this.expectContextual("namespace"),
                        (t.id = this.parseIdentifier()),
                        this.semicolon(),
                        this.finishNode(t, "TSNamespaceExportDeclaration")
                      );
                    }
                    return super.parseExport(e);
                  }
                  isAbstractClass() {
                    return (
                      this.isContextual("abstract") &&
                      this.lookahead().type === u._class
                    );
                  }
                  parseExportDefaultExpression() {
                    if (this.isAbstractClass()) {
                      const e = this.startNode();
                      return (
                        this.next(),
                        this.parseClass(e, !0, !0),
                        (e.abstract = !0),
                        e
                      );
                    }
                    if ("interface" === this.state.value) {
                      const e = this.tsParseDeclaration(
                        this.startNode(),
                        this.state.value,
                        !0
                      );
                      if (e) return e;
                    }
                    return super.parseExportDefaultExpression();
                  }
                  parseStatementContent(e, t) {
                    if (this.state.type === u._const) {
                      const e = this.lookahead();
                      if (e.type === u.name && "enum" === e.value) {
                        const e = this.startNode();
                        return (
                          this.expect(u._const),
                          this.expectContextual("enum"),
                          this.tsParseEnumDeclaration(e, !0)
                        );
                      }
                    }
                    return super.parseStatementContent(e, t);
                  }
                  parseAccessModifier() {
                    return this.tsParseModifier([
                      "public",
                      "protected",
                      "private"
                    ]);
                  }
                  parseClassMember(e, t, r, n) {
                    const i = this.parseAccessModifier();
                    i && (t.accessibility = i),
                      super.parseClassMember(e, t, r, n);
                  }
                  parseClassMemberWithIsStatic(e, t, r, n, i) {
                    const s = t,
                      a = t,
                      o = t;
                    let u = !1,
                      l = !1;
                    switch (this.tsParseModifier(["abstract", "readonly"])) {
                      case "readonly":
                        (l = !0), (u = !!this.tsParseModifier(["abstract"]));
                        break;
                      case "abstract":
                        (u = !0), (l = !!this.tsParseModifier(["readonly"]));
                    }
                    if (
                      (u && (s.abstract = !0),
                      l && (o.readonly = !0),
                      !u && !n && !s.accessibility)
                    ) {
                      const r = this.tsTryParseIndexSignature(t);
                      if (r) return void e.body.push(r);
                    }
                    if (l)
                      return (
                        (s.static = n),
                        this.parseClassPropertyName(a),
                        this.parsePostMemberNameModifiers(s),
                        void this.pushClassProperty(e, a)
                      );
                    super.parseClassMemberWithIsStatic(e, t, r, n, i);
                  }
                  parsePostMemberNameModifiers(e) {
                    this.eat(u.question) && (e.optional = !0);
                  }
                  parseExpressionStatement(e, t) {
                    return (
                      ("Identifier" === t.type
                        ? this.tsParseExpressionStatement(e, t)
                        : void 0) || super.parseExpressionStatement(e, t)
                    );
                  }
                  shouldParseExportDeclaration() {
                    return (
                      !!this.tsIsDeclarationStart() ||
                      super.shouldParseExportDeclaration()
                    );
                  }
                  parseConditional(e, t, r, n, i) {
                    if (!i || !this.match(u.question))
                      return super.parseConditional(e, t, r, n, i);
                    const s = this.state.clone();
                    try {
                      return super.parseConditional(e, t, r, n);
                    } catch (t) {
                      if (!(t instanceof SyntaxError)) throw t;
                      return (
                        (this.state = s),
                        (i.start = t.pos || this.state.start),
                        e
                      );
                    }
                  }
                  parseParenItem(e, t, r) {
                    if (
                      ((e = super.parseParenItem(e, t, r)),
                      this.eat(u.question) &&
                        ((e.optional = !0), this.resetEndLocation(e)),
                      this.match(u.colon))
                    ) {
                      const n = this.startNodeAt(t, r);
                      return (
                        (n.expression = e),
                        (n.typeAnnotation = this.tsParseTypeAnnotation()),
                        this.finishNode(n, "TSTypeCastExpression")
                      );
                    }
                    return e;
                  }
                  parseExportDeclaration(e) {
                    const t = this.state.start,
                      r = this.state.startLoc,
                      n = this.eatContextual("declare");
                    let i;
                    return (
                      this.match(u.name) &&
                        (i = this.tsTryParseExportDeclaration()),
                      i || (i = super.parseExportDeclaration(e)),
                      i &&
                        n &&
                        (this.resetStartLocation(i, t, r), (i.declare = !0)),
                      i
                    );
                  }
                  parseClassId(e, t, r) {
                    if ((!t || r) && this.isContextual("implements")) return;
                    super.parseClassId(...arguments);
                    const n = this.tsTryParseTypeParameters();
                    n && (e.typeParameters = n);
                  }
                  parseClassProperty(e) {
                    !e.optional && this.eat(u.bang) && (e.definite = !0);
                    const t = this.tsTryParseTypeAnnotation();
                    return (
                      t && (e.typeAnnotation = t), super.parseClassProperty(e)
                    );
                  }
                  pushClassMethod(e, t, r, n, i, s) {
                    const a = this.tsTryParseTypeParameters();
                    a && (t.typeParameters = a),
                      super.pushClassMethod(e, t, r, n, i, s);
                  }
                  pushClassPrivateMethod(e, t, r, n) {
                    const i = this.tsTryParseTypeParameters();
                    i && (t.typeParameters = i),
                      super.pushClassPrivateMethod(e, t, r, n);
                  }
                  parseClassSuper(e) {
                    super.parseClassSuper(e),
                      e.superClass &&
                        this.isRelational("<") &&
                        (e.superTypeParameters = this.tsParseTypeArguments()),
                      this.eatContextual("implements") &&
                        (e.implements = this.tsParseHeritageClause(
                          "implements"
                        ));
                  }
                  parseObjPropValue(e, ...t) {
                    const r = this.tsTryParseTypeParameters();
                    r && (e.typeParameters = r),
                      super.parseObjPropValue(e, ...t);
                  }
                  parseFunctionParams(e, t) {
                    const r = this.tsTryParseTypeParameters();
                    r && (e.typeParameters = r),
                      super.parseFunctionParams(e, t);
                  }
                  parseVarId(e, t) {
                    super.parseVarId(e, t),
                      "Identifier" === e.id.type &&
                        this.eat(u.bang) &&
                        (e.definite = !0);
                    const r = this.tsTryParseTypeAnnotation();
                    r &&
                      ((e.id.typeAnnotation = r), this.resetEndLocation(e.id));
                  }
                  parseAsyncArrowFromCallExpression(e, t) {
                    return (
                      this.match(u.colon) &&
                        (e.returnType = this.tsParseTypeAnnotation()),
                      super.parseAsyncArrowFromCallExpression(e, t)
                    );
                  }
                  parseMaybeAssign(...e) {
                    let t, r, n;
                    if (this.match(u.jsxTagStart)) {
                      Ce(this.curContext() === H.j_oTag),
                        Ce(
                          this.state.context[this.state.context.length - 2] ===
                            H.j_expr
                        );
                      const r = this.state.clone();
                      try {
                        return super.parseMaybeAssign(...e);
                      } catch (e) {
                        if (!(e instanceof SyntaxError)) throw e;
                        (this.state = r),
                          Ce(this.curContext() === H.j_oTag),
                          this.state.context.pop(),
                          Ce(this.curContext() === H.j_expr),
                          this.state.context.pop(),
                          (t = e);
                      }
                    }
                    if (void 0 === t && !this.isRelational("<"))
                      return super.parseMaybeAssign(...e);
                    const i = this.state.clone();
                    try {
                      (n = this.tsParseTypeParameters()),
                        ("ArrowFunctionExpression" !==
                          (r = super.parseMaybeAssign(...e)).type ||
                          (r.extra && r.extra.parenthesized)) &&
                          this.unexpected();
                    } catch (r) {
                      if (!(r instanceof SyntaxError)) throw r;
                      if (t) throw t;
                      return (
                        Ce(!this.hasPlugin("jsx")),
                        (this.state = i),
                        super.parseMaybeAssign(...e)
                      );
                    }
                    return (
                      n &&
                        0 !== n.params.length &&
                        this.resetStartLocationFromNode(r, n),
                      (r.typeParameters = n),
                      r
                    );
                  }
                  parseMaybeUnary(e) {
                    return !this.hasPlugin("jsx") && this.isRelational("<")
                      ? this.tsParseTypeAssertion()
                      : super.parseMaybeUnary(e);
                  }
                  parseArrow(e) {
                    if (this.match(u.colon)) {
                      const t = this.state.clone();
                      try {
                        const r = this.tsParseTypeOrTypePredicateAnnotation(
                          u.colon
                        );
                        if (this.canInsertSemicolon() || !this.match(u.arrow))
                          return void (this.state = t);
                        e.returnType = r;
                      } catch (e) {
                        if (!(e instanceof SyntaxError)) throw e;
                        this.state = t;
                      }
                    }
                    return super.parseArrow(e);
                  }
                  parseAssignableListItemTypes(e) {
                    if (this.eat(u.question)) {
                      if ("Identifier" !== e.type)
                        throw this.raise(
                          e.start,
                          "A binding pattern parameter cannot be optional in an implementation signature."
                        );
                      e.optional = !0;
                    }
                    const t = this.tsTryParseTypeAnnotation();
                    return (
                      t && (e.typeAnnotation = t), this.resetEndLocation(e), e
                    );
                  }
                  toAssignable(e, t, r) {
                    switch (e.type) {
                      case "TSTypeCastExpression":
                        return super.toAssignable(
                          this.typeCastToParameter(e),
                          t,
                          r
                        );
                      case "TSParameterProperty":
                        return super.toAssignable(e, t, r);
                      case "TSAsExpression":
                      case "TSNonNullExpression":
                      case "TSTypeAssertion":
                        return (
                          (e.expression = this.toAssignable(
                            e.expression,
                            t,
                            r
                          )),
                          e
                        );
                      default:
                        return super.toAssignable(e, t, r);
                    }
                  }
                  checkLVal(e, t = j, r, n) {
                    switch (e.type) {
                      case "TSTypeCastExpression":
                        return;
                      case "TSParameterProperty":
                        return void this.checkLVal(
                          e.parameter,
                          t,
                          r,
                          "parameter property"
                        );
                      case "TSAsExpression":
                      case "TSNonNullExpression":
                      case "TSTypeAssertion":
                        return void this.checkLVal(e.expression, t, r, n);
                      default:
                        return void super.checkLVal(e, t, r, n);
                    }
                  }
                  parseBindingAtom() {
                    switch (this.state.type) {
                      case u._this:
                        return this.parseIdentifier(!0);
                      default:
                        return super.parseBindingAtom();
                    }
                  }
                  parseMaybeDecoratorArguments(e) {
                    if (this.isRelational("<")) {
                      const t = this.tsParseTypeArguments();
                      if (this.match(u.parenL)) {
                        const r = super.parseMaybeDecoratorArguments(e);
                        return (r.typeParameters = t), r;
                      }
                      this.unexpected(this.state.start, u.parenL);
                    }
                    return super.parseMaybeDecoratorArguments(e);
                  }
                  isClassMethod() {
                    return this.isRelational("<") || super.isClassMethod();
                  }
                  isClassProperty() {
                    return (
                      this.match(u.bang) ||
                      this.match(u.colon) ||
                      super.isClassProperty()
                    );
                  }
                  parseMaybeDefault(...e) {
                    const t = super.parseMaybeDefault(...e);
                    return (
                      "AssignmentPattern" === t.type &&
                        t.typeAnnotation &&
                        t.right.start < t.typeAnnotation.start &&
                        this.raise(
                          t.typeAnnotation.start,
                          "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`"
                        ),
                      t
                    );
                  }
                  getTokenFromCode(e) {
                    return !this.state.inType || (62 !== e && 60 !== e)
                      ? super.getTokenFromCode(e)
                      : this.finishOp(u.relational, 1);
                  }
                  toAssignableList(e, t, r) {
                    for (let t = 0; t < e.length; t++) {
                      const r = e[t];
                      if (r)
                        switch (r.type) {
                          case "TSTypeCastExpression":
                            e[t] = this.typeCastToParameter(r);
                            break;
                          case "TSAsExpression":
                          case "TSTypeAssertion":
                            this.raise(
                              r.start,
                              "Unexpected type cast in parameter position."
                            );
                        }
                    }
                    return super.toAssignableList(e, t, r);
                  }
                  typeCastToParameter(e) {
                    return (
                      (e.expression.typeAnnotation = e.typeAnnotation),
                      this.resetEndLocation(
                        e.expression,
                        e.typeAnnotation.end,
                        e.typeAnnotation.loc.end
                      ),
                      e.expression
                    );
                  }
                  toReferencedList(e, t) {
                    for (let t = 0; t < e.length; t++) {
                      const r = e[t];
                      r &&
                        r._exprListItem &&
                        "TsTypeCastExpression" === r.type &&
                        this.raise(
                          r.start,
                          "Did not expect a type annotation here."
                        );
                    }
                    return e;
                  }
                  shouldParseArrow() {
                    return this.match(u.colon) || super.shouldParseArrow();
                  }
                  shouldParseAsyncArrow() {
                    return this.match(u.colon) || super.shouldParseAsyncArrow();
                  }
                  canHaveLeadingDecorator() {
                    return (
                      super.canHaveLeadingDecorator() || this.isAbstractClass()
                    );
                  }
                  jsxParseOpeningElementAfterName(e) {
                    if (this.isRelational("<")) {
                      const t = this.tsTryParseAndCatch(() =>
                        this.tsParseTypeArguments()
                      );
                      t && (e.typeParameters = t);
                    }
                    return super.jsxParseOpeningElementAfterName(e);
                  }
                  getGetterSetterExpectedParamCount(e) {
                    const t = super.getGetterSetterExpectedParamCount(e),
                      r = e.params[0];
                    return r && "Identifier" === r.type && "this" === r.name
                      ? t + 1
                      : t;
                  }
                },
              placeholders: e =>
                class extends e {
                  parsePlaceholder(e) {
                    if (this.match(u.placeholder)) {
                      const t = this.startNode();
                      return (
                        this.next(),
                        this.assertNoSpace("Unexpected space in placeholder."),
                        (t.name = super.parseIdentifier(!0)),
                        this.assertNoSpace("Unexpected space in placeholder."),
                        this.expect(u.placeholder),
                        this.finishPlaceholder(t, e)
                      );
                    }
                  }
                  finishPlaceholder(e, t) {
                    const r = !(!e.expectedNode || "Placeholder" !== e.type);
                    return (
                      (e.expectedNode = t),
                      r ? e : this.finishNode(e, "Placeholder")
                    );
                  }
                  getTokenFromCode(e) {
                    return 37 === e &&
                      37 === this.input.charCodeAt(this.state.pos + 1)
                      ? this.finishOp(u.placeholder, 2)
                      : super.getTokenFromCode(...arguments);
                  }
                  parseExprAtom() {
                    return (
                      this.parsePlaceholder("Expression") ||
                      super.parseExprAtom(...arguments)
                    );
                  }
                  parseIdentifier() {
                    return (
                      this.parsePlaceholder("Identifier") ||
                      super.parseIdentifier(...arguments)
                    );
                  }
                  checkReservedWord(e) {
                    void 0 !== e && super.checkReservedWord(...arguments);
                  }
                  parseBindingAtom() {
                    return (
                      this.parsePlaceholder("Pattern") ||
                      super.parseBindingAtom(...arguments)
                    );
                  }
                  checkLVal(e) {
                    "Placeholder" !== e.type && super.checkLVal(...arguments);
                  }
                  toAssignable(e) {
                    return e &&
                      "Placeholder" === e.type &&
                      "Expression" === e.expectedNode
                      ? ((e.expectedNode = "Pattern"), e)
                      : super.toAssignable(...arguments);
                  }
                  verifyBreakContinue(e) {
                    (e.label && "Placeholder" === e.label.type) ||
                      super.verifyBreakContinue(...arguments);
                  }
                  parseExpressionStatement(e, t) {
                    if (
                      "Placeholder" !== t.type ||
                      (t.extra && t.extra.parenthesized)
                    )
                      return super.parseExpressionStatement(...arguments);
                    if (this.match(u.colon)) {
                      const r = e;
                      return (
                        (r.label = this.finishPlaceholder(t, "Identifier")),
                        this.next(),
                        (r.body = this.parseStatement("label")),
                        this.finishNode(r, "LabeledStatement")
                      );
                    }
                    return (
                      this.semicolon(),
                      (e.name = t.name),
                      this.finishPlaceholder(e, "Statement")
                    );
                  }
                  parseBlock() {
                    return (
                      this.parsePlaceholder("BlockStatement") ||
                      super.parseBlock(...arguments)
                    );
                  }
                  parseFunctionId() {
                    return (
                      this.parsePlaceholder("Identifier") ||
                      super.parseFunctionId(...arguments)
                    );
                  }
                  parseClass(e, t, r) {
                    const n = t ? "ClassDeclaration" : "ClassExpression";
                    this.next(), this.takeDecorators(e);
                    const i = this.parsePlaceholder("Identifier");
                    if (i)
                      if (
                        this.match(u._extends) ||
                        this.match(u.placeholder) ||
                        this.match(u.braceL)
                      )
                        e.id = i;
                      else {
                        if (r || !t)
                          return (
                            (e.id = null),
                            (e.body = this.finishPlaceholder(i, "ClassBody")),
                            this.finishNode(e, n)
                          );
                        this.unexpected(null, "A class name is required");
                      }
                    else this.parseClassId(e, t, r);
                    return (
                      this.parseClassSuper(e),
                      (e.body =
                        this.parsePlaceholder("ClassBody") ||
                        this.parseClassBody(!!e.superClass)),
                      this.finishNode(e, n)
                    );
                  }
                  parseExport(e) {
                    const t = this.parsePlaceholder("Identifier");
                    if (!t) return super.parseExport(...arguments);
                    if (!this.isContextual("from") && !this.match(u.comma))
                      return (
                        (e.specifiers = []),
                        (e.source = null),
                        (e.declaration = this.finishPlaceholder(
                          t,
                          "Declaration"
                        )),
                        this.finishNode(e, "ExportNamedDeclaration")
                      );
                    this.expectPlugin("exportDefaultFrom");
                    const r = this.startNode();
                    return (
                      (r.exported = t),
                      (e.specifiers = [
                        this.finishNode(r, "ExportDefaultSpecifier")
                      ]),
                      super.parseExport(e)
                    );
                  }
                  maybeParseExportDefaultSpecifier(e) {
                    return (
                      !!(e.specifiers && e.specifiers.length > 0) ||
                      super.maybeParseExportDefaultSpecifier(...arguments)
                    );
                  }
                  checkExport(e) {
                    const { specifiers: t } = e;
                    t &&
                      t.length &&
                      (e.specifiers = t.filter(
                        e => "Placeholder" === e.exported.type
                      )),
                      super.checkExport(e),
                      (e.specifiers = t);
                  }
                  parseImport(e) {
                    const t = this.parsePlaceholder("Identifier");
                    if (!t) return super.parseImport(...arguments);
                    if (
                      ((e.specifiers = []),
                      !this.isContextual("from") && !this.match(u.comma))
                    )
                      return (
                        (e.source = this.finishPlaceholder(t, "StringLiteral")),
                        this.semicolon(),
                        this.finishNode(e, "ImportDeclaration")
                      );
                    const r = this.startNodeAtNode(t);
                    return (
                      (r.local = t),
                      this.finishNode(r, "ImportDefaultSpecifier"),
                      e.specifiers.push(r),
                      this.eat(u.comma) &&
                        (this.maybeParseStarImportSpecifier(e) ||
                          this.parseNamedImportSpecifiers(e)),
                      this.expectContextual("from"),
                      (e.source = this.parseImportSource()),
                      this.semicolon(),
                      this.finishNode(e, "ImportDeclaration")
                    );
                  }
                  parseImportSource() {
                    return (
                      this.parsePlaceholder("StringLiteral") ||
                      super.parseImportSource(...arguments)
                    );
                  }
                }
            },
            ke = Object.keys(Oe),
            Ie = {
              sourceType: "script",
              sourceFilename: void 0,
              startLine: 1,
              allowAwaitOutsideFunction: !1,
              allowReturnOutsideFunction: !1,
              allowImportExportEverywhere: !1,
              allowSuperOutsideMethod: !1,
              allowUndeclaredExports: !1,
              plugins: [],
              strictMode: null,
              ranges: !1,
              tokens: !1,
              createParenthesizedExpressions: !1
            };
          class Ne {
            constructor(e, t) {
              (this.line = e), (this.column = t);
            }
          }
          class Le {
            constructor(e, t) {
              (this.start = e), (this.end = t);
            }
          }
          class Be {
            constructor() {
              this.sawUnambiguousESM = !1;
            }
            hasPlugin(e) {
              return this.plugins.has(e);
            }
            getPluginOption(e, t) {
              if (this.hasPlugin(e)) return this.plugins.get(e)[t];
            }
          }
          function Me(e) {
            return e[e.length - 1];
          }
          class je extends Be {
            addComment(e) {
              this.filename && (e.loc.filename = this.filename),
                this.state.trailingComments.push(e),
                this.state.leadingComments.push(e);
            }
            processComment(e) {
              if ("Program" === e.type && e.body.length > 0) return;
              const t = this.state.commentStack;
              let r, n, i, s, a;
              if (this.state.trailingComments.length > 0)
                this.state.trailingComments[0].start >= e.end
                  ? ((i = this.state.trailingComments),
                    (this.state.trailingComments = []))
                  : (this.state.trailingComments.length = 0);
              else if (t.length > 0) {
                const r = Me(t);
                r.trailingComments &&
                  r.trailingComments[0].start >= e.end &&
                  ((i = r.trailingComments), delete r.trailingComments);
              }
              for (
                t.length > 0 && Me(t).start >= e.start && (r = t.pop());
                t.length > 0 && Me(t).start >= e.start;

              )
                n = t.pop();
              if (
                (!n && r && (n = r), r && this.state.leadingComments.length > 0)
              ) {
                const t = Me(this.state.leadingComments);
                if ("ObjectProperty" === r.type) {
                  if (t.start >= e.start && this.state.commentPreviousNode) {
                    for (a = 0; a < this.state.leadingComments.length; a++)
                      this.state.leadingComments[a].end <
                        this.state.commentPreviousNode.end &&
                        (this.state.leadingComments.splice(a, 1), a--);
                    this.state.leadingComments.length > 0 &&
                      ((r.trailingComments = this.state.leadingComments),
                      (this.state.leadingComments = []));
                  }
                } else if (
                  "CallExpression" === e.type &&
                  e.arguments &&
                  e.arguments.length
                ) {
                  const r = Me(e.arguments);
                  if (
                    r &&
                    t.start >= r.start &&
                    t.end <= e.end &&
                    this.state.commentPreviousNode
                  ) {
                    for (a = 0; a < this.state.leadingComments.length; a++)
                      this.state.leadingComments[a].end <
                        this.state.commentPreviousNode.end &&
                        (this.state.leadingComments.splice(a, 1), a--);
                    this.state.leadingComments.length > 0 &&
                      ((r.trailingComments = this.state.leadingComments),
                      (this.state.leadingComments = []));
                  }
                }
              }
              if (n) {
                if (n.leadingComments)
                  if (
                    n !== e &&
                    n.leadingComments.length > 0 &&
                    Me(n.leadingComments).end <= e.start
                  )
                    (e.leadingComments = n.leadingComments),
                      delete n.leadingComments;
                  else
                    for (s = n.leadingComments.length - 2; s >= 0; --s)
                      if (n.leadingComments[s].end <= e.start) {
                        e.leadingComments = n.leadingComments.splice(0, s + 1);
                        break;
                      }
              } else if (this.state.leadingComments.length > 0)
                if (Me(this.state.leadingComments).end <= e.start) {
                  if (this.state.commentPreviousNode)
                    for (a = 0; a < this.state.leadingComments.length; a++)
                      this.state.leadingComments[a].end <
                        this.state.commentPreviousNode.end &&
                        (this.state.leadingComments.splice(a, 1), a--);
                  this.state.leadingComments.length > 0 &&
                    ((e.leadingComments = this.state.leadingComments),
                    (this.state.leadingComments = []));
                } else {
                  for (
                    s = 0;
                    s < this.state.leadingComments.length &&
                    !(this.state.leadingComments[s].end > e.start);
                    s++
                  );
                  const t = this.state.leadingComments.slice(0, s);
                  t.length && (e.leadingComments = t),
                    0 === (i = this.state.leadingComments.slice(s)).length &&
                      (i = null);
                }
              (this.state.commentPreviousNode = e),
                i &&
                  (i.length && i[0].start >= e.start && Me(i).end <= e.end
                    ? (e.innerComments = i)
                    : (e.trailingComments = i)),
                t.push(e);
            }
          }
          class Re extends je {
            getLocationForPosition(e) {
              let t;
              return (t =
                e === this.state.start
                  ? this.state.startLoc
                  : e === this.state.lastTokStart
                  ? this.state.lastTokStartLoc
                  : e === this.state.end
                  ? this.state.endLoc
                  : e === this.state.lastTokEnd
                  ? this.state.lastTokEndLoc
                  : (function(e, t) {
                      let r,
                        n = 1,
                        i = 0;
                      for (G.lastIndex = 0; (r = G.exec(e)) && r.index < t; )
                        n++, (i = G.lastIndex);
                      return new Ne(n, t - i);
                    })(this.input, e));
            }
            raise(e, t, { missingPluginNames: r, code: n } = {}) {
              const i = this.getLocationForPosition(e);
              t += ` (${i.line}:${i.column})`;
              const s = new SyntaxError(t);
              throw ((s.pos = e),
              (s.loc = i),
              r && (s.missingPlugin = r),
              void 0 !== n && (s.code = n),
              s);
            }
          }
          class qe {
            constructor() {
              (this.potentialArrowAt = -1),
                (this.noArrowAt = []),
                (this.noArrowParamsConversionAt = []),
                (this.commaAfterSpreadAt = -1),
                (this.inParameters = !1),
                (this.maybeInArrowParameters = !1),
                (this.inPipeline = !1),
                (this.inType = !1),
                (this.noAnonFunctionType = !1),
                (this.inPropertyName = !1),
                (this.inClassProperty = !1),
                (this.hasFlowComment = !1),
                (this.isIterator = !1),
                (this.topicContext = {
                  maxNumOfResolvableTopics: 0,
                  maxTopicIndex: null
                }),
                (this.soloAwait = !1),
                (this.inFSharpPipelineDirectBody = !1),
                (this.classLevel = 0),
                (this.labels = []),
                (this.decoratorStack = [[]]),
                (this.yieldPos = 0),
                (this.awaitPos = 0),
                (this.tokens = []),
                (this.comments = []),
                (this.trailingComments = []),
                (this.leadingComments = []),
                (this.commentStack = []),
                (this.commentPreviousNode = null),
                (this.pos = 0),
                (this.lineStart = 0),
                (this.type = u.eof),
                (this.value = null),
                (this.start = 0),
                (this.end = 0),
                (this.lastTokEndLoc = null),
                (this.lastTokStartLoc = null),
                (this.lastTokStart = 0),
                (this.lastTokEnd = 0),
                (this.context = [H.braceStatement]),
                (this.exprAllowed = !0),
                (this.containsEsc = !1),
                (this.containsOctal = !1),
                (this.octalPosition = null),
                (this.exportedIdentifiers = []),
                (this.invalidTemplateEscapePosition = null);
            }
            init(e) {
              (this.strict = !1 !== e.strictMode && "module" === e.sourceType),
                (this.curLine = e.startLine),
                (this.startLoc = this.endLoc = this.curPosition());
            }
            curPosition() {
              return new Ne(this.curLine, this.pos - this.lineStart);
            }
            clone(e) {
              const t = new qe(),
                r = Object.keys(this);
              for (let n = 0, i = r.length; n < i; n++) {
                const i = r[n];
                let s = this[i];
                !e && Array.isArray(s) && (s = s.slice()), (t[i] = s);
              }
              return t;
            }
          }
          var Ve = function(e) {
            return e >= 48 && e <= 57;
          };
          const Ue = new Set(["g", "m", "s", "i", "y", "u"]),
            Ke = {
              decBinOct: [46, 66, 69, 79, 95, 98, 101, 111],
              hex: [46, 88, 95, 120]
            },
            Ge = { bin: [48, 49] };
          (Ge.oct = [...Ge.bin, 50, 51, 52, 53, 54, 55]),
            (Ge.dec = [...Ge.oct, 56, 57]),
            (Ge.hex = [
              ...Ge.dec,
              65,
              66,
              67,
              68,
              69,
              70,
              97,
              98,
              99,
              100,
              101,
              102
            ]);
          class We {
            constructor(e) {
              (this.type = e.type),
                (this.value = e.value),
                (this.start = e.start),
                (this.end = e.end),
                (this.loc = new Le(e.startLoc, e.endLoc));
            }
          }
          class Je extends Re {
            constructor(e, t) {
              super(),
                (this.state = new qe()),
                this.state.init(e),
                (this.input = t),
                (this.length = t.length),
                (this.isLookahead = !1);
            }
            next() {
              this.options.tokens &&
                !this.isLookahead &&
                this.state.tokens.push(new We(this.state)),
                (this.state.lastTokEnd = this.state.end),
                (this.state.lastTokStart = this.state.start),
                (this.state.lastTokEndLoc = this.state.endLoc),
                (this.state.lastTokStartLoc = this.state.startLoc),
                this.nextToken();
            }
            eat(e) {
              return !!this.match(e) && (this.next(), !0);
            }
            match(e) {
              return this.state.type === e;
            }
            lookahead() {
              const e = this.state;
              (this.state = e.clone(!0)),
                (this.isLookahead = !0),
                this.next(),
                (this.isLookahead = !1);
              const t = this.state;
              return (this.state = e), t;
            }
            setStrict(e) {
              if (
                ((this.state.strict = e),
                this.match(u.num) || this.match(u.string))
              ) {
                for (
                  this.state.pos = this.state.start;
                  this.state.pos < this.state.lineStart;

                )
                  (this.state.lineStart =
                    this.input.lastIndexOf("\n", this.state.lineStart - 2) + 1),
                    --this.state.curLine;
                this.nextToken();
              }
            }
            curContext() {
              return this.state.context[this.state.context.length - 1];
            }
            nextToken() {
              const e = this.curContext();
              (e && e.preserveSpace) || this.skipSpace(),
                (this.state.containsOctal = !1),
                (this.state.octalPosition = null),
                (this.state.start = this.state.pos),
                (this.state.startLoc = this.state.curPosition()),
                this.state.pos >= this.length
                  ? this.finishToken(u.eof)
                  : e.override
                  ? e.override(this)
                  : this.getTokenFromCode(
                      this.input.codePointAt(this.state.pos)
                    );
            }
            pushComment(e, t, r, n, i, s) {
              const a = {
                type: e ? "CommentBlock" : "CommentLine",
                value: t,
                start: r,
                end: n,
                loc: new Le(i, s)
              };
              this.options.tokens && this.state.tokens.push(a),
                this.state.comments.push(a),
                this.addComment(a);
            }
            skipBlockComment() {
              const e = this.state.curPosition(),
                t = this.state.pos,
                r = this.input.indexOf("*/", (this.state.pos += 2));
              let n;
              for (
                -1 === r &&
                  this.raise(this.state.pos - 2, "Unterminated comment"),
                  this.state.pos = r + 2,
                  G.lastIndex = t;
                (n = G.exec(this.input)) && n.index < this.state.pos;

              )
                ++this.state.curLine,
                  (this.state.lineStart = n.index + n[0].length);
              this.isLookahead ||
                this.pushComment(
                  !0,
                  this.input.slice(t + 2, r),
                  t,
                  this.state.pos,
                  e,
                  this.state.curPosition()
                );
            }
            skipLineComment(e) {
              const t = this.state.pos,
                r = this.state.curPosition();
              let n = this.input.charCodeAt((this.state.pos += e));
              if (this.state.pos < this.length)
                for (
                  ;
                  10 !== n &&
                  13 !== n &&
                  8232 !== n &&
                  8233 !== n &&
                  ++this.state.pos < this.length;

                )
                  n = this.input.charCodeAt(this.state.pos);
              this.isLookahead ||
                this.pushComment(
                  !1,
                  this.input.slice(t + e, this.state.pos),
                  t,
                  this.state.pos,
                  r,
                  this.state.curPosition()
                );
            }
            skipSpace() {
              e: for (; this.state.pos < this.length; ) {
                const e = this.input.charCodeAt(this.state.pos);
                switch (e) {
                  case 32:
                  case 160:
                  case 9:
                    ++this.state.pos;
                    break;
                  case 13:
                    10 === this.input.charCodeAt(this.state.pos + 1) &&
                      ++this.state.pos;
                  case 10:
                  case 8232:
                  case 8233:
                    ++this.state.pos,
                      ++this.state.curLine,
                      (this.state.lineStart = this.state.pos);
                    break;
                  case 47:
                    switch (this.input.charCodeAt(this.state.pos + 1)) {
                      case 42:
                        this.skipBlockComment();
                        break;
                      case 47:
                        this.skipLineComment(2);
                        break;
                      default:
                        break e;
                    }
                    break;
                  default:
                    if (!X(e)) break e;
                    ++this.state.pos;
                }
              }
            }
            finishToken(e, t) {
              (this.state.end = this.state.pos),
                (this.state.endLoc = this.state.curPosition());
              const r = this.state.type;
              (this.state.type = e),
                (this.state.value = t),
                this.isLookahead || this.updateContext(r);
            }
            readToken_numberSign() {
              if (0 === this.state.pos && this.readToken_interpreter()) return;
              const e = this.state.pos + 1,
                t = this.input.charCodeAt(e);
              if (
                (t >= 48 &&
                  t <= 57 &&
                  this.raise(
                    this.state.pos,
                    "Unexpected digit after hash token"
                  ),
                (this.hasPlugin("classPrivateProperties") ||
                  this.hasPlugin("classPrivateMethods")) &&
                  this.state.classLevel > 0)
              )
                return ++this.state.pos, void this.finishToken(u.hash);
              "smart" === this.getPluginOption("pipelineOperator", "proposal")
                ? this.finishOp(u.hash, 1)
                : this.raise(this.state.pos, "Unexpected character '#'");
            }
            readToken_dot() {
              const e = this.input.charCodeAt(this.state.pos + 1);
              if (e >= 48 && e <= 57) return void this.readNumber(!0);
              const t = this.input.charCodeAt(this.state.pos + 2);
              46 === e && 46 === t
                ? ((this.state.pos += 3), this.finishToken(u.ellipsis))
                : (++this.state.pos, this.finishToken(u.dot));
            }
            readToken_slash() {
              if (this.state.exprAllowed && !this.state.inType)
                return ++this.state.pos, void this.readRegexp();
              61 === this.input.charCodeAt(this.state.pos + 1)
                ? this.finishOp(u.assign, 2)
                : this.finishOp(u.slash, 1);
            }
            readToken_interpreter() {
              if (0 !== this.state.pos || this.length < 2) return !1;
              const e = this.state.pos;
              this.state.pos += 1;
              let t = this.input.charCodeAt(this.state.pos);
              if (33 !== t) return !1;
              for (
                ;
                10 !== t &&
                13 !== t &&
                8232 !== t &&
                8233 !== t &&
                ++this.state.pos < this.length;

              )
                t = this.input.charCodeAt(this.state.pos);
              const r = this.input.slice(e + 2, this.state.pos);
              return this.finishToken(u.interpreterDirective, r), !0;
            }
            readToken_mult_modulo(e) {
              let t = 42 === e ? u.star : u.modulo,
                r = 1,
                n = this.input.charCodeAt(this.state.pos + 1);
              const i = this.state.exprAllowed;
              42 === e &&
                42 === n &&
                (r++,
                (n = this.input.charCodeAt(this.state.pos + 2)),
                (t = u.exponent)),
                61 !== n || i || (r++, (t = u.assign)),
                this.finishOp(t, r);
            }
            readToken_pipe_amp(e) {
              const t = this.input.charCodeAt(this.state.pos + 1);
              t !== e
                ? 124 !== e || 62 !== t
                  ? 61 !== t
                    ? this.finishOp(124 === e ? u.bitwiseOR : u.bitwiseAND, 1)
                    : this.finishOp(u.assign, 2)
                  : this.finishOp(u.pipeline, 2)
                : 61 === this.input.charCodeAt(this.state.pos + 2)
                ? this.finishOp(u.assign, 3)
                : this.finishOp(124 === e ? u.logicalOR : u.logicalAND, 2);
            }
            readToken_caret() {
              61 === this.input.charCodeAt(this.state.pos + 1)
                ? this.finishOp(u.assign, 2)
                : this.finishOp(u.bitwiseXOR, 1);
            }
            readToken_plus_min(e) {
              const t = this.input.charCodeAt(this.state.pos + 1);
              if (t === e)
                return 45 !== t ||
                  this.inModule ||
                  62 !== this.input.charCodeAt(this.state.pos + 2) ||
                  (0 !== this.state.lastTokEnd &&
                    !K.test(
                      this.input.slice(this.state.lastTokEnd, this.state.pos)
                    ))
                  ? void this.finishOp(u.incDec, 2)
                  : (this.skipLineComment(3),
                    this.skipSpace(),
                    void this.nextToken());
              61 === t
                ? this.finishOp(u.assign, 2)
                : this.finishOp(u.plusMin, 1);
            }
            readToken_lt_gt(e) {
              const t = this.input.charCodeAt(this.state.pos + 1);
              let r = 1;
              return t === e
                ? ((r =
                    62 === e && 62 === this.input.charCodeAt(this.state.pos + 2)
                      ? 3
                      : 2),
                  61 === this.input.charCodeAt(this.state.pos + r)
                    ? void this.finishOp(u.assign, r + 1)
                    : void this.finishOp(u.bitShift, r))
                : 33 !== t ||
                  60 !== e ||
                  this.inModule ||
                  45 !== this.input.charCodeAt(this.state.pos + 2) ||
                  45 !== this.input.charCodeAt(this.state.pos + 3)
                ? (61 === t && (r = 2), void this.finishOp(u.relational, r))
                : (this.skipLineComment(4),
                  this.skipSpace(),
                  void this.nextToken());
            }
            readToken_eq_excl(e) {
              const t = this.input.charCodeAt(this.state.pos + 1);
              if (61 !== t)
                return 61 === e && 62 === t
                  ? ((this.state.pos += 2), void this.finishToken(u.arrow))
                  : void this.finishOp(61 === e ? u.eq : u.bang, 1);
              this.finishOp(
                u.equality,
                61 === this.input.charCodeAt(this.state.pos + 2) ? 3 : 2
              );
            }
            readToken_question() {
              const e = this.input.charCodeAt(this.state.pos + 1),
                t = this.input.charCodeAt(this.state.pos + 2);
              63 !== e || this.state.inType
                ? 46 !== e || (t >= 48 && t <= 57)
                  ? (++this.state.pos, this.finishToken(u.question))
                  : ((this.state.pos += 2), this.finishToken(u.questionDot))
                : 61 === t
                ? this.finishOp(u.assign, 3)
                : this.finishOp(u.nullishCoalescing, 2);
            }
            getTokenFromCode(e) {
              switch (e) {
                case 46:
                  return void this.readToken_dot();
                case 40:
                  return ++this.state.pos, void this.finishToken(u.parenL);
                case 41:
                  return ++this.state.pos, void this.finishToken(u.parenR);
                case 59:
                  return ++this.state.pos, void this.finishToken(u.semi);
                case 44:
                  return ++this.state.pos, void this.finishToken(u.comma);
                case 91:
                  return ++this.state.pos, void this.finishToken(u.bracketL);
                case 93:
                  return ++this.state.pos, void this.finishToken(u.bracketR);
                case 123:
                  return ++this.state.pos, void this.finishToken(u.braceL);
                case 125:
                  return ++this.state.pos, void this.finishToken(u.braceR);
                case 58:
                  return void (this.hasPlugin("functionBind") &&
                  58 === this.input.charCodeAt(this.state.pos + 1)
                    ? this.finishOp(u.doubleColon, 2)
                    : (++this.state.pos, this.finishToken(u.colon)));
                case 63:
                  return void this.readToken_question();
                case 96:
                  return ++this.state.pos, void this.finishToken(u.backQuote);
                case 48: {
                  const e = this.input.charCodeAt(this.state.pos + 1);
                  if (120 === e || 88 === e)
                    return void this.readRadixNumber(16);
                  if (111 === e || 79 === e)
                    return void this.readRadixNumber(8);
                  if (98 === e || 66 === e) return void this.readRadixNumber(2);
                }
                case 49:
                case 50:
                case 51:
                case 52:
                case 53:
                case 54:
                case 55:
                case 56:
                case 57:
                  return void this.readNumber(!1);
                case 34:
                case 39:
                  return void this.readString(e);
                case 47:
                  return void this.readToken_slash();
                case 37:
                case 42:
                  return void this.readToken_mult_modulo(e);
                case 124:
                case 38:
                  return void this.readToken_pipe_amp(e);
                case 94:
                  return void this.readToken_caret();
                case 43:
                case 45:
                  return void this.readToken_plus_min(e);
                case 60:
                case 62:
                  return void this.readToken_lt_gt(e);
                case 61:
                case 33:
                  return void this.readToken_eq_excl(e);
                case 126:
                  return void this.finishOp(u.tilde, 1);
                case 64:
                  return ++this.state.pos, void this.finishToken(u.at);
                case 35:
                  return void this.readToken_numberSign();
                case 92:
                  return void this.readWord();
                default:
                  if (ce(e)) return void this.readWord();
              }
              this.raise(
                this.state.pos,
                `Unexpected character '${String.fromCodePoint(e)}'`
              );
            }
            finishOp(e, t) {
              const r = this.input.slice(this.state.pos, this.state.pos + t);
              (this.state.pos += t), this.finishToken(e, r);
            }
            readRegexp() {
              const e = this.state.pos;
              let t, r;
              for (;;) {
                this.state.pos >= this.length &&
                  this.raise(e, "Unterminated regular expression");
                const n = this.input.charAt(this.state.pos);
                if (
                  (K.test(n) &&
                    this.raise(e, "Unterminated regular expression"),
                  t)
                )
                  t = !1;
                else {
                  if ("[" === n) r = !0;
                  else if ("]" === n && r) r = !1;
                  else if ("/" === n && !r) break;
                  t = "\\" === n;
                }
                ++this.state.pos;
              }
              const n = this.input.slice(e, this.state.pos);
              ++this.state.pos;
              let i = "";
              for (; this.state.pos < this.length; ) {
                const e = this.input[this.state.pos],
                  t = this.input.codePointAt(this.state.pos);
                if (Ue.has(e))
                  i.indexOf(e) > -1 &&
                    this.raise(
                      this.state.pos + 1,
                      "Duplicate regular expression flag"
                    ),
                    ++this.state.pos,
                    (i += e);
                else {
                  if (!pe(t) && 92 !== t) break;
                  this.raise(
                    this.state.pos + 1,
                    "Invalid regular expression flag"
                  );
                }
              }
              this.finishToken(u.regexp, { pattern: n, flags: i });
            }
            readInt(e, t) {
              const r = this.state.pos,
                n = 16 === e ? Ke.hex : Ke.decBinOct,
                i =
                  16 === e
                    ? Ge.hex
                    : 10 === e
                    ? Ge.dec
                    : 8 === e
                    ? Ge.oct
                    : Ge.bin;
              let s = 0;
              for (let r = 0, a = null == t ? 1 / 0 : t; r < a; ++r) {
                const t = this.input.charCodeAt(this.state.pos);
                let r;
                if (this.hasPlugin("numericSeparator")) {
                  const e = this.input.charCodeAt(this.state.pos - 1),
                    r = this.input.charCodeAt(this.state.pos + 1);
                  if (95 === t) {
                    -1 === i.indexOf(r) &&
                      this.raise(this.state.pos, "Invalid or unexpected token"),
                      (n.indexOf(e) > -1 ||
                        n.indexOf(r) > -1 ||
                        Number.isNaN(r)) &&
                        this.raise(
                          this.state.pos,
                          "Invalid or unexpected token"
                        ),
                      ++this.state.pos;
                    continue;
                  }
                }
                if (
                  (r =
                    t >= 97
                      ? t - 97 + 10
                      : t >= 65
                      ? t - 65 + 10
                      : Ve(t)
                      ? t - 48
                      : 1 / 0) >= e
                )
                  break;
                ++this.state.pos, (s = s * e + r);
              }
              return this.state.pos === r ||
                (null != t && this.state.pos - r !== t)
                ? null
                : s;
            }
            readRadixNumber(e) {
              const t = this.state.pos;
              let r = !1;
              this.state.pos += 2;
              const n = this.readInt(e);
              if (
                (null == n &&
                  this.raise(
                    this.state.start + 2,
                    "Expected number in radix " + e
                  ),
                this.hasPlugin("bigInt") &&
                  110 === this.input.charCodeAt(this.state.pos) &&
                  (++this.state.pos, (r = !0)),
                ce(this.input.codePointAt(this.state.pos)) &&
                  this.raise(
                    this.state.pos,
                    "Identifier directly after number"
                  ),
                r)
              ) {
                const e = this.input
                  .slice(t, this.state.pos)
                  .replace(/[_n]/g, "");
                this.finishToken(u.bigint, e);
              } else this.finishToken(u.num, n);
            }
            readNumber(e) {
              const t = this.state.pos;
              let r = !1,
                n = !1;
              e || null !== this.readInt(10) || this.raise(t, "Invalid number");
              let i =
                this.state.pos - t >= 2 && 48 === this.input.charCodeAt(t);
              i &&
                (this.state.strict &&
                  this.raise(
                    t,
                    "Legacy octal literals are not allowed in strict mode"
                  ),
                /[89]/.test(this.input.slice(t, this.state.pos)) && (i = !1));
              let s = this.input.charCodeAt(this.state.pos);
              46 !== s ||
                i ||
                (++this.state.pos,
                this.readInt(10),
                (r = !0),
                (s = this.input.charCodeAt(this.state.pos))),
                (69 !== s && 101 !== s) ||
                  i ||
                  ((43 !== (s = this.input.charCodeAt(++this.state.pos)) &&
                    45 !== s) ||
                    ++this.state.pos,
                  null === this.readInt(10) && this.raise(t, "Invalid number"),
                  (r = !0),
                  (s = this.input.charCodeAt(this.state.pos))),
                this.hasPlugin("bigInt") &&
                  110 === s &&
                  ((r || i) && this.raise(t, "Invalid BigIntLiteral"),
                  ++this.state.pos,
                  (n = !0)),
                ce(this.input.codePointAt(this.state.pos)) &&
                  this.raise(
                    this.state.pos,
                    "Identifier directly after number"
                  );
              const a = this.input
                .slice(t, this.state.pos)
                .replace(/[_n]/g, "");
              if (n) return void this.finishToken(u.bigint, a);
              const o = i ? parseInt(a, 8) : parseFloat(a);
              this.finishToken(u.num, o);
            }
            readCodePoint(e) {
              let t;
              if (123 === this.input.charCodeAt(this.state.pos)) {
                const r = ++this.state.pos;
                if (
                  ((t = this.readHexChar(
                    this.input.indexOf("}", this.state.pos) - this.state.pos,
                    e
                  )),
                  ++this.state.pos,
                  null === t)
                )
                  --this.state.invalidTemplateEscapePosition;
                else if (t > 1114111) {
                  if (!e)
                    return (
                      (this.state.invalidTemplateEscapePosition = r - 2), null
                    );
                  this.raise(r, "Code point out of bounds");
                }
              } else t = this.readHexChar(4, e);
              return t;
            }
            readString(e) {
              let t = "",
                r = ++this.state.pos;
              for (;;) {
                this.state.pos >= this.length &&
                  this.raise(this.state.start, "Unterminated string constant");
                const n = this.input.charCodeAt(this.state.pos);
                if (n === e) break;
                92 === n
                  ? ((t += this.input.slice(r, this.state.pos)),
                    (t += this.readEscapedChar(!1)),
                    (r = this.state.pos))
                  : 8232 === n || 8233 === n
                  ? (++this.state.pos, ++this.state.curLine)
                  : W(n)
                  ? this.raise(this.state.start, "Unterminated string constant")
                  : ++this.state.pos;
              }
              (t += this.input.slice(r, this.state.pos++)),
                this.finishToken(u.string, t);
            }
            readTmplToken() {
              let e = "",
                t = this.state.pos,
                r = !1;
              for (;;) {
                this.state.pos >= this.length &&
                  this.raise(this.state.start, "Unterminated template");
                const n = this.input.charCodeAt(this.state.pos);
                if (
                  96 === n ||
                  (36 === n &&
                    123 === this.input.charCodeAt(this.state.pos + 1))
                )
                  return this.state.pos === this.state.start &&
                    this.match(u.template)
                    ? 36 === n
                      ? ((this.state.pos += 2),
                        void this.finishToken(u.dollarBraceL))
                      : (++this.state.pos, void this.finishToken(u.backQuote))
                    : ((e += this.input.slice(t, this.state.pos)),
                      void this.finishToken(u.template, r ? null : e));
                if (92 === n) {
                  e += this.input.slice(t, this.state.pos);
                  const n = this.readEscapedChar(!0);
                  null === n ? (r = !0) : (e += n), (t = this.state.pos);
                } else if (W(n)) {
                  switch (
                    ((e += this.input.slice(t, this.state.pos)),
                    ++this.state.pos,
                    n)
                  ) {
                    case 13:
                      10 === this.input.charCodeAt(this.state.pos) &&
                        ++this.state.pos;
                    case 10:
                      e += "\n";
                      break;
                    default:
                      e += String.fromCharCode(n);
                  }
                  ++this.state.curLine,
                    (this.state.lineStart = this.state.pos),
                    (t = this.state.pos);
                } else ++this.state.pos;
              }
            }
            readEscapedChar(e) {
              const t = !e,
                r = this.input.charCodeAt(++this.state.pos);
              switch ((++this.state.pos, r)) {
                case 110:
                  return "\n";
                case 114:
                  return "\r";
                case 120: {
                  const e = this.readHexChar(2, t);
                  return null === e ? null : String.fromCharCode(e);
                }
                case 117: {
                  const e = this.readCodePoint(t);
                  return null === e ? null : String.fromCodePoint(e);
                }
                case 116:
                  return "\t";
                case 98:
                  return "\b";
                case 118:
                  return "\v";
                case 102:
                  return "\f";
                case 13:
                  10 === this.input.charCodeAt(this.state.pos) &&
                    ++this.state.pos;
                case 10:
                  (this.state.lineStart = this.state.pos), ++this.state.curLine;
                case 8232:
                case 8233:
                  return "";
                default:
                  if (r >= 48 && r <= 55) {
                    const t = this.state.pos - 1;
                    let r = this.input
                        .substr(this.state.pos - 1, 3)
                        .match(/^[0-7]+/)[0],
                      n = parseInt(r, 8);
                    n > 255 && ((r = r.slice(0, -1)), (n = parseInt(r, 8))),
                      (this.state.pos += r.length - 1);
                    const i = this.input.charCodeAt(this.state.pos);
                    if ("0" !== r || 56 === i || 57 === i) {
                      if (e)
                        return (
                          (this.state.invalidTemplateEscapePosition = t), null
                        );
                      this.state.strict
                        ? this.raise(t, "Octal literal in strict mode")
                        : this.state.containsOctal ||
                          ((this.state.containsOctal = !0),
                          (this.state.octalPosition = t));
                    }
                    return String.fromCharCode(n);
                  }
                  return String.fromCharCode(r);
              }
            }
            readHexChar(e, t) {
              const r = this.state.pos,
                n = this.readInt(16, e);
              return (
                null === n &&
                  (t
                    ? this.raise(r, "Bad character escape sequence")
                    : ((this.state.pos = r - 1),
                      (this.state.invalidTemplateEscapePosition = r - 1))),
                n
              );
            }
            readWord1() {
              let e = "";
              this.state.containsEsc = !1;
              const t = this.state.pos;
              let r = this.state.pos;
              for (; this.state.pos < this.length; ) {
                const n = this.input.codePointAt(this.state.pos);
                if (pe(n)) this.state.pos += n <= 65535 ? 1 : 2;
                else if (this.state.isIterator && 64 === n) ++this.state.pos;
                else {
                  if (92 !== n) break;
                  {
                    (this.state.containsEsc = !0),
                      (e += this.input.slice(r, this.state.pos));
                    const n = this.state.pos,
                      i = this.state.pos === t ? ce : pe;
                    117 !== this.input.charCodeAt(++this.state.pos) &&
                      this.raise(
                        this.state.pos,
                        "Expecting Unicode escape sequence \\uXXXX"
                      ),
                      ++this.state.pos;
                    const s = this.readCodePoint(!0);
                    i(s, !0) || this.raise(n, "Invalid Unicode escape"),
                      (e += String.fromCodePoint(s)),
                      (r = this.state.pos);
                  }
                }
              }
              return e + this.input.slice(r, this.state.pos);
            }
            isIterator(e) {
              return "@@iterator" === e || "@@asyncIterator" === e;
            }
            readWord() {
              const e = this.readWord1(),
                t = s.get(e) || u.name;
              t.keyword &&
                this.state.containsEsc &&
                this.raise(this.state.pos, `Escape sequence in keyword ${e}`),
                !this.state.isIterator ||
                  (this.isIterator(e) && this.state.inType) ||
                  this.raise(this.state.pos, `Invalid identifier ${e}`),
                this.finishToken(t, e);
            }
            braceIsBlock(e) {
              const t = this.curContext();
              return (
                t === H.functionExpression ||
                t === H.functionStatement ||
                (e !== u.colon ||
                (t !== H.braceStatement && t !== H.braceExpression)
                  ? e === u._return || (e === u.name && this.state.exprAllowed)
                    ? K.test(
                        this.input.slice(
                          this.state.lastTokEnd,
                          this.state.start
                        )
                      )
                    : e === u._else ||
                      e === u.semi ||
                      e === u.eof ||
                      e === u.parenR ||
                      e === u.arrow ||
                      (e === u.braceL
                        ? t === H.braceStatement
                        : e !== u._var &&
                          e !== u._const &&
                          e !== u.name &&
                          (e === u.relational || !this.state.exprAllowed))
                  : !t.isExpr)
              );
            }
            updateContext(e) {
              const t = this.state.type;
              let r;
              !t.keyword || (e !== u.dot && e !== u.questionDot)
                ? (r = t.updateContext)
                  ? r.call(this, e)
                  : (this.state.exprAllowed = t.beforeExpr)
                : (this.state.exprAllowed = !1);
            }
          }
          const Xe = /^('|")((?:\\?.)*?)\1/;
          class $e extends Je {
            addExtra(e, t, r) {
              if (!e) return;
              (e.extra = e.extra || {})[t] = r;
            }
            isRelational(e) {
              return this.match(u.relational) && this.state.value === e;
            }
            isLookaheadRelational(e) {
              const t = this.lookahead();
              return t.type === u.relational && t.value === e;
            }
            expectRelational(e) {
              this.isRelational(e)
                ? this.next()
                : this.unexpected(null, u.relational);
            }
            eatRelational(e) {
              return !!this.isRelational(e) && (this.next(), !0);
            }
            isContextual(e) {
              return (
                this.match(u.name) &&
                this.state.value === e &&
                !this.state.containsEsc
              );
            }
            isLookaheadContextual(e) {
              const t = this.lookahead();
              return t.type === u.name && t.value === e;
            }
            eatContextual(e) {
              return this.isContextual(e) && this.eat(u.name);
            }
            expectContextual(e, t) {
              this.eatContextual(e) || this.unexpected(null, t);
            }
            canInsertSemicolon() {
              return (
                this.match(u.eof) ||
                this.match(u.braceR) ||
                this.hasPrecedingLineBreak()
              );
            }
            hasPrecedingLineBreak() {
              return K.test(
                this.input.slice(this.state.lastTokEnd, this.state.start)
              );
            }
            isLineTerminator() {
              return this.eat(u.semi) || this.canInsertSemicolon();
            }
            semicolon() {
              this.isLineTerminator() || this.unexpected(null, u.semi);
            }
            expect(e, t) {
              this.eat(e) || this.unexpected(t, e);
            }
            assertNoSpace(e = "Unexpected space.") {
              this.state.start > this.state.lastTokEnd &&
                this.raise(this.state.lastTokEnd, e);
            }
            unexpected(e, t = "Unexpected token") {
              throw ("string" != typeof t &&
                (t = `Unexpected token, expected "${t.label}"`),
              this.raise(null != e ? e : this.state.start, t));
            }
            expectPlugin(e, t) {
              if (!this.hasPlugin(e))
                throw this.raise(
                  null != t ? t : this.state.start,
                  `This experimental syntax requires enabling the parser plugin: '${e}'`,
                  { missingPluginNames: [e] }
                );
              return !0;
            }
            expectOnePlugin(e, t) {
              if (!e.some(e => this.hasPlugin(e)))
                throw this.raise(
                  null != t ? t : this.state.start,
                  `This experimental syntax requires enabling one of the following parser plugin(s): '${e.join(
                    ", "
                  )}'`,
                  { missingPluginNames: e }
                );
            }
            checkYieldAwaitInDefaultParams() {
              this.state.yieldPos &&
                (!this.state.awaitPos ||
                  this.state.yieldPos < this.state.awaitPos) &&
                this.raise(
                  this.state.yieldPos,
                  "Yield cannot be used as name inside a generator function"
                ),
                this.state.awaitPos &&
                  this.raise(
                    this.state.awaitPos,
                    "Await cannot be used as name inside an async function"
                  );
            }
            strictDirective(e) {
              for (;;) {
                (J.lastIndex = e), (e += J.exec(this.input)[0].length);
                const t = Xe.exec(this.input.slice(e));
                if (!t) break;
                if ("use strict" === t[2]) return !0;
                (e += t[0].length),
                  (J.lastIndex = e),
                  (e += J.exec(this.input)[0].length),
                  ";" === this.input[e] && e++;
              }
              return !1;
            }
          }
          class He {
            constructor(e, t, r) {
              (this.type = ""),
                (this.start = t),
                (this.end = 0),
                (this.loc = new Le(r)),
                e && e.options.ranges && (this.range = [t, 0]),
                e && e.filename && (this.loc.filename = e.filename);
            }
            __clone() {
              const e = new He(),
                t = Object.keys(this);
              for (let r = 0, n = t.length; r < n; r++) {
                const n = t[r];
                "leadingComments" !== n &&
                  "trailingComments" !== n &&
                  "innerComments" !== n &&
                  (e[n] = this[n]);
              }
              return e;
            }
          }
          class Ye extends $e {
            startNode() {
              return new He(this, this.state.start, this.state.startLoc);
            }
            startNodeAt(e, t) {
              return new He(this, e, t);
            }
            startNodeAtNode(e) {
              return this.startNodeAt(e.start, e.loc.start);
            }
            finishNode(e, t) {
              return this.finishNodeAt(
                e,
                t,
                this.state.lastTokEnd,
                this.state.lastTokEndLoc
              );
            }
            finishNodeAt(e, t, r, n) {
              return (
                (e.type = t),
                (e.end = r),
                (e.loc.end = n),
                this.options.ranges && (e.range[1] = r),
                this.processComment(e),
                e
              );
            }
            resetStartLocation(e, t, r) {
              (e.start = t),
                (e.loc.start = r),
                this.options.ranges && (e.range[0] = t);
            }
            resetEndLocation(
              e,
              t = this.state.lastTokEnd,
              r = this.state.lastTokEndLoc
            ) {
              (e.end = t),
                (e.loc.end = r),
                this.options.ranges && (e.range[1] = t);
            }
            resetStartLocationFromNode(e, t) {
              this.resetStartLocation(e, t.start, t.loc.start);
            }
          }
          class ze extends Ye {
            toAssignable(e, t, r) {
              if (e)
                switch (e.type) {
                  case "Identifier":
                  case "ObjectPattern":
                  case "ArrayPattern":
                  case "AssignmentPattern":
                    break;
                  case "ObjectExpression":
                    e.type = "ObjectPattern";
                    for (
                      let r = 0, n = e.properties.length, i = n - 1;
                      r < n;
                      r++
                    ) {
                      const n = e.properties[r],
                        s = r === i;
                      this.toAssignableObjectExpressionProp(n, t, s);
                    }
                    break;
                  case "ObjectProperty":
                    this.toAssignable(e.value, t, r);
                    break;
                  case "SpreadElement": {
                    this.checkToRestConversion(e), (e.type = "RestElement");
                    const n = e.argument;
                    this.toAssignable(n, t, r);
                    break;
                  }
                  case "ArrayExpression":
                    (e.type = "ArrayPattern"),
                      this.toAssignableList(e.elements, t, r);
                    break;
                  case "AssignmentExpression":
                    "=" === e.operator
                      ? ((e.type = "AssignmentPattern"), delete e.operator)
                      : this.raise(
                          e.left.end,
                          "Only '=' operator can be used for specifying default value."
                        );
                    break;
                  case "ParenthesizedExpression":
                    e.expression = this.toAssignable(e.expression, t, r);
                    break;
                  case "MemberExpression":
                    if (!t) break;
                  default: {
                    const t =
                      "Invalid left-hand side" +
                      (r ? " in " + r : "expression");
                    this.raise(e.start, t);
                  }
                }
              return e;
            }
            toAssignableObjectExpressionProp(e, t, r) {
              if ("ObjectMethod" === e.type) {
                const t =
                  "get" === e.kind || "set" === e.kind
                    ? "Object pattern can't contain getter or setter"
                    : "Object pattern can't contain methods";
                this.raise(e.key.start, t);
              } else
                "SpreadElement" !== e.type || r
                  ? this.toAssignable(e, t, "object destructuring pattern")
                  : this.raiseRestNotLast(e.start);
            }
            toAssignableList(e, t, r) {
              let n = e.length;
              if (n) {
                const i = e[n - 1];
                if (i && "RestElement" === i.type) --n;
                else if (i && "SpreadElement" === i.type) {
                  i.type = "RestElement";
                  const e = i.argument;
                  this.toAssignable(e, t, r),
                    "Identifier" !== e.type &&
                      "MemberExpression" !== e.type &&
                      "ArrayPattern" !== e.type &&
                      "ObjectPattern" !== e.type &&
                      this.unexpected(e.start),
                    --n;
                }
              }
              for (let i = 0; i < n; i++) {
                const n = e[i];
                n &&
                  (this.toAssignable(n, t, r),
                  "RestElement" === n.type && this.raiseRestNotLast(n.start));
              }
              return e;
            }
            toReferencedList(e, t) {
              return e;
            }
            toReferencedListDeep(e, t) {
              this.toReferencedList(e, t);
              for (let t = 0; t < e.length; t++) {
                const r = e[t];
                r &&
                  "ArrayExpression" === r.type &&
                  this.toReferencedListDeep(r.elements);
              }
              return e;
            }
            parseSpread(e, t) {
              const r = this.startNode();
              return (
                this.next(),
                (r.argument = this.parseMaybeAssign(!1, e, void 0, t)),
                -1 === this.state.commaAfterSpreadAt &&
                  this.match(u.comma) &&
                  (this.state.commaAfterSpreadAt = this.state.start),
                this.finishNode(r, "SpreadElement")
              );
            }
            parseRestBinding() {
              const e = this.startNode();
              return (
                this.next(),
                (e.argument = this.parseBindingAtom()),
                this.finishNode(e, "RestElement")
              );
            }
            parseBindingAtom() {
              switch (this.state.type) {
                case u.bracketL: {
                  const e = this.startNode();
                  return (
                    this.next(),
                    (e.elements = this.parseBindingList(u.bracketR, !0)),
                    this.finishNode(e, "ArrayPattern")
                  );
                }
                case u.braceL:
                  return this.parseObj(!0);
              }
              return this.parseIdentifier();
            }
            parseBindingList(e, t, r) {
              const n = [];
              let i = !0;
              for (; !this.eat(e); )
                if (
                  (i ? (i = !1) : this.expect(u.comma),
                  t && this.match(u.comma))
                )
                  n.push(null);
                else {
                  if (this.eat(e)) break;
                  if (this.match(u.ellipsis)) {
                    n.push(
                      this.parseAssignableListItemTypes(this.parseRestBinding())
                    ),
                      this.checkCommaAfterRest(),
                      this.expect(e);
                    break;
                  }
                  {
                    const e = [];
                    for (
                      this.match(u.at) &&
                      this.hasPlugin("decorators") &&
                      this.raise(
                        this.state.start,
                        "Stage 2 decorators cannot be used to decorate parameters"
                      );
                      this.match(u.at);

                    )
                      e.push(this.parseDecorator());
                    n.push(this.parseAssignableListItem(r, e));
                  }
                }
              return n;
            }
            parseAssignableListItem(e, t) {
              const r = this.parseMaybeDefault();
              this.parseAssignableListItemTypes(r);
              const n = this.parseMaybeDefault(r.start, r.loc.start, r);
              return t.length && (r.decorators = t), n;
            }
            parseAssignableListItemTypes(e) {
              return e;
            }
            parseMaybeDefault(e, t, r) {
              if (
                ((t = t || this.state.startLoc),
                (e = e || this.state.start),
                (r = r || this.parseBindingAtom()),
                !this.eat(u.eq))
              )
                return r;
              const n = this.startNodeAt(e, t);
              return (
                (n.left = r),
                (n.right = this.parseMaybeAssign()),
                this.finishNode(n, "AssignmentPattern")
              );
            }
            checkLVal(e, t = j, r, n) {
              switch (e.type) {
                case "Identifier":
                  if (
                    (this.state.strict &&
                      te(e.name, this.inModule) &&
                      this.raise(
                        e.start,
                        `${t === j ? "Assigning to" : "Binding"} '${
                          e.name
                        }' in strict mode`
                      ),
                    r)
                  ) {
                    const t = `_${e.name}`;
                    r[t]
                      ? this.raise(e.start, "Argument name clash")
                      : (r[t] = !0);
                  }
                  t === O &&
                    "let" === e.name &&
                    this.raise(
                      e.start,
                      "'let' is not allowed to be used as a name in 'let' or 'const' declarations."
                    ),
                    t & j || this.scope.declareName(e.name, t, e.start);
                  break;
                case "MemberExpression":
                  t !== j && this.raise(e.start, "Binding member expression");
                  break;
                case "ObjectPattern":
                  for (let n = 0, i = e.properties; n < i.length; n++) {
                    let e = i[n];
                    "ObjectProperty" === e.type && (e = e.value),
                      this.checkLVal(e, t, r, "object destructuring pattern");
                  }
                  break;
                case "ArrayPattern":
                  for (let n = 0, i = e.elements; n < i.length; n++) {
                    const e = i[n];
                    e && this.checkLVal(e, t, r, "array destructuring pattern");
                  }
                  break;
                case "AssignmentPattern":
                  this.checkLVal(e.left, t, r, "assignment pattern");
                  break;
                case "RestElement":
                  this.checkLVal(e.argument, t, r, "rest element");
                  break;
                case "ParenthesizedExpression":
                  this.checkLVal(
                    e.expression,
                    t,
                    r,
                    "parenthesized expression"
                  );
                  break;
                default: {
                  const r =
                    (t === j ? "Invalid" : "Binding invalid") +
                    " left-hand side" +
                    (n ? " in " + n : "expression");
                  this.raise(e.start, r);
                }
              }
            }
            checkToRestConversion(e) {
              "Identifier" !== e.argument.type &&
                "MemberExpression" !== e.argument.type &&
                this.raise(
                  e.argument.start,
                  "Invalid rest operator's argument"
                );
            }
            checkCommaAfterRest() {
              this.match(u.comma) && this.raiseRestNotLast(this.state.start);
            }
            checkCommaAfterRestFromSpread() {
              this.state.commaAfterSpreadAt > -1 &&
                this.raiseRestNotLast(this.state.commaAfterSpreadAt);
            }
            raiseRestNotLast(e) {
              this.raise(e, "Rest element must be last element");
            }
          }
          const Qe = e =>
            "ParenthesizedExpression" === e.type ? Qe(e.expression) : e;
          class Ze extends ze {
            checkPropClash(e, t) {
              if (
                "SpreadElement" === e.type ||
                e.computed ||
                e.kind ||
                e.shorthand
              )
                return;
              const r = e.key;
              "__proto__" ===
                ("Identifier" === r.type ? r.name : String(r.value)) &&
                (t.proto &&
                  this.raise(r.start, "Redefinition of __proto__ property"),
                (t.proto = !0));
            }
            getExpression() {
              this.scope.enter(c), this.nextToken();
              const e = this.parseExpression();
              return (
                this.match(u.eof) || this.unexpected(),
                (e.comments = this.state.comments),
                e
              );
            }
            parseExpression(e, t) {
              const r = this.state.start,
                n = this.state.startLoc,
                i = this.parseMaybeAssign(e, t);
              if (this.match(u.comma)) {
                const s = this.startNodeAt(r, n);
                for (s.expressions = [i]; this.eat(u.comma); )
                  s.expressions.push(this.parseMaybeAssign(e, t));
                return (
                  this.toReferencedList(s.expressions),
                  this.finishNode(s, "SequenceExpression")
                );
              }
              return i;
            }
            parseMaybeAssign(e, t, r, n) {
              const i = this.state.start,
                s = this.state.startLoc;
              if (this.isContextual("yield")) {
                if (this.scope.inGenerator) {
                  let t = this.parseYield(e);
                  return r && (t = r.call(this, t, i, s)), t;
                }
                this.state.exprAllowed = !1;
              }
              const a = this.state.commaAfterSpreadAt;
              let o;
              (this.state.commaAfterSpreadAt = -1),
                t ? (o = !1) : ((t = { start: 0 }), (o = !0)),
                (this.match(u.parenL) || this.match(u.name)) &&
                  (this.state.potentialArrowAt = this.state.start);
              let l = this.parseMaybeConditional(e, t, n);
              if (
                (r && (l = r.call(this, l, i, s)), this.state.type.isAssign)
              ) {
                const r = this.startNodeAt(i, s),
                  n = this.state.value;
                (r.operator = n),
                  "??=" === n &&
                    (this.expectPlugin("nullishCoalescingOperator"),
                    this.expectPlugin("logicalAssignment")),
                  ("||=" !== n && "&&=" !== n) ||
                    this.expectPlugin("logicalAssignment"),
                  (r.left = this.match(u.eq)
                    ? this.toAssignable(l, void 0, "assignment expression")
                    : l),
                  (t.start = 0),
                  this.checkLVal(l, void 0, void 0, "assignment expression");
                const o = Qe(l);
                let c;
                return (
                  "ObjectPattern" === o.type
                    ? (c = "`({a}) = 0` use `({a} = 0)`")
                    : "ArrayPattern" === o.type &&
                      (c = "`([a]) = 0` use `([a] = 0)`"),
                  c &&
                    ((l.extra && l.extra.parenthesized) ||
                      "ParenthesizedExpression" === l.type) &&
                    this.raise(
                      o.start,
                      `You're trying to assign to a parenthesized expression, eg. instead of ${c}`
                    ),
                  c && this.checkCommaAfterRestFromSpread(),
                  (this.state.commaAfterSpreadAt = a),
                  this.next(),
                  (r.right = this.parseMaybeAssign(e)),
                  this.finishNode(r, "AssignmentExpression")
                );
              }
              return (
                o && t.start && this.unexpected(t.start),
                (this.state.commaAfterSpreadAt = a),
                l
              );
            }
            parseMaybeConditional(e, t, r) {
              const n = this.state.start,
                i = this.state.startLoc,
                s = this.state.potentialArrowAt,
                a = this.parseExprOps(e, t);
              return "ArrowFunctionExpression" === a.type && a.start === s
                ? a
                : t && t.start
                ? a
                : this.parseConditional(a, e, n, i, r);
            }
            parseConditional(e, t, r, n, i) {
              if (this.eat(u.question)) {
                const i = this.startNodeAt(r, n);
                return (
                  (i.test = e),
                  (i.consequent = this.parseMaybeAssign()),
                  this.expect(u.colon),
                  (i.alternate = this.parseMaybeAssign(t)),
                  this.finishNode(i, "ConditionalExpression")
                );
              }
              return e;
            }
            parseExprOps(e, t) {
              const r = this.state.start,
                n = this.state.startLoc,
                i = this.state.potentialArrowAt,
                s = this.parseMaybeUnary(t);
              return "ArrowFunctionExpression" === s.type && s.start === i
                ? s
                : t && t.start
                ? s
                : this.parseExprOp(s, r, n, -1, e);
            }
            parseExprOp(e, t, r, n, i) {
              const s = this.state.type.binop;
              if (!(null == s || (i && this.match(u._in))) && s > n) {
                const a = this.state.value;
                if ("|>" === a && this.state.inFSharpPipelineDirectBody)
                  return e;
                const o = this.startNodeAt(t, r);
                (o.left = e),
                  (o.operator = a),
                  "**" !== a ||
                    "UnaryExpression" !== e.type ||
                    (!this.options.createParenthesizedExpressions &&
                      e.extra &&
                      e.extra.parenthesized) ||
                    this.raise(
                      e.argument.start,
                      "Illegal expression. Wrap left hand side or entire exponentiation in parentheses."
                    );
                const l = this.state.type;
                if (
                  (l === u.pipeline
                    ? (this.expectPlugin("pipelineOperator"),
                      (this.state.inPipeline = !0),
                      this.checkPipelineAtInfixOperator(e, t))
                    : l === u.nullishCoalescing &&
                      this.expectPlugin("nullishCoalescingOperator"),
                  this.next(),
                  l === u.pipeline &&
                    "minimal" ===
                      this.getPluginOption("pipelineOperator", "proposal") &&
                    this.match(u.name) &&
                    "await" === this.state.value &&
                    this.scope.inAsync)
                )
                  throw this.raise(
                    this.state.start,
                    'Unexpected "await" after pipeline body; await must have parentheses in minimal proposal'
                  );
                return (
                  (o.right = this.parseExprOpRightExpr(l, s, i)),
                  this.finishNode(
                    o,
                    l === u.logicalOR ||
                      l === u.logicalAND ||
                      l === u.nullishCoalescing
                      ? "LogicalExpression"
                      : "BinaryExpression"
                  ),
                  this.parseExprOp(o, t, r, n, i)
                );
              }
              return e;
            }
            parseExprOpRightExpr(e, t, r) {
              const n = this.state.start,
                i = this.state.startLoc;
              switch (e) {
                case u.pipeline:
                  switch (
                    this.getPluginOption("pipelineOperator", "proposal")
                  ) {
                    case "smart":
                      return this.withTopicPermittingContext(() =>
                        this.parseSmartPipelineBody(
                          this.parseExprOpBaseRightExpr(e, t, r),
                          n,
                          i
                        )
                      );
                    case "fsharp":
                      return this.withSoloAwaitPermittingContext(() =>
                        this.parseFSharpPipelineBody(t, r)
                      );
                  }
                default:
                  return this.parseExprOpBaseRightExpr(e, t, r);
              }
            }
            parseExprOpBaseRightExpr(e, t, r) {
              const n = this.state.start,
                i = this.state.startLoc;
              return this.parseExprOp(
                this.parseMaybeUnary(),
                n,
                i,
                e.rightAssociative ? t - 1 : t,
                r
              );
            }
            parseMaybeUnary(e) {
              if (
                this.isContextual("await") &&
                (this.scope.inAsync ||
                  (!this.scope.inFunction &&
                    this.options.allowAwaitOutsideFunction))
              )
                return this.parseAwait();
              if (this.state.type.prefix) {
                const t = this.startNode(),
                  r = this.match(u.incDec);
                if (
                  ((t.operator = this.state.value),
                  (t.prefix = !0),
                  "throw" === t.operator &&
                    this.expectPlugin("throwExpressions"),
                  this.next(),
                  (t.argument = this.parseMaybeUnary()),
                  e && e.start && this.unexpected(e.start),
                  r)
                )
                  this.checkLVal(
                    t.argument,
                    void 0,
                    void 0,
                    "prefix operation"
                  );
                else if (this.state.strict && "delete" === t.operator) {
                  const e = t.argument;
                  "Identifier" === e.type
                    ? this.raise(
                        t.start,
                        "Deleting local variable in strict mode"
                      )
                    : "MemberExpression" === e.type &&
                      "PrivateName" === e.property.type &&
                      this.raise(
                        t.start,
                        "Deleting a private field is not allowed"
                      );
                }
                return this.finishNode(
                  t,
                  r ? "UpdateExpression" : "UnaryExpression"
                );
              }
              const t = this.state.start,
                r = this.state.startLoc;
              let n = this.parseExprSubscripts(e);
              if (e && e.start) return n;
              for (; this.state.type.postfix && !this.canInsertSemicolon(); ) {
                const e = this.startNodeAt(t, r);
                (e.operator = this.state.value),
                  (e.prefix = !1),
                  (e.argument = n),
                  this.checkLVal(n, void 0, void 0, "postfix operation"),
                  this.next(),
                  (n = this.finishNode(e, "UpdateExpression"));
              }
              return n;
            }
            parseExprSubscripts(e) {
              const t = this.state.start,
                r = this.state.startLoc,
                n = this.state.potentialArrowAt,
                i = this.parseExprAtom(e);
              return "ArrowFunctionExpression" === i.type && i.start === n
                ? i
                : e && e.start
                ? i
                : this.parseSubscripts(i, t, r);
            }
            parseSubscripts(e, t, r, n) {
              const i = this.atPossibleAsync(e),
                s = { optionalChainMember: !1, stop: !1 };
              do {
                e = this.parseSubscript(e, t, r, n, s, i);
              } while (!s.stop);
              return e;
            }
            parseSubscript(e, t, r, n, i, s) {
              if (!n && this.eat(u.doubleColon)) {
                const s = this.startNodeAt(t, r);
                return (
                  (s.object = e),
                  (s.callee = this.parseNoCallExpr()),
                  (i.stop = !0),
                  this.parseSubscripts(
                    this.finishNode(s, "BindExpression"),
                    t,
                    r,
                    n
                  )
                );
              }
              if (this.match(u.questionDot)) {
                if (
                  (this.expectPlugin("optionalChaining"),
                  (i.optionalChainMember = !0),
                  n && this.lookahead().type === u.parenL)
                )
                  return (i.stop = !0), e;
                this.next();
                const s = this.startNodeAt(t, r);
                return this.eat(u.bracketL)
                  ? ((s.object = e),
                    (s.property = this.parseExpression()),
                    (s.computed = !0),
                    (s.optional = !0),
                    this.expect(u.bracketR),
                    this.finishNode(s, "OptionalMemberExpression"))
                  : this.eat(u.parenL)
                  ? ((s.callee = e),
                    (s.arguments = this.parseCallExpressionArguments(
                      u.parenR,
                      !1
                    )),
                    (s.optional = !0),
                    this.finishNode(s, "OptionalCallExpression"))
                  : ((s.object = e),
                    (s.property = this.parseIdentifier(!0)),
                    (s.computed = !1),
                    (s.optional = !0),
                    this.finishNode(s, "OptionalMemberExpression"));
              }
              if (this.eat(u.dot)) {
                const n = this.startNodeAt(t, r);
                return (
                  (n.object = e),
                  (n.property = this.parseMaybePrivateName()),
                  (n.computed = !1),
                  i.optionalChainMember
                    ? ((n.optional = !1),
                      this.finishNode(n, "OptionalMemberExpression"))
                    : this.finishNode(n, "MemberExpression")
                );
              }
              if (this.eat(u.bracketL)) {
                const n = this.startNodeAt(t, r);
                return (
                  (n.object = e),
                  (n.property = this.parseExpression()),
                  (n.computed = !0),
                  this.expect(u.bracketR),
                  i.optionalChainMember
                    ? ((n.optional = !1),
                      this.finishNode(n, "OptionalMemberExpression"))
                    : this.finishNode(n, "MemberExpression")
                );
              }
              if (!n && this.match(u.parenL)) {
                const n = this.state.maybeInArrowParameters,
                  a = this.state.yieldPos,
                  o = this.state.awaitPos;
                (this.state.maybeInArrowParameters = !0),
                  (this.state.yieldPos = 0),
                  (this.state.awaitPos = 0),
                  this.next();
                let l = this.startNodeAt(t, r);
                l.callee = e;
                const c = this.state.commaAfterSpreadAt;
                return (
                  (this.state.commaAfterSpreadAt = -1),
                  (l.arguments = this.parseCallExpressionArguments(
                    u.parenR,
                    s,
                    "Import" === e.type,
                    "Super" !== e.type
                  )),
                  i.optionalChainMember
                    ? this.finishOptionalCallExpression(l)
                    : this.finishCallExpression(l),
                  s && this.shouldParseAsyncArrow()
                    ? ((i.stop = !0),
                      this.checkCommaAfterRestFromSpread(),
                      (l = this.parseAsyncArrowFromCallExpression(
                        this.startNodeAt(t, r),
                        l
                      )),
                      this.checkYieldAwaitInDefaultParams(),
                      (this.state.yieldPos = a),
                      (this.state.awaitPos = o))
                    : (this.toReferencedListDeep(l.arguments),
                      (this.state.yieldPos = a || this.state.yieldPos),
                      (this.state.awaitPos = o || this.state.awaitPos)),
                  (this.state.maybeInArrowParameters = n),
                  (this.state.commaAfterSpreadAt = c),
                  l
                );
              }
              return this.match(u.backQuote)
                ? this.parseTaggedTemplateExpression(t, r, e, i)
                : ((i.stop = !0), e);
            }
            parseTaggedTemplateExpression(e, t, r, n, i) {
              const s = this.startNodeAt(e, t);
              return (
                (s.tag = r),
                (s.quasi = this.parseTemplate(!0)),
                i && (s.typeParameters = i),
                n.optionalChainMember &&
                  this.raise(
                    e,
                    "Tagged Template Literals are not allowed in optionalChain"
                  ),
                this.finishNode(s, "TaggedTemplateExpression")
              );
            }
            atPossibleAsync(e) {
              return (
                "Identifier" === e.type &&
                "async" === e.name &&
                this.state.lastTokEnd === e.end &&
                !this.canInsertSemicolon() &&
                "async" === this.input.slice(e.start, e.end)
              );
            }
            finishCallExpression(e) {
              if ("Import" === e.callee.type) {
                1 !== e.arguments.length &&
                  this.raise(e.start, "import() requires exactly one argument");
                const t = e.arguments[0];
                t &&
                  "SpreadElement" === t.type &&
                  this.raise(t.start, "... is not allowed in import()");
              }
              return this.finishNode(e, "CallExpression");
            }
            finishOptionalCallExpression(e) {
              if ("Import" === e.callee.type) {
                1 !== e.arguments.length &&
                  this.raise(e.start, "import() requires exactly one argument");
                const t = e.arguments[0];
                t &&
                  "SpreadElement" === t.type &&
                  this.raise(t.start, "... is not allowed in import()");
              }
              return this.finishNode(e, "OptionalCallExpression");
            }
            parseCallExpressionArguments(e, t, r, n) {
              const i = [];
              let s,
                a = !0;
              const o = this.state.inFSharpPipelineDirectBody;
              for (this.state.inFSharpPipelineDirectBody = !1; !this.eat(e); ) {
                if (a) a = !1;
                else if ((this.expect(u.comma), this.eat(e))) {
                  r &&
                    this.raise(
                      this.state.lastTokStart,
                      "Trailing comma is disallowed inside import(...) arguments"
                    );
                  break;
                }
                this.match(u.parenL) && !s && (s = this.state.start),
                  i.push(
                    this.parseExprListItem(
                      !1,
                      t ? { start: 0 } : void 0,
                      t ? { start: 0 } : void 0,
                      n
                    )
                  );
              }
              return (
                t && s && this.shouldParseAsyncArrow() && this.unexpected(),
                (this.state.inFSharpPipelineDirectBody = o),
                i
              );
            }
            shouldParseAsyncArrow() {
              return this.match(u.arrow) && !this.canInsertSemicolon();
            }
            parseAsyncArrowFromCallExpression(e, t) {
              return (
                this.expect(u.arrow),
                this.parseArrowExpression(e, t.arguments, !0),
                e
              );
            }
            parseNoCallExpr() {
              const e = this.state.start,
                t = this.state.startLoc;
              return this.parseSubscripts(this.parseExprAtom(), e, t, !0);
            }
            parseExprAtom(e) {
              this.state.type === u.slash && this.readRegexp();
              const t = this.state.potentialArrowAt === this.state.start;
              let r;
              switch (this.state.type) {
                case u._super:
                  return (
                    this.scope.allowSuper ||
                      this.options.allowSuperOutsideMethod ||
                      this.raise(
                        this.state.start,
                        "super is only allowed in object methods and classes"
                      ),
                    (r = this.startNode()),
                    this.next(),
                    !this.match(u.parenL) ||
                      this.scope.allowDirectSuper ||
                      this.options.allowSuperOutsideMethod ||
                      this.raise(
                        r.start,
                        "super() is only valid inside a class constructor of a subclass. Maybe a typo in the method name ('constructor') or not extending another class?"
                      ),
                    this.match(u.parenL) ||
                      this.match(u.bracketL) ||
                      this.match(u.dot) ||
                      this.unexpected(),
                    this.finishNode(r, "Super")
                  );
                case u._import:
                  return (
                    (r = this.startNode()),
                    this.next(),
                    this.match(u.dot)
                      ? this.parseImportMetaProperty(r)
                      : (this.expectPlugin("dynamicImport", r.start),
                        this.match(u.parenL) || this.unexpected(null, u.parenL),
                        this.finishNode(r, "Import"))
                  );
                case u._this:
                  return (
                    (r = this.startNode()),
                    this.next(),
                    this.finishNode(r, "ThisExpression")
                  );
                case u.name: {
                  r = this.startNode();
                  const e = this.state.containsEsc,
                    n = this.parseIdentifier();
                  if (
                    !e &&
                    "async" === n.name &&
                    this.match(u._function) &&
                    !this.canInsertSemicolon()
                  )
                    return this.next(), this.parseFunction(r, void 0, !0);
                  if (
                    t &&
                    !e &&
                    "async" === n.name &&
                    this.match(u.name) &&
                    !this.canInsertSemicolon()
                  ) {
                    const e = [this.parseIdentifier()];
                    return (
                      this.expect(u.arrow),
                      this.parseArrowExpression(r, e, !0),
                      r
                    );
                  }
                  return t && this.match(u.arrow) && !this.canInsertSemicolon()
                    ? (this.next(), this.parseArrowExpression(r, [n], !1), r)
                    : n;
                }
                case u._do: {
                  this.expectPlugin("doExpressions");
                  const e = this.startNode();
                  this.next();
                  const t = this.state.labels;
                  return (
                    (this.state.labels = []),
                    (e.body = this.parseBlock()),
                    (this.state.labels = t),
                    this.finishNode(e, "DoExpression")
                  );
                }
                case u.regexp: {
                  const e = this.state.value;
                  return (
                    ((r = this.parseLiteral(e.value, "RegExpLiteral")).pattern =
                      e.pattern),
                    (r.flags = e.flags),
                    r
                  );
                }
                case u.num:
                  return this.parseLiteral(this.state.value, "NumericLiteral");
                case u.bigint:
                  return this.parseLiteral(this.state.value, "BigIntLiteral");
                case u.string:
                  return this.parseLiteral(this.state.value, "StringLiteral");
                case u._null:
                  return (
                    (r = this.startNode()),
                    this.next(),
                    this.finishNode(r, "NullLiteral")
                  );
                case u._true:
                case u._false:
                  return this.parseBooleanLiteral();
                case u.parenL:
                  return this.parseParenAndDistinguishExpression(t);
                case u.bracketL: {
                  const t = this.state.inFSharpPipelineDirectBody;
                  return (
                    (this.state.inFSharpPipelineDirectBody = !1),
                    (r = this.startNode()),
                    this.next(),
                    (r.elements = this.parseExprList(u.bracketR, !0, e)),
                    this.state.maybeInArrowParameters ||
                      this.toReferencedList(r.elements),
                    (this.state.inFSharpPipelineDirectBody = t),
                    this.finishNode(r, "ArrayExpression")
                  );
                }
                case u.braceL: {
                  const t = this.state.inFSharpPipelineDirectBody;
                  this.state.inFSharpPipelineDirectBody = !1;
                  const r = this.parseObj(!1, e);
                  return (this.state.inFSharpPipelineDirectBody = t), r;
                }
                case u._function:
                  return this.parseFunctionExpression();
                case u.at:
                  this.parseDecorators();
                case u._class:
                  return (
                    (r = this.startNode()),
                    this.takeDecorators(r),
                    this.parseClass(r, !1)
                  );
                case u._new:
                  return this.parseNew();
                case u.backQuote:
                  return this.parseTemplate(!1);
                case u.doubleColon: {
                  (r = this.startNode()), this.next(), (r.object = null);
                  const e = (r.callee = this.parseNoCallExpr());
                  if ("MemberExpression" === e.type)
                    return this.finishNode(r, "BindExpression");
                  throw this.raise(
                    e.start,
                    "Binding should be performed on object property."
                  );
                }
                case u.hash:
                  if (this.state.inPipeline) {
                    if (
                      ((r = this.startNode()),
                      "smart" !==
                        this.getPluginOption("pipelineOperator", "proposal") &&
                        this.raise(
                          r.start,
                          "Primary Topic Reference found but pipelineOperator not passed 'smart' for 'proposal' option."
                        ),
                      this.next(),
                      this.primaryTopicReferenceIsAllowedInCurrentTopicContext())
                    )
                      return (
                        this.registerTopicReference(),
                        this.finishNode(r, "PipelinePrimaryTopicReference")
                      );
                    throw this.raise(
                      r.start,
                      "Topic reference was used in a lexical context without topic binding"
                    );
                  }
                default:
                  throw this.unexpected();
              }
            }
            parseBooleanLiteral() {
              const e = this.startNode();
              return (
                (e.value = this.match(u._true)),
                this.next(),
                this.finishNode(e, "BooleanLiteral")
              );
            }
            parseMaybePrivateName() {
              if (this.match(u.hash)) {
                this.expectOnePlugin([
                  "classPrivateProperties",
                  "classPrivateMethods"
                ]);
                const e = this.startNode();
                return (
                  this.next(),
                  this.assertNoSpace(
                    "Unexpected space between # and identifier"
                  ),
                  (e.id = this.parseIdentifier(!0)),
                  this.finishNode(e, "PrivateName")
                );
              }
              return this.parseIdentifier(!0);
            }
            parseFunctionExpression() {
              const e = this.startNode();
              let t = this.startNode();
              return (
                this.next(),
                (t = this.createIdentifier(t, "function")),
                this.scope.inGenerator && this.eat(u.dot)
                  ? this.parseMetaProperty(e, t, "sent")
                  : this.parseFunction(e)
              );
            }
            parseMetaProperty(e, t, r) {
              (e.meta = t),
                "function" === t.name &&
                  "sent" === r &&
                  (this.isContextual(r)
                    ? this.expectPlugin("functionSent")
                    : this.hasPlugin("functionSent") || this.unexpected());
              const n = this.state.containsEsc;
              return (
                (e.property = this.parseIdentifier(!0)),
                (e.property.name !== r || n) &&
                  this.raise(
                    e.property.start,
                    `The only valid meta property for ${t.name} is ${t.name}.${r}`
                  ),
                this.finishNode(e, "MetaProperty")
              );
            }
            parseImportMetaProperty(e) {
              const t = this.createIdentifier(
                this.startNodeAtNode(e),
                "import"
              );
              return (
                this.expect(u.dot),
                this.isContextual("meta")
                  ? this.expectPlugin("importMeta")
                  : this.hasPlugin("importMeta") ||
                    this.raise(
                      t.start,
                      "Dynamic imports require a parameter: import('a.js')"
                    ),
                this.inModule ||
                  this.raise(
                    t.start,
                    "import.meta may appear only with 'sourceType: \"module\"'",
                    { code: "BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED" }
                  ),
                (this.sawUnambiguousESM = !0),
                this.parseMetaProperty(e, t, "meta")
              );
            }
            parseLiteral(e, t, r, n) {
              (r = r || this.state.start), (n = n || this.state.startLoc);
              const i = this.startNodeAt(r, n);
              return (
                this.addExtra(i, "rawValue", e),
                this.addExtra(i, "raw", this.input.slice(r, this.state.end)),
                (i.value = e),
                this.next(),
                this.finishNode(i, t)
              );
            }
            parseParenAndDistinguishExpression(e) {
              const t = this.state.start,
                r = this.state.startLoc;
              let n;
              this.expect(u.parenL);
              const i = this.state.maybeInArrowParameters,
                s = this.state.yieldPos,
                a = this.state.awaitPos,
                o = this.state.inFSharpPipelineDirectBody;
              (this.state.maybeInArrowParameters = !0),
                (this.state.yieldPos = 0),
                (this.state.awaitPos = 0),
                (this.state.inFSharpPipelineDirectBody = !1);
              const l = this.state.start,
                c = this.state.startLoc,
                p = [],
                d = { start: 0 },
                h = { start: 0 };
              let f,
                m,
                y = !0;
              for (; !this.match(u.parenR); ) {
                if (y) y = !1;
                else if (
                  (this.expect(u.comma, h.start || null), this.match(u.parenR))
                ) {
                  m = this.state.start;
                  break;
                }
                if (this.match(u.ellipsis)) {
                  const e = this.state.start,
                    t = this.state.startLoc;
                  (f = this.state.start),
                    p.push(this.parseParenItem(this.parseRestBinding(), e, t)),
                    this.checkCommaAfterRest();
                  break;
                }
                p.push(this.parseMaybeAssign(!1, d, this.parseParenItem, h));
              }
              const g = this.state.start,
                b = this.state.startLoc;
              this.expect(u.parenR),
                (this.state.maybeInArrowParameters = i),
                (this.state.inFSharpPipelineDirectBody = o);
              let v = this.startNodeAt(t, r);
              if (e && this.shouldParseArrow() && (v = this.parseArrow(v))) {
                this.checkYieldAwaitInDefaultParams(),
                  (this.state.yieldPos = s),
                  (this.state.awaitPos = a);
                for (let e = 0; e < p.length; e++) {
                  const t = p[e];
                  t.extra &&
                    t.extra.parenthesized &&
                    this.unexpected(t.extra.parenStart);
                }
                return this.parseArrowExpression(v, p, !1), v;
              }
              if (
                ((this.state.yieldPos = s || this.state.yieldPos),
                (this.state.awaitPos = a || this.state.awaitPos),
                p.length || this.unexpected(this.state.lastTokStart),
                m && this.unexpected(m),
                f && this.unexpected(f),
                d.start && this.unexpected(d.start),
                h.start && this.unexpected(h.start),
                this.toReferencedListDeep(p, !0),
                p.length > 1
                  ? (((n = this.startNodeAt(l, c)).expressions = p),
                    this.finishNodeAt(n, "SequenceExpression", g, b))
                  : (n = p[0]),
                !this.options.createParenthesizedExpressions)
              )
                return (
                  this.addExtra(n, "parenthesized", !0),
                  this.addExtra(n, "parenStart", t),
                  n
                );
              const E = this.startNodeAt(t, r);
              return (
                (E.expression = n),
                this.finishNode(E, "ParenthesizedExpression"),
                E
              );
            }
            shouldParseArrow() {
              return !this.canInsertSemicolon();
            }
            parseArrow(e) {
              if (this.eat(u.arrow)) return e;
            }
            parseParenItem(e, t, r) {
              return e;
            }
            parseNew() {
              const e = this.startNode(),
                t = this.parseIdentifier(!0);
              if (this.eat(u.dot)) {
                const r = this.parseMetaProperty(e, t, "target");
                if (
                  !this.scope.inNonArrowFunction &&
                  !this.state.inClassProperty
                ) {
                  let e = "new.target can only be used in functions";
                  this.hasPlugin("classProperties") &&
                    (e += " or class properties"),
                    this.raise(r.start, e);
                }
                return r;
              }
              return (
                (e.callee = this.parseNoCallExpr()),
                "Import" === e.callee.type
                  ? this.raise(
                      e.callee.start,
                      "Cannot use new with import(...)"
                    )
                  : "OptionalMemberExpression" === e.callee.type ||
                    "OptionalCallExpression" === e.callee.type
                  ? this.raise(
                      this.state.lastTokEnd,
                      "constructors in/after an Optional Chain are not allowed"
                    )
                  : this.eat(u.questionDot) &&
                    this.raise(
                      this.state.start,
                      "constructors in/after an Optional Chain are not allowed"
                    ),
                this.parseNewArguments(e),
                this.finishNode(e, "NewExpression")
              );
            }
            parseNewArguments(e) {
              if (this.eat(u.parenL)) {
                const t = this.parseExprList(u.parenR);
                this.toReferencedList(t), (e.arguments = t);
              } else e.arguments = [];
            }
            parseTemplateElement(e) {
              const t = this.startNode();
              return (
                null === this.state.value &&
                  (e
                    ? (this.state.invalidTemplateEscapePosition = null)
                    : this.raise(
                        this.state.invalidTemplateEscapePosition || 0,
                        "Invalid escape sequence in template"
                      )),
                (t.value = {
                  raw: this.input
                    .slice(this.state.start, this.state.end)
                    .replace(/\r\n?/g, "\n"),
                  cooked: this.state.value
                }),
                this.next(),
                (t.tail = this.match(u.backQuote)),
                this.finishNode(t, "TemplateElement")
              );
            }
            parseTemplate(e) {
              const t = this.startNode();
              this.next(), (t.expressions = []);
              let r = this.parseTemplateElement(e);
              for (t.quasis = [r]; !r.tail; )
                this.expect(u.dollarBraceL),
                  t.expressions.push(this.parseExpression()),
                  this.expect(u.braceR),
                  t.quasis.push((r = this.parseTemplateElement(e)));
              return this.next(), this.finishNode(t, "TemplateLiteral");
            }
            parseObj(e, t) {
              const r = Object.create(null);
              let n = !0;
              const i = this.startNode();
              for (i.properties = [], this.next(); !this.eat(u.braceR); ) {
                if (n) n = !1;
                else if ((this.expect(u.comma), this.eat(u.braceR))) break;
                const s = this.parseObjectMember(e, t);
                e || this.checkPropClash(s, r),
                  s.shorthand && this.addExtra(s, "shorthand", !0),
                  i.properties.push(s);
              }
              return this.finishNode(
                i,
                e ? "ObjectPattern" : "ObjectExpression"
              );
            }
            isAsyncProp(e) {
              return (
                !e.computed &&
                "Identifier" === e.key.type &&
                "async" === e.key.name &&
                (this.match(u.name) ||
                  this.match(u.num) ||
                  this.match(u.string) ||
                  this.match(u.bracketL) ||
                  this.state.type.keyword ||
                  this.match(u.star)) &&
                !this.hasPrecedingLineBreak()
              );
            }
            parseObjectMember(e, t) {
              let r = [];
              if (this.match(u.at))
                if (this.hasPlugin("decorators"))
                  this.raise(
                    this.state.start,
                    "Stage 2 decorators disallow object literal property decorators"
                  );
                else for (; this.match(u.at); ) r.push(this.parseDecorator());
              const n = this.startNode();
              let i,
                s,
                a = !1,
                o = !1;
              if (this.match(u.ellipsis))
                return (
                  r.length && this.unexpected(),
                  e
                    ? (this.next(),
                      (n.argument = this.parseIdentifier()),
                      this.checkCommaAfterRest(),
                      this.finishNode(n, "RestElement"))
                    : this.parseSpread()
                );
              r.length && ((n.decorators = r), (r = [])),
                (n.method = !1),
                (e || t) && ((i = this.state.start), (s = this.state.startLoc)),
                e || (a = this.eat(u.star));
              const l = this.state.containsEsc;
              return (
                this.parsePropertyName(n),
                e || l || a || !this.isAsyncProp(n)
                  ? (o = !1)
                  : ((o = !0),
                    (a = this.eat(u.star)),
                    this.parsePropertyName(n)),
                this.parseObjPropValue(n, i, s, a, o, e, t, l),
                n
              );
            }
            isGetterOrSetterMethod(e, t) {
              return (
                !t &&
                !e.computed &&
                "Identifier" === e.key.type &&
                ("get" === e.key.name || "set" === e.key.name) &&
                (this.match(u.string) ||
                  this.match(u.num) ||
                  this.match(u.bracketL) ||
                  this.match(u.name) ||
                  !!this.state.type.keyword)
              );
            }
            getGetterSetterExpectedParamCount(e) {
              return "get" === e.kind ? 0 : 1;
            }
            checkGetterSetterParams(e) {
              const t = this.getGetterSetterExpectedParamCount(e),
                r = e.start;
              e.params.length !== t &&
                ("get" === e.kind
                  ? this.raise(r, "getter must not have any formal parameters")
                  : this.raise(
                      r,
                      "setter must have exactly one formal parameter"
                    )),
                "set" === e.kind &&
                  "RestElement" === e.params[e.params.length - 1].type &&
                  this.raise(
                    r,
                    "setter function argument must not be a rest parameter"
                  );
            }
            parseObjectMethod(e, t, r, n, i) {
              return r || t || this.match(u.parenL)
                ? (n && this.unexpected(),
                  (e.kind = "method"),
                  (e.method = !0),
                  this.parseMethod(e, t, r, !1, !1, "ObjectMethod"))
                : !i && this.isGetterOrSetterMethod(e, n)
                ? ((t || r) && this.unexpected(),
                  (e.kind = e.key.name),
                  this.parsePropertyName(e),
                  this.parseMethod(e, !1, !1, !1, !1, "ObjectMethod"),
                  this.checkGetterSetterParams(e),
                  e)
                : void 0;
            }
            parseObjectProperty(e, t, r, n, i) {
              return (
                (e.shorthand = !1),
                this.eat(u.colon)
                  ? ((e.value = n
                      ? this.parseMaybeDefault(
                          this.state.start,
                          this.state.startLoc
                        )
                      : this.parseMaybeAssign(!1, i)),
                    this.finishNode(e, "ObjectProperty"))
                  : e.computed || "Identifier" !== e.key.type
                  ? void 0
                  : (this.checkReservedWord(e.key.name, e.key.start, !0, !0),
                    n
                      ? (e.value = this.parseMaybeDefault(
                          t,
                          r,
                          e.key.__clone()
                        ))
                      : this.match(u.eq) && i
                      ? (i.start || (i.start = this.state.start),
                        (e.value = this.parseMaybeDefault(
                          t,
                          r,
                          e.key.__clone()
                        )))
                      : (e.value = e.key.__clone()),
                    (e.shorthand = !0),
                    this.finishNode(e, "ObjectProperty"))
              );
            }
            parseObjPropValue(e, t, r, n, i, s, a, o) {
              const u =
                this.parseObjectMethod(e, n, i, s, o) ||
                this.parseObjectProperty(e, t, r, s, a);
              return u || this.unexpected(), u;
            }
            parsePropertyName(e) {
              if (this.eat(u.bracketL))
                (e.computed = !0),
                  (e.key = this.parseMaybeAssign()),
                  this.expect(u.bracketR);
              else {
                const t = this.state.inPropertyName;
                (this.state.inPropertyName = !0),
                  (e.key =
                    this.match(u.num) || this.match(u.string)
                      ? this.parseExprAtom()
                      : this.parseMaybePrivateName()),
                  "PrivateName" !== e.key.type && (e.computed = !1),
                  (this.state.inPropertyName = t);
              }
              return e.key;
            }
            initFunction(e, t) {
              (e.id = null), (e.generator = !1), (e.async = !!t);
            }
            parseMethod(e, t, r, n, i, s, a = !1) {
              const o = this.state.yieldPos,
                u = this.state.awaitPos;
              (this.state.yieldPos = 0),
                (this.state.awaitPos = 0),
                this.initFunction(e, r),
                (e.generator = !!t);
              const l = n;
              return (
                this.scope.enter(
                  E(r, e.generator) | y | (a ? b : 0) | (i ? g : 0)
                ),
                this.parseFunctionParams(e, l),
                this.checkYieldAwaitInDefaultParams(),
                this.parseFunctionBodyAndFinish(e, s, !0),
                this.scope.exit(),
                (this.state.yieldPos = o),
                (this.state.awaitPos = u),
                e
              );
            }
            parseArrowExpression(e, t, r) {
              this.scope.enter(E(r, !1) | f), this.initFunction(e, r);
              const n = this.state.maybeInArrowParameters,
                i = this.state.yieldPos,
                s = this.state.awaitPos;
              return (
                (this.state.maybeInArrowParameters = !1),
                (this.state.yieldPos = 0),
                (this.state.awaitPos = 0),
                t && this.setArrowFunctionParameters(e, t),
                this.parseFunctionBody(e, !0),
                this.scope.exit(),
                (this.state.maybeInArrowParameters = n),
                (this.state.yieldPos = i),
                (this.state.awaitPos = s),
                this.finishNode(e, "ArrowFunctionExpression")
              );
            }
            setArrowFunctionParameters(e, t) {
              e.params = this.toAssignableList(
                t,
                !0,
                "arrow function parameters"
              );
            }
            isStrictBody(e) {
              if ("BlockStatement" === e.body.type && e.body.directives.length)
                for (let t = 0, r = e.body.directives; t < r.length; t++) {
                  if ("use strict" === r[t].value.value) return !0;
                }
              return !1;
            }
            parseFunctionBodyAndFinish(e, t, r = !1) {
              this.parseFunctionBody(e, !1, r), this.finishNode(e, t);
            }
            parseFunctionBody(e, t, r = !1) {
              const n = t && !this.match(u.braceL),
                i = this.state.strict;
              let s = !1;
              const a = this.state.inParameters;
              if (((this.state.inParameters = !1), n))
                (e.body = this.parseMaybeAssign()), this.checkParams(e, !1, t);
              else {
                const n = !this.isSimpleParamList(e.params);
                if (
                  (!i || n) &&
                  (s = this.strictDirective(this.state.end)) &&
                  n
                ) {
                  const t =
                    ("method" !== e.kind && "constructor" !== e.kind) || !e.key
                      ? e.start
                      : e.key.end;
                  this.raise(
                    t,
                    "Illegal 'use strict' directive in function with non-simple parameter list"
                  );
                }
                const a = this.state.labels;
                (this.state.labels = []),
                  s && (this.state.strict = !0),
                  this.checkParams(e, !(i || s || t || r || n), t),
                  (e.body = this.parseBlock(!0, !1)),
                  (this.state.labels = a);
              }
              (this.state.inParameters = a),
                this.state.strict &&
                  e.id &&
                  this.checkLVal(e.id, R, void 0, "function name"),
                (this.state.strict = i);
            }
            isSimpleParamList(e) {
              for (let t = 0, r = e.length; t < r; t++)
                if ("Identifier" !== e[t].type) return !1;
              return !0;
            }
            checkParams(e, t, r) {
              const n = Object.create(null);
              for (let r = 0; r < e.params.length; r++)
                this.checkLVal(
                  e.params[r],
                  k,
                  t ? null : n,
                  "function paramter list"
                );
            }
            parseExprList(e, t, r) {
              const n = [];
              let i = !0;
              for (; !this.eat(e); ) {
                if (i) i = !1;
                else if ((this.expect(u.comma), this.eat(e))) break;
                n.push(this.parseExprListItem(t, r));
              }
              return n;
            }
            parseExprListItem(e, t, r, n) {
              let i;
              if (e && this.match(u.comma)) i = null;
              else if (this.match(u.ellipsis)) {
                const e = this.state.start,
                  n = this.state.startLoc;
                i = this.parseParenItem(this.parseSpread(t, r), e, n);
              } else if (this.match(u.question)) {
                this.expectPlugin("partialApplication"),
                  n ||
                    this.raise(
                      this.state.start,
                      "Unexpected argument placeholder"
                    );
                const e = this.startNode();
                this.next(), (i = this.finishNode(e, "ArgumentPlaceholder"));
              } else i = this.parseMaybeAssign(!1, t, this.parseParenItem, r);
              return i;
            }
            parseIdentifier(e) {
              const t = this.startNode(),
                r = this.parseIdentifierName(t.start, e);
              return this.createIdentifier(t, r);
            }
            createIdentifier(e, t) {
              return (
                (e.name = t),
                (e.loc.identifierName = t),
                this.finishNode(e, "Identifier")
              );
            }
            parseIdentifierName(e, t) {
              let r;
              if (this.match(u.name)) r = this.state.value;
              else {
                if (!this.state.type.keyword) throw this.unexpected();
                ("class" !== (r = this.state.type.keyword) &&
                  "function" !== r) ||
                  (this.state.lastTokEnd === this.state.lastTokStart + 1 &&
                    46 === this.input.charCodeAt(this.state.lastTokStart)) ||
                  this.state.context.pop();
              }
              return (
                t ||
                  this.checkReservedWord(
                    r,
                    this.state.start,
                    !!this.state.type.keyword,
                    !1
                  ),
                this.next(),
                r
              );
            }
            checkReservedWord(e, t, r, n) {
              this.scope.inGenerator &&
                "yield" === e &&
                this.raise(
                  t,
                  "Can not use 'yield' as identifier inside a generator"
                ),
                this.scope.inAsync &&
                  "await" === e &&
                  this.raise(
                    t,
                    "Can not use 'await' as identifier inside an async function"
                  ),
                this.state.inClassProperty &&
                  "arguments" === e &&
                  this.raise(
                    t,
                    "'arguments' is not allowed in class field initializer"
                  ),
                r &&
                  (function(e) {
                    return s.has(e);
                  })(e) &&
                  this.raise(t, `Unexpected keyword '${e}'`),
                (this.state.strict ? (n ? te : ee) : Z)(e, this.inModule) &&
                  (this.scope.inAsync ||
                    "await" !== e ||
                    this.raise(
                      t,
                      "Can not use keyword 'await' outside an async function"
                    ),
                  this.raise(t, `Unexpected reserved word '${e}'`));
            }
            parseAwait() {
              this.state.awaitPos || (this.state.awaitPos = this.state.start);
              const e = this.startNode();
              return (
                this.next(),
                this.state.inParameters &&
                  this.raise(
                    e.start,
                    "await is not allowed in async function parameters"
                  ),
                this.match(u.star) &&
                  this.raise(
                    e.start,
                    "await* has been removed from the async functions proposal. Use Promise.all() instead."
                  ),
                this.state.soloAwait || (e.argument = this.parseMaybeUnary()),
                this.finishNode(e, "AwaitExpression")
              );
            }
            parseYield(e) {
              this.state.yieldPos || (this.state.yieldPos = this.state.start);
              const t = this.startNode();
              return (
                this.state.inParameters &&
                  this.raise(
                    t.start,
                    "yield is not allowed in generator parameters"
                  ),
                this.next(),
                this.match(u.semi) ||
                (!this.match(u.star) && !this.state.type.startsExpr) ||
                this.canInsertSemicolon()
                  ? ((t.delegate = !1), (t.argument = null))
                  : ((t.delegate = this.eat(u.star)),
                    (t.argument = this.parseMaybeAssign(e))),
                this.finishNode(t, "YieldExpression")
              );
            }
            checkPipelineAtInfixOperator(e, t) {
              if (
                "smart" ===
                  this.getPluginOption("pipelineOperator", "proposal") &&
                "SequenceExpression" === e.type
              )
                throw this.raise(
                  t,
                  "Pipeline head should not be a comma-separated sequence expression"
                );
            }
            parseSmartPipelineBody(e, t, r) {
              const n = this.checkSmartPipelineBodyStyle(e);
              return (
                this.checkSmartPipelineBodyEarlyErrors(e, n, t),
                this.parseSmartPipelineBodyInStyle(e, n, t, r)
              );
            }
            checkSmartPipelineBodyEarlyErrors(e, t, r) {
              if (this.match(u.arrow))
                throw this.raise(
                  this.state.start,
                  'Unexpected arrow "=>" after pipeline body; arrow function in pipeline body must be parenthesized'
                );
              if (
                "PipelineTopicExpression" === t &&
                "SequenceExpression" === e.type
              )
                throw this.raise(
                  r,
                  "Pipeline body may not be a comma-separated sequence expression"
                );
            }
            parseSmartPipelineBodyInStyle(e, t, r, n) {
              const i = this.startNodeAt(r, n);
              switch (t) {
                case "PipelineBareFunction":
                  i.callee = e;
                  break;
                case "PipelineBareConstructor":
                  i.callee = e.callee;
                  break;
                case "PipelineBareAwaitedFunction":
                  i.callee = e.argument;
                  break;
                case "PipelineTopicExpression":
                  if (!this.topicReferenceWasUsedInCurrentTopicContext())
                    throw this.raise(
                      r,
                      "Pipeline is in topic style but does not use topic reference"
                    );
                  i.expression = e;
                  break;
                default:
                  throw this.raise(r, `Unknown pipeline style ${t}`);
              }
              return this.finishNode(i, t);
            }
            checkSmartPipelineBodyStyle(e) {
              return (
                e.type,
                this.isSimpleReference(e)
                  ? "PipelineBareFunction"
                  : "PipelineTopicExpression"
              );
            }
            isSimpleReference(e) {
              switch (e.type) {
                case "MemberExpression":
                  return !e.computed && this.isSimpleReference(e.object);
                case "Identifier":
                  return !0;
                default:
                  return !1;
              }
            }
            withTopicPermittingContext(e) {
              const t = this.state.topicContext;
              this.state.topicContext = {
                maxNumOfResolvableTopics: 1,
                maxTopicIndex: null
              };
              try {
                return e();
              } finally {
                this.state.topicContext = t;
              }
            }
            withTopicForbiddingContext(e) {
              const t = this.state.topicContext;
              this.state.topicContext = {
                maxNumOfResolvableTopics: 0,
                maxTopicIndex: null
              };
              try {
                return e();
              } finally {
                this.state.topicContext = t;
              }
            }
            withSoloAwaitPermittingContext(e) {
              const t = this.state.soloAwait;
              this.state.soloAwait = !0;
              try {
                return e();
              } finally {
                this.state.soloAwait = t;
              }
            }
            registerTopicReference() {
              this.state.topicContext.maxTopicIndex = 0;
            }
            primaryTopicReferenceIsAllowedInCurrentTopicContext() {
              return this.state.topicContext.maxNumOfResolvableTopics >= 1;
            }
            topicReferenceWasUsedInCurrentTopicContext() {
              return (
                null != this.state.topicContext.maxTopicIndex &&
                this.state.topicContext.maxTopicIndex >= 0
              );
            }
            parseFSharpPipelineBody(e, t) {
              const r = this.state.start,
                n = this.state.startLoc;
              this.state.potentialArrowAt = this.state.start;
              const i = this.state.inFSharpPipelineDirectBody;
              this.state.inFSharpPipelineDirectBody = !0;
              const s = this.parseExprOp(this.parseMaybeUnary(), r, n, e, t);
              return (this.state.inFSharpPipelineDirectBody = i), s;
            }
          }
          const et = { kind: "loop" },
            tt = { kind: "switch" },
            rt = 0,
            nt = 1,
            it = 2,
            st = 4;
          class at extends Ze {
            parseTopLevel(e, t) {
              if (
                ((t.sourceType = this.options.sourceType),
                (t.interpreter = this.parseInterpreterDirective()),
                this.parseBlockBody(t, !0, !0, u.eof),
                this.inModule &&
                  !this.options.allowUndeclaredExports &&
                  this.scope.undefinedExports.size > 0)
              )
                for (
                  let e = 0, t = Array.from(this.scope.undefinedExports);
                  e < t.length;
                  e++
                ) {
                  const [r] = t[e],
                    n = this.scope.undefinedExports.get(r);
                  this.raise(n, `Export '${r}' is not defined`);
                }
              return (
                (e.program = this.finishNode(t, "Program")),
                (e.comments = this.state.comments),
                this.options.tokens && (e.tokens = this.state.tokens),
                this.finishNode(e, "File")
              );
            }
            stmtToDirective(e) {
              const t = e.expression,
                r = this.startNodeAt(t.start, t.loc.start),
                n = this.startNodeAt(e.start, e.loc.start),
                i = this.input.slice(t.start, t.end),
                s = (r.value = i.slice(1, -1));
              return (
                this.addExtra(r, "raw", i),
                this.addExtra(r, "rawValue", s),
                (n.value = this.finishNodeAt(
                  r,
                  "DirectiveLiteral",
                  t.end,
                  t.loc.end
                )),
                this.finishNodeAt(n, "Directive", e.end, e.loc.end)
              );
            }
            parseInterpreterDirective() {
              if (!this.match(u.interpreterDirective)) return null;
              const e = this.startNode();
              return (
                (e.value = this.state.value),
                this.next(),
                this.finishNode(e, "InterpreterDirective")
              );
            }
            isLet(e) {
              if (!this.isContextual("let")) return !1;
              J.lastIndex = this.state.pos;
              const t = J.exec(this.input),
                r = this.state.pos + t[0].length,
                n = this.input.charCodeAt(r);
              if (91 === n) return !0;
              if (e) return !1;
              if (123 === n) return !0;
              if (ce(n)) {
                let e = r + 1;
                for (; pe(this.input.charCodeAt(e)); ) ++e;
                const t = this.input.slice(r, e);
                if (!re.test(t)) return !0;
              }
              return !1;
            }
            parseStatement(e, t) {
              return (
                this.match(u.at) && this.parseDecorators(!0),
                this.parseStatementContent(e, t)
              );
            }
            parseStatementContent(e, t) {
              let r = this.state.type;
              const n = this.startNode();
              let i;
              switch ((this.isLet(e) && ((r = u._var), (i = "let")), r)) {
                case u._break:
                case u._continue:
                  return this.parseBreakContinueStatement(n, r.keyword);
                case u._debugger:
                  return this.parseDebuggerStatement(n);
                case u._do:
                  return this.parseDoStatement(n);
                case u._for:
                  return this.parseForStatement(n);
                case u._function:
                  if (this.lookahead().type === u.dot) break;
                  return (
                    e &&
                      (this.state.strict
                        ? this.raise(
                            this.state.start,
                            "In strict mode code, functions can only be declared at top level or inside a block"
                          )
                        : "if" !== e &&
                          "label" !== e &&
                          this.raise(
                            this.state.start,
                            "In non-strict mode code, functions can only be declared at top level, inside a block, or as the body of an if statement"
                          )),
                    this.parseFunctionStatement(n, !1, !e)
                  );
                case u._class:
                  return e && this.unexpected(), this.parseClass(n, !0);
                case u._if:
                  return this.parseIfStatement(n);
                case u._return:
                  return this.parseReturnStatement(n);
                case u._switch:
                  return this.parseSwitchStatement(n);
                case u._throw:
                  return this.parseThrowStatement(n);
                case u._try:
                  return this.parseTryStatement(n);
                case u._const:
                case u._var:
                  return (
                    (i = i || this.state.value),
                    e &&
                      "var" !== i &&
                      this.unexpected(
                        this.state.start,
                        "Lexical declaration cannot appear in a single-statement context"
                      ),
                    this.parseVarStatement(n, i)
                  );
                case u._while:
                  return this.parseWhileStatement(n);
                case u._with:
                  return this.parseWithStatement(n);
                case u.braceL:
                  return this.parseBlock();
                case u.semi:
                  return this.parseEmptyStatement(n);
                case u._export:
                case u._import: {
                  const e = this.lookahead();
                  if (e.type === u.parenL || e.type === u.dot) break;
                  let i;
                  return (
                    this.options.allowImportExportEverywhere ||
                      t ||
                      this.raise(
                        this.state.start,
                        "'import' and 'export' may only appear at the top level"
                      ),
                    this.next(),
                    r === u._import
                      ? "ImportDeclaration" !==
                          (i = this.parseImport(n)).type ||
                        (i.importKind && "value" !== i.importKind) ||
                        (this.sawUnambiguousESM = !0)
                      : (("ExportNamedDeclaration" !==
                          (i = this.parseExport(n)).type ||
                          (i.exportKind && "value" !== i.exportKind)) &&
                          ("ExportAllDeclaration" !== i.type ||
                            (i.exportKind && "value" !== i.exportKind)) &&
                          "ExportDefaultDeclaration" !== i.type) ||
                        (this.sawUnambiguousESM = !0),
                    this.assertModuleNodeAllowed(n),
                    i
                  );
                }
                default:
                  if (this.isAsyncFunction())
                    return (
                      e &&
                        this.unexpected(
                          null,
                          "Async functions can only be declared at the top level or inside a block"
                        ),
                      this.next(),
                      this.parseFunctionStatement(n, !0, !e)
                    );
              }
              const s = this.state.value,
                a = this.parseExpression();
              return r === u.name &&
                "Identifier" === a.type &&
                this.eat(u.colon)
                ? this.parseLabeledStatement(n, s, a, e)
                : this.parseExpressionStatement(n, a);
            }
            assertModuleNodeAllowed(e) {
              this.options.allowImportExportEverywhere ||
                this.inModule ||
                this.raise(
                  e.start,
                  "'import' and 'export' may appear only with 'sourceType: \"module\"'",
                  { code: "BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED" }
                );
            }
            takeDecorators(e) {
              const t = this.state.decoratorStack[
                this.state.decoratorStack.length - 1
              ];
              t.length &&
                ((e.decorators = t),
                this.resetStartLocationFromNode(e, t[0]),
                (this.state.decoratorStack[
                  this.state.decoratorStack.length - 1
                ] = []));
            }
            canHaveLeadingDecorator() {
              return this.match(u._class);
            }
            parseDecorators(e) {
              const t = this.state.decoratorStack[
                this.state.decoratorStack.length - 1
              ];
              for (; this.match(u.at); ) {
                const e = this.parseDecorator();
                t.push(e);
              }
              this.match(u._export)
                ? (e || this.unexpected(),
                  this.hasPlugin("decorators") &&
                    !this.getPluginOption(
                      "decorators",
                      "decoratorsBeforeExport"
                    ) &&
                    this.raise(
                      this.state.start,
                      "Using the export keyword between a decorator and a class is not allowed. Please use `export @dec class` instead."
                    ))
                : this.canHaveLeadingDecorator() ||
                  this.raise(
                    this.state.start,
                    "Leading decorators must be attached to a class declaration"
                  );
            }
            parseDecorator() {
              this.expectOnePlugin(["decorators-legacy", "decorators"]);
              const e = this.startNode();
              if ((this.next(), this.hasPlugin("decorators"))) {
                this.state.decoratorStack.push([]);
                const t = this.state.start,
                  r = this.state.startLoc;
                let n;
                if (this.eat(u.parenL))
                  (n = this.parseExpression()), this.expect(u.parenR);
                else
                  for (n = this.parseIdentifier(!1); this.eat(u.dot); ) {
                    const e = this.startNodeAt(t, r);
                    (e.object = n),
                      (e.property = this.parseIdentifier(!0)),
                      (e.computed = !1),
                      (n = this.finishNode(e, "MemberExpression"));
                  }
                (e.expression = this.parseMaybeDecoratorArguments(n)),
                  this.state.decoratorStack.pop();
              } else e.expression = this.parseExprSubscripts();
              return this.finishNode(e, "Decorator");
            }
            parseMaybeDecoratorArguments(e) {
              if (this.eat(u.parenL)) {
                const t = this.startNodeAtNode(e);
                return (
                  (t.callee = e),
                  (t.arguments = this.parseCallExpressionArguments(
                    u.parenR,
                    !1
                  )),
                  this.toReferencedList(t.arguments),
                  this.finishNode(t, "CallExpression")
                );
              }
              return e;
            }
            parseBreakContinueStatement(e, t) {
              const r = "break" === t;
              return (
                this.next(),
                this.isLineTerminator()
                  ? (e.label = null)
                  : ((e.label = this.parseIdentifier()), this.semicolon()),
                this.verifyBreakContinue(e, t),
                this.finishNode(e, r ? "BreakStatement" : "ContinueStatement")
              );
            }
            verifyBreakContinue(e, t) {
              const r = "break" === t;
              let n;
              for (n = 0; n < this.state.labels.length; ++n) {
                const t = this.state.labels[n];
                if (null == e.label || t.name === e.label.name) {
                  if (null != t.kind && (r || "loop" === t.kind)) break;
                  if (e.label && r) break;
                }
              }
              n === this.state.labels.length &&
                this.raise(e.start, "Unsyntactic " + t);
            }
            parseDebuggerStatement(e) {
              return (
                this.next(),
                this.semicolon(),
                this.finishNode(e, "DebuggerStatement")
              );
            }
            parseHeaderExpression() {
              this.expect(u.parenL);
              const e = this.parseExpression();
              return this.expect(u.parenR), e;
            }
            parseDoStatement(e) {
              return (
                this.next(),
                this.state.labels.push(et),
                (e.body = this.withTopicForbiddingContext(() =>
                  this.parseStatement("do")
                )),
                this.state.labels.pop(),
                this.expect(u._while),
                (e.test = this.parseHeaderExpression()),
                this.eat(u.semi),
                this.finishNode(e, "DoWhileStatement")
              );
            }
            parseForStatement(e) {
              this.next(), this.state.labels.push(et);
              let t = -1;
              if (
                ((this.scope.inAsync ||
                  (!this.scope.inFunction &&
                    this.options.allowAwaitOutsideFunction)) &&
                  this.eatContextual("await") &&
                  (t = this.state.lastTokStart),
                this.scope.enter(l),
                this.expect(u.parenL),
                this.match(u.semi))
              )
                return t > -1 && this.unexpected(t), this.parseFor(e, null);
              const r = this.isLet();
              if (this.match(u._var) || this.match(u._const) || r) {
                const n = this.startNode(),
                  i = r ? "let" : this.state.value;
                return (
                  this.next(),
                  this.parseVar(n, !0, i),
                  this.finishNode(n, "VariableDeclaration"),
                  (this.match(u._in) || this.isContextual("of")) &&
                  1 === n.declarations.length
                    ? this.parseForIn(e, n, t)
                    : (t > -1 && this.unexpected(t), this.parseFor(e, n))
                );
              }
              const n = { start: 0 },
                i = this.parseExpression(!0, n);
              if (this.match(u._in) || this.isContextual("of")) {
                const r = this.isContextual("of")
                  ? "for-of statement"
                  : "for-in statement";
                return (
                  this.toAssignable(i, void 0, r),
                  this.checkLVal(i, void 0, void 0, r),
                  this.parseForIn(e, i, t)
                );
              }
              return (
                n.start && this.unexpected(n.start),
                t > -1 && this.unexpected(t),
                this.parseFor(e, i)
              );
            }
            parseFunctionStatement(e, t, r) {
              return this.next(), this.parseFunction(e, nt | (r ? 0 : it), t);
            }
            parseIfStatement(e) {
              return (
                this.next(),
                (e.test = this.parseHeaderExpression()),
                (e.consequent = this.parseStatement("if")),
                (e.alternate = this.eat(u._else)
                  ? this.parseStatement("if")
                  : null),
                this.finishNode(e, "IfStatement")
              );
            }
            parseReturnStatement(e) {
              return (
                this.scope.inFunction ||
                  this.options.allowReturnOutsideFunction ||
                  this.raise(this.state.start, "'return' outside of function"),
                this.next(),
                this.isLineTerminator()
                  ? (e.argument = null)
                  : ((e.argument = this.parseExpression()), this.semicolon()),
                this.finishNode(e, "ReturnStatement")
              );
            }
            parseSwitchStatement(e) {
              this.next(), (e.discriminant = this.parseHeaderExpression());
              const t = (e.cases = []);
              let r, n;
              for (
                this.expect(u.braceL),
                  this.state.labels.push(tt),
                  this.scope.enter(l);
                !this.match(u.braceR);

              )
                if (this.match(u._case) || this.match(u._default)) {
                  const e = this.match(u._case);
                  r && this.finishNode(r, "SwitchCase"),
                    t.push((r = this.startNode())),
                    (r.consequent = []),
                    this.next(),
                    e
                      ? (r.test = this.parseExpression())
                      : (n &&
                          this.raise(
                            this.state.lastTokStart,
                            "Multiple default clauses"
                          ),
                        (n = !0),
                        (r.test = null)),
                    this.expect(u.colon);
                } else
                  r
                    ? r.consequent.push(this.parseStatement(null))
                    : this.unexpected();
              return (
                this.scope.exit(),
                r && this.finishNode(r, "SwitchCase"),
                this.next(),
                this.state.labels.pop(),
                this.finishNode(e, "SwitchStatement")
              );
            }
            parseThrowStatement(e) {
              return (
                this.next(),
                K.test(
                  this.input.slice(this.state.lastTokEnd, this.state.start)
                ) &&
                  this.raise(
                    this.state.lastTokEnd,
                    "Illegal newline after throw"
                  ),
                (e.argument = this.parseExpression()),
                this.semicolon(),
                this.finishNode(e, "ThrowStatement")
              );
            }
            parseTryStatement(e) {
              if (
                (this.next(),
                (e.block = this.parseBlock()),
                (e.handler = null),
                this.match(u._catch))
              ) {
                const t = this.startNode();
                if ((this.next(), this.match(u.parenL))) {
                  this.expect(u.parenL), (t.param = this.parseBindingAtom());
                  const e = "Identifier" === t.param.type;
                  this.scope.enter(e ? m : 0),
                    this.checkLVal(t.param, O, null, "catch clause"),
                    this.expect(u.parenR);
                } else (t.param = null), this.scope.enter(l);
                (t.body = this.withTopicForbiddingContext(() =>
                  this.parseBlock(!1, !1)
                )),
                  this.scope.exit(),
                  (e.handler = this.finishNode(t, "CatchClause"));
              }
              return (
                (e.finalizer = this.eat(u._finally) ? this.parseBlock() : null),
                e.handler ||
                  e.finalizer ||
                  this.raise(e.start, "Missing catch or finally clause"),
                this.finishNode(e, "TryStatement")
              );
            }
            parseVarStatement(e, t) {
              return (
                this.next(),
                this.parseVar(e, !1, t),
                this.semicolon(),
                this.finishNode(e, "VariableDeclaration")
              );
            }
            parseWhileStatement(e) {
              return (
                this.next(),
                (e.test = this.parseHeaderExpression()),
                this.state.labels.push(et),
                (e.body = this.withTopicForbiddingContext(() =>
                  this.parseStatement("while")
                )),
                this.state.labels.pop(),
                this.finishNode(e, "WhileStatement")
              );
            }
            parseWithStatement(e) {
              return (
                this.state.strict &&
                  this.raise(this.state.start, "'with' in strict mode"),
                this.next(),
                (e.object = this.parseHeaderExpression()),
                (e.body = this.withTopicForbiddingContext(() =>
                  this.parseStatement("with")
                )),
                this.finishNode(e, "WithStatement")
              );
            }
            parseEmptyStatement(e) {
              return this.next(), this.finishNode(e, "EmptyStatement");
            }
            parseLabeledStatement(e, t, r, n) {
              for (let e = 0, n = this.state.labels; e < n.length; e++) {
                n[e].name === t &&
                  this.raise(r.start, `Label '${t}' is already declared`);
              }
              const i = this.state.type.isLoop
                ? "loop"
                : this.match(u._switch)
                ? "switch"
                : null;
              for (let t = this.state.labels.length - 1; t >= 0; t--) {
                const r = this.state.labels[t];
                if (r.statementStart !== e.start) break;
                (r.statementStart = this.state.start), (r.kind = i);
              }
              return (
                this.state.labels.push({
                  name: t,
                  kind: i,
                  statementStart: this.state.start
                }),
                (e.body = this.parseStatement(
                  n ? (-1 === n.indexOf("label") ? n + "label" : n) : "label"
                )),
                this.state.labels.pop(),
                (e.label = r),
                this.finishNode(e, "LabeledStatement")
              );
            }
            parseExpressionStatement(e, t) {
              return (
                (e.expression = t),
                this.semicolon(),
                this.finishNode(e, "ExpressionStatement")
              );
            }
            parseBlock(e = !1, t = !0) {
              const r = this.startNode();
              return (
                this.expect(u.braceL),
                t && this.scope.enter(l),
                this.parseBlockBody(r, e, !1, u.braceR),
                t && this.scope.exit(),
                this.finishNode(r, "BlockStatement")
              );
            }
            isValidDirective(e) {
              return (
                "ExpressionStatement" === e.type &&
                "StringLiteral" === e.expression.type &&
                !e.expression.extra.parenthesized
              );
            }
            parseBlockBody(e, t, r, n) {
              const i = (e.body = []),
                s = (e.directives = []);
              this.parseBlockOrModuleBlockBody(i, t ? s : void 0, r, n);
            }
            parseBlockOrModuleBlockBody(e, t, r, n) {
              let i,
                s,
                a = !1;
              for (; !this.eat(n); ) {
                a ||
                  !this.state.containsOctal ||
                  s ||
                  (s = this.state.octalPosition);
                const n = this.parseStatement(null, r);
                if (t && !a && this.isValidDirective(n)) {
                  const e = this.stmtToDirective(n);
                  t.push(e),
                    void 0 === i &&
                      "use strict" === e.value.value &&
                      ((i = this.state.strict),
                      this.setStrict(!0),
                      s && this.raise(s, "Octal literal in strict mode"));
                } else (a = !0), e.push(n);
              }
              !1 === i && this.setStrict(!1);
            }
            parseFor(e, t) {
              return (
                (e.init = t),
                this.expect(u.semi),
                (e.test = this.match(u.semi) ? null : this.parseExpression()),
                this.expect(u.semi),
                (e.update = this.match(u.parenR)
                  ? null
                  : this.parseExpression()),
                this.expect(u.parenR),
                (e.body = this.withTopicForbiddingContext(() =>
                  this.parseStatement("for")
                )),
                this.scope.exit(),
                this.state.labels.pop(),
                this.finishNode(e, "ForStatement")
              );
            }
            parseForIn(e, t, r) {
              const n = this.match(u._in);
              return (
                this.next(),
                n ? r > -1 && this.unexpected(r) : (e.await = r > -1),
                "VariableDeclaration" !== t.type ||
                null == t.declarations[0].init ||
                (n &&
                  !this.state.strict &&
                  "var" === t.kind &&
                  "Identifier" === t.declarations[0].id.type)
                  ? "AssignmentPattern" === t.type &&
                    this.raise(t.start, "Invalid left-hand side in for-loop")
                  : this.raise(
                      t.start,
                      `${
                        n ? "for-in" : "for-of"
                      } loop variable declaration may not have an initializer`
                    ),
                (e.left = t),
                (e.right = n
                  ? this.parseExpression()
                  : this.parseMaybeAssign()),
                this.expect(u.parenR),
                (e.body = this.withTopicForbiddingContext(() =>
                  this.parseStatement("for")
                )),
                this.scope.exit(),
                this.state.labels.pop(),
                this.finishNode(e, n ? "ForInStatement" : "ForOfStatement")
              );
            }
            parseVar(e, t, r) {
              const n = (e.declarations = []),
                i = this.hasPlugin("typescript");
              for (e.kind = r; ; ) {
                const e = this.startNode();
                if (
                  (this.parseVarId(e, r),
                  this.eat(u.eq)
                    ? (e.init = this.parseMaybeAssign(t))
                    : ("const" !== r ||
                      this.match(u._in) ||
                      this.isContextual("of")
                        ? "Identifier" === e.id.type ||
                          (t &&
                            (this.match(u._in) || this.isContextual("of"))) ||
                          this.raise(
                            this.state.lastTokEnd,
                            "Complex binding patterns require an initialization value"
                          )
                        : i || this.unexpected(),
                      (e.init = null)),
                  n.push(this.finishNode(e, "VariableDeclarator")),
                  !this.eat(u.comma))
                )
                  break;
              }
              return e;
            }
            parseVarId(e, t) {
              (e.id = this.parseBindingAtom()),
                this.checkLVal(
                  e.id,
                  "var" === t ? k : O,
                  void 0,
                  "variable declaration"
                );
            }
            parseFunction(e, t = rt, r = !1) {
              const n = t & nt,
                i = t & it,
                s = !(!n || t & st);
              this.initFunction(e, r),
                this.match(u.star) &&
                  i &&
                  this.unexpected(
                    this.state.start,
                    "Generators can only be declared at the top level or inside a block"
                  ),
                (e.generator = this.eat(u.star)),
                n && (e.id = this.parseFunctionId(s));
              const a = this.state.inClassProperty,
                o = this.state.yieldPos,
                l = this.state.awaitPos;
              return (
                (this.state.inClassProperty = !1),
                (this.state.yieldPos = 0),
                (this.state.awaitPos = 0),
                this.scope.enter(E(e.async, e.generator)),
                n || (e.id = this.parseFunctionId()),
                this.parseFunctionParams(e),
                this.withTopicForbiddingContext(() => {
                  this.parseFunctionBodyAndFinish(
                    e,
                    n ? "FunctionDeclaration" : "FunctionExpression"
                  );
                }),
                this.scope.exit(),
                n && !i && this.checkFunctionStatementId(e),
                (this.state.inClassProperty = a),
                (this.state.yieldPos = o),
                (this.state.awaitPos = l),
                e
              );
            }
            parseFunctionId(e) {
              return e || this.match(u.name) ? this.parseIdentifier() : null;
            }
            parseFunctionParams(e, t) {
              const r = this.state.inParameters;
              (this.state.inParameters = !0),
                this.expect(u.parenL),
                (e.params = this.parseBindingList(u.parenR, !1, t)),
                (this.state.inParameters = r),
                this.checkYieldAwaitInDefaultParams();
            }
            checkFunctionStatementId(e) {
              e.id &&
                this.checkLVal(
                  e.id,
                  this.state.strict || e.generator || e.async
                    ? this.scope.treatFunctionsAsVar
                      ? k
                      : O
                    : I,
                  null,
                  "function name"
                );
            }
            parseClass(e, t, r) {
              this.next(), this.takeDecorators(e);
              const n = this.state.strict;
              return (
                (this.state.strict = !0),
                this.parseClassId(e, t, r),
                this.parseClassSuper(e),
                (e.body = this.parseClassBody(!!e.superClass)),
                (this.state.strict = n),
                this.finishNode(e, t ? "ClassDeclaration" : "ClassExpression")
              );
            }
            isClassProperty() {
              return (
                this.match(u.eq) || this.match(u.semi) || this.match(u.braceR)
              );
            }
            isClassMethod() {
              return this.match(u.parenL);
            }
            isNonstaticConstructor(e) {
              return !(
                e.computed ||
                e.static ||
                ("constructor" !== e.key.name && "constructor" !== e.key.value)
              );
            }
            parseClassBody(e) {
              this.state.classLevel++;
              const t = { hadConstructor: !1 };
              let r = [];
              const n = this.startNode();
              return (
                (n.body = []),
                this.expect(u.braceL),
                this.withTopicForbiddingContext(() => {
                  for (; !this.eat(u.braceR); ) {
                    if (this.eat(u.semi)) {
                      r.length > 0 &&
                        this.raise(
                          this.state.lastTokEnd,
                          "Decorators must not be followed by a semicolon"
                        );
                      continue;
                    }
                    if (this.match(u.at)) {
                      r.push(this.parseDecorator());
                      continue;
                    }
                    const i = this.startNode();
                    r.length &&
                      ((i.decorators = r),
                      this.resetStartLocationFromNode(i, r[0]),
                      (r = [])),
                      this.parseClassMember(n, i, t, e),
                      "constructor" === i.kind &&
                        i.decorators &&
                        i.decorators.length > 0 &&
                        this.raise(
                          i.start,
                          "Decorators can't be used with a constructor. Did you mean '@dec class { ... }'?"
                        );
                  }
                }),
                r.length &&
                  this.raise(
                    this.state.start,
                    "You have trailing decorators with no method"
                  ),
                this.state.classLevel--,
                this.finishNode(n, "ClassBody")
              );
            }
            parseClassMember(e, t, r, n) {
              let i = !1;
              const s = this.state.containsEsc;
              if (this.match(u.name) && "static" === this.state.value) {
                const r = this.parseIdentifier(!0);
                if (this.isClassMethod()) {
                  const n = t;
                  return (
                    (n.kind = "method"),
                    (n.computed = !1),
                    (n.key = r),
                    (n.static = !1),
                    void this.pushClassMethod(e, n, !1, !1, !1, !1)
                  );
                }
                if (this.isClassProperty()) {
                  const n = t;
                  return (
                    (n.computed = !1),
                    (n.key = r),
                    (n.static = !1),
                    void e.body.push(this.parseClassProperty(n))
                  );
                }
                if (s) throw this.unexpected();
                i = !0;
              }
              this.parseClassMemberWithIsStatic(e, t, r, i, n);
            }
            parseClassMemberWithIsStatic(e, t, r, n, i) {
              const s = t,
                a = t,
                o = t,
                l = t,
                c = s,
                p = s;
              if (((t.static = n), this.eat(u.star)))
                return (
                  (c.kind = "method"),
                  this.parseClassPropertyName(c),
                  "PrivateName" === c.key.type
                    ? void this.pushClassPrivateMethod(e, a, !0, !1)
                    : (this.isNonstaticConstructor(s) &&
                        this.raise(
                          s.key.start,
                          "Constructor can't be a generator"
                        ),
                      void this.pushClassMethod(e, s, !0, !1, !1, !1))
                );
              const d = this.state.containsEsc,
                h = this.parseClassPropertyName(t),
                f = "PrivateName" === h.type,
                m = "Identifier" === h.type;
              if (
                (this.parsePostMemberNameModifiers(p), this.isClassMethod())
              ) {
                if (((c.kind = "method"), f))
                  return void this.pushClassPrivateMethod(e, a, !1, !1);
                const t = this.isNonstaticConstructor(s);
                let n = !1;
                t &&
                  ((s.kind = "constructor"),
                  s.decorators &&
                    this.raise(
                      s.start,
                      "You can't attach decorators to a class constructor"
                    ),
                  r.hadConstructor &&
                    !this.hasPlugin("typescript") &&
                    this.raise(
                      h.start,
                      "Duplicate constructor in the same class"
                    ),
                  (r.hadConstructor = !0),
                  (n = i)),
                  this.pushClassMethod(e, s, !1, !1, t, n);
              } else if (this.isClassProperty())
                f
                  ? this.pushClassPrivateProperty(e, l)
                  : this.pushClassProperty(e, o);
              else if (!m || "async" !== h.name || d || this.isLineTerminator())
                !m ||
                ("get" !== h.name && "set" !== h.name) ||
                d ||
                (this.match(u.star) && this.isLineTerminator())
                  ? this.isLineTerminator()
                    ? f
                      ? this.pushClassPrivateProperty(e, l)
                      : this.pushClassProperty(e, o)
                    : this.unexpected()
                  : ((c.kind = h.name),
                    this.parseClassPropertyName(s),
                    "PrivateName" === c.key.type
                      ? this.pushClassPrivateMethod(e, a, !1, !1)
                      : (this.isNonstaticConstructor(s) &&
                          this.raise(
                            s.key.start,
                            "Constructor can't have get/set modifier"
                          ),
                        this.pushClassMethod(e, s, !1, !1, !1, !1)),
                    this.checkGetterSetterParams(s));
              else {
                const t = this.eat(u.star);
                (c.kind = "method"),
                  this.parseClassPropertyName(c),
                  "PrivateName" === c.key.type
                    ? this.pushClassPrivateMethod(e, a, t, !0)
                    : (this.isNonstaticConstructor(s) &&
                        this.raise(
                          s.key.start,
                          "Constructor can't be an async function"
                        ),
                      this.pushClassMethod(e, s, t, !0, !1, !1));
              }
            }
            parseClassPropertyName(e) {
              const t = this.parsePropertyName(e);
              return (
                e.computed ||
                  !e.static ||
                  ("prototype" !== t.name && "prototype" !== t.value) ||
                  this.raise(
                    t.start,
                    "Classes may not have static property named prototype"
                  ),
                "PrivateName" === t.type &&
                  "constructor" === t.id.name &&
                  this.raise(
                    t.start,
                    "Classes may not have a private field named '#constructor'"
                  ),
                t
              );
            }
            pushClassProperty(e, t) {
              this.isNonstaticConstructor(t) &&
                this.raise(
                  t.key.start,
                  "Classes may not have a non-static field named 'constructor'"
                ),
                e.body.push(this.parseClassProperty(t));
            }
            pushClassPrivateProperty(e, t) {
              this.expectPlugin("classPrivateProperties", t.key.start),
                e.body.push(this.parseClassPrivateProperty(t));
            }
            pushClassMethod(e, t, r, n, i, s) {
              e.body.push(this.parseMethod(t, r, n, i, s, "ClassMethod", !0));
            }
            pushClassPrivateMethod(e, t, r, n) {
              this.expectPlugin("classPrivateMethods", t.key.start),
                e.body.push(
                  this.parseMethod(t, r, n, !1, !1, "ClassPrivateMethod", !0)
                );
            }
            parsePostMemberNameModifiers(e) {}
            parseAccessModifier() {}
            parseClassPrivateProperty(e) {
              return (
                (this.state.inClassProperty = !0),
                this.scope.enter(b | y),
                (e.value = this.eat(u.eq) ? this.parseMaybeAssign() : null),
                this.semicolon(),
                (this.state.inClassProperty = !1),
                this.scope.exit(),
                this.finishNode(e, "ClassPrivateProperty")
              );
            }
            parseClassProperty(e) {
              return (
                e.typeAnnotation || this.expectPlugin("classProperties"),
                (this.state.inClassProperty = !0),
                this.scope.enter(b | y),
                this.match(u.eq)
                  ? (this.expectPlugin("classProperties"),
                    this.next(),
                    (e.value = this.parseMaybeAssign()))
                  : (e.value = null),
                this.semicolon(),
                (this.state.inClassProperty = !1),
                this.scope.exit(),
                this.finishNode(e, "ClassProperty")
              );
            }
            parseClassId(e, t, r) {
              this.match(u.name)
                ? ((e.id = this.parseIdentifier()),
                  t && this.checkLVal(e.id, _, void 0, "class name"))
                : r || !t
                ? (e.id = null)
                : this.unexpected(null, "A class name is required");
            }
            parseClassSuper(e) {
              e.superClass = this.eat(u._extends)
                ? this.parseExprSubscripts()
                : null;
            }
            parseExport(e) {
              const t = this.maybeParseExportDefaultSpecifier(e),
                r = !t || this.eat(u.comma),
                n = r && this.eatExportStar(e),
                i = n && this.maybeParseExportNamespaceSpecifier(e),
                s = r && (!i || this.eat(u.comma)),
                a = t || n;
              if (n && !i)
                return (
                  t && this.unexpected(),
                  this.parseExportFrom(e, !0),
                  this.finishNode(e, "ExportAllDeclaration")
                );
              const o = this.maybeParseExportNamedSpecifiers(e);
              if ((t && r && !n && !o) || (i && s && !o))
                throw this.unexpected(null, u.braceL);
              let l;
              if (
                (a || o
                  ? ((l = !1), this.parseExportFrom(e, a))
                  : (l = this.maybeParseExportDeclaration(e)),
                a || o || l)
              )
                return (
                  this.checkExport(e, !0, !1, !!e.source),
                  this.finishNode(e, "ExportNamedDeclaration")
                );
              if (this.eat(u._default))
                return (
                  (e.declaration = this.parseExportDefaultExpression()),
                  this.checkExport(e, !0, !0),
                  this.finishNode(e, "ExportDefaultDeclaration")
                );
              throw this.unexpected(null, u.braceL);
            }
            eatExportStar(e) {
              return this.eat(u.star);
            }
            maybeParseExportDefaultSpecifier(e) {
              if (this.isExportDefaultSpecifier()) {
                this.expectPlugin("exportDefaultFrom");
                const t = this.startNode();
                return (
                  (t.exported = this.parseIdentifier(!0)),
                  (e.specifiers = [
                    this.finishNode(t, "ExportDefaultSpecifier")
                  ]),
                  !0
                );
              }
              return !1;
            }
            maybeParseExportNamespaceSpecifier(e) {
              if (this.isContextual("as")) {
                e.specifiers || (e.specifiers = []),
                  this.expectPlugin("exportNamespaceFrom");
                const t = this.startNodeAt(
                  this.state.lastTokStart,
                  this.state.lastTokStartLoc
                );
                return (
                  this.next(),
                  (t.exported = this.parseIdentifier(!0)),
                  e.specifiers.push(
                    this.finishNode(t, "ExportNamespaceSpecifier")
                  ),
                  !0
                );
              }
              return !1;
            }
            maybeParseExportNamedSpecifiers(e) {
              return (
                !!this.match(u.braceL) &&
                (e.specifiers || (e.specifiers = []),
                e.specifiers.push(...this.parseExportSpecifiers()),
                (e.source = null),
                (e.declaration = null),
                !0)
              );
            }
            maybeParseExportDeclaration(e) {
              if (this.shouldParseExportDeclaration()) {
                if (this.isContextual("async")) {
                  const e = this.lookahead();
                  e.type !== u._function &&
                    this.unexpected(
                      e.start,
                      'Unexpected token, expected "function"'
                    );
                }
                return (
                  (e.specifiers = []),
                  (e.source = null),
                  (e.declaration = this.parseExportDeclaration(e)),
                  !0
                );
              }
              return !1;
            }
            isAsyncFunction() {
              if (!this.isContextual("async")) return !1;
              const { pos: e } = this.state;
              J.lastIndex = e;
              const t = J.exec(this.input);
              if (!t || !t.length) return !1;
              const r = e + t[0].length;
              return !(
                K.test(this.input.slice(e, r)) ||
                "function" !== this.input.slice(r, r + 8) ||
                (r + 8 !== this.length && pe(this.input.charCodeAt(r + 8)))
              );
            }
            parseExportDefaultExpression() {
              const e = this.startNode(),
                t = this.isAsyncFunction();
              if (this.match(u._function) || t)
                return (
                  this.next(),
                  t && this.next(),
                  this.parseFunction(e, nt | st, t)
                );
              if (this.match(u._class)) return this.parseClass(e, !0, !0);
              if (this.match(u.at))
                return (
                  this.hasPlugin("decorators") &&
                    this.getPluginOption(
                      "decorators",
                      "decoratorsBeforeExport"
                    ) &&
                    this.unexpected(
                      this.state.start,
                      "Decorators must be placed *before* the 'export' keyword. You can set the 'decoratorsBeforeExport' option to false to use the 'export @decorator class {}' syntax"
                    ),
                  this.parseDecorators(!1),
                  this.parseClass(e, !0, !0)
                );
              if (this.match(u._const) || this.match(u._var) || this.isLet())
                return this.raise(
                  this.state.start,
                  "Only expressions, functions or classes are allowed as the `default` export."
                );
              {
                const e = this.parseMaybeAssign();
                return this.semicolon(), e;
              }
            }
            parseExportDeclaration(e) {
              return this.parseStatement(null);
            }
            isExportDefaultSpecifier() {
              if (this.match(u.name))
                return (
                  "async" !== this.state.value && "let" !== this.state.value
                );
              if (!this.match(u._default)) return !1;
              const e = this.lookahead();
              return (
                e.type === u.comma || (e.type === u.name && "from" === e.value)
              );
            }
            parseExportFrom(e, t) {
              this.eatContextual("from")
                ? ((e.source = this.parseImportSource()), this.checkExport(e))
                : t
                ? this.unexpected()
                : (e.source = null),
                this.semicolon();
            }
            shouldParseExportDeclaration() {
              if (
                this.match(u.at) &&
                (this.expectOnePlugin(["decorators", "decorators-legacy"]),
                this.hasPlugin("decorators"))
              ) {
                if (
                  !this.getPluginOption("decorators", "decoratorsBeforeExport")
                )
                  return !0;
                this.unexpected(
                  this.state.start,
                  "Decorators must be placed *before* the 'export' keyword. You can set the 'decoratorsBeforeExport' option to false to use the 'export @decorator class {}' syntax"
                );
              }
              return (
                "var" === this.state.type.keyword ||
                "const" === this.state.type.keyword ||
                "function" === this.state.type.keyword ||
                "class" === this.state.type.keyword ||
                this.isLet() ||
                this.isAsyncFunction()
              );
            }
            checkExport(e, t, r, n) {
              if (t)
                if (r) this.checkDuplicateExports(e, "default");
                else if (e.specifiers && e.specifiers.length)
                  for (let t = 0, r = e.specifiers; t < r.length; t++) {
                    const e = r[t];
                    this.checkDuplicateExports(e, e.exported.name),
                      !n &&
                        e.local &&
                        (this.checkReservedWord(
                          e.local.name,
                          e.local.start,
                          !0,
                          !1
                        ),
                        this.scope.checkLocalExport(e.local));
                  }
                else if (e.declaration)
                  if (
                    "FunctionDeclaration" === e.declaration.type ||
                    "ClassDeclaration" === e.declaration.type
                  ) {
                    const t = e.declaration.id;
                    if (!t) throw new Error("Assertion failure");
                    this.checkDuplicateExports(e, t.name);
                  } else if ("VariableDeclaration" === e.declaration.type)
                    for (
                      let t = 0, r = e.declaration.declarations;
                      t < r.length;
                      t++
                    ) {
                      const e = r[t];
                      this.checkDeclaration(e.id);
                    }
              if (
                this.state.decoratorStack[this.state.decoratorStack.length - 1]
                  .length
              ) {
                const t =
                  e.declaration &&
                  ("ClassDeclaration" === e.declaration.type ||
                    "ClassExpression" === e.declaration.type);
                if (!e.declaration || !t)
                  throw this.raise(
                    e.start,
                    "You can only use decorators on an export when exporting a class"
                  );
                this.takeDecorators(e.declaration);
              }
            }
            checkDeclaration(e) {
              if ("Identifier" === e.type)
                this.checkDuplicateExports(e, e.name);
              else if ("ObjectPattern" === e.type)
                for (let t = 0, r = e.properties; t < r.length; t++) {
                  const e = r[t];
                  this.checkDeclaration(e);
                }
              else if ("ArrayPattern" === e.type)
                for (let t = 0, r = e.elements; t < r.length; t++) {
                  const e = r[t];
                  e && this.checkDeclaration(e);
                }
              else
                "ObjectProperty" === e.type
                  ? this.checkDeclaration(e.value)
                  : "RestElement" === e.type
                  ? this.checkDeclaration(e.argument)
                  : "AssignmentPattern" === e.type &&
                    this.checkDeclaration(e.left);
            }
            checkDuplicateExports(e, t) {
              if (this.state.exportedIdentifiers.indexOf(t) > -1)
                throw this.raise(
                  e.start,
                  "default" === t
                    ? "Only one default export allowed per module."
                    : `\`${t}\` has already been exported. Exported identifiers must be unique.`
                );
              this.state.exportedIdentifiers.push(t);
            }
            parseExportSpecifiers() {
              const e = [];
              let t = !0;
              for (this.expect(u.braceL); !this.eat(u.braceR); ) {
                if (t) t = !1;
                else if ((this.expect(u.comma), this.eat(u.braceR))) break;
                const r = this.startNode();
                (r.local = this.parseIdentifier(!0)),
                  (r.exported = this.eatContextual("as")
                    ? this.parseIdentifier(!0)
                    : r.local.__clone()),
                  e.push(this.finishNode(r, "ExportSpecifier"));
              }
              return e;
            }
            parseImport(e) {
              if (((e.specifiers = []), !this.match(u.string))) {
                const t =
                    !this.maybeParseDefaultImportSpecifier(e) ||
                    this.eat(u.comma),
                  r = t && this.maybeParseStarImportSpecifier(e);
                t && !r && this.parseNamedImportSpecifiers(e),
                  this.expectContextual("from");
              }
              return (
                (e.source = this.parseImportSource()),
                this.semicolon(),
                this.finishNode(e, "ImportDeclaration")
              );
            }
            parseImportSource() {
              return (
                this.match(u.string) || this.unexpected(), this.parseExprAtom()
              );
            }
            shouldParseDefaultImport(e) {
              return this.match(u.name);
            }
            parseImportSpecifierLocal(e, t, r, n) {
              (t.local = this.parseIdentifier()),
                this.checkLVal(t.local, O, void 0, n),
                e.specifiers.push(this.finishNode(t, r));
            }
            maybeParseDefaultImportSpecifier(e) {
              return (
                !!this.shouldParseDefaultImport(e) &&
                (this.parseImportSpecifierLocal(
                  e,
                  this.startNode(),
                  "ImportDefaultSpecifier",
                  "default import specifier"
                ),
                !0)
              );
            }
            maybeParseStarImportSpecifier(e) {
              if (this.match(u.star)) {
                const t = this.startNode();
                return (
                  this.next(),
                  this.expectContextual("as"),
                  this.parseImportSpecifierLocal(
                    e,
                    t,
                    "ImportNamespaceSpecifier",
                    "import namespace specifier"
                  ),
                  !0
                );
              }
              return !1;
            }
            parseNamedImportSpecifiers(e) {
              let t = !0;
              for (this.expect(u.braceL); !this.eat(u.braceR); ) {
                if (t) t = !1;
                else if (
                  (this.eat(u.colon) &&
                    this.unexpected(
                      null,
                      "ES2015 named imports do not destructure. Use another statement for destructuring after the import."
                    ),
                  this.expect(u.comma),
                  this.eat(u.braceR))
                )
                  break;
                this.parseImportSpecifier(e);
              }
            }
            parseImportSpecifier(e) {
              const t = this.startNode();
              (t.imported = this.parseIdentifier(!0)),
                this.eatContextual("as")
                  ? (t.local = this.parseIdentifier())
                  : (this.checkReservedWord(t.imported.name, t.start, !0, !0),
                    (t.local = t.imported.__clone())),
                this.checkLVal(t.local, O, void 0, "import specifier"),
                e.specifiers.push(this.finishNode(t, "ImportSpecifier"));
            }
          }
          class ot extends at {
            constructor(e, t) {
              super(
                (e = (function(e) {
                  const t = {};
                  for (let r = 0, n = Object.keys(Ie); r < n.length; r++) {
                    const i = n[r];
                    t[i] = e && null != e[i] ? e[i] : Ie[i];
                  }
                  return t;
                })(e)),
                t
              );
              const r = this.getScopeHandler();
              (this.options = e),
                (this.inModule = "module" === this.options.sourceType),
                (this.scope = new r(this.raise.bind(this), this.inModule)),
                (this.plugins = (function(e) {
                  const t = new Map();
                  for (let r = 0; r < e.length; r++) {
                    const n = e[r],
                      [i, s] = Array.isArray(n) ? n : [n, {}];
                    t.has(i) || t.set(i, s || {});
                  }
                  return t;
                })(this.options.plugins)),
                (this.filename = e.sourceFilename);
            }
            getScopeHandler() {
              return Ae;
            }
            parse() {
              this.scope.enter(c);
              const e = this.startNode(),
                t = this.startNode();
              return this.nextToken(), this.parseTopLevel(e, t);
            }
          }
          function ut(e, t) {
            let r = ot;
            return (
              e &&
                e.plugins &&
                (!(function(e) {
                  if (we(e, "decorators")) {
                    if (we(e, "decorators-legacy"))
                      throw new Error(
                        "Cannot use the decorators and decorators-legacy plugin together"
                      );
                    const t = Fe(e, "decorators", "decoratorsBeforeExport");
                    if (null == t)
                      throw new Error(
                        "The 'decorators' plugin requires a 'decoratorsBeforeExport' option, whose value must be a boolean. If you are migrating from Babylon/Babel 6 or want to use the old decorators proposal, you should use the 'decorators-legacy' plugin instead of 'decorators'."
                      );
                    if ("boolean" != typeof t)
                      throw new Error(
                        "'decoratorsBeforeExport' must be a boolean."
                      );
                  }
                  if (we(e, "flow") && we(e, "typescript"))
                    throw new Error(
                      "Cannot combine flow and typescript plugins."
                    );
                  if (
                    we(e, "pipelineOperator") &&
                    !_e.includes(Fe(e, "pipelineOperator", "proposal"))
                  )
                    throw new Error(
                      "'pipelineOperator' requires 'proposal' option whose value should be one of: " +
                        _e.map(e => `'${e}'`).join(", ")
                    );
                })(e.plugins),
                (r = (function(e) {
                  const t = ke.filter(t => we(e, t)),
                    r = t.join("/");
                  let n = lt[r];
                  if (!n) {
                    n = ot;
                    for (let e = 0; e < t.length; e++) {
                      const r = t[e];
                      n = Oe[r](n);
                    }
                    lt[r] = n;
                  }
                  return n;
                })(e.plugins))),
              new r(e, t)
            );
          }
          const lt = {};
          (r.parse = function(e, t) {
            if (!t || "unambiguous" !== t.sourceType) return ut(t, e).parse();
            t = Object.assign({}, t);
            try {
              t.sourceType = "module";
              const r = ut(t, e),
                n = r.parse();
              return (
                r.sawUnambiguousESM || (n.program.sourceType = "script"), n
              );
            } catch (r) {
              try {
                return (t.sourceType = "script"), ut(t, e).parse();
              } catch (e) {}
              throw r;
            }
          }),
            (r.parseExpression = function(e, t) {
              const r = ut(t, e);
              return (
                r.options.strictMode && (r.state.strict = !0), r.getExpression()
              );
            }),
            (r.tokTypes = u);
        },
        {}
      ],
      26: [
        function(e, t, r) {
          "use strict";
          Object.defineProperty(r, "__esModule", { value: !0 }),
            (r.default = function e(t, r) {
              const a = new WeakMap();
              const l = new WeakMap();
              const c = r || (0, n.validate)(null);
              return Object.assign(
                (r, ...o) => {
                  if ("string" == typeof r) {
                    if (o.length > 1)
                      throw new Error("Unexpected extra params.");
                    return u(
                      (0, i.default)(
                        t,
                        r,
                        (0, n.merge)(c, (0, n.validate)(o[0]))
                      )
                    );
                  }
                  if (Array.isArray(r)) {
                    let e = a.get(r);
                    return (
                      e || ((e = (0, s.default)(t, r, c)), a.set(r, e)), u(e(o))
                    );
                  }
                  if ("object" == typeof r && r) {
                    if (o.length > 0)
                      throw new Error("Unexpected extra params.");
                    return e(t, (0, n.merge)(c, (0, n.validate)(r)));
                  }
                  throw new Error(`Unexpected template param ${typeof r}`);
                },
                {
                  ast: (e, ...r) => {
                    if ("string" == typeof e) {
                      if (r.length > 1)
                        throw new Error("Unexpected extra params.");
                      return (0, i.default)(
                        t,
                        e,
                        (0, n.merge)((0, n.merge)(c, (0, n.validate)(r[0])), o)
                      )();
                    }
                    if (Array.isArray(e)) {
                      let i = l.get(e);
                      return (
                        i ||
                          ((i = (0, s.default)(t, e, (0, n.merge)(c, o))),
                          l.set(e, i)),
                        i(r)()
                      );
                    }
                    throw new Error(`Unexpected template param ${typeof e}`);
                  }
                }
              );
            });
          var n = e("./options"),
            i = a(e("./string")),
            s = a(e("./literal"));
          function a(e) {
            return e && e.__esModule ? e : { default: e };
          }
          const o = (0, n.validate)({ placeholderPattern: !1 });
          function u(e) {
            let t = "";
            try {
              throw new Error();
            } catch (e) {
              e.stack &&
                (t = e.stack
                  .split("\n")
                  .slice(3)
                  .join("\n"));
            }
            return r => {
              try {
                return e(r);
              } catch (e) {
                throw ((e.stack += `\n    =============\n${t}`), e);
              }
            };
          }
        },
        { "./literal": 29, "./options": 30, "./string": 33 }
      ],
      27: [
        function(e, t, r) {
          "use strict";
          function n(e) {
            return {
              code: e => `/* @babel/template */;\n${e}`,
              validate: () => {},
              unwrap: t => e(t.program.body.slice(1))
            };
          }
          Object.defineProperty(r, "__esModule", { value: !0 }),
            (r.program = r.expression = r.statement = r.statements = r.smart = void 0);
          const i = n(e => (e.length > 1 ? e : e[0]));
          r.smart = i;
          const s = n(e => e);
          r.statements = s;
          const a = n(e => {
            if (0 === e.length) throw new Error("Found nothing to return.");
            if (e.length > 1)
              throw new Error("Found multiple statements but wanted one");
            return e[0];
          });
          r.statement = a;
          const o = {
            code: e => `(\n${e}\n)`,
            validate: ({ program: e }) => {
              if (e.body.length > 1)
                throw new Error("Found multiple statements but wanted one");
              if (0 === e.body[0].expression.start)
                throw new Error("Parse result included parens.");
            },
            unwrap: e => e.program.body[0].expression
          };
          r.expression = o;
          r.program = {
            code: e => e,
            validate: () => {},
            unwrap: e => e.program
          };
        },
        {}
      ],
      28: [
        function(e, t, r) {
          "use strict";
          Object.defineProperty(r, "__esModule", { value: !0 }),
            (r.default = r.program = r.expression = r.statements = r.statement = r.smart = void 0);
          var n,
            i = (function(e) {
              if (e && e.__esModule) return e;
              var t = {};
              if (null != e)
                for (var r in e)
                  if (Object.prototype.hasOwnProperty.call(e, r)) {
                    var n =
                      Object.defineProperty && Object.getOwnPropertyDescriptor
                        ? Object.getOwnPropertyDescriptor(e, r)
                        : {};
                    n.get || n.set
                      ? Object.defineProperty(t, r, n)
                      : (t[r] = e[r]);
                  }
              return (t.default = e), t;
            })(e("./formatters")),
            s = (n = e("./builder")) && n.__esModule ? n : { default: n };
          const a = (0, s.default)(i.smart);
          r.smart = a;
          const o = (0, s.default)(i.statement);
          r.statement = o;
          const u = (0, s.default)(i.statements);
          r.statements = u;
          const l = (0, s.default)(i.expression);
          r.expression = l;
          const c = (0, s.default)(i.program);
          r.program = c;
          var p = Object.assign(a.bind(void 0), {
            smart: a,
            statement: o,
            statements: u,
            expression: l,
            program: c,
            ast: a.ast
          });
          r.default = p;
        },
        { "./builder": 26, "./formatters": 27 }
      ],
      29: [
        function(e, t, r) {
          "use strict";
          Object.defineProperty(r, "__esModule", { value: !0 }),
            (r.default = function(e, t, r) {
              const { metadata: a, names: u } = (function(e, t, r) {
                let n,
                  s,
                  a,
                  u = "";
                do {
                  const l = o(t, (u += "$"));
                  (n = l.names),
                    (s = new Set(n)),
                    (a = (0, i.default)(e, e.code(l.code), {
                      parser: r.parser,
                      placeholderWhitelist: new Set(
                        l.names.concat(
                          r.placeholderWhitelist
                            ? Array.from(r.placeholderWhitelist)
                            : []
                        )
                      ),
                      placeholderPattern: r.placeholderPattern,
                      preserveComments: r.preserveComments,
                      syntacticPlaceholders: r.syntacticPlaceholders
                    }));
                } while (
                  a.placeholders.some(e => e.isDuplicate && s.has(e.name))
                );
                return { metadata: a, names: n };
              })(e, t, r);
              return t => {
                const r = t.reduce((e, t, r) => ((e[u[r]] = t), e), {});
                return t => {
                  const i = (0, n.normalizeReplacements)(t);
                  return (
                    i &&
                      Object.keys(i).forEach(e => {
                        if (Object.prototype.hasOwnProperty.call(r, e))
                          throw new Error("Unexpected replacement overlap.");
                      }),
                    e.unwrap((0, s.default)(a, i ? Object.assign(i, r) : r))
                  );
                };
              };
            });
          var n = e("./options"),
            i = a(e("./parse")),
            s = a(e("./populate"));
          function a(e) {
            return e && e.__esModule ? e : { default: e };
          }
          function o(e, t) {
            const r = [];
            let n = e[0];
            for (let i = 1; i < e.length; i++) {
              const s = `${t}${i - 1}`;
              r.push(s), (n += s + e[i]);
            }
            return { names: r, code: n };
          }
        },
        { "./options": 30, "./parse": 31, "./populate": 32 }
      ],
      30: [
        function(e, t, r) {
          "use strict";
          Object.defineProperty(r, "__esModule", { value: !0 }),
            (r.merge = function(e, t) {
              const {
                placeholderWhitelist: r = e.placeholderWhitelist,
                placeholderPattern: n = e.placeholderPattern,
                preserveComments: i = e.preserveComments,
                syntacticPlaceholders: s = e.syntacticPlaceholders
              } = t;
              return {
                parser: Object.assign({}, e.parser, t.parser),
                placeholderWhitelist: r,
                placeholderPattern: n,
                preserveComments: i,
                syntacticPlaceholders: s
              };
            }),
            (r.validate = function(e) {
              if (null != e && "object" != typeof e)
                throw new Error("Unknown template options.");
              const t = e || {},
                {
                  placeholderWhitelist: r,
                  placeholderPattern: n,
                  preserveComments: i,
                  syntacticPlaceholders: s
                } = t,
                a = (function(e, t) {
                  if (null == e) return {};
                  var r,
                    n,
                    i = {},
                    s = Object.keys(e);
                  for (n = 0; n < s.length; n++)
                    (r = s[n]), t.indexOf(r) >= 0 || (i[r] = e[r]);
                  return i;
                })(t, [
                  "placeholderWhitelist",
                  "placeholderPattern",
                  "preserveComments",
                  "syntacticPlaceholders"
                ]);
              if (null != r && !(r instanceof Set))
                throw new Error(
                  "'.placeholderWhitelist' must be a Set, null, or undefined"
                );
              if (null != n && !(n instanceof RegExp) && !1 !== n)
                throw new Error(
                  "'.placeholderPattern' must be a RegExp, false, null, or undefined"
                );
              if (null != i && "boolean" != typeof i)
                throw new Error(
                  "'.preserveComments' must be a boolean, null, or undefined"
                );
              if (null != s && "boolean" != typeof s)
                throw new Error(
                  "'.syntacticPlaceholders' must be a boolean, null, or undefined"
                );
              if (!0 === s && (null != r || null != n))
                throw new Error(
                  "'.placeholderWhitelist' and '.placeholderPattern' aren't compatible with '.syntacticPlaceholders: true'"
                );
              return {
                parser: a,
                placeholderWhitelist: r || void 0,
                placeholderPattern: null == n ? void 0 : n,
                preserveComments: null != i && i,
                syntacticPlaceholders: null == s ? void 0 : s
              };
            }),
            (r.normalizeReplacements = function(e) {
              if (Array.isArray(e))
                return e.reduce((e, t, r) => ((e["$" + r] = t), e), {});
              if ("object" == typeof e || null == e) return e || void 0;
              throw new Error(
                "Template replacements must be an array, object, null, or undefined"
              );
            });
        },
        {}
      ],
      31: [
        function(e, t, r) {
          "use strict";
          function n() {
            const t = (function(e) {
              if (e && e.__esModule) return e;
              var t = {};
              if (null != e)
                for (var r in e)
                  if (Object.prototype.hasOwnProperty.call(e, r)) {
                    var n =
                      Object.defineProperty && Object.getOwnPropertyDescriptor
                        ? Object.getOwnPropertyDescriptor(e, r)
                        : {};
                    n.get || n.set
                      ? Object.defineProperty(t, r, n)
                      : (t[r] = e[r]);
                  }
              return (t.default = e), t;
            })(e("@babel/types"));
            return (
              (n = function() {
                return t;
              }),
              t
            );
          }
          function i() {
            const t = e("@babel/parser");
            return (
              (i = function() {
                return t;
              }),
              t
            );
          }
          function s() {
            const t = e("@babel/code-frame");
            return (
              (s = function() {
                return t;
              }),
              t
            );
          }
          Object.defineProperty(r, "__esModule", { value: !0 }),
            (r.default = function(e, t, r) {
              const a = (function(e, t) {
                  t = Object.assign(
                    {
                      allowReturnOutsideFunction: !0,
                      allowSuperOutsideMethod: !0,
                      sourceType: "module"
                    },
                    t,
                    { plugins: (t.plugins || []).concat("placeholders") }
                  );
                  try {
                    return (0, i().parse)(e, t);
                  } catch (t) {
                    const r = t.loc;
                    throw (r &&
                      ((t.message +=
                        "\n" + (0, s().codeFrameColumns)(e, { start: r })),
                      (t.code = "BABEL_TEMPLATE_PARSE_ERROR")),
                    t);
                  }
                })(t, r.parser),
                {
                  placeholderWhitelist: u,
                  placeholderPattern: l,
                  preserveComments: c,
                  syntacticPlaceholders: p
                } = r;
              n().removePropertiesDeep(a, { preserveComments: c }),
                e.validate(a);
              const d = { placeholders: [], placeholderNames: new Set() },
                h = { placeholders: [], placeholderNames: new Set() },
                f = { value: void 0 };
              return (
                n().traverse(a, o, {
                  syntactic: d,
                  legacy: h,
                  isLegacyRef: f,
                  placeholderWhitelist: u,
                  placeholderPattern: l,
                  syntacticPlaceholders: p
                }),
                Object.assign({ ast: a }, f.value ? h : d)
              );
            });
          const a = /^[_$A-Z0-9]+$/;
          function o(e, t, r) {
            let i;
            if (n().isPlaceholder(e)) {
              if (!1 === r.syntacticPlaceholders)
                throw new Error(
                  "%%foo%%-style placeholders can't be used when '.syntacticPlaceholders' is false."
                );
              (i = e.name.name), (r.isLegacyRef.value = !1);
            } else {
              if (!1 === r.isLegacyRef.value || r.syntacticPlaceholders) return;
              if (n().isIdentifier(e) || n().isJSXIdentifier(e))
                (i = e.name), (r.isLegacyRef.value = !0);
              else {
                if (!n().isStringLiteral(e)) return;
                (i = e.value), (r.isLegacyRef.value = !0);
              }
            }
            if (
              !r.isLegacyRef.value &&
              (null != r.placeholderPattern || null != r.placeholderWhitelist)
            )
              throw new Error(
                "'.placeholderWhitelist' and '.placeholderPattern' aren't compatible with '.syntacticPlaceholders: true'"
              );
            if (
              r.isLegacyRef.value &&
              (!1 === r.placeholderPattern ||
                !(r.placeholderPattern || a).test(i)) &&
              (!r.placeholderWhitelist || !r.placeholderWhitelist.has(i))
            )
              return;
            t = t.slice();
            const { node: s, key: o } = t[t.length - 1];
            let u;
            n().isStringLiteral(e) ||
            n().isPlaceholder(e, { expectedNode: "StringLiteral" })
              ? (u = "string")
              : (n().isNewExpression(s) && "arguments" === o) ||
                (n().isCallExpression(s) && "arguments" === o) ||
                (n().isFunction(s) && "params" === o)
              ? (u = "param")
              : n().isExpressionStatement(s) && !n().isPlaceholder(e)
              ? ((u = "statement"), (t = t.slice(0, -1)))
              : (u =
                  n().isStatement(e) && n().isPlaceholder(e)
                    ? "statement"
                    : "other");
            const { placeholders: l, placeholderNames: c } = r.isLegacyRef.value
              ? r.legacy
              : r.syntactic;
            l.push({
              name: i,
              type: u,
              resolve: e =>
                (function(e, t) {
                  let r = e;
                  for (let e = 0; e < t.length - 1; e++) {
                    const { key: n, index: i } = t[e];
                    r = void 0 === i ? r[n] : r[n][i];
                  }
                  const { key: n, index: i } = t[t.length - 1];
                  return { parent: r, key: n, index: i };
                })(e, t),
              isDuplicate: c.has(i)
            }),
              c.add(i);
          }
        },
        { "@babel/code-frame": 1, "@babel/parser": 25, "@babel/types": 100 }
      ],
      32: [
        function(e, t, r) {
          "use strict";
          function n() {
            const t = (function(e) {
              if (e && e.__esModule) return e;
              var t = {};
              if (null != e)
                for (var r in e)
                  if (Object.prototype.hasOwnProperty.call(e, r)) {
                    var n =
                      Object.defineProperty && Object.getOwnPropertyDescriptor
                        ? Object.getOwnPropertyDescriptor(e, r)
                        : {};
                    n.get || n.set
                      ? Object.defineProperty(t, r, n)
                      : (t[r] = e[r]);
                  }
              return (t.default = e), t;
            })(e("@babel/types"));
            return (
              (n = function() {
                return t;
              }),
              t
            );
          }
          Object.defineProperty(r, "__esModule", { value: !0 }),
            (r.default = function(e, t) {
              const r = n().cloneNode(e.ast);
              t &&
                (e.placeholders.forEach(e => {
                  if (!Object.prototype.hasOwnProperty.call(t, e.name)) {
                    const t = e.name;
                    throw new Error(
                      `Error: No substitution given for "${t}". If this is not meant to be a\n            placeholder you may want to consider passing one of the following options to @babel/template:\n            - { placeholderPattern: false, placeholderWhitelist: new Set(['${t}'])}\n            - { placeholderPattern: /^${t}$/ }`
                    );
                  }
                }),
                Object.keys(t).forEach(t => {
                  if (!e.placeholderNames.has(t))
                    throw new Error(`Unknown substitution "${t}" given`);
                }));
              return (
                e.placeholders
                  .slice()
                  .reverse()
                  .forEach(e => {
                    try {
                      !(function(e, t, r) {
                        e.isDuplicate &&
                          (Array.isArray(r)
                            ? (r = r.map(e => n().cloneNode(e)))
                            : "object" == typeof r && (r = n().cloneNode(r)));
                        const { parent: i, key: s, index: a } = e.resolve(t);
                        if ("string" === e.type) {
                          if (
                            ("string" == typeof r && (r = n().stringLiteral(r)),
                            !r || !n().isStringLiteral(r))
                          )
                            throw new Error("Expected string substitution");
                        } else if ("statement" === e.type)
                          void 0 === a
                            ? r
                              ? Array.isArray(r)
                                ? (r = n().blockStatement(r))
                                : "string" == typeof r
                                ? (r = n().expressionStatement(
                                    n().identifier(r)
                                  ))
                                : n().isStatement(r) ||
                                  (r = n().expressionStatement(r))
                              : (r = n().emptyStatement())
                            : r &&
                              !Array.isArray(r) &&
                              ("string" == typeof r && (r = n().identifier(r)),
                              n().isStatement(r) ||
                                (r = n().expressionStatement(r)));
                        else if ("param" === e.type) {
                          if (
                            ("string" == typeof r && (r = n().identifier(r)),
                            void 0 === a)
                          )
                            throw new Error("Assertion failure.");
                        } else if (
                          ("string" == typeof r && (r = n().identifier(r)),
                          Array.isArray(r))
                        )
                          throw new Error(
                            "Cannot replace single expression with an array."
                          );
                        if (void 0 === a) n().validate(i, s, r), (i[s] = r);
                        else {
                          const t = i[s].slice();
                          "statement" === e.type || "param" === e.type
                            ? null == r
                              ? t.splice(a, 1)
                              : Array.isArray(r)
                              ? t.splice(a, 1, ...r)
                              : (t[a] = r)
                            : (t[a] = r),
                            n().validate(i, s, t),
                            (i[s] = t);
                        }
                      })(e, r, (t && t[e.name]) || null);
                    } catch (t) {
                      throw ((t.message = `@babel/template placeholder "${e.name}": ${t.message}`),
                      t);
                    }
                  }),
                r
              );
            });
        },
        { "@babel/types": 100 }
      ],
      33: [
        function(e, t, r) {
          "use strict";
          Object.defineProperty(r, "__esModule", { value: !0 }),
            (r.default = function(e, t, r) {
              let a;
              return (
                (t = e.code(t)),
                o => {
                  const u = (0, n.normalizeReplacements)(o);
                  return (
                    a || (a = (0, i.default)(e, t, r)),
                    e.unwrap((0, s.default)(a, u))
                  );
                }
              );
            });
          var n = e("./options"),
            i = a(e("./parse")),
            s = a(e("./populate"));
          function a(e) {
            return e && e.__esModule ? e : { default: e };
          }
        },
        { "./options": 30, "./parse": 31, "./populate": 32 }
      ],
      34: [
        function(e, t, r) {
          "use strict";
          Object.defineProperty(r, "__esModule", { value: !0 }),
            (r.clear = function() {
              s(), a();
            }),
            (r.clearPath = s),
            (r.clearScope = a),
            (r.scope = r.path = void 0);
          let n = new WeakMap();
          r.path = n;
          let i = new WeakMap();
          function s() {
            r.path = n = new WeakMap();
          }
          function a() {
            r.scope = i = new WeakMap();
          }
          r.scope = i;
        },
        {}
      ],
      35: [
        function(e, t, r) {
          (function(t) {
            "use strict";
            Object.defineProperty(r, "__esModule", { value: !0 }),
              (r.default = void 0);
            var n,
              i = (n = e("./path")) && n.__esModule ? n : { default: n };
            function s() {
              const t = (function(e) {
                if (e && e.__esModule) return e;
                var t = {};
                if (null != e)
                  for (var r in e)
                    if (Object.prototype.hasOwnProperty.call(e, r)) {
                      var n =
                        Object.defineProperty && Object.getOwnPropertyDescriptor
                          ? Object.getOwnPropertyDescriptor(e, r)
                          : {};
                      n.get || n.set
                        ? Object.defineProperty(t, r, n)
                        : (t[r] = e[r]);
                    }
                return (t.default = e), t;
              })(e("@babel/types"));
              return (
                (s = function() {
                  return t;
                }),
                t
              );
            }
            const a = "test" === t.env.NODE_ENV;
            r.default = class {
              constructor(e, t, r, n) {
                (this.queue = null),
                  (this.parentPath = n),
                  (this.scope = e),
                  (this.state = r),
                  (this.opts = t);
              }
              shouldVisit(e) {
                const t = this.opts;
                if (t.enter || t.exit) return !0;
                if (t[e.type]) return !0;
                const r = s().VISITOR_KEYS[e.type];
                if (!r || !r.length) return !1;
                for (const t of r) if (e[t]) return !0;
                return !1;
              }
              create(e, t, r, n) {
                return i.default.get({
                  parentPath: this.parentPath,
                  parent: e,
                  container: t,
                  key: r,
                  listKey: n
                });
              }
              maybeQueue(e, t) {
                if (this.trap) throw new Error("Infinite cycle detected");
                this.queue &&
                  (t ? this.queue.push(e) : this.priorityQueue.push(e));
              }
              visitMultiple(e, t, r) {
                if (0 === e.length) return !1;
                const n = [];
                for (let i = 0; i < e.length; i++) {
                  const s = e[i];
                  s && this.shouldVisit(s) && n.push(this.create(t, e, i, r));
                }
                return this.visitQueue(n);
              }
              visitSingle(e, t) {
                return (
                  !!this.shouldVisit(e[t]) &&
                  this.visitQueue([this.create(e, e, t)])
                );
              }
              visitQueue(e) {
                (this.queue = e), (this.priorityQueue = []);
                const t = [];
                let r = !1;
                for (const n of e)
                  if (
                    (n.resync(),
                    (0 !== n.contexts.length &&
                      n.contexts[n.contexts.length - 1] === this) ||
                      n.pushContext(this),
                    null !== n.key &&
                      (a && e.length >= 1e4 && (this.trap = !0),
                      !(t.indexOf(n.node) >= 0)))
                  ) {
                    if ((t.push(n.node), n.visit())) {
                      r = !0;
                      break;
                    }
                    if (
                      this.priorityQueue.length &&
                      ((r = this.visitQueue(this.priorityQueue)),
                      (this.priorityQueue = []),
                      (this.queue = e),
                      r)
                    )
                      break;
                  }
                for (const t of e) t.popContext();
                return (this.queue = null), r;
              }
              visit(e, t) {
                const r = e[t];
                return (
                  !!r &&
                  (Array.isArray(r)
                    ? this.visitMultiple(r, e, t)
                    : this.visitSingle(e, t))
                );
              }
            };
          }.call(this, e("_process")));
        },
        { "./path": 44, "@babel/types": 100, _process: 331 }
      ],
      36: [
        function(e, t, r) {
          "use strict";
          Object.defineProperty(r, "__esModule", { value: !0 }),
            (r.default = void 0);
          r.default = class {
            getCode() {}
            getScope() {}
            addHelper() {
              throw new Error("Helpers are not supported by the default hub.");
            }
            buildError(e, t, r = TypeError) {
              return new r(t);
            }
          };
        },
        {}
      ],
      37: [
        function(e, t, r) {
          "use strict";
          Object.defineProperty(r, "__esModule", { value: !0 }),
            (r.default = h),
            Object.defineProperty(r, "NodePath", {
              enumerable: !0,
              get: function() {
                return u.default;
              }
            }),
            Object.defineProperty(r, "Scope", {
              enumerable: !0,
              get: function() {
                return l.default;
              }
            }),
            Object.defineProperty(r, "Hub", {
              enumerable: !0,
              get: function() {
                return c.default;
              }
            }),
            (r.visitors = void 0);
          var n = d(e("./context")),
            i = p(e("./visitors"));
          function s() {
            const t = d(e("lodash/includes"));
            return (
              (s = function() {
                return t;
              }),
              t
            );
          }
          function a() {
            const t = p(e("@babel/types"));
            return (
              (a = function() {
                return t;
              }),
              t
            );
          }
          r.visitors = i;
          var o = p(e("./cache")),
            u = d(e("./path")),
            l = d(e("./scope")),
            c = d(e("./hub"));
          function p(e) {
            if (e && e.__esModule) return e;
            var t = {};
            if (null != e)
              for (var r in e)
                if (Object.prototype.hasOwnProperty.call(e, r)) {
                  var n =
                    Object.defineProperty && Object.getOwnPropertyDescriptor
                      ? Object.getOwnPropertyDescriptor(e, r)
                      : {};
                  n.get || n.set
                    ? Object.defineProperty(t, r, n)
                    : (t[r] = e[r]);
                }
            return (t.default = e), t;
          }
          function d(e) {
            return e && e.__esModule ? e : { default: e };
          }
          function h(e, t, r, n, s) {
            if (e) {
              if (
                (t || (t = {}),
                !t.noScope && !r && "Program" !== e.type && "File" !== e.type)
              )
                throw new Error(
                  "You must pass a scope and parentPath unless traversing a Program/File. " +
                    `Instead of that you tried to traverse a ${e.type} node without ` +
                    "passing scope and parentPath."
                );
              i.explode(t), h.node(e, t, r, n, s);
            }
          }
          function f(e, t) {
            e.node.type === t.type && ((t.has = !0), e.stop());
          }
          (h.visitors = i),
            (h.verify = i.verify),
            (h.explode = i.explode),
            (h.cheap = function(e, t) {
              return a().traverseFast(e, t);
            }),
            (h.node = function(e, t, r, i, s, o) {
              const u = a().VISITOR_KEYS[e.type];
              if (!u) return;
              const l = new n.default(r, t, i, s);
              for (const t of u) if ((!o || !o[t]) && l.visit(e, t)) return;
            }),
            (h.clearNode = function(e, t) {
              a().removeProperties(e, t), o.path.delete(e);
            }),
            (h.removeProperties = function(e, t) {
              return a().traverseFast(e, h.clearNode, t), e;
            }),
            (h.hasType = function(e, t, r) {
              if ((0, s().default)(r, e.type)) return !1;
              if (e.type === t) return !0;
              const n = { has: !1, type: t };
              return (
                h(e, { noScope: !0, blacklist: r, enter: f }, null, n), n.has
              );
            }),
            (h.cache = o);
        },
        {
          "./cache": 34,
          "./context": 35,
          "./hub": 36,
          "./path": 44,
          "./scope": 56,
          "./visitors": 58,
          "@babel/types": 100,
          "lodash/includes": 274
        }
      ],
      38: [
        function(e, t, r) {
          "use strict";
          function n() {
            const t = (function(e) {
              if (e && e.__esModule) return e;
              var t = {};
              if (null != e)
                for (var r in e)
                  if (Object.prototype.hasOwnProperty.call(e, r)) {
                    var n =
                      Object.defineProperty && Object.getOwnPropertyDescriptor
                        ? Object.getOwnPropertyDescriptor(e, r)
                        : {};
                    n.get || n.set
                      ? Object.defineProperty(t, r, n)
                      : (t[r] = e[r]);
                  }
              return (t.default = e), t;
            })(e("@babel/types"));
            return (
              (n = function() {
                return t;
              }),
              t
            );
          }
          Object.defineProperty(r, "__esModule", { value: !0 }),
            (r.findParent = function(e) {
              let t = this;
              for (; (t = t.parentPath); ) if (e(t)) return t;
              return null;
            }),
            (r.find = function(e) {
              let t = this;
              do {
                if (e(t)) return t;
              } while ((t = t.parentPath));
              return null;
            }),
            (r.getFunctionParent = function() {
              return this.findParent(e => e.isFunction());
            }),
            (r.getStatementParent = function() {
              let e = this;
              do {
                if (
                  !e.parentPath ||
                  (Array.isArray(e.container) && e.isStatement())
                )
                  break;
                e = e.parentPath;
              } while (e);
              if (e && (e.isProgram() || e.isFile()))
                throw new Error(
                  "File/Program node, we can't possibly find a statement parent to this"
                );
              return e;
            }),
            (r.getEarliestCommonAncestorFrom = function(e) {
              return this.getDeepestCommonAncestorFrom(e, function(e, t, r) {
                let i;
                const s = n().VISITOR_KEYS[e.type];
                for (const e of r) {
                  const r = e[t + 1];
                  if (!i) {
                    i = r;
                    continue;
                  }
                  if (r.listKey && i.listKey === r.listKey && r.key < i.key) {
                    i = r;
                    continue;
                  }
                  const n = s.indexOf(i.parentKey),
                    a = s.indexOf(r.parentKey);
                  n > a && (i = r);
                }
                return i;
              });
            }),
            (r.getDeepestCommonAncestorFrom = function(e, t) {
              if (!e.length) return this;
              if (1 === e.length) return e[0];
              let r,
                n,
                i = 1 / 0;
              const s = e.map(e => {
                  const t = [];
                  do {
                    t.unshift(e);
                  } while ((e = e.parentPath) && e !== this);
                  return t.length < i && (i = t.length), t;
                }),
                a = s[0];
              e: for (let e = 0; e < i; e++) {
                const t = a[e];
                for (const r of s) if (r[e] !== t) break e;
                (r = e), (n = t);
              }
              if (n) return t ? t(n, r, s) : n;
              throw new Error("Couldn't find intersection");
            }),
            (r.getAncestry = function() {
              let e = this;
              const t = [];
              do {
                t.push(e);
              } while ((e = e.parentPath));
              return t;
            }),
            (r.isAncestor = function(e) {
              return e.isDescendant(this);
            }),
            (r.isDescendant = function(e) {
              return !!this.findParent(t => t === e);
            }),
            (r.inType = function() {
              let e = this;
              for (; e; ) {
                for (const t of arguments) if (e.node.type === t) return !0;
                e = e.parentPath;
              }
              return !1;
            });
          var i;
          (i = e("./index")) && i.__esModule;
        },
        { "./index": 44, "@babel/types": 100 }
      ],
      39: [
        function(e, t, r) {
          "use strict";
          function n() {
            const t = (function(e) {
              if (e && e.__esModule) return e;
              var t = {};
              if (null != e)
                for (var r in e)
                  if (Object.prototype.hasOwnProperty.call(e, r)) {
                    var n =
                      Object.defineProperty && Object.getOwnPropertyDescriptor
                        ? Object.getOwnPropertyDescriptor(e, r)
                        : {};
                    n.get || n.set
                      ? Object.defineProperty(t, r, n)
                      : (t[r] = e[r]);
                  }
              return (t.default = e), t;
            })(e("@babel/types"));
            return (
              (n = function() {
                return t;
              }),
              t
            );
          }
          Object.defineProperty(r, "__esModule", { value: !0 }),
            (r.shareCommentsWithSiblings = function() {
              if ("string" == typeof this.key) return;
              const e = this.node;
              if (!e) return;
              const t = e.trailingComments,
                r = e.leadingComments;
              if (!t && !r) return;
              const n = this.getSibling(this.key - 1),
                i = this.getSibling(this.key + 1),
                s = Boolean(n.node),
                a = Boolean(i.node);
              (s && a) ||
                (s
                  ? n.addComments("trailing", t)
                  : a && i.addComments("leading", r));
            }),
            (r.addComment = function(e, t, r) {
              n().addComment(this.node, e, t, r);
            }),
            (r.addComments = function(e, t) {
              n().addComments(this.node, e, t);
            });
        },
        { "@babel/types": 100 }
      ],
      40: [
        function(e, t, r) {
          "use strict";
          Object.defineProperty(r, "__esModule", { value: !0 }),
            (r.call = function(e) {
              const t = this.opts;
              if ((this.debug(e), this.node && this._call(t[e]))) return !0;
              if (this.node)
                return this._call(t[this.node.type] && t[this.node.type][e]);
              return !1;
            }),
            (r._call = function(e) {
              if (!e) return !1;
              for (const t of e) {
                if (!t) continue;
                const e = this.node;
                if (!e) return !0;
                const r = t.call(this.state, this, this.state);
                if (r && "object" == typeof r && "function" == typeof r.then)
                  throw new Error(
                    "You appear to be using a plugin with an async traversal visitor, which your current version of Babel does not support. If you're using a published plugin, you may need to upgrade your @babel/core version."
                  );
                if (r)
                  throw new Error(
                    `Unexpected return value from visitor method ${t}`
                  );
                if (this.node !== e) return !0;
                if (this.shouldStop || this.shouldSkip || this.removed)
                  return !0;
              }
              return !1;
            }),
            (r.isBlacklisted = function() {
              const e = this.opts.blacklist;
              return e && e.indexOf(this.node.type) > -1;
            }),
            (r.visit = function() {
              if (!this.node) return !1;
              if (this.isBlacklisted()) return !1;
              if (this.opts.shouldSkip && this.opts.shouldSkip(this)) return !1;
              if (this.call("enter") || this.shouldSkip)
                return this.debug("Skip..."), this.shouldStop;
              return (
                this.debug("Recursing into..."),
                i.default.node(
                  this.node,
                  this.opts,
                  this.scope,
                  this.state,
                  this,
                  this.skipKeys
                ),
                this.call("exit"),
                this.shouldStop
              );
            }),
            (r.skip = function() {
              this.shouldSkip = !0;
            }),
            (r.skipKey = function(e) {
              this.skipKeys[e] = !0;
            }),
            (r.stop = function() {
              (this.shouldStop = !0), (this.shouldSkip = !0);
            }),
            (r.setScope = function() {
              if (this.opts && this.opts.noScope) return;
              let e,
                t = this.parentPath;
              for (; t && !e; ) {
                if (t.opts && t.opts.noScope) return;
                (e = t.scope), (t = t.parentPath);
              }
              (this.scope = this.getScope(e)), this.scope && this.scope.init();
            }),
            (r.setContext = function(e) {
              (this.shouldSkip = !1),
                (this.shouldStop = !1),
                (this.removed = !1),
                (this.skipKeys = {}),
                e &&
                  ((this.context = e),
                  (this.state = e.state),
                  (this.opts = e.opts));
              return this.setScope(), this;
            }),
            (r.resync = function() {
              if (this.removed) return;
              this._resyncParent(), this._resyncList(), this._resyncKey();
            }),
            (r._resyncParent = function() {
              this.parentPath && (this.parent = this.parentPath.node);
            }),
            (r._resyncKey = function() {
              if (!this.container) return;
              if (this.node === this.container[this.key]) return;
              if (Array.isArray(this.container)) {
                for (let e = 0; e < this.container.length; e++)
                  if (this.container[e] === this.node) return this.setKey(e);
              } else
                for (const e of Object.keys(this.container))
                  if (this.container[e] === this.node) return this.setKey(e);
              this.key = null;
            }),
            (r._resyncList = function() {
              if (!this.parent || !this.inList) return;
              const e = this.parent[this.listKey];
              if (this.container === e) return;
              this.container = e || null;
            }),
            (r._resyncRemoved = function() {
              (null != this.key &&
                this.container &&
                this.container[this.key] === this.node) ||
                this._markRemoved();
            }),
            (r.popContext = function() {
              this.contexts.pop(),
                this.contexts.length > 0
                  ? this.setContext(this.contexts[this.contexts.length - 1])
                  : this.setContext(void 0);
            }),
            (r.pushContext = function(e) {
              this.contexts.push(e), this.setContext(e);
            }),
            (r.setup = function(e, t, r, n) {
              (this.inList = !!r),
                (this.listKey = r),
                (this.parentKey = r || n),
                (this.container = t),
                (this.parentPath = e || this.parentPath),
                this.setKey(n);
            }),
            (r.setKey = function(e) {
              (this.key = e),
                (this.node = this.container[this.key]),
                (this.type = this.node && this.node.type);
            }),
            (r.requeue = function(e = this) {
              if (e.removed) return;
              const t = this.contexts;
              for (const r of t) r.maybeQueue(e);
            }),
            (r._getQueueContexts = function() {
              let e = this,
                t = this.contexts;
              for (; !t.length && (e = e.parentPath); ) t = e.contexts;
              return t;
            });
          var n,
            i = (n = e("../index")) && n.__esModule ? n : { default: n };
        },
        { "../index": 37 }
      ],
      41: [
        function(e, t, r) {
          "use strict";
          function n() {
            const t = (function(e) {
              if (e && e.__esModule) return e;
              var t = {};
              if (null != e)
                for (var r in e)
                  if (Object.prototype.hasOwnProperty.call(e, r)) {
                    var n =
                      Object.defineProperty && Object.getOwnPropertyDescriptor
                        ? Object.getOwnPropertyDescriptor(e, r)
                        : {};
                    n.get || n.set
                      ? Object.defineProperty(t, r, n)
                      : (t[r] = e[r]);
                  }
              return (t.default = e), t;
            })(e("@babel/types"));
            return (
              (n = function() {
                return t;
              }),
              t
            );
          }
          function i() {
            const t =
              (r = e("@babel/helper-function-name")) && r.__esModule
                ? r
                : { default: r };
            var r;
            return (
              (i = function() {
                return t;
              }),
              t
            );
          }
          function s(e, t = !1, r = !0) {
            const i = e.findParent(
                e =>
                  (e.isFunction() && !e.isArrowFunctionExpression()) ||
                  e.isProgram() ||
                  e.isClassProperty({ static: !1 })
              ),
              s = i && "constructor" === i.node.kind;
            if (i.isClassProperty())
              throw e.buildCodeFrameError(
                "Unable to transform arrow inside class property"
              );
            const {
              thisPaths: u,
              argumentsPaths: l,
              newTargetPaths: c,
              superProps: p,
              superCalls: d
            } = (function(e) {
              const t = [],
                r = [],
                n = [],
                i = [],
                s = [];
              return (
                e.traverse({
                  ClassProperty(e) {
                    e.skip();
                  },
                  Function(e) {
                    e.isArrowFunctionExpression() || e.skip();
                  },
                  ThisExpression(e) {
                    t.push(e);
                  },
                  JSXIdentifier(e) {
                    "this" === e.node.name &&
                      (e.parentPath.isJSXMemberExpression({ object: e.node }) ||
                        e.parentPath.isJSXOpeningElement({ name: e.node })) &&
                      t.push(e);
                  },
                  CallExpression(e) {
                    e.get("callee").isSuper() && s.push(e);
                  },
                  MemberExpression(e) {
                    e.get("object").isSuper() && i.push(e);
                  },
                  ReferencedIdentifier(e) {
                    "arguments" === e.node.name && r.push(e);
                  },
                  MetaProperty(e) {
                    e.get("meta").isIdentifier({ name: "new" }) &&
                      e.get("property").isIdentifier({ name: "target" }) &&
                      n.push(e);
                  }
                }),
                {
                  thisPaths: t,
                  argumentsPaths: r,
                  newTargetPaths: n,
                  superProps: i,
                  superCalls: s
                }
              );
            })(e);
            if (s && d.length > 0) {
              if (!r)
                throw d[0].buildCodeFrameError(
                  "Unable to handle nested super() usage in arrow"
                );
              const e = [];
              i.traverse({
                Function(e) {
                  e.isArrowFunctionExpression() || e.skip();
                },
                ClassProperty(e) {
                  e.skip();
                },
                CallExpression(t) {
                  t.get("callee").isSuper() && e.push(t);
                }
              });
              const t = (function(e) {
                return o(e, "supercall", () => {
                  const t = e.scope.generateUidIdentifier("args");
                  return n().arrowFunctionExpression(
                    [n().restElement(t)],
                    n().callExpression(n().super(), [
                      n().spreadElement(n().identifier(t.name))
                    ])
                  );
                });
              })(i);
              e.forEach(e => {
                const r = n().identifier(t);
                (r.loc = e.node.callee.loc), e.get("callee").replaceWith(r);
              });
            }
            let h;
            if (
              ((u.length > 0 || t) &&
                ((h = (function(e, t) {
                  return o(e, "this", r => {
                    if (!t || !a(e)) return n().thisExpression();
                    const i = new WeakSet();
                    e.traverse({
                      Function(e) {
                        e.isArrowFunctionExpression() || e.skip();
                      },
                      ClassProperty(e) {
                        e.skip();
                      },
                      CallExpression(e) {
                        e.get("callee").isSuper() &&
                          (i.has(e.node) ||
                            (i.add(e.node),
                            e.replaceWithMultiple([
                              e.node,
                              n().assignmentExpression(
                                "=",
                                n().identifier(r),
                                n().identifier("this")
                              )
                            ])));
                      }
                    });
                  });
                })(i, s)),
                (!t || (s && a(i))) &&
                  (u.forEach(e => {
                    const t = e.isJSX()
                      ? n().jsxIdentifier(h)
                      : n().identifier(h);
                    (t.loc = e.node.loc), e.replaceWith(t);
                  }),
                  t && (h = null))),
              l.length > 0)
            ) {
              const e = o(i, "arguments", () => n().identifier("arguments"));
              l.forEach(t => {
                const r = n().identifier(e);
                (r.loc = t.node.loc), t.replaceWith(r);
              });
            }
            if (c.length > 0) {
              const e = o(i, "newtarget", () =>
                n().metaProperty(
                  n().identifier("new"),
                  n().identifier("target")
                )
              );
              c.forEach(t => {
                const r = n().identifier(e);
                (r.loc = t.node.loc), t.replaceWith(r);
              });
            }
            if (p.length > 0) {
              if (!r)
                throw p[0].buildCodeFrameError(
                  "Unable to handle nested super.prop usage"
                );
              p.reduce(
                (e, t) =>
                  e.concat(
                    (function(e) {
                      if (
                        e.parentPath.isAssignmentExpression() &&
                        "=" !== e.parentPath.node.operator
                      ) {
                        const t = e.parentPath,
                          r = t.node.operator.slice(0, -1),
                          i = t.node.right;
                        if (((t.node.operator = "="), e.node.computed)) {
                          const s = e.scope.generateDeclaredUidIdentifier(
                            "tmp"
                          );
                          t
                            .get("left")
                            .replaceWith(
                              n().memberExpression(
                                e.node.object,
                                n().assignmentExpression(
                                  "=",
                                  s,
                                  e.node.property
                                ),
                                !0
                              )
                            ),
                            t
                              .get("right")
                              .replaceWith(
                                n().binaryExpression(
                                  r,
                                  n().memberExpression(
                                    e.node.object,
                                    n().identifier(s.name),
                                    !0
                                  ),
                                  i
                                )
                              );
                        } else
                          t
                            .get("left")
                            .replaceWith(
                              n().memberExpression(
                                e.node.object,
                                e.node.property
                              )
                            ),
                            t
                              .get("right")
                              .replaceWith(
                                n().binaryExpression(
                                  r,
                                  n().memberExpression(
                                    e.node.object,
                                    n().identifier(e.node.property.name)
                                  ),
                                  i
                                )
                              );
                        return [t.get("left"), t.get("right").get("left")];
                      }
                      if (e.parentPath.isUpdateExpression()) {
                        const t = e.parentPath,
                          r = e.scope.generateDeclaredUidIdentifier("tmp"),
                          i = e.node.computed
                            ? e.scope.generateDeclaredUidIdentifier("prop")
                            : null,
                          s = [
                            n().assignmentExpression(
                              "=",
                              r,
                              n().memberExpression(
                                e.node.object,
                                i
                                  ? n().assignmentExpression(
                                      "=",
                                      i,
                                      e.node.property
                                    )
                                  : e.node.property,
                                e.node.computed
                              )
                            ),
                            n().assignmentExpression(
                              "=",
                              n().memberExpression(
                                e.node.object,
                                i ? n().identifier(i.name) : e.node.property,
                                e.node.computed
                              ),
                              n().binaryExpression(
                                "+",
                                n().identifier(r.name),
                                n().numericLiteral(1)
                              )
                            )
                          ];
                        e.parentPath.node.prefix ||
                          s.push(n().identifier(r.name)),
                          t.replaceWith(n().sequenceExpression(s));
                        const a = t.get("expressions.0.right"),
                          o = t.get("expressions.1.left");
                        return [a, o];
                      }
                      return [e];
                    })(t)
                  ),
                []
              ).forEach(e => {
                const t = e.node.computed ? "" : e.get("property").node.name;
                if (e.parentPath.isCallExpression({ callee: e.node })) {
                  const r = (function(e, t) {
                    return o(e, `superprop_call:${t || ""}`, () => {
                      const r = e.scope.generateUidIdentifier("args"),
                        i = [n().restElement(r)];
                      let s;
                      if (t)
                        s = n().callExpression(
                          n().memberExpression(n().super(), n().identifier(t)),
                          [n().spreadElement(n().identifier(r.name))]
                        );
                      else {
                        const t = e.scope.generateUidIdentifier("prop");
                        i.unshift(t),
                          (s = n().callExpression(
                            n().memberExpression(
                              n().super(),
                              n().identifier(t.name),
                              !0
                            ),
                            [n().spreadElement(n().identifier(r.name))]
                          ));
                      }
                      return n().arrowFunctionExpression(i, s);
                    });
                  })(i, t);
                  if (e.node.computed) {
                    const t = e.get("property").node;
                    e.replaceWith(n().identifier(r)),
                      e.parentPath.node.arguments.unshift(t);
                  } else e.replaceWith(n().identifier(r));
                } else {
                  const r = e.parentPath.isAssignmentExpression({
                      left: e.node
                    }),
                    s = (function(e, t, r) {
                      return o(
                        e,
                        `superprop_${t ? "set" : "get"}:${r || ""}`,
                        () => {
                          const i = [];
                          let s;
                          if (r)
                            s = n().memberExpression(
                              n().super(),
                              n().identifier(r)
                            );
                          else {
                            const t = e.scope.generateUidIdentifier("prop");
                            i.unshift(t),
                              (s = n().memberExpression(
                                n().super(),
                                n().identifier(t.name),
                                !0
                              ));
                          }
                          if (t) {
                            const t = e.scope.generateUidIdentifier("value");
                            i.push(t),
                              (s = n().assignmentExpression(
                                "=",
                                s,
                                n().identifier(t.name)
                              ));
                          }
                          return n().arrowFunctionExpression(i, s);
                        }
                      );
                    })(i, r, t),
                    a = [];
                  if ((e.node.computed && a.push(e.get("property").node), r)) {
                    const t = e.parentPath.node.right;
                    a.push(t),
                      e.parentPath.replaceWith(
                        n().callExpression(n().identifier(s), a)
                      );
                  } else
                    e.replaceWith(n().callExpression(n().identifier(s), a));
                }
              });
            }
            return h;
          }
          function a(e) {
            return (
              e.isClassMethod() && !!e.parentPath.parentPath.node.superClass
            );
          }
          function o(e, t, r) {
            const n = "binding:" + t;
            let i = e.getData(n);
            if (!i) {
              const s = e.scope.generateUidIdentifier(t);
              (i = s.name),
                e.setData(n, i),
                e.scope.push({ id: s, init: r(i) });
            }
            return i;
          }
          Object.defineProperty(r, "__esModule", { value: !0 }),
            (r.toComputedKey = function() {
              const e = this.node;
              let t;
              if (this.isMemberExpression()) t = e.property;
              else {
                if (!this.isProperty() && !this.isMethod())
                  throw new ReferenceError("todo");
                t = e.key;
              }
              e.computed ||
                (n().isIdentifier(t) && (t = n().stringLiteral(t.name)));
              return t;
            }),
            (r.ensureBlock = function() {
              const e = this.get("body"),
                t = e.node;
              if (Array.isArray(e))
                throw new Error(
                  "Can't convert array path to a block statement"
                );
              if (!t) throw new Error("Can't convert node without a body");
              if (e.isBlockStatement()) return t;
              const r = [];
              let i,
                s,
                a = "body";
              e.isStatement()
                ? ((s = "body"), (i = 0), r.push(e.node))
                : ((a += ".body.0"),
                  this.isFunction()
                    ? ((i = "argument"), r.push(n().returnStatement(e.node)))
                    : ((i = "expression"),
                      r.push(n().expressionStatement(e.node))));
              this.node.body = n().blockStatement(r);
              const o = this.get(a);
              return e.setup(o, s ? o.node[s] : o.node, s, i), this.node;
            }),
            (r.arrowFunctionToShadowed = function() {
              if (!this.isArrowFunctionExpression()) return;
              this.arrowFunctionToExpression();
            }),
            (r.unwrapFunctionEnvironment = function() {
              if (
                !this.isArrowFunctionExpression() &&
                !this.isFunctionExpression() &&
                !this.isFunctionDeclaration()
              )
                throw this.buildCodeFrameError(
                  "Can only unwrap the environment of a function."
                );
              s(this);
            }),
            (r.arrowFunctionToExpression = function({
              allowInsertArrow: e = !0,
              specCompliant: t = !1
            } = {}) {
              if (!this.isArrowFunctionExpression())
                throw this.buildCodeFrameError(
                  "Cannot convert non-arrow function to a function expression."
                );
              const r = s(this, t, e);
              if (
                (this.ensureBlock(), (this.node.type = "FunctionExpression"), t)
              ) {
                const e = r
                  ? null
                  : this.parentPath.scope.generateUidIdentifier("arrowCheckId");
                e &&
                  this.parentPath.scope.push({
                    id: e,
                    init: n().objectExpression([])
                  }),
                  this.get("body").unshiftContainer(
                    "body",
                    n().expressionStatement(
                      n().callExpression(this.hub.addHelper("newArrowCheck"), [
                        n().thisExpression(),
                        e ? n().identifier(e.name) : n().identifier(r)
                      ])
                    )
                  ),
                  this.replaceWith(
                    n().callExpression(
                      n().memberExpression(
                        (0, i().default)(this, !0) || this.node,
                        n().identifier("bind")
                      ),
                      [e ? n().identifier(e.name) : n().thisExpression()]
                    )
                  );
              }
            });
        },
        { "@babel/helper-function-name": 21, "@babel/types": 100 }
      ],
      42: [
        function(e, t, r) {
          (function(e) {
            "use strict";
            Object.defineProperty(r, "__esModule", { value: !0 }),
              (r.evaluateTruthy = function() {
                const e = this.evaluate();
                if (e.confident) return !!e.value;
              }),
              (r.evaluate = function() {
                const e = { confident: !0, deoptPath: null, seen: new Map() };
                let t = s(this, e);
                e.confident || (t = void 0);
                return { confident: e.confident, deopt: e.deoptPath, value: t };
              });
            const t = ["String", "Number", "Math"],
              n = ["random"];
            function i(e, t) {
              t.confident && ((t.deoptPath = e), (t.confident = !1));
            }
            function s(r, o) {
              const { node: u } = r,
                { seen: l } = o;
              if (l.has(u)) {
                const e = l.get(u);
                return e.resolved ? e.value : void i(r, o);
              }
              {
                const c = { resolved: !1 };
                l.set(u, c);
                const p = (function(r, o) {
                  if (!o.confident) return;
                  const { node: u } = r;
                  if (r.isSequenceExpression()) {
                    const e = r.get("expressions");
                    return s(e[e.length - 1], o);
                  }
                  if (
                    r.isStringLiteral() ||
                    r.isNumericLiteral() ||
                    r.isBooleanLiteral()
                  )
                    return u.value;
                  if (r.isNullLiteral()) return null;
                  if (r.isTemplateLiteral()) return a(r, u.quasis, o);
                  if (
                    r.isTaggedTemplateExpression() &&
                    r.get("tag").isMemberExpression()
                  ) {
                    const e = r.get("tag.object"),
                      {
                        node: { name: t }
                      } = e,
                      n = r.get("tag.property");
                    if (
                      e.isIdentifier() &&
                      "String" === t &&
                      !r.scope.getBinding(t, !0) &&
                      n.isIdentifier &&
                      "raw" === n.node.name
                    )
                      return a(r, u.quasi.quasis, o, !0);
                  }
                  if (r.isConditionalExpression()) {
                    const e = s(r.get("test"), o);
                    if (!o.confident) return;
                    return s(e ? r.get("consequent") : r.get("alternate"), o);
                  }
                  if (r.isExpressionWrapper()) return s(r.get("expression"), o);
                  if (
                    r.isMemberExpression() &&
                    !r.parentPath.isCallExpression({ callee: u })
                  ) {
                    const e = r.get("property"),
                      t = r.get("object");
                    if (t.isLiteral() && e.isIdentifier()) {
                      const r = t.node.value,
                        n = typeof r;
                      if ("number" === n || "string" === n)
                        return r[e.node.name];
                    }
                  }
                  if (r.isReferencedIdentifier()) {
                    const e = r.scope.getBinding(u.name);
                    if (e && e.constantViolations.length > 0)
                      return i(e.path, o);
                    if (e && r.node.start < e.path.node.end)
                      return i(e.path, o);
                    if (e && e.hasValue) return e.value;
                    {
                      if ("undefined" === u.name)
                        return e ? i(e.path, o) : void 0;
                      if ("Infinity" === u.name)
                        return e ? i(e.path, o) : 1 / 0;
                      if ("NaN" === u.name) return e ? i(e.path, o) : NaN;
                      const t = r.resolve();
                      return t === r ? i(r, o) : s(t, o);
                    }
                  }
                  if (r.isUnaryExpression({ prefix: !0 })) {
                    if ("void" === u.operator) return;
                    const e = r.get("argument");
                    if (
                      "typeof" === u.operator &&
                      (e.isFunction() || e.isClass())
                    )
                      return "function";
                    const t = s(e, o);
                    if (!o.confident) return;
                    switch (u.operator) {
                      case "!":
                        return !t;
                      case "+":
                        return +t;
                      case "-":
                        return -t;
                      case "~":
                        return ~t;
                      case "typeof":
                        return typeof t;
                    }
                  }
                  if (r.isArrayExpression()) {
                    const e = [],
                      t = r.get("elements");
                    for (const r of t) {
                      const t = r.evaluate();
                      if (!t.confident) return i(r, o);
                      e.push(t.value);
                    }
                    return e;
                  }
                  if (r.isObjectExpression()) {
                    const e = {},
                      t = r.get("properties");
                    for (const r of t) {
                      if (r.isObjectMethod() || r.isSpreadElement())
                        return i(r, o);
                      const t = r.get("key");
                      let n = t;
                      if (r.node.computed) {
                        if (!(n = n.evaluate()).confident) return i(t, o);
                        n = n.value;
                      } else n = n.isIdentifier() ? n.node.name : n.node.value;
                      const s = r.get("value");
                      let a = s.evaluate();
                      if (!a.confident) return i(s, o);
                      (a = a.value), (e[n] = a);
                    }
                    return e;
                  }
                  if (r.isLogicalExpression()) {
                    const e = o.confident,
                      t = s(r.get("left"), o),
                      n = o.confident;
                    o.confident = e;
                    const i = s(r.get("right"), o),
                      a = o.confident;
                    switch (u.operator) {
                      case "||":
                        if (((o.confident = n && (!!t || a)), !o.confident))
                          return;
                        return t || i;
                      case "&&":
                        if (((o.confident = n && (!t || a)), !o.confident))
                          return;
                        return t && i;
                    }
                  }
                  if (r.isBinaryExpression()) {
                    const e = s(r.get("left"), o);
                    if (!o.confident) return;
                    const t = s(r.get("right"), o);
                    if (!o.confident) return;
                    switch (u.operator) {
                      case "-":
                        return e - t;
                      case "+":
                        return e + t;
                      case "/":
                        return e / t;
                      case "*":
                        return e * t;
                      case "%":
                        return e % t;
                      case "**":
                        return Math.pow(e, t);
                      case "<":
                        return e < t;
                      case ">":
                        return e > t;
                      case "<=":
                        return e <= t;
                      case ">=":
                        return e >= t;
                      case "==":
                        return e == t;
                      case "!=":
                        return e != t;
                      case "===":
                        return e === t;
                      case "!==":
                        return e !== t;
                      case "|":
                        return e | t;
                      case "&":
                        return e & t;
                      case "^":
                        return e ^ t;
                      case "<<":
                        return e << t;
                      case ">>":
                        return e >> t;
                      case ">>>":
                        return e >>> t;
                    }
                  }
                  if (r.isCallExpression()) {
                    const i = r.get("callee");
                    let a, l;
                    if (
                      (i.isIdentifier() &&
                        !r.scope.getBinding(i.node.name, !0) &&
                        t.indexOf(i.node.name) >= 0 &&
                        (l = e[u.callee.name]),
                      i.isMemberExpression())
                    ) {
                      const r = i.get("object"),
                        s = i.get("property");
                      if (
                        (r.isIdentifier() &&
                          s.isIdentifier() &&
                          t.indexOf(r.node.name) >= 0 &&
                          n.indexOf(s.node.name) < 0 &&
                          ((a = e[r.node.name]), (l = a[s.node.name])),
                        r.isLiteral() && s.isIdentifier())
                      ) {
                        const e = typeof r.node.value;
                        ("string" !== e && "number" !== e) ||
                          ((a = r.node.value), (l = a[s.node.name]));
                      }
                    }
                    if (l) {
                      const e = r.get("arguments").map(e => s(e, o));
                      if (!o.confident) return;
                      return l.apply(a, e);
                    }
                  }
                  i(r, o);
                })(r, o);
                return o.confident && ((c.resolved = !0), (c.value = p)), p;
              }
            }
            function a(e, t, r, n = !1) {
              let i = "",
                a = 0;
              const o = e.get("expressions");
              for (const e of t) {
                if (!r.confident) break;
                i += n ? e.value.raw : e.value.cooked;
                const t = o[a++];
                t && (i += String(s(t, r)));
              }
              if (r.confident) return i;
            }
          }.call(
            this,
            "undefined" != typeof global
              ? global
              : "undefined" != typeof self
              ? self
              : "undefined" != typeof window
              ? window
              : {}
          ));
        },
        {}
      ],
      43: [
        function(e, t, r) {
          "use strict";
          Object.defineProperty(r, "__esModule", { value: !0 }),
            (r.getOpposite = function() {
              if ("left" === this.key) return this.getSibling("right");
              if ("right" === this.key) return this.getSibling("left");
            }),
            (r.getCompletionRecords = function() {
              let e = [];
              if (this.isIfStatement())
                (e = a(this.get("consequent"), e)),
                  (e = a(this.get("alternate"), e));
              else if (this.isDoExpression() || this.isFor() || this.isWhile())
                e = a(this.get("body"), e);
              else if (this.isProgram() || this.isBlockStatement())
                e = a(this.get("body").pop(), e);
              else {
                if (this.isFunction())
                  return this.get("body").getCompletionRecords();
                this.isTryStatement()
                  ? ((e = a(this.get("block"), e)),
                    (e = a(this.get("handler"), e)),
                    (e = a(this.get("finalizer"), e)))
                  : this.isCatchClause()
                  ? (e = a(this.get("body"), e))
                  : e.push(this);
              }
              return e;
            }),
            (r.getSibling = function(e) {
              return i.default.get({
                parentPath: this.parentPath,
                parent: this.parent,
                container: this.container,
                listKey: this.listKey,
                key: e
              });
            }),
            (r.getPrevSibling = function() {
              return this.getSibling(this.key - 1);
            }),
            (r.getNextSibling = function() {
              return this.getSibling(this.key + 1);
            }),
            (r.getAllNextSiblings = function() {
              let e = this.key,
                t = this.getSibling(++e);
              const r = [];
              for (; t.node; ) r.push(t), (t = this.getSibling(++e));
              return r;
            }),
            (r.getAllPrevSiblings = function() {
              let e = this.key,
                t = this.getSibling(--e);
              const r = [];
              for (; t.node; ) r.push(t), (t = this.getSibling(--e));
              return r;
            }),
            (r.get = function(e, t) {
              !0 === t && (t = this.context);
              const r = e.split(".");
              return 1 === r.length
                ? this._getKey(e, t)
                : this._getPattern(r, t);
            }),
            (r._getKey = function(e, t) {
              const r = this.node,
                n = r[e];
              return Array.isArray(n)
                ? n.map((s, a) =>
                    i.default
                      .get({
                        listKey: e,
                        parentPath: this,
                        parent: r,
                        container: n,
                        key: a
                      })
                      .setContext(t)
                  )
                : i.default
                    .get({ parentPath: this, parent: r, container: r, key: e })
                    .setContext(t);
            }),
            (r._getPattern = function(e, t) {
              let r = this;
              for (const n of e)
                r =
                  "." === n
                    ? r.parentPath
                    : Array.isArray(r)
                    ? r[n]
                    : r.get(n, t);
              return r;
            }),
            (r.getBindingIdentifiers = function(e) {
              return s().getBindingIdentifiers(this.node, e);
            }),
            (r.getOuterBindingIdentifiers = function(e) {
              return s().getOuterBindingIdentifiers(this.node, e);
            }),
            (r.getBindingIdentifierPaths = function(e = !1, t = !1) {
              let r = [].concat(this);
              const n = Object.create(null);
              for (; r.length; ) {
                const i = r.shift();
                if (!i) continue;
                if (!i.node) continue;
                const a = s().getBindingIdentifiers.keys[i.node.type];
                if (i.isIdentifier())
                  if (e) {
                    const e = (n[i.node.name] = n[i.node.name] || []);
                    e.push(i);
                  } else n[i.node.name] = i;
                else if (i.isExportDeclaration()) {
                  const e = i.get("declaration");
                  e.isDeclaration() && r.push(e);
                } else {
                  if (t) {
                    if (i.isFunctionDeclaration()) {
                      r.push(i.get("id"));
                      continue;
                    }
                    if (i.isFunctionExpression()) continue;
                  }
                  if (a)
                    for (let e = 0; e < a.length; e++) {
                      const t = a[e],
                        n = i.get(t);
                      (Array.isArray(n) || n.node) && (r = r.concat(n));
                    }
                }
              }
              return n;
            }),
            (r.getOuterBindingIdentifierPaths = function(e) {
              return this.getBindingIdentifierPaths(e, !0);
            });
          var n,
            i = (n = e("./index")) && n.__esModule ? n : { default: n };
          function s() {
            const t = (function(e) {
              if (e && e.__esModule) return e;
              var t = {};
              if (null != e)
                for (var r in e)
                  if (Object.prototype.hasOwnProperty.call(e, r)) {
                    var n =
                      Object.defineProperty && Object.getOwnPropertyDescriptor
                        ? Object.getOwnPropertyDescriptor(e, r)
                        : {};
                    n.get || n.set
                      ? Object.defineProperty(t, r, n)
                      : (t[r] = e[r]);
                  }
              return (t.default = e), t;
            })(e("@babel/types"));
            return (
              (s = function() {
                return t;
              }),
              t
            );
          }
          function a(e, t) {
            return e ? t.concat(e.getCompletionRecords()) : t;
          }
        },
        { "./index": 44, "@babel/types": 100 }
      ],
      44: [
        function(e, t, r) {
          "use strict";
          Object.defineProperty(r, "__esModule", { value: !0 }),
            (r.default = void 0);
          var n = x(e("./lib/virtual-types"));
          function i() {
            const t = T(e("debug"));
            return (
              (i = function() {
                return t;
              }),
              t
            );
          }
          var s = T(e("../index")),
            a = T(e("../scope"));
          function o() {
            const t = x(e("@babel/types"));
            return (
              (o = function() {
                return t;
              }),
              t
            );
          }
          var u = e("../cache");
          function l() {
            const t = T(e("@babel/generator"));
            return (
              (l = function() {
                return t;
              }),
              t
            );
          }
          var c = x(e("./ancestry")),
            p = x(e("./inference")),
            d = x(e("./replacement")),
            h = x(e("./evaluation")),
            f = x(e("./conversion")),
            m = x(e("./introspection")),
            y = x(e("./context")),
            g = x(e("./removal")),
            b = x(e("./modification")),
            v = x(e("./family")),
            E = x(e("./comments"));
          function T(e) {
            return e && e.__esModule ? e : { default: e };
          }
          function x(e) {
            if (e && e.__esModule) return e;
            var t = {};
            if (null != e)
              for (var r in e)
                if (Object.prototype.hasOwnProperty.call(e, r)) {
                  var n =
                    Object.defineProperty && Object.getOwnPropertyDescriptor
                      ? Object.getOwnPropertyDescriptor(e, r)
                      : {};
                  n.get || n.set
                    ? Object.defineProperty(t, r, n)
                    : (t[r] = e[r]);
                }
            return (t.default = e), t;
          }
          const A = (0, i().default)("babel");
          class S {
            constructor(e, t) {
              (this.parent = t),
                (this.hub = e),
                (this.contexts = []),
                (this.data = Object.create(null)),
                (this.shouldSkip = !1),
                (this.shouldStop = !1),
                (this.removed = !1),
                (this.state = null),
                (this.opts = null),
                (this.skipKeys = null),
                (this.parentPath = null),
                (this.context = null),
                (this.container = null),
                (this.listKey = null),
                (this.inList = !1),
                (this.parentKey = null),
                (this.key = null),
                (this.node = null),
                (this.scope = null),
                (this.type = null),
                (this.typeAnnotation = null);
            }
            static get({
              hub: e,
              parentPath: t,
              parent: r,
              container: n,
              listKey: i,
              key: s
            }) {
              if ((!e && t && (e = t.hub), !r))
                throw new Error("To get a node path the parent needs to exist");
              const a = n[s],
                o = u.path.get(r) || [];
              let l;
              u.path.has(r) || u.path.set(r, o);
              for (let e = 0; e < o.length; e++) {
                const t = o[e];
                if (t.node === a) {
                  l = t;
                  break;
                }
              }
              return (
                l || ((l = new S(e, r)), o.push(l)), l.setup(t, n, i, s), l
              );
            }
            getScope(e) {
              return this.isScope() ? new a.default(this) : e;
            }
            setData(e, t) {
              return (this.data[e] = t);
            }
            getData(e, t) {
              let r = this.data[e];
              return void 0 === r && void 0 !== t && (r = this.data[e] = t), r;
            }
            buildCodeFrameError(e, t = SyntaxError) {
              return this.hub.buildError(this.node, e, t);
            }
            traverse(e, t) {
              (0, s.default)(this.node, e, this.scope, t, this);
            }
            set(e, t) {
              o().validate(this.node, e, t), (this.node[e] = t);
            }
            getPathLocation() {
              const e = [];
              let t = this;
              do {
                let r = t.key;
                t.inList && (r = `${t.listKey}[${r}]`), e.unshift(r);
              } while ((t = t.parentPath));
              return e.join(".");
            }
            debug(e) {
              A.enabled && A(`${this.getPathLocation()} ${this.type}: ${e}`);
            }
            toString() {
              return (0, l().default)(this.node).code;
            }
          }
          (r.default = S),
            Object.assign(S.prototype, c, p, d, h, f, m, y, g, b, v, E);
          for (const e of o().TYPES) {
            const t = `is${e}`,
              r = o()[t];
            (S.prototype[t] = function(e) {
              return r(this.node, e);
            }),
              (S.prototype[`assert${e}`] = function(t) {
                if (!r(this.node, t))
                  throw new TypeError(`Expected node path of type ${e}`);
              });
          }
          for (const e of Object.keys(n)) {
            if ("_" === e[0]) continue;
            o().TYPES.indexOf(e) < 0 && o().TYPES.push(e);
            const t = n[e];
            S.prototype[`is${e}`] = function(e) {
              return t.checkPath(this, e);
            };
          }
        },
        {
          "../cache": 34,
          "../index": 37,
          "../scope": 56,
          "./ancestry": 38,
          "./comments": 39,
          "./context": 40,
          "./conversion": 41,
          "./evaluation": 42,
          "./family": 43,
          "./inference": 45,
          "./introspection": 48,
          "./lib/virtual-types": 51,
          "./modification": 52,
          "./removal": 53,
          "./replacement": 54,
          "@babel/generator": 15,
          "@babel/types": 100,
          debug: 142
        }
      ],
      45: [
        function(e, t, r) {
          "use strict";
          Object.defineProperty(r, "__esModule", { value: !0 }),
            (r.getTypeAnnotation = function() {
              if (this.typeAnnotation) return this.typeAnnotation;
              let e = this._getTypeAnnotation() || i().anyTypeAnnotation();
              i().isTypeAnnotation(e) && (e = e.typeAnnotation);
              return (this.typeAnnotation = e);
            }),
            (r._getTypeAnnotation = function() {
              const e = this.node;
              if (!e) {
                if (
                  "init" === this.key &&
                  this.parentPath.isVariableDeclarator()
                ) {
                  const e = this.parentPath.parentPath,
                    t = e.parentPath;
                  return "left" === e.key && t.isForInStatement()
                    ? i().stringTypeAnnotation()
                    : "left" === e.key && t.isForOfStatement()
                    ? i().anyTypeAnnotation()
                    : i().voidTypeAnnotation();
                }
                return;
              }
              if (e.typeAnnotation) return e.typeAnnotation;
              let t = n[e.type];
              if (t) return t.call(this, e);
              if ((t = n[this.parentPath.type]) && t.validParent)
                return this.parentPath.getTypeAnnotation();
            }),
            (r.isBaseType = function(e, t) {
              return a(e, this.getTypeAnnotation(), t);
            }),
            (r.couldBeBaseType = function(e) {
              const t = this.getTypeAnnotation();
              if (i().isAnyTypeAnnotation(t)) return !0;
              if (i().isUnionTypeAnnotation(t)) {
                for (const r of t.types)
                  if (i().isAnyTypeAnnotation(r) || a(e, r, !0)) return !0;
                return !1;
              }
              return a(e, t, !0);
            }),
            (r.baseTypeStrictlyMatches = function(e) {
              const t = this.getTypeAnnotation();
              if (
                ((e = e.getTypeAnnotation()),
                !i().isAnyTypeAnnotation(t) && i().isFlowBaseAnnotation(t))
              )
                return e.type === t.type;
            }),
            (r.isGenericType = function(e) {
              const t = this.getTypeAnnotation();
              return (
                i().isGenericTypeAnnotation(t) &&
                i().isIdentifier(t.id, { name: e })
              );
            });
          var n = s(e("./inferers"));
          function i() {
            const t = s(e("@babel/types"));
            return (
              (i = function() {
                return t;
              }),
              t
            );
          }
          function s(e) {
            if (e && e.__esModule) return e;
            var t = {};
            if (null != e)
              for (var r in e)
                if (Object.prototype.hasOwnProperty.call(e, r)) {
                  var n =
                    Object.defineProperty && Object.getOwnPropertyDescriptor
                      ? Object.getOwnPropertyDescriptor(e, r)
                      : {};
                  n.get || n.set
                    ? Object.defineProperty(t, r, n)
                    : (t[r] = e[r]);
                }
            return (t.default = e), t;
          }
          function a(e, t, r) {
            if ("string" === e) return i().isStringTypeAnnotation(t);
            if ("number" === e) return i().isNumberTypeAnnotation(t);
            if ("boolean" === e) return i().isBooleanTypeAnnotation(t);
            if ("any" === e) return i().isAnyTypeAnnotation(t);
            if ("mixed" === e) return i().isMixedTypeAnnotation(t);
            if ("empty" === e) return i().isEmptyTypeAnnotation(t);
            if ("void" === e) return i().isVoidTypeAnnotation(t);
            if (r) return !1;
            throw new Error(`Unknown base type ${e}`);
          }
        },
        { "./inferers": 47, "@babel/types": 100 }
      ],
      46: [
        function(e, t, r) {
          "use strict";
          function n() {
            const t = (function(e) {
              if (e && e.__esModule) return e;
              var t = {};
              if (null != e)
                for (var r in e)
                  if (Object.prototype.hasOwnProperty.call(e, r)) {
                    var n =
                      Object.defineProperty && Object.getOwnPropertyDescriptor
                        ? Object.getOwnPropertyDescriptor(e, r)
                        : {};
                    n.get || n.set
                      ? Object.defineProperty(t, r, n)
                      : (t[r] = e[r]);
                  }
              return (t.default = e), t;
            })(e("@babel/types"));
            return (
              (n = function() {
                return t;
              }),
              t
            );
          }
          function i(e, t, r) {
            const n = e.constantViolations.slice();
            return (
              n.unshift(e.path),
              n.filter(e => {
                const n = (e = e.resolve())._guessExecutionStatusRelativeTo(t);
                return r && "function" === n && r.push(e), "before" === n;
              })
            );
          }
          function s(e, t) {
            const r = t.node.operator,
              i = t.get("right").resolve(),
              s = t.get("left").resolve();
            let a, o, u;
            if (
              (s.isIdentifier({ name: e })
                ? (a = i)
                : i.isIdentifier({ name: e }) && (a = s),
              a)
            )
              return "===" === r
                ? a.getTypeAnnotation()
                : n().BOOLEAN_NUMBER_BINARY_OPERATORS.indexOf(r) >= 0
                ? n().numberTypeAnnotation()
                : void 0;
            if ("===" !== r && "==" !== r) return;
            if (
              (s.isUnaryExpression({ operator: "typeof" })
                ? ((o = s), (u = i))
                : i.isUnaryExpression({ operator: "typeof" }) &&
                  ((o = i), (u = s)),
              !o)
            )
              return;
            if (!o.get("argument").isIdentifier({ name: e })) return;
            if (!(u = u.resolve()).isLiteral()) return;
            const l = u.node.value;
            return "string" == typeof l
              ? n().createTypeAnnotationBasedOnTypeof(l)
              : void 0;
          }
          Object.defineProperty(r, "__esModule", { value: !0 }),
            (r.default = function(e) {
              if (!this.isReferenced()) return;
              const t = this.scope.getBinding(e.name);
              if (t)
                return t.identifier.typeAnnotation
                  ? t.identifier.typeAnnotation
                  : (function(e, t, r) {
                      const a = [],
                        o = [];
                      let u = i(e, t, o);
                      const l = (function e(t, r, i) {
                        const a = (function(e, t, r) {
                          let n;
                          for (; (n = t.parentPath); ) {
                            if (
                              n.isIfStatement() ||
                              n.isConditionalExpression()
                            ) {
                              if ("test" === t.key) return;
                              return n;
                            }
                            if (
                              n.isFunction() &&
                              n.parentPath.scope.getBinding(r) !== e
                            )
                              return;
                            t = n;
                          }
                        })(t, r, i);
                        if (!a) return;
                        const o = a.get("test");
                        const u = [o];
                        const l = [];
                        for (let e = 0; e < u.length; e++) {
                          const t = u[e];
                          if (t.isLogicalExpression())
                            "&&" === t.node.operator &&
                              (u.push(t.get("left")), u.push(t.get("right")));
                          else if (t.isBinaryExpression()) {
                            const e = s(i, t);
                            e && l.push(e);
                          }
                        }
                        if (l.length)
                          return {
                            typeAnnotation: n().createUnionTypeAnnotation(l),
                            ifStatement: a
                          };
                        return e(a, i);
                      })(e, t, r);
                      if (l) {
                        const t = i(e, l.ifStatement);
                        (u = u.filter(e => t.indexOf(e) < 0)),
                          a.push(l.typeAnnotation);
                      }
                      if (u.length) {
                        u = u.concat(o);
                        for (const e of u) a.push(e.getTypeAnnotation());
                      }
                      if (a.length) return n().createUnionTypeAnnotation(a);
                    })(t, this, e.name);
              if ("undefined" === e.name) return n().voidTypeAnnotation();
              if ("NaN" === e.name || "Infinity" === e.name)
                return n().numberTypeAnnotation();
              e.name;
            });
        },
        { "@babel/types": 100 }
      ],
      47: [
        function(e, t, r) {
          "use strict";
          function n() {
            const t = (function(e) {
              if (e && e.__esModule) return e;
              var t = {};
              if (null != e)
                for (var r in e)
                  if (Object.prototype.hasOwnProperty.call(e, r)) {
                    var n =
                      Object.defineProperty && Object.getOwnPropertyDescriptor
                        ? Object.getOwnPropertyDescriptor(e, r)
                        : {};
                    n.get || n.set
                      ? Object.defineProperty(t, r, n)
                      : (t[r] = e[r]);
                  }
              return (t.default = e), t;
            })(e("@babel/types"));
            return (
              (n = function() {
                return t;
              }),
              t
            );
          }
          Object.defineProperty(r, "__esModule", { value: !0 }),
            (r.VariableDeclarator = function() {
              if (!this.get("id").isIdentifier()) return;
              const e = this.get("init");
              let t = e.getTypeAnnotation();
              t &&
                "AnyTypeAnnotation" === t.type &&
                e.isCallExpression() &&
                e.get("callee").isIdentifier({ name: "Array" }) &&
                !e.scope.hasBinding("Array", !0) &&
                (t = o());
              return t;
            }),
            (r.TypeCastExpression = a),
            (r.NewExpression = function(e) {
              if (this.get("callee").isIdentifier())
                return n().genericTypeAnnotation(e.callee);
            }),
            (r.TemplateLiteral = function() {
              return n().stringTypeAnnotation();
            }),
            (r.UnaryExpression = function(e) {
              const t = e.operator;
              if ("void" === t) return n().voidTypeAnnotation();
              if (n().NUMBER_UNARY_OPERATORS.indexOf(t) >= 0)
                return n().numberTypeAnnotation();
              if (n().STRING_UNARY_OPERATORS.indexOf(t) >= 0)
                return n().stringTypeAnnotation();
              if (n().BOOLEAN_UNARY_OPERATORS.indexOf(t) >= 0)
                return n().booleanTypeAnnotation();
            }),
            (r.BinaryExpression = function(e) {
              const t = e.operator;
              if (n().NUMBER_BINARY_OPERATORS.indexOf(t) >= 0)
                return n().numberTypeAnnotation();
              if (n().BOOLEAN_BINARY_OPERATORS.indexOf(t) >= 0)
                return n().booleanTypeAnnotation();
              if ("+" === t) {
                const e = this.get("right"),
                  t = this.get("left");
                return t.isBaseType("number") && e.isBaseType("number")
                  ? n().numberTypeAnnotation()
                  : t.isBaseType("string") || e.isBaseType("string")
                  ? n().stringTypeAnnotation()
                  : n().unionTypeAnnotation([
                      n().stringTypeAnnotation(),
                      n().numberTypeAnnotation()
                    ]);
              }
            }),
            (r.LogicalExpression = function() {
              return n().createUnionTypeAnnotation([
                this.get("left").getTypeAnnotation(),
                this.get("right").getTypeAnnotation()
              ]);
            }),
            (r.ConditionalExpression = function() {
              return n().createUnionTypeAnnotation([
                this.get("consequent").getTypeAnnotation(),
                this.get("alternate").getTypeAnnotation()
              ]);
            }),
            (r.SequenceExpression = function() {
              return this.get("expressions")
                .pop()
                .getTypeAnnotation();
            }),
            (r.ParenthesizedExpression = function() {
              return this.get("expression").getTypeAnnotation();
            }),
            (r.AssignmentExpression = function() {
              return this.get("right").getTypeAnnotation();
            }),
            (r.UpdateExpression = function(e) {
              const t = e.operator;
              if ("++" === t || "--" === t) return n().numberTypeAnnotation();
            }),
            (r.StringLiteral = function() {
              return n().stringTypeAnnotation();
            }),
            (r.NumericLiteral = function() {
              return n().numberTypeAnnotation();
            }),
            (r.BooleanLiteral = function() {
              return n().booleanTypeAnnotation();
            }),
            (r.NullLiteral = function() {
              return n().nullLiteralTypeAnnotation();
            }),
            (r.RegExpLiteral = function() {
              return n().genericTypeAnnotation(n().identifier("RegExp"));
            }),
            (r.ObjectExpression = function() {
              return n().genericTypeAnnotation(n().identifier("Object"));
            }),
            (r.ArrayExpression = o),
            (r.RestElement = u),
            (r.ClassDeclaration = r.ClassExpression = r.FunctionDeclaration = r.ArrowFunctionExpression = r.FunctionExpression = function() {
              return n().genericTypeAnnotation(n().identifier("Function"));
            }),
            (r.CallExpression = function() {
              const { callee: e } = this.node;
              if (c(e))
                return n().arrayTypeAnnotation(n().stringTypeAnnotation());
              if (l(e) || p(e))
                return n().arrayTypeAnnotation(n().anyTypeAnnotation());
              if (d(e))
                return n().arrayTypeAnnotation(
                  n().tupleTypeAnnotation([
                    n().stringTypeAnnotation(),
                    n().anyTypeAnnotation()
                  ])
                );
              return h(this.get("callee"));
            }),
            (r.TaggedTemplateExpression = function() {
              return h(this.get("tag"));
            }),
            Object.defineProperty(r, "Identifier", {
              enumerable: !0,
              get: function() {
                return s.default;
              }
            });
          var i,
            s =
              (i = e("./inferer-reference")) && i.__esModule
                ? i
                : { default: i };
          function a(e) {
            return e.typeAnnotation;
          }
          function o() {
            return n().genericTypeAnnotation(n().identifier("Array"));
          }
          function u() {
            return o();
          }
          (a.validParent = !0), (u.validParent = !0);
          const l = n().buildMatchMemberExpression("Array.from"),
            c = n().buildMatchMemberExpression("Object.keys"),
            p = n().buildMatchMemberExpression("Object.values"),
            d = n().buildMatchMemberExpression("Object.entries");
          function h(e) {
            if ((e = e.resolve()).isFunction()) {
              if (e.is("async"))
                return e.is("generator")
                  ? n().genericTypeAnnotation(n().identifier("AsyncIterator"))
                  : n().genericTypeAnnotation(n().identifier("Promise"));
              if (e.node.returnType) return e.node.returnType;
            }
          }
        },
        { "./inferer-reference": 46, "@babel/types": 100 }
      ],
      48: [
        function(e, t, r) {
          "use strict";
          function n() {
            const t =
              (r = e("lodash/includes")) && r.__esModule ? r : { default: r };
            var r;
            return (
              (n = function() {
                return t;
              }),
              t
            );
          }
          function i() {
            const t = (function(e) {
              if (e && e.__esModule) return e;
              var t = {};
              if (null != e)
                for (var r in e)
                  if (Object.prototype.hasOwnProperty.call(e, r)) {
                    var n =
                      Object.defineProperty && Object.getOwnPropertyDescriptor
                        ? Object.getOwnPropertyDescriptor(e, r)
                        : {};
                    n.get || n.set
                      ? Object.defineProperty(t, r, n)
                      : (t[r] = e[r]);
                  }
              return (t.default = e), t;
            })(e("@babel/types"));
            return (
              (i = function() {
                return t;
              }),
              t
            );
          }
          function s(e) {
            const t = this.node && this.node[e];
            return t && Array.isArray(t) ? !!t.length : !!t;
          }
          Object.defineProperty(r, "__esModule", { value: !0 }),
            (r.matchesPattern = function(e, t) {
              return i().matchesPattern(this.node, e, t);
            }),
            (r.has = s),
            (r.isStatic = function() {
              return this.scope.isStatic(this.node);
            }),
            (r.isnt = function(e) {
              return !this.has(e);
            }),
            (r.equals = function(e, t) {
              return this.node[e] === t;
            }),
            (r.isNodeType = function(e) {
              return i().isType(this.type, e);
            }),
            (r.canHaveVariableDeclarationOrExpression = function() {
              return (
                ("init" === this.key || "left" === this.key) &&
                this.parentPath.isFor()
              );
            }),
            (r.canSwapBetweenExpressionAndStatement = function(e) {
              if (
                "body" !== this.key ||
                !this.parentPath.isArrowFunctionExpression()
              )
                return !1;
              if (this.isExpression()) return i().isBlockStatement(e);
              if (this.isBlockStatement()) return i().isExpression(e);
              return !1;
            }),
            (r.isCompletionRecord = function(e) {
              let t = this,
                r = !0;
              do {
                const n = t.container;
                if (t.isFunction() && !r) return !!e;
                if (((r = !1), Array.isArray(n) && t.key !== n.length - 1))
                  return !1;
              } while ((t = t.parentPath) && !t.isProgram());
              return !0;
            }),
            (r.isStatementOrBlock = function() {
              return (
                !this.parentPath.isLabeledStatement() &&
                !i().isBlockStatement(this.container) &&
                (0, n().default)(i().STATEMENT_OR_BLOCK_KEYS, this.key)
              );
            }),
            (r.referencesImport = function(e, t) {
              if (!this.isReferencedIdentifier()) return !1;
              const r = this.scope.getBinding(this.node.name);
              if (!r || "module" !== r.kind) return !1;
              const n = r.path,
                i = n.parentPath;
              if (!i.isImportDeclaration()) return !1;
              if (i.node.source.value !== e) return !1;
              if (!t) return !0;
              if (n.isImportDefaultSpecifier() && "default" === t) return !0;
              if (n.isImportNamespaceSpecifier() && "*" === t) return !0;
              if (n.isImportSpecifier() && n.node.imported.name === t)
                return !0;
              return !1;
            }),
            (r.getSource = function() {
              const e = this.node;
              if (e.end) {
                const t = this.hub.getCode();
                if (t) return t.slice(e.start, e.end);
              }
              return "";
            }),
            (r.willIMaybeExecuteBefore = function(e) {
              return "after" !== this._guessExecutionStatusRelativeTo(e);
            }),
            (r._guessExecutionStatusRelativeTo = function(e) {
              const t =
                  e.scope.getFunctionParent() || e.scope.getProgramParent(),
                r =
                  this.scope.getFunctionParent() || e.scope.getProgramParent();
              if (t.node !== r.node) {
                const r = this._guessExecutionStatusRelativeToDifferentFunctions(
                  t
                );
                if (r) return r;
                e = t.path;
              }
              const n = e.getAncestry();
              if (n.indexOf(this) >= 0) return "after";
              const s = this.getAncestry();
              let a, o, u;
              for (u = 0; u < s.length; u++) {
                const e = s[u];
                if ((o = n.indexOf(e)) >= 0) {
                  a = e;
                  break;
                }
              }
              if (!a) return "before";
              const l = n[o - 1],
                c = s[u - 1];
              if (!l || !c) return "before";
              if (l.listKey && l.container === c.container)
                return l.key > c.key ? "before" : "after";
              const p = i().VISITOR_KEYS[a.type],
                d = p.indexOf(l.key),
                h = p.indexOf(c.key);
              return d > h ? "before" : "after";
            }),
            (r._guessExecutionStatusRelativeToDifferentFunctions = function(e) {
              const t = e.path;
              if (!t.isFunctionDeclaration()) return;
              const r = t.scope.getBinding(t.node.id.name);
              if (!r.references) return "before";
              const n = r.referencePaths;
              for (const e of n)
                if ("callee" !== e.key || !e.parentPath.isCallExpression())
                  return;
              let i;
              for (const e of n) {
                const r = !!e.find(e => e.node === t.node);
                if (r) continue;
                const n = this._guessExecutionStatusRelativeTo(e);
                if (i) {
                  if (i !== n) return;
                } else i = n;
              }
              return i;
            }),
            (r.resolve = function(e, t) {
              return this._resolve(e, t) || this;
            }),
            (r._resolve = function(e, t) {
              if (t && t.indexOf(this) >= 0) return;
              if (((t = t || []).push(this), this.isVariableDeclarator())) {
                if (this.get("id").isIdentifier())
                  return this.get("init").resolve(e, t);
              } else if (this.isReferencedIdentifier()) {
                const r = this.scope.getBinding(this.node.name);
                if (!r) return;
                if (!r.constant) return;
                if ("module" === r.kind) return;
                if (r.path !== this) {
                  const n = r.path.resolve(e, t);
                  if (this.find(e => e.node === n.node)) return;
                  return n;
                }
              } else {
                if (this.isTypeCastExpression())
                  return this.get("expression").resolve(e, t);
                if (e && this.isMemberExpression()) {
                  const r = this.toComputedKey();
                  if (!i().isLiteral(r)) return;
                  const n = r.value,
                    s = this.get("object").resolve(e, t);
                  if (s.isObjectExpression()) {
                    const r = s.get("properties");
                    for (const i of r) {
                      if (!i.isProperty()) continue;
                      const r = i.get("key");
                      let s = i.isnt("computed") && r.isIdentifier({ name: n });
                      if ((s = s || r.isLiteral({ value: n })))
                        return i.get("value").resolve(e, t);
                    }
                  } else if (s.isArrayExpression() && !isNaN(+n)) {
                    const r = s.get("elements"),
                      i = r[n];
                    if (i) return i.resolve(e, t);
                  }
                }
              }
            }),
            (r.isConstantExpression = function() {
              if (this.isIdentifier()) {
                const e = this.scope.getBinding(this.node.name);
                return !!e && e.constant;
              }
              if (this.isLiteral())
                return (
                  !this.isRegExpLiteral() &&
                  (!this.isTemplateLiteral() ||
                    this.get("expressions").every(e =>
                      e.isConstantExpression()
                    ))
                );
              if (this.isUnaryExpression())
                return (
                  "void" === this.get("operator").node &&
                  this.get("argument").isConstantExpression()
                );
              if (this.isBinaryExpression())
                return (
                  this.get("left").isConstantExpression() &&
                  this.get("right").isConstantExpression()
                );
              return !1;
            }),
            (r.isInStrictMode = function() {
              return !!(this.isProgram() ? this : this.parentPath).find(e => {
                if (e.isProgram({ sourceType: "module" })) return !0;
                if (e.isClass()) return !0;
                if (!e.isProgram() && !e.isFunction()) return !1;
                if (
                  e.isArrowFunctionExpression() &&
                  !e.get("body").isBlockStatement()
                )
                  return !1;
                let { node: t } = e;
                e.isFunction() && (t = t.body);
                for (const e of t.directives)
                  if ("use strict" === e.value.value) return !0;
              });
            }),
            (r.is = void 0);
          const a = s;
          r.is = a;
        },
        { "@babel/types": 100, "lodash/includes": 274 }
      ],
      49: [
        function(e, t, r) {
          "use strict";
          function n() {
            const t = (function(e) {
              if (e && e.__esModule) return e;
              var t = {};
              if (null != e)
                for (var r in e)
                  if (Object.prototype.hasOwnProperty.call(e, r)) {
                    var n =
                      Object.defineProperty && Object.getOwnPropertyDescriptor
                        ? Object.getOwnPropertyDescriptor(e, r)
                        : {};
                    n.get || n.set
                      ? Object.defineProperty(t, r, n)
                      : (t[r] = e[r]);
                  }
              return (t.default = e), t;
            })(e("@babel/types"));
            return (
              (n = function() {
                return t;
              }),
              t
            );
          }
          Object.defineProperty(r, "__esModule", { value: !0 }),
            (r.default = void 0);
          const i = {
            ReferencedIdentifier(e, t) {
              if (
                e.isJSXIdentifier() &&
                n().react.isCompatTag(e.node.name) &&
                !e.parentPath.isJSXMemberExpression()
              )
                return;
              if ("this" === e.node.name) {
                let r = e.scope;
                do {
                  if (
                    r.path.isFunction() &&
                    !r.path.isArrowFunctionExpression()
                  )
                    break;
                } while ((r = r.parent));
                r && t.breakOnScopePaths.push(r.path);
              }
              const r = e.scope.getBinding(e.node.name);
              r &&
                r === t.scope.getBinding(e.node.name) &&
                (t.bindings[e.node.name] = r);
            }
          };
          r.default = class {
            constructor(e, t) {
              (this.breakOnScopePaths = []),
                (this.bindings = {}),
                (this.scopes = []),
                (this.scope = t),
                (this.path = e),
                (this.attachAfter = !1);
            }
            isCompatibleScope(e) {
              for (const t of Object.keys(this.bindings)) {
                const r = this.bindings[t];
                if (!e.bindingIdentifierEquals(t, r.identifier)) return !1;
              }
              return !0;
            }
            getCompatibleScopes() {
              let e = this.path.scope;
              do {
                if (!this.isCompatibleScope(e)) break;
                if (
                  (this.scopes.push(e),
                  this.breakOnScopePaths.indexOf(e.path) >= 0)
                )
                  break;
              } while ((e = e.parent));
            }
            getAttachmentPath() {
              let e = this._getAttachmentPath();
              if (!e) return;
              let t = e.scope;
              if (
                (t.path === e && (t = e.scope.parent),
                t.path.isProgram() || t.path.isFunction())
              )
                for (const r of Object.keys(this.bindings)) {
                  if (!t.hasOwnBinding(r)) continue;
                  const n = this.bindings[r];
                  if (
                    "param" !== n.kind &&
                    "params" !== n.path.parentKey &&
                    this.getAttachmentParentForPath(n.path).key >= e.key
                  ) {
                    (this.attachAfter = !0), (e = n.path);
                    for (const t of n.constantViolations)
                      this.getAttachmentParentForPath(t).key > e.key && (e = t);
                  }
                }
              return e;
            }
            _getAttachmentPath() {
              const e = this.scopes.pop();
              if (e)
                if (e.path.isFunction()) {
                  if (!this.hasOwnParamBindings(e))
                    return this.getNextScopeAttachmentParent();
                  {
                    if (this.scope === e) return;
                    const t = e.path.get("body").get("body");
                    for (let e = 0; e < t.length; e++)
                      if (!t[e].node._blockHoist) return t[e];
                  }
                } else if (e.path.isProgram())
                  return this.getNextScopeAttachmentParent();
            }
            getNextScopeAttachmentParent() {
              const e = this.scopes.pop();
              if (e) return this.getAttachmentParentForPath(e.path);
            }
            getAttachmentParentForPath(e) {
              do {
                if (
                  !e.parentPath ||
                  (Array.isArray(e.container) && e.isStatement())
                )
                  return e;
              } while ((e = e.parentPath));
            }
            hasOwnParamBindings(e) {
              for (const t of Object.keys(this.bindings)) {
                if (!e.hasOwnBinding(t)) continue;
                const r = this.bindings[t];
                if ("param" === r.kind && r.constant) return !0;
              }
              return !1;
            }
            run() {
              this.path.traverse(i, this), this.getCompatibleScopes();
              const e = this.getAttachmentPath();
              if (!e) return;
              if (e.getFunctionParent() === this.path.getFunctionParent())
                return;
              let t = e.scope.generateUidIdentifier("ref");
              const r = n().variableDeclarator(t, this.path.node),
                s = this.attachAfter ? "insertAfter" : "insertBefore",
                [a] = e[s]([
                  e.isVariableDeclarator()
                    ? r
                    : n().variableDeclaration("var", [r])
                ]),
                o = this.path.parentPath;
              return (
                o.isJSXElement() &&
                  this.path.container === o.node.children &&
                  (t = n().JSXExpressionContainer(t)),
                this.path.replaceWith(n().cloneNode(t)),
                e.isVariableDeclarator()
                  ? a.get("init")
                  : a.get("declarations.0.init")
              );
            }
          };
        },
        { "@babel/types": 100 }
      ],
      50: [
        function(e, t, r) {
          "use strict";
          Object.defineProperty(r, "__esModule", { value: !0 }),
            (r.hooks = void 0);
          r.hooks = [
            function(e, t) {
              if (
                ("test" === e.key && (t.isWhile() || t.isSwitchCase())) ||
                ("declaration" === e.key && t.isExportDeclaration()) ||
                ("body" === e.key && t.isLabeledStatement()) ||
                ("declarations" === e.listKey &&
                  t.isVariableDeclaration() &&
                  1 === t.node.declarations.length) ||
                ("expression" === e.key && t.isExpressionStatement())
              )
                return t.remove(), !0;
            },
            function(e, t) {
              if (t.isSequenceExpression() && 1 === t.node.expressions.length)
                return t.replaceWith(t.node.expressions[0]), !0;
            },
            function(e, t) {
              if (t.isBinary())
                return (
                  "left" === e.key
                    ? t.replaceWith(t.node.right)
                    : t.replaceWith(t.node.left),
                  !0
                );
            },
            function(e, t) {
              if (
                (t.isIfStatement() &&
                  ("consequent" === e.key || "alternate" === e.key)) ||
                ("body" === e.key &&
                  (t.isLoop() || t.isArrowFunctionExpression()))
              )
                return e.replaceWith({ type: "BlockStatement", body: [] }), !0;
            }
          ];
        },
        {}
      ],
      51: [
        function(e, t, r) {
          "use strict";
          function n() {
            const t = (function(e) {
              if (e && e.__esModule) return e;
              var t = {};
              if (null != e)
                for (var r in e)
                  if (Object.prototype.hasOwnProperty.call(e, r)) {
                    var n =
                      Object.defineProperty && Object.getOwnPropertyDescriptor
                        ? Object.getOwnPropertyDescriptor(e, r)
                        : {};
                    n.get || n.set
                      ? Object.defineProperty(t, r, n)
                      : (t[r] = e[r]);
                  }
              return (t.default = e), t;
            })(e("@babel/types"));
            return (
              (n = function() {
                return t;
              }),
              t
            );
          }
          Object.defineProperty(r, "__esModule", { value: !0 }),
            (r.ForAwaitStatement = r.NumericLiteralTypeAnnotation = r.ExistentialTypeParam = r.SpreadProperty = r.RestProperty = r.Flow = r.Pure = r.Generated = r.User = r.Var = r.BlockScoped = r.Referenced = r.Scope = r.Expression = r.Statement = r.BindingIdentifier = r.ReferencedMemberExpression = r.ReferencedIdentifier = void 0);
          const i = {
            types: ["Identifier", "JSXIdentifier"],
            checkPath(e, t) {
              const { node: r, parent: i } = e;
              if (!n().isIdentifier(r, t) && !n().isJSXMemberExpression(i, t)) {
                if (!n().isJSXIdentifier(r, t)) return !1;
                if (n().react.isCompatTag(r.name)) return !1;
              }
              return n().isReferenced(r, i, e.parentPath.parent);
            }
          };
          r.ReferencedIdentifier = i;
          const s = {
            types: ["MemberExpression"],
            checkPath: ({ node: e, parent: t }) =>
              n().isMemberExpression(e) && n().isReferenced(e, t)
          };
          r.ReferencedMemberExpression = s;
          const a = {
            types: ["Identifier"],
            checkPath(e) {
              const { node: t, parent: r } = e,
                i = e.parentPath.parent;
              return n().isIdentifier(t) && n().isBinding(t, r, i);
            }
          };
          r.BindingIdentifier = a;
          const o = {
            types: ["Statement"],
            checkPath({ node: e, parent: t }) {
              if (n().isStatement(e)) {
                if (n().isVariableDeclaration(e)) {
                  if (n().isForXStatement(t, { left: e })) return !1;
                  if (n().isForStatement(t, { init: e })) return !1;
                }
                return !0;
              }
              return !1;
            }
          };
          r.Statement = o;
          const u = {
            types: ["Expression"],
            checkPath: e =>
              e.isIdentifier()
                ? e.isReferencedIdentifier()
                : n().isExpression(e.node)
          };
          r.Expression = u;
          const l = {
            types: ["Scopable"],
            checkPath: e => n().isScope(e.node, e.parent)
          };
          r.Scope = l;
          const c = { checkPath: e => n().isReferenced(e.node, e.parent) };
          r.Referenced = c;
          const p = { checkPath: e => n().isBlockScoped(e.node) };
          r.BlockScoped = p;
          const d = {
            types: ["VariableDeclaration"],
            checkPath: e => n().isVar(e.node)
          };
          r.Var = d;
          const h = { checkPath: e => e.node && !!e.node.loc };
          r.User = h;
          const f = { checkPath: e => !e.isUser() };
          r.Generated = f;
          const m = { checkPath: (e, t) => e.scope.isPure(e.node, t) };
          r.Pure = m;
          const y = {
            types: [
              "Flow",
              "ImportDeclaration",
              "ExportDeclaration",
              "ImportSpecifier"
            ],
            checkPath: ({ node: e }) =>
              !!n().isFlow(e) ||
              (n().isImportDeclaration(e)
                ? "type" === e.importKind || "typeof" === e.importKind
                : n().isExportDeclaration(e)
                ? "type" === e.exportKind
                : !!n().isImportSpecifier(e) &&
                  ("type" === e.importKind || "typeof" === e.importKind))
          };
          r.Flow = y;
          const g = {
            types: ["RestElement"],
            checkPath: e => e.parentPath && e.parentPath.isObjectPattern()
          };
          r.RestProperty = g;
          const b = {
            types: ["RestElement"],
            checkPath: e => e.parentPath && e.parentPath.isObjectExpression()
          };
          r.SpreadProperty = b;
          r.ExistentialTypeParam = { types: ["ExistsTypeAnnotation"] };
          r.NumericLiteralTypeAnnotation = {
            types: ["NumberLiteralTypeAnnotation"]
          };
          const v = {
            types: ["ForOfStatement"],
            checkPath: ({ node: e }) => !0 === e.await
          };
          r.ForAwaitStatement = v;
        },
        { "@babel/types": 100 }
      ],
      52: [
        function(e, t, r) {
          "use strict";
          Object.defineProperty(r, "__esModule", { value: !0 }),
            (r.insertBefore = function(e) {
              this._assertUnremoved(), (e = this._verifyNodeList(e));
              const { parentPath: t } = this;
              if (
                t.isExpressionStatement() ||
                t.isLabeledStatement() ||
                t.isExportNamedDeclaration() ||
                (t.isExportDefaultDeclaration() && this.isDeclaration())
              )
                return t.insertBefore(e);
              if (
                (this.isNodeType("Expression") && !this.isJSXElement()) ||
                (t.isForStatement() && "init" === this.key)
              )
                return (
                  this.node && e.push(this.node),
                  this.replaceExpressionWithStatements(e)
                );
              if (Array.isArray(this.container))
                return this._containerInsertBefore(e);
              if (this.isStatementOrBlock()) {
                const t =
                  this.node &&
                  (!this.isExpressionStatement() ||
                    null != this.node.expression);
                return (
                  this.replaceWith(a().blockStatement(t ? [this.node] : [])),
                  this.unshiftContainer("body", e)
                );
              }
              throw new Error(
                "We don't know what to do with this node type. We were previously a Statement but we can't fit in here?"
              );
            }),
            (r._containerInsert = function(e, t) {
              this.updateSiblingKeys(e, t.length);
              const r = [];
              this.container.splice(e, 0, ...t);
              for (let n = 0; n < t.length; n++) {
                const t = e + n,
                  i = this.getSibling(t);
                r.push(i),
                  this.context &&
                    this.context.queue &&
                    i.pushContext(this.context);
              }
              const n = this._getQueueContexts();
              for (const e of r) {
                e.setScope(), e.debug("Inserted.");
                for (const t of n) t.maybeQueue(e, !0);
              }
              return r;
            }),
            (r._containerInsertBefore = function(e) {
              return this._containerInsert(this.key, e);
            }),
            (r._containerInsertAfter = function(e) {
              return this._containerInsert(this.key + 1, e);
            }),
            (r.insertAfter = function(e) {
              this._assertUnremoved(), (e = this._verifyNodeList(e));
              const { parentPath: t } = this;
              if (
                t.isExpressionStatement() ||
                t.isLabeledStatement() ||
                t.isExportNamedDeclaration() ||
                (t.isExportDefaultDeclaration() && this.isDeclaration())
              )
                return t.insertAfter(
                  e.map(e =>
                    a().isExpression(e) ? a().expressionStatement(e) : e
                  )
                );
              if (
                (this.isNodeType("Expression") && !this.isJSXElement()) ||
                (t.isForStatement() && "init" === this.key)
              ) {
                if (this.node) {
                  let { scope: r } = this;
                  t.isMethod({ computed: !0, key: this.node }) &&
                    (r = r.parent);
                  const n = r.generateDeclaredUidIdentifier();
                  e.unshift(
                    a().expressionStatement(
                      a().assignmentExpression("=", a().cloneNode(n), this.node)
                    )
                  ),
                    e.push(a().expressionStatement(a().cloneNode(n)));
                }
                return this.replaceExpressionWithStatements(e);
              }
              if (Array.isArray(this.container))
                return this._containerInsertAfter(e);
              if (this.isStatementOrBlock()) {
                const t =
                  this.node &&
                  (!this.isExpressionStatement() ||
                    null != this.node.expression);
                return (
                  this.replaceWith(a().blockStatement(t ? [this.node] : [])),
                  this.pushContainer("body", e)
                );
              }
              throw new Error(
                "We don't know what to do with this node type. We were previously a Statement but we can't fit in here?"
              );
            }),
            (r.updateSiblingKeys = function(e, t) {
              if (!this.parent) return;
              const r = n.path.get(this.parent);
              for (let n = 0; n < r.length; n++) {
                const i = r[n];
                i.key >= e && (i.key += t);
              }
            }),
            (r._verifyNodeList = function(e) {
              if (!e) return [];
              e.constructor !== Array && (e = [e]);
              for (let t = 0; t < e.length; t++) {
                const r = e[t];
                let n;
                if (
                  (r
                    ? "object" != typeof r
                      ? (n = "contains a non-object node")
                      : r.type
                      ? r instanceof s.default &&
                        (n = "has a NodePath when it expected a raw object")
                      : (n = "without a type")
                    : (n = "has falsy node"),
                  n)
                ) {
                  const e = Array.isArray(r) ? "array" : typeof r;
                  throw new Error(
                    `Node list ${n} with the index of ${t} and type of ${e}`
                  );
                }
              }
              return e;
            }),
            (r.unshiftContainer = function(e, t) {
              return (
                this._assertUnremoved(),
                (t = this._verifyNodeList(t)),
                s.default
                  .get({
                    parentPath: this,
                    parent: this.node,
                    container: this.node[e],
                    listKey: e,
                    key: 0
                  })
                  ._containerInsertBefore(t)
              );
            }),
            (r.pushContainer = function(e, t) {
              this._assertUnremoved(), (t = this._verifyNodeList(t));
              const r = this.node[e];
              return s.default
                .get({
                  parentPath: this,
                  parent: this.node,
                  container: r,
                  listKey: e,
                  key: r.length
                })
                .replaceWithMultiple(t);
            }),
            (r.hoist = function(e = this.scope) {
              return new i.default(this, e).run();
            });
          var n = e("../cache"),
            i = o(e("./lib/hoister")),
            s = o(e("./index"));
          function a() {
            const t = (function(e) {
              if (e && e.__esModule) return e;
              var t = {};
              if (null != e)
                for (var r in e)
                  if (Object.prototype.hasOwnProperty.call(e, r)) {
                    var n =
                      Object.defineProperty && Object.getOwnPropertyDescriptor
                        ? Object.getOwnPropertyDescriptor(e, r)
                        : {};
                    n.get || n.set
                      ? Object.defineProperty(t, r, n)
                      : (t[r] = e[r]);
                  }
              return (t.default = e), t;
            })(e("@babel/types"));
            return (
              (a = function() {
                return t;
              }),
              t
            );
          }
          function o(e) {
            return e && e.__esModule ? e : { default: e };
          }
        },
        {
          "../cache": 34,
          "./index": 44,
          "./lib/hoister": 49,
          "@babel/types": 100
        }
      ],
      53: [
        function(e, t, r) {
          "use strict";
          Object.defineProperty(r, "__esModule", { value: !0 }),
            (r.remove = function() {
              if (
                (this._assertUnremoved(),
                this.resync(),
                this._removeFromScope(),
                this._callRemovalHooks())
              )
                return void this._markRemoved();
              this.shareCommentsWithSiblings(),
                this._remove(),
                this._markRemoved();
            }),
            (r._removeFromScope = function() {
              const e = this.getBindingIdentifiers();
              Object.keys(e).forEach(e => this.scope.removeBinding(e));
            }),
            (r._callRemovalHooks = function() {
              for (const e of n.hooks) if (e(this, this.parentPath)) return !0;
            }),
            (r._remove = function() {
              Array.isArray(this.container)
                ? (this.container.splice(this.key, 1),
                  this.updateSiblingKeys(this.key, -1))
                : this._replaceWith(null);
            }),
            (r._markRemoved = function() {
              (this.shouldSkip = !0), (this.removed = !0), (this.node = null);
            }),
            (r._assertUnremoved = function() {
              if (this.removed)
                throw this.buildCodeFrameError(
                  "NodePath has been removed so is read-only."
                );
            });
          var n = e("./lib/removal-hooks");
        },
        { "./lib/removal-hooks": 50 }
      ],
      54: [
        function(e, t, r) {
          "use strict";
          function n() {
            const t = e("@babel/code-frame");
            return (
              (n = function() {
                return t;
              }),
              t
            );
          }
          Object.defineProperty(r, "__esModule", { value: !0 }),
            (r.replaceWithMultiple = function(e) {
              this.resync(),
                (e = this._verifyNodeList(e)),
                o().inheritLeadingComments(e[0], this.node),
                o().inheritTrailingComments(e[e.length - 1], this.node),
                (this.node = this.container[this.key] = null);
              const t = this.insertAfter(e);
              this.node ? this.requeue() : this.remove();
              return t;
            }),
            (r.replaceWithSourceString = function(e) {
              this.resync();
              try {
                (e = `(${e})`), (e = (0, a().parse)(e));
              } catch (t) {
                const r = t.loc;
                throw (r &&
                  ((t.message +=
                    " - make sure this is an expression.\n" +
                    (0, n().codeFrameColumns)(e, {
                      start: { line: r.line, column: r.column + 1 }
                    })),
                  (t.code = "BABEL_REPLACE_SOURCE_ERROR")),
                t);
              }
              return (
                (e = e.program.body[0].expression),
                i.default.removeProperties(e),
                this.replaceWith(e)
              );
            }),
            (r.replaceWith = function(e) {
              if ((this.resync(), this.removed))
                throw new Error(
                  "You can't replace this node, we've already removed it"
                );
              e instanceof s.default && (e = e.node);
              if (!e)
                throw new Error(
                  "You passed `path.replaceWith()` a falsy node, use `path.remove()` instead"
                );
              if (this.node === e) return [this];
              if (this.isProgram() && !o().isProgram(e))
                throw new Error(
                  "You can only replace a Program root node with another Program node"
                );
              if (Array.isArray(e))
                throw new Error(
                  "Don't use `path.replaceWith()` with an array of nodes, use `path.replaceWithMultiple()`"
                );
              if ("string" == typeof e)
                throw new Error(
                  "Don't use `path.replaceWith()` with a source string, use `path.replaceWithSourceString()`"
                );
              let t = "";
              this.isNodeType("Statement") &&
                o().isExpression(e) &&
                (this.canHaveVariableDeclarationOrExpression() ||
                  this.canSwapBetweenExpressionAndStatement(e) ||
                  this.parentPath.isExportDefaultDeclaration() ||
                  ((e = o().expressionStatement(e)), (t = "expression")));
              if (
                this.isNodeType("Expression") &&
                o().isStatement(e) &&
                !this.canHaveVariableDeclarationOrExpression() &&
                !this.canSwapBetweenExpressionAndStatement(e)
              )
                return this.replaceExpressionWithStatements([e]);
              const r = this.node;
              r && (o().inheritsComments(e, r), o().removeComments(r));
              return (
                this._replaceWith(e),
                (this.type = e.type),
                this.setScope(),
                this.requeue(),
                [t ? this.get(t) : this]
              );
            }),
            (r._replaceWith = function(e) {
              if (!this.container)
                throw new ReferenceError("Container is falsy");
              this.inList
                ? o().validate(this.parent, this.key, [e])
                : o().validate(this.parent, this.key, e);
              this.debug(`Replace with ${e && e.type}`),
                (this.node = this.container[this.key] = e);
            }),
            (r.replaceExpressionWithStatements = function(e) {
              this.resync();
              const t = o().toSequenceExpression(e, this.scope);
              if (t) return this.replaceWith(t)[0].get("expressions");
              const r = this.getFunctionParent(),
                n = r && r.is("async"),
                s = o().arrowFunctionExpression([], o().blockStatement(e));
              this.replaceWith(o().callExpression(s, [])), this.traverse(l);
              const a = this.get("callee").getCompletionRecords();
              for (const e of a) {
                if (!e.isExpressionStatement()) continue;
                const t = e.findParent(e => e.isLoop());
                if (t) {
                  let r = t.getData("expressionReplacementReturnUid");
                  if (r) r = o().identifier(r.name);
                  else {
                    const e = this.get("callee");
                    (r = e.scope.generateDeclaredUidIdentifier("ret")),
                      e
                        .get("body")
                        .pushContainer(
                          "body",
                          o().returnStatement(o().cloneNode(r))
                        ),
                      t.setData("expressionReplacementReturnUid", r);
                  }
                  e.get("expression").replaceWith(
                    o().assignmentExpression(
                      "=",
                      o().cloneNode(r),
                      e.node.expression
                    )
                  );
                } else e.replaceWith(o().returnStatement(e.node.expression));
              }
              const u = this.get("callee");
              u.arrowFunctionToExpression(),
                n &&
                  i.default.hasType(
                    this.get("callee.body").node,
                    "AwaitExpression",
                    o().FUNCTION_TYPES
                  ) &&
                  (u.set("async", !0),
                  this.replaceWith(o().awaitExpression(this.node)));
              return u.get("body.body");
            }),
            (r.replaceInline = function(e) {
              if ((this.resync(), Array.isArray(e))) {
                if (Array.isArray(this.container)) {
                  e = this._verifyNodeList(e);
                  const t = this._containerInsertAfter(e);
                  return this.remove(), t;
                }
                return this.replaceWithMultiple(e);
              }
              return this.replaceWith(e);
            });
          var i = u(e("../index")),
            s = u(e("./index"));
          function a() {
            const t = e("@babel/parser");
            return (
              (a = function() {
                return t;
              }),
              t
            );
          }
          function o() {
            const t = (function(e) {
              if (e && e.__esModule) return e;
              var t = {};
              if (null != e)
                for (var r in e)
                  if (Object.prototype.hasOwnProperty.call(e, r)) {
                    var n =
                      Object.defineProperty && Object.getOwnPropertyDescriptor
                        ? Object.getOwnPropertyDescriptor(e, r)
                        : {};
                    n.get || n.set
                      ? Object.defineProperty(t, r, n)
                      : (t[r] = e[r]);
                  }
              return (t.default = e), t;
            })(e("@babel/types"));
            return (
              (o = function() {
                return t;
              }),
              t
            );
          }
          function u(e) {
            return e && e.__esModule ? e : { default: e };
          }
          const l = {
            Function(e) {
              e.skip();
            },
            VariableDeclaration(e) {
              if ("var" !== e.node.kind) return;
              const t = e.getBindingIdentifiers();
              for (const r of Object.keys(t)) e.scope.push({ id: t[r] });
              const r = [];
              for (const t of e.node.declarations)
                t.init &&
                  r.push(
                    o().expressionStatement(
                      o().assignmentExpression("=", t.id, t.init)
                    )
                  );
              e.replaceWithMultiple(r);
            }
          };
        },
        {
          "../index": 37,
          "./index": 44,
          "@babel/code-frame": 1,
          "@babel/parser": 25,
          "@babel/types": 100
        }
      ],
      55: [
        function(e, t, r) {
          "use strict";
          Object.defineProperty(r, "__esModule", { value: !0 }),
            (r.default = void 0);
          r.default = class {
            constructor({ identifier: e, scope: t, path: r, kind: n }) {
              (this.identifier = e),
                (this.scope = t),
                (this.path = r),
                (this.kind = n),
                (this.constantViolations = []),
                (this.constant = !0),
                (this.referencePaths = []),
                (this.referenced = !1),
                (this.references = 0),
                this.clearValue();
            }
            deoptValue() {
              this.clearValue(), (this.hasDeoptedValue = !0);
            }
            setValue(e) {
              this.hasDeoptedValue || ((this.hasValue = !0), (this.value = e));
            }
            clearValue() {
              (this.hasDeoptedValue = !1),
                (this.hasValue = !1),
                (this.value = null);
            }
            reassign(e) {
              (this.constant = !1),
                -1 === this.constantViolations.indexOf(e) &&
                  this.constantViolations.push(e);
            }
            reference(e) {
              -1 === this.referencePaths.indexOf(e) &&
                ((this.referenced = !0),
                this.references++,
                this.referencePaths.push(e));
            }
            dereference() {
              this.references--, (this.referenced = !!this.references);
            }
          };
        },
        {}
      ],
      56: [
        function(e, t, r) {
          "use strict";
          function n() {
            const t = d(e("lodash/includes"));
            return (
              (n = function() {
                return t;
              }),
              t
            );
          }
          function i() {
            const t = d(e("lodash/repeat"));
            return (
              (i = function() {
                return t;
              }),
              t
            );
          }
          Object.defineProperty(r, "__esModule", { value: !0 }),
            (r.default = void 0);
          var s = d(e("./lib/renamer")),
            a = d(e("../index"));
          function o() {
            const t = d(e("lodash/defaults"));
            return (
              (o = function() {
                return t;
              }),
              t
            );
          }
          var u = d(e("./binding"));
          function l() {
            const t = d(e("globals"));
            return (
              (l = function() {
                return t;
              }),
              t
            );
          }
          function c() {
            const t = (function(e) {
              if (e && e.__esModule) return e;
              var t = {};
              if (null != e)
                for (var r in e)
                  if (Object.prototype.hasOwnProperty.call(e, r)) {
                    var n =
                      Object.defineProperty && Object.getOwnPropertyDescriptor
                        ? Object.getOwnPropertyDescriptor(e, r)
                        : {};
                    n.get || n.set
                      ? Object.defineProperty(t, r, n)
                      : (t[r] = e[r]);
                  }
              return (t.default = e), t;
            })(e("@babel/types"));
            return (
              (c = function() {
                return t;
              }),
              t
            );
          }
          var p = e("../cache");
          function d(e) {
            return e && e.__esModule ? e : { default: e };
          }
          const h = {
            For(e) {
              for (const t of c().FOR_INIT_KEYS) {
                const r = e.get(t);
                if (r.isVar()) {
                  (
                    e.scope.getFunctionParent() || e.scope.getProgramParent()
                  ).registerBinding("var", r);
                }
              }
            },
            Declaration(e) {
              if (e.isBlockScoped()) return;
              if (
                e.isExportDeclaration() &&
                e.get("declaration").isDeclaration()
              )
                return;
              (
                e.scope.getFunctionParent() || e.scope.getProgramParent()
              ).registerDeclaration(e);
            },
            ReferencedIdentifier(e, t) {
              t.references.push(e);
            },
            ForXStatement(e, t) {
              const r = e.get("left");
              (r.isPattern() || r.isIdentifier()) &&
                t.constantViolations.push(e);
            },
            ExportDeclaration: {
              exit(e) {
                const { node: t, scope: r } = e,
                  n = t.declaration;
                if (c().isClassDeclaration(n) || c().isFunctionDeclaration(n)) {
                  const t = n.id;
                  if (!t) return;
                  const i = r.getBinding(t.name);
                  i && i.reference(e);
                } else if (c().isVariableDeclaration(n))
                  for (const t of n.declarations)
                    for (const n of Object.keys(c().getBindingIdentifiers(t))) {
                      const t = r.getBinding(n);
                      t && t.reference(e);
                    }
              }
            },
            LabeledStatement(e) {
              e.scope.getProgramParent().addGlobal(e.node),
                e.scope.getBlockParent().registerDeclaration(e);
            },
            AssignmentExpression(e, t) {
              t.assignments.push(e);
            },
            UpdateExpression(e, t) {
              t.constantViolations.push(e);
            },
            UnaryExpression(e, t) {
              "delete" === e.node.operator && t.constantViolations.push(e);
            },
            BlockScoped(e) {
              let t = e.scope;
              t.path === e && (t = t.parent),
                t.getBlockParent().registerDeclaration(e);
            },
            ClassDeclaration(e) {
              const t = e.node.id;
              if (!t) return;
              const r = t.name;
              e.scope.bindings[r] = e.scope.getBinding(r);
            },
            Block(e) {
              const t = e.get("body");
              for (const r of t)
                r.isFunctionDeclaration() &&
                  e.scope.getBlockParent().registerDeclaration(r);
            }
          };
          let f = 0;
          class m {
            constructor(e) {
              const { node: t } = e,
                r = p.scope.get(t);
              if (r && r.path === e) return r;
              p.scope.set(t, this),
                (this.uid = f++),
                (this.block = t),
                (this.path = e),
                (this.labels = new Map());
            }
            get parent() {
              const e = this.path.findParent(e => e.isScope());
              return e && e.scope;
            }
            get parentBlock() {
              return this.path.parent;
            }
            get hub() {
              return this.path.hub;
            }
            traverse(e, t, r) {
              (0, a.default)(e, t, this, r, this.path);
            }
            generateDeclaredUidIdentifier(e) {
              const t = this.generateUidIdentifier(e);
              return this.push({ id: t }), c().cloneNode(t);
            }
            generateUidIdentifier(e) {
              return c().identifier(this.generateUid(e));
            }
            generateUid(e = "temp") {
              let t;
              e = c()
                .toIdentifier(e)
                .replace(/^_+/, "")
                .replace(/[0-9]+$/g, "");
              let r = 0;
              do {
                (t = this._generateUid(e, r)), r++;
              } while (
                this.hasLabel(t) ||
                this.hasBinding(t) ||
                this.hasGlobal(t) ||
                this.hasReference(t)
              );
              const n = this.getProgramParent();
              return (n.references[t] = !0), (n.uids[t] = !0), t;
            }
            _generateUid(e, t) {
              let r = e;
              return t > 1 && (r += t), `_${r}`;
            }
            generateUidBasedOnNode(e, t) {
              let r = e;
              c().isAssignmentExpression(e)
                ? (r = e.left)
                : c().isVariableDeclarator(e)
                ? (r = e.id)
                : (c().isObjectProperty(r) || c().isObjectMethod(r)) &&
                  (r = r.key);
              const n = [];
              !(function e(t, r) {
                if (c().isModuleDeclaration(t))
                  if (t.source) e(t.source, r);
                  else if (t.specifiers && t.specifiers.length)
                    for (const n of t.specifiers) e(n, r);
                  else t.declaration && e(t.declaration, r);
                else if (c().isModuleSpecifier(t)) e(t.local, r);
                else if (c().isMemberExpression(t))
                  e(t.object, r), e(t.property, r);
                else if (c().isIdentifier(t)) r.push(t.name);
                else if (c().isLiteral(t)) r.push(t.value);
                else if (c().isCallExpression(t)) e(t.callee, r);
                else if (c().isObjectExpression(t) || c().isObjectPattern(t))
                  for (const n of t.properties) e(n.key || n.argument, r);
                else
                  c().isPrivateName(t)
                    ? e(t.id, r)
                    : c().isThisExpression(t)
                    ? r.push("this")
                    : c().isSuper(t) && r.push("super");
              })(r, n);
              let i = n.join("$");
              return (
                (i = i.replace(/^_/, "") || t || "ref"),
                this.generateUid(i.slice(0, 20))
              );
            }
            generateUidIdentifierBasedOnNode(e, t) {
              return c().identifier(this.generateUidBasedOnNode(e, t));
            }
            isStatic(e) {
              if (c().isThisExpression(e) || c().isSuper(e)) return !0;
              if (c().isIdentifier(e)) {
                const t = this.getBinding(e.name);
                return t ? t.constant : this.hasBinding(e.name);
              }
              return !1;
            }
            maybeGenerateMemoised(e, t) {
              if (this.isStatic(e)) return null;
              {
                const r = this.generateUidIdentifierBasedOnNode(e);
                return t ? r : (this.push({ id: r }), c().cloneNode(r));
              }
            }
            checkBlockScopedCollisions(e, t, r, n) {
              if ("param" === t) return;
              if ("local" === e.kind) return;
              if (
                "let" === t ||
                "let" === e.kind ||
                "const" === e.kind ||
                "module" === e.kind ||
                ("param" === e.kind && ("let" === t || "const" === t))
              )
                throw this.hub.buildError(
                  n,
                  `Duplicate declaration "${r}"`,
                  TypeError
                );
            }
            rename(e, t, r) {
              const n = this.getBinding(e);
              if (n)
                return (
                  (t = t || this.generateUidIdentifier(e).name),
                  new s.default(n, e, t).rename(r)
                );
            }
            _renameFromMap(e, t, r, n) {
              e[t] && ((e[r] = n), (e[t] = null));
            }
            dump() {
              const e = (0, i().default)("-", 60);
              console.log(e);
              let t = this;
              do {
                console.log("#", t.block.type);
                for (const e of Object.keys(t.bindings)) {
                  const r = t.bindings[e];
                  console.log(" -", e, {
                    constant: r.constant,
                    references: r.references,
                    violations: r.constantViolations.length,
                    kind: r.kind
                  });
                }
              } while ((t = t.parent));
              console.log(e);
            }
            toArray(e, t) {
              if (c().isIdentifier(e)) {
                const t = this.getBinding(e.name);
                if (t && t.constant && t.path.isGenericType("Array")) return e;
              }
              if (c().isArrayExpression(e)) return e;
              if (c().isIdentifier(e, { name: "arguments" }))
                return c().callExpression(
                  c().memberExpression(
                    c().memberExpression(
                      c().memberExpression(
                        c().identifier("Array"),
                        c().identifier("prototype")
                      ),
                      c().identifier("slice")
                    ),
                    c().identifier("call")
                  ),
                  [e]
                );
              let r;
              const n = [e];
              return (
                !0 === t
                  ? (r = "toConsumableArray")
                  : t
                  ? (n.push(c().numericLiteral(t)), (r = "slicedToArray"))
                  : (r = "toArray"),
                c().callExpression(this.hub.addHelper(r), n)
              );
            }
            hasLabel(e) {
              return !!this.getLabel(e);
            }
            getLabel(e) {
              return this.labels.get(e);
            }
            registerLabel(e) {
              this.labels.set(e.node.label.name, e);
            }
            registerDeclaration(e) {
              if (e.isLabeledStatement()) this.registerLabel(e);
              else if (e.isFunctionDeclaration())
                this.registerBinding("hoisted", e.get("id"), e);
              else if (e.isVariableDeclaration()) {
                const t = e.get("declarations");
                for (const r of t) this.registerBinding(e.node.kind, r);
              } else if (e.isClassDeclaration()) this.registerBinding("let", e);
              else if (e.isImportDeclaration()) {
                const t = e.get("specifiers");
                for (const e of t) this.registerBinding("module", e);
              } else if (e.isExportDeclaration()) {
                const t = e.get("declaration");
                (t.isClassDeclaration() ||
                  t.isFunctionDeclaration() ||
                  t.isVariableDeclaration()) &&
                  this.registerDeclaration(t);
              } else this.registerBinding("unknown", e);
            }
            buildUndefinedNode() {
              return this.hasBinding("undefined")
                ? c().unaryExpression("void", c().numericLiteral(0), !0)
                : c().identifier("undefined");
            }
            registerConstantViolation(e) {
              const t = e.getBindingIdentifiers();
              for (const r of Object.keys(t)) {
                const t = this.getBinding(r);
                t && t.reassign(e);
              }
            }
            registerBinding(e, t, r = t) {
              if (!e) throw new ReferenceError("no `kind`");
              if (t.isVariableDeclaration()) {
                const r = t.get("declarations");
                for (const t of r) this.registerBinding(e, t);
                return;
              }
              const n = this.getProgramParent(),
                i = t.getOuterBindingIdentifiers(!0);
              for (const t of Object.keys(i))
                for (const s of i[t]) {
                  const i = this.getOwnBinding(t);
                  if (i) {
                    if (i.identifier === s) continue;
                    this.checkBlockScopedCollisions(i, e, t, s);
                  }
                  (n.references[t] = !0),
                    i
                      ? this.registerConstantViolation(r)
                      : (this.bindings[t] = new u.default({
                          identifier: s,
                          scope: this,
                          path: r,
                          kind: e
                        }));
                }
            }
            addGlobal(e) {
              this.globals[e.name] = e;
            }
            hasUid(e) {
              let t = this;
              do {
                if (t.uids[e]) return !0;
              } while ((t = t.parent));
              return !1;
            }
            hasGlobal(e) {
              let t = this;
              do {
                if (t.globals[e]) return !0;
              } while ((t = t.parent));
              return !1;
            }
            hasReference(e) {
              let t = this;
              do {
                if (t.references[e]) return !0;
              } while ((t = t.parent));
              return !1;
            }
            isPure(e, t) {
              if (c().isIdentifier(e)) {
                const r = this.getBinding(e.name);
                return !!r && (!t || r.constant);
              }
              if (c().isClass(e))
                return (
                  !(e.superClass && !this.isPure(e.superClass, t)) &&
                  this.isPure(e.body, t)
                );
              if (c().isClassBody(e)) {
                for (const r of e.body) if (!this.isPure(r, t)) return !1;
                return !0;
              }
              if (c().isBinary(e))
                return this.isPure(e.left, t) && this.isPure(e.right, t);
              if (c().isArrayExpression(e)) {
                for (const r of e.elements) if (!this.isPure(r, t)) return !1;
                return !0;
              }
              if (c().isObjectExpression(e)) {
                for (const r of e.properties) if (!this.isPure(r, t)) return !1;
                return !0;
              }
              if (c().isClassMethod(e))
                return (
                  !(e.computed && !this.isPure(e.key, t)) &&
                  ("get" !== e.kind && "set" !== e.kind)
                );
              if (c().isProperty(e))
                return (
                  !(e.computed && !this.isPure(e.key, t)) &&
                  this.isPure(e.value, t)
                );
              if (c().isUnaryExpression(e)) return this.isPure(e.argument, t);
              if (c().isTaggedTemplateExpression(e))
                return (
                  c().matchesPattern(e.tag, "String.raw") &&
                  !this.hasBinding("String", !0) &&
                  this.isPure(e.quasi, t)
                );
              if (c().isTemplateLiteral(e)) {
                for (const r of e.expressions)
                  if (!this.isPure(r, t)) return !1;
                return !0;
              }
              return c().isPureish(e);
            }
            setData(e, t) {
              return (this.data[e] = t);
            }
            getData(e) {
              let t = this;
              do {
                const r = t.data[e];
                if (null != r) return r;
              } while ((t = t.parent));
            }
            removeData(e) {
              let t = this;
              do {
                null != t.data[e] && (t.data[e] = null);
              } while ((t = t.parent));
            }
            init() {
              this.references || this.crawl();
            }
            crawl() {
              const e = this.path;
              if (
                ((this.references = Object.create(null)),
                (this.bindings = Object.create(null)),
                (this.globals = Object.create(null)),
                (this.uids = Object.create(null)),
                (this.data = Object.create(null)),
                e.isLoop())
              )
                for (const t of c().FOR_INIT_KEYS) {
                  const r = e.get(t);
                  r.isBlockScoped() && this.registerBinding(r.node.kind, r);
                }
              if (
                (e.isFunctionExpression() &&
                  e.has("id") &&
                  (e.get("id").node[c().NOT_LOCAL_BINDING] ||
                    this.registerBinding("local", e.get("id"), e)),
                e.isClassExpression() &&
                  e.has("id") &&
                  (e.get("id").node[c().NOT_LOCAL_BINDING] ||
                    this.registerBinding("local", e)),
                e.isFunction())
              ) {
                const t = e.get("params");
                for (const e of t) this.registerBinding("param", e);
              }
              if (
                (e.isCatchClause() && this.registerBinding("let", e),
                this.getProgramParent().crawling)
              )
                return;
              const t = {
                references: [],
                constantViolations: [],
                assignments: []
              };
              (this.crawling = !0), e.traverse(h, t), (this.crawling = !1);
              for (const e of t.assignments) {
                const t = e.getBindingIdentifiers();
                let r;
                for (const n of Object.keys(t))
                  e.scope.getBinding(n) ||
                    (r = r || e.scope.getProgramParent()).addGlobal(t[n]);
                e.scope.registerConstantViolation(e);
              }
              for (const e of t.references) {
                const t = e.scope.getBinding(e.node.name);
                t
                  ? t.reference(e)
                  : e.scope.getProgramParent().addGlobal(e.node);
              }
              for (const e of t.constantViolations)
                e.scope.registerConstantViolation(e);
            }
            push(e) {
              let t = this.path;
              t.isBlockStatement() ||
                t.isProgram() ||
                (t = this.getBlockParent().path),
                t.isSwitchStatement() &&
                  (t = (this.getFunctionParent() || this.getProgramParent())
                    .path),
                (t.isLoop() || t.isCatchClause() || t.isFunction()) &&
                  (t.ensureBlock(), (t = t.get("body")));
              const r = e.unique,
                n = e.kind || "var",
                i = null == e._blockHoist ? 2 : e._blockHoist,
                s = `declaration:${n}:${i}`;
              let a = !r && t.getData(s);
              if (!a) {
                const e = c().variableDeclaration(n, []);
                (e._blockHoist = i),
                  ([a] = t.unshiftContainer("body", [e])),
                  r || t.setData(s, a);
              }
              const o = c().variableDeclarator(e.id, e.init);
              a.node.declarations.push(o),
                this.registerBinding(n, a.get("declarations").pop());
            }
            getProgramParent() {
              let e = this;
              do {
                if (e.path.isProgram()) return e;
              } while ((e = e.parent));
              throw new Error("Couldn't find a Program");
            }
            getFunctionParent() {
              let e = this;
              do {
                if (e.path.isFunctionParent()) return e;
              } while ((e = e.parent));
              return null;
            }
            getBlockParent() {
              let e = this;
              do {
                if (e.path.isBlockParent()) return e;
              } while ((e = e.parent));
              throw new Error(
                "We couldn't find a BlockStatement, For, Switch, Function, Loop or Program..."
              );
            }
            getAllBindings() {
              const e = Object.create(null);
              let t = this;
              do {
                (0, o().default)(e, t.bindings), (t = t.parent);
              } while (t);
              return e;
            }
            getAllBindingsOfKind() {
              const e = Object.create(null);
              for (const t of arguments) {
                let r = this;
                do {
                  for (const n of Object.keys(r.bindings)) {
                    const i = r.bindings[n];
                    i.kind === t && (e[n] = i);
                  }
                  r = r.parent;
                } while (r);
              }
              return e;
            }
            bindingIdentifierEquals(e, t) {
              return this.getBindingIdentifier(e) === t;
            }
            getBinding(e) {
              let t = this;
              do {
                const r = t.getOwnBinding(e);
                if (r) return r;
              } while ((t = t.parent));
            }
            getOwnBinding(e) {
              return this.bindings[e];
            }
            getBindingIdentifier(e) {
              const t = this.getBinding(e);
              return t && t.identifier;
            }
            getOwnBindingIdentifier(e) {
              const t = this.bindings[e];
              return t && t.identifier;
            }
            hasOwnBinding(e) {
              return !!this.getOwnBinding(e);
            }
            hasBinding(e, t) {
              return (
                !!e &&
                (!!this.hasOwnBinding(e) ||
                  (!!this.parentHasBinding(e, t) ||
                    (!!this.hasUid(e) ||
                      (!(t || !(0, n().default)(m.globals, e)) ||
                        !(t || !(0, n().default)(m.contextVariables, e))))))
              );
            }
            parentHasBinding(e, t) {
              return this.parent && this.parent.hasBinding(e, t);
            }
            moveBindingTo(e, t) {
              const r = this.getBinding(e);
              r &&
                (r.scope.removeOwnBinding(e),
                (r.scope = t),
                (t.bindings[e] = r));
            }
            removeOwnBinding(e) {
              delete this.bindings[e];
            }
            removeBinding(e) {
              const t = this.getBinding(e);
              t && t.scope.removeOwnBinding(e);
              let r = this;
              do {
                r.uids[e] && (r.uids[e] = !1);
              } while ((r = r.parent));
            }
          }
          (r.default = m),
            (m.globals = Object.keys(l().default.builtin)),
            (m.contextVariables = [
              "arguments",
              "undefined",
              "Infinity",
              "NaN"
            ]);
        },
        {
          "../cache": 34,
          "../index": 37,
          "./binding": 55,
          "./lib/renamer": 57,
          "@babel/types": 100,
          globals: 150,
          "lodash/defaults": 271,
          "lodash/includes": 274,
          "lodash/repeat": 294
        }
      ],
      57: [
        function(e, t, r) {
          "use strict";
          Object.defineProperty(r, "__esModule", { value: !0 }),
            (r.default = void 0);
          i(e("../binding"));
          function n() {
            const t = i(e("@babel/helper-split-export-declaration"));
            return (
              (n = function() {
                return t;
              }),
              t
            );
          }
          function i(e) {
            return e && e.__esModule ? e : { default: e };
          }
          const s = {
            ReferencedIdentifier({ node: e }, t) {
              e.name === t.oldName && (e.name = t.newName);
            },
            Scope(e, t) {
              e.scope.bindingIdentifierEquals(
                t.oldName,
                t.binding.identifier
              ) || e.skip();
            },
            "AssignmentExpression|Declaration"(e, t) {
              const r = e.getOuterBindingIdentifiers();
              for (const e in r) e === t.oldName && (r[e].name = t.newName);
            }
          };
          r.default = class {
            constructor(e, t, r) {
              (this.newName = r), (this.oldName = t), (this.binding = e);
            }
            maybeConvertFromExportDeclaration(e) {
              const t = e.parentPath;
              t.isExportDeclaration() &&
                ((t.isExportDefaultDeclaration() &&
                  !t.get("declaration").node.id) ||
                  (0, n().default)(t));
            }
            maybeConvertFromClassFunctionDeclaration(e) {}
            maybeConvertFromClassFunctionExpression(e) {}
            rename(e) {
              const { binding: t, oldName: r, newName: n } = this,
                { scope: i, path: a } = t,
                o = a.find(
                  e =>
                    e.isDeclaration() ||
                    e.isFunctionExpression() ||
                    e.isClassExpression()
                );
              o &&
                o.getOuterBindingIdentifiers()[r] === t.identifier &&
                this.maybeConvertFromExportDeclaration(o),
                i.traverse(e || i.block, s, this),
                e ||
                  (i.removeOwnBinding(r),
                  (i.bindings[n] = t),
                  (this.binding.identifier.name = n)),
                t.type,
                o &&
                  (this.maybeConvertFromClassFunctionDeclaration(o),
                  this.maybeConvertFromClassFunctionExpression(o));
            }
          };
        },
        {
          "../binding": 55,
          "@babel/helper-split-export-declaration": 23,
          "@babel/types": 100
        }
      ],
      58: [
        function(e, t, r) {
          "use strict";
          Object.defineProperty(r, "__esModule", { value: !0 }),
            (r.explode = o),
            (r.verify = u),
            (r.merge = function(e, t = [], r) {
              const n = {};
              for (let i = 0; i < e.length; i++) {
                const s = e[i],
                  a = t[i];
                o(s);
                for (const e of Object.keys(s)) {
                  let t = s[e];
                  (a || r) && (t = c(t, a, r));
                  const i = (n[e] = n[e] || {});
                  f(i, t);
                }
              }
              return n;
            });
          var n = a(e("./path/lib/virtual-types"));
          function i() {
            const t = a(e("@babel/types"));
            return (
              (i = function() {
                return t;
              }),
              t
            );
          }
          function s() {
            const t =
              (r = e("lodash/clone")) && r.__esModule ? r : { default: r };
            var r;
            return (
              (s = function() {
                return t;
              }),
              t
            );
          }
          function a(e) {
            if (e && e.__esModule) return e;
            var t = {};
            if (null != e)
              for (var r in e)
                if (Object.prototype.hasOwnProperty.call(e, r)) {
                  var n =
                    Object.defineProperty && Object.getOwnPropertyDescriptor
                      ? Object.getOwnPropertyDescriptor(e, r)
                      : {};
                  n.get || n.set
                    ? Object.defineProperty(t, r, n)
                    : (t[r] = e[r]);
                }
            return (t.default = e), t;
          }
          function o(e) {
            if (e._exploded) return e;
            e._exploded = !0;
            for (const t of Object.keys(e)) {
              if (h(t)) continue;
              const r = t.split("|");
              if (1 === r.length) continue;
              const n = e[t];
              delete e[t];
              for (const t of r) e[t] = n;
            }
            u(e),
              delete e.__esModule,
              (function(e) {
                for (const t of Object.keys(e)) {
                  if (h(t)) continue;
                  const r = e[t];
                  "function" == typeof r && (e[t] = { enter: r });
                }
              })(e),
              p(e);
            for (const t of Object.keys(e)) {
              if (h(t)) continue;
              const r = n[t];
              if (!r) continue;
              const i = e[t];
              for (const e of Object.keys(i)) i[e] = d(r, i[e]);
              if ((delete e[t], r.types))
                for (const t of r.types) e[t] ? f(e[t], i) : (e[t] = i);
              else f(e, i);
            }
            for (const t of Object.keys(e)) {
              if (h(t)) continue;
              const r = e[t];
              let n = i().FLIPPED_ALIAS_KEYS[t];
              const a = i().DEPRECATED_KEYS[t];
              if (
                (a &&
                  (console.trace(
                    `Visitor defined for ${t} but it has been renamed to ${a}`
                  ),
                  (n = [a])),
                n)
              ) {
                delete e[t];
                for (const t of n) {
                  const n = e[t];
                  n ? f(n, r) : (e[t] = (0, s().default)(r));
                }
              }
            }
            for (const t of Object.keys(e)) h(t) || p(e[t]);
            return e;
          }
          function u(e) {
            if (!e._verified) {
              if ("function" == typeof e)
                throw new Error(
                  "You passed `traverse()` a function when it expected a visitor object, are you sure you didn't mean `{ enter: Function }`?"
                );
              for (const t of Object.keys(e)) {
                if ((("enter" !== t && "exit" !== t) || l(t, e[t]), h(t)))
                  continue;
                if (i().TYPES.indexOf(t) < 0)
                  throw new Error(
                    `You gave us a visitor for the node type ${t} but it's not a valid type`
                  );
                const r = e[t];
                if ("object" == typeof r)
                  for (const e of Object.keys(r)) {
                    if ("enter" !== e && "exit" !== e)
                      throw new Error(
                        "You passed `traverse()` a visitor object with the property " +
                          `${t} that has the invalid property ${e}`
                      );
                    l(`${t}.${e}`, r[e]);
                  }
              }
              e._verified = !0;
            }
          }
          function l(e, t) {
            const r = [].concat(t);
            for (const t of r)
              if ("function" != typeof t)
                throw new TypeError(
                  `Non-function found defined in ${e} with type ${typeof t}`
                );
          }
          function c(e, t, r) {
            const n = {};
            for (const i of Object.keys(e)) {
              let s = e[i];
              Array.isArray(s) &&
                ((s = s.map(function(e) {
                  let n = e;
                  return (
                    t &&
                      (n = function(r) {
                        return e.call(t, r, t);
                      }),
                    r && (n = r(t.key, i, n)),
                    n
                  );
                })),
                (n[i] = s));
            }
            return n;
          }
          function p(e) {
            e.enter && !Array.isArray(e.enter) && (e.enter = [e.enter]),
              e.exit && !Array.isArray(e.exit) && (e.exit = [e.exit]);
          }
          function d(e, t) {
            const r = function(r) {
              if (e.checkPath(r)) return t.apply(this, arguments);
            };
            return (r.toString = () => t.toString()), r;
          }
          function h(e) {
            return (
              "_" === e[0] ||
              ("enter" === e ||
                "exit" === e ||
                "shouldSkip" === e ||
                ("blacklist" === e || "noScope" === e || "skipKeys" === e))
            );
          }
          function f(e, t) {
            for (const r of Object.keys(t)) e[r] = [].concat(e[r] || [], t[r]);
          }
        },
        {
          "./path/lib/virtual-types": 51,
          "@babel/types": 100,
          "lodash/clone": 269
        }
      ],
      59: [
        function(e, t, r) {
          "use strict";
          Object.defineProperty(r, "__esModule", { value: !0 }),
            (r.default = function(e) {
              if (!(0, i.default)(e)) {
                const t = (e && e.type) || JSON.stringify(e);
                throw new TypeError(`Not a valid node of type "${t}"`);
              }
            });
          var n,
            i =
              (n = e("../validators/isNode")) && n.__esModule
                ? n
                : { default: n };
        },
        { "../validators/isNode": 121 }
      ],
      60: [
        function(e, t, r) {
          "use strict";
          Object.defineProperty(r, "__esModule", { value: !0 }),
            (r.assertArrayExpression = function(e, t = {}) {
              s("ArrayExpression", e, t);
            }),
            (r.assertAssignmentExpression = function(e, t = {}) {
              s("AssignmentExpression", e, t);
            }),
            (r.assertBinaryExpression = function(e, t = {}) {
              s("BinaryExpression", e, t);
            }),
            (r.assertInterpreterDirective = function(e, t = {}) {
              s("InterpreterDirective", e, t);
            }),
            (r.assertDirective = function(e, t = {}) {
              s("Directive", e, t);
            }),
            (r.assertDirectiveLiteral = function(e, t = {}) {
              s("DirectiveLiteral", e, t);
            }),
            (r.assertBlockStatement = function(e, t = {}) {
              s("BlockStatement", e, t);
            }),
            (r.assertBreakStatement = function(e, t = {}) {
              s("BreakStatement", e, t);
            }),
            (r.assertCallExpression = function(e, t = {}) {
              s("CallExpression", e, t);
            }),
            (r.assertCatchClause = function(e, t = {}) {
              s("CatchClause", e, t);
            }),
            (r.assertConditionalExpression = function(e, t = {}) {
              s("ConditionalExpression", e, t);
            }),
            (r.assertContinueStatement = function(e, t = {}) {
              s("ContinueStatement", e, t);
            }),
            (r.assertDebuggerStatement = function(e, t = {}) {
              s("DebuggerStatement", e, t);
            }),
            (r.assertDoWhileStatement = function(e, t = {}) {
              s("DoWhileStatement", e, t);
            }),
            (r.assertEmptyStatement = function(e, t = {}) {
              s("EmptyStatement", e, t);
            }),
            (r.assertExpressionStatement = function(e, t = {}) {
              s("ExpressionStatement", e, t);
            }),
            (r.assertFile = function(e, t = {}) {
              s("File", e, t);
            }),
            (r.assertForInStatement = function(e, t = {}) {
              s("ForInStatement", e, t);
            }),
            (r.assertForStatement = function(e, t = {}) {
              s("ForStatement", e, t);
            }),
            (r.assertFunctionDeclaration = function(e, t = {}) {
              s("FunctionDeclaration", e, t);
            }),
            (r.assertFunctionExpression = function(e, t = {}) {
              s("FunctionExpression", e, t);
            }),
            (r.assertIdentifier = function(e, t = {}) {
              s("Identifier", e, t);
            }),
            (r.assertIfStatement = function(e, t = {}) {
              s("IfStatement", e, t);
            }),
            (r.assertLabeledStatement = function(e, t = {}) {
              s("LabeledStatement", e, t);
            }),
            (r.assertStringLiteral = function(e, t = {}) {
              s("StringLiteral", e, t);
            }),
            (r.assertNumericLiteral = function(e, t = {}) {
              s("NumericLiteral", e, t);
            }),
            (r.assertNullLiteral = function(e, t = {}) {
              s("NullLiteral", e, t);
            }),
            (r.assertBooleanLiteral = function(e, t = {}) {
              s("BooleanLiteral", e, t);
            }),
            (r.assertRegExpLiteral = function(e, t = {}) {
              s("RegExpLiteral", e, t);
            }),
            (r.assertLogicalExpression = function(e, t = {}) {
              s("LogicalExpression", e, t);
            }),
            (r.assertMemberExpression = function(e, t = {}) {
              s("MemberExpression", e, t);
            }),
            (r.assertNewExpression = function(e, t = {}) {
              s("NewExpression", e, t);
            }),
            (r.assertProgram = function(e, t = {}) {
              s("Program", e, t);
            }),
            (r.assertObjectExpression = function(e, t = {}) {
              s("ObjectExpression", e, t);
            }),
            (r.assertObjectMethod = function(e, t = {}) {
              s("ObjectMethod", e, t);
            }),
            (r.assertObjectProperty = function(e, t = {}) {
              s("ObjectProperty", e, t);
            }),
            (r.assertRestElement = function(e, t = {}) {
              s("RestElement", e, t);
            }),
            (r.assertReturnStatement = function(e, t = {}) {
              s("ReturnStatement", e, t);
            }),
            (r.assertSequenceExpression = function(e, t = {}) {
              s("SequenceExpression", e, t);
            }),
            (r.assertParenthesizedExpression = function(e, t = {}) {
              s("ParenthesizedExpression", e, t);
            }),
            (r.assertSwitchCase = function(e, t = {}) {
              s("SwitchCase", e, t);
            }),
            (r.assertSwitchStatement = function(e, t = {}) {
              s("SwitchStatement", e, t);
            }),
            (r.assertThisExpression = function(e, t = {}) {
              s("ThisExpression", e, t);
            }),
            (r.assertThrowStatement = function(e, t = {}) {
              s("ThrowStatement", e, t);
            }),
            (r.assertTryStatement = function(e, t = {}) {
              s("TryStatement", e, t);
            }),
            (r.assertUnaryExpression = function(e, t = {}) {
              s("UnaryExpression", e, t);
            }),
            (r.assertUpdateExpression = function(e, t = {}) {
              s("UpdateExpression", e, t);
            }),
            (r.assertVariableDeclaration = function(e, t = {}) {
              s("VariableDeclaration", e, t);
            }),
            (r.assertVariableDeclarator = function(e, t = {}) {
              s("VariableDeclarator", e, t);
            }),
            (r.assertWhileStatement = function(e, t = {}) {
              s("WhileStatement", e, t);
            }),
            (r.assertWithStatement = function(e, t = {}) {
              s("WithStatement", e, t);
            }),
            (r.assertAssignmentPattern = function(e, t = {}) {
              s("AssignmentPattern", e, t);
            }),
            (r.assertArrayPattern = function(e, t = {}) {
              s("ArrayPattern", e, t);
            }),
            (r.assertArrowFunctionExpression = function(e, t = {}) {
              s("ArrowFunctionExpression", e, t);
            }),
            (r.assertClassBody = function(e, t = {}) {
              s("ClassBody", e, t);
            }),
            (r.assertClassDeclaration = function(e, t = {}) {
              s("ClassDeclaration", e, t);
            }),
            (r.assertClassExpression = function(e, t = {}) {
              s("ClassExpression", e, t);
            }),
            (r.assertExportAllDeclaration = function(e, t = {}) {
              s("ExportAllDeclaration", e, t);
            }),
            (r.assertExportDefaultDeclaration = function(e, t = {}) {
              s("ExportDefaultDeclaration", e, t);
            }),
            (r.assertExportNamedDeclaration = function(e, t = {}) {
              s("ExportNamedDeclaration", e, t);
            }),
            (r.assertExportSpecifier = function(e, t = {}) {
              s("ExportSpecifier", e, t);
            }),
            (r.assertForOfStatement = function(e, t = {}) {
              s("ForOfStatement", e, t);
            }),
            (r.assertImportDeclaration = function(e, t = {}) {
              s("ImportDeclaration", e, t);
            }),
            (r.assertImportDefaultSpecifier = function(e, t = {}) {
              s("ImportDefaultSpecifier", e, t);
            }),
            (r.assertImportNamespaceSpecifier = function(e, t = {}) {
              s("ImportNamespaceSpecifier", e, t);
            }),
            (r.assertImportSpecifier = function(e, t = {}) {
              s("ImportSpecifier", e, t);
            }),
            (r.assertMetaProperty = function(e, t = {}) {
              s("MetaProperty", e, t);
            }),
            (r.assertClassMethod = function(e, t = {}) {
              s("ClassMethod", e, t);
            }),
            (r.assertObjectPattern = function(e, t = {}) {
              s("ObjectPattern", e, t);
            }),
            (r.assertSpreadElement = function(e, t = {}) {
              s("SpreadElement", e, t);
            }),
            (r.assertSuper = function(e, t = {}) {
              s("Super", e, t);
            }),
            (r.assertTaggedTemplateExpression = function(e, t = {}) {
              s("TaggedTemplateExpression", e, t);
            }),
            (r.assertTemplateElement = function(e, t = {}) {
              s("TemplateElement", e, t);
            }),
            (r.assertTemplateLiteral = function(e, t = {}) {
              s("TemplateLiteral", e, t);
            }),
            (r.assertYieldExpression = function(e, t = {}) {
              s("YieldExpression", e, t);
            }),
            (r.assertAnyTypeAnnotation = function(e, t = {}) {
              s("AnyTypeAnnotation", e, t);
            }),
            (r.assertArrayTypeAnnotation = function(e, t = {}) {
              s("ArrayTypeAnnotation", e, t);
            }),
            (r.assertBooleanTypeAnnotation = function(e, t = {}) {
              s("BooleanTypeAnnotation", e, t);
            }),
            (r.assertBooleanLiteralTypeAnnotation = function(e, t = {}) {
              s("BooleanLiteralTypeAnnotation", e, t);
            }),
            (r.assertNullLiteralTypeAnnotation = function(e, t = {}) {
              s("NullLiteralTypeAnnotation", e, t);
            }),
            (r.assertClassImplements = function(e, t = {}) {
              s("ClassImplements", e, t);
            }),
            (r.assertDeclareClass = function(e, t = {}) {
              s("DeclareClass", e, t);
            }),
            (r.assertDeclareFunction = function(e, t = {}) {
              s("DeclareFunction", e, t);
            }),
            (r.assertDeclareInterface = function(e, t = {}) {
              s("DeclareInterface", e, t);
            }),
            (r.assertDeclareModule = function(e, t = {}) {
              s("DeclareModule", e, t);
            }),
            (r.assertDeclareModuleExports = function(e, t = {}) {
              s("DeclareModuleExports", e, t);
            }),
            (r.assertDeclareTypeAlias = function(e, t = {}) {
              s("DeclareTypeAlias", e, t);
            }),
            (r.assertDeclareOpaqueType = function(e, t = {}) {
              s("DeclareOpaqueType", e, t);
            }),
            (r.assertDeclareVariable = function(e, t = {}) {
              s("DeclareVariable", e, t);
            }),
            (r.assertDeclareExportDeclaration = function(e, t = {}) {
              s("DeclareExportDeclaration", e, t);
            }),
            (r.assertDeclareExportAllDeclaration = function(e, t = {}) {
              s("DeclareExportAllDeclaration", e, t);
            }),
            (r.assertDeclaredPredicate = function(e, t = {}) {
              s("DeclaredPredicate", e, t);
            }),
            (r.assertExistsTypeAnnotation = function(e, t = {}) {
              s("ExistsTypeAnnotation", e, t);
            }),
            (r.assertFunctionTypeAnnotation = function(e, t = {}) {
              s("FunctionTypeAnnotation", e, t);
            }),
            (r.assertFunctionTypeParam = function(e, t = {}) {
              s("FunctionTypeParam", e, t);
            }),
            (r.assertGenericTypeAnnotation = function(e, t = {}) {
              s("GenericTypeAnnotation", e, t);
            }),
            (r.assertInferredPredicate = function(e, t = {}) {
              s("InferredPredicate", e, t);
            }),
            (r.assertInterfaceExtends = function(e, t = {}) {
              s("InterfaceExtends", e, t);
            }),
            (r.assertInterfaceDeclaration = function(e, t = {}) {
              s("InterfaceDeclaration", e, t);
            }),
            (r.assertInterfaceTypeAnnotation = function(e, t = {}) {
              s("InterfaceTypeAnnotation", e, t);
            }),
            (r.assertIntersectionTypeAnnotation = function(e, t = {}) {
              s("IntersectionTypeAnnotation", e, t);
            }),
            (r.assertMixedTypeAnnotation = function(e, t = {}) {
              s("MixedTypeAnnotation", e, t);
            }),
            (r.assertEmptyTypeAnnotation = function(e, t = {}) {
              s("EmptyTypeAnnotation", e, t);
            }),
            (r.assertNullableTypeAnnotation = function(e, t = {}) {
              s("NullableTypeAnnotation", e, t);
            }),
            (r.assertNumberLiteralTypeAnnotation = function(e, t = {}) {
              s("NumberLiteralTypeAnnotation", e, t);
            }),
            (r.assertNumberTypeAnnotation = function(e, t = {}) {
              s("NumberTypeAnnotation", e, t);
            }),
            (r.assertObjectTypeAnnotation = function(e, t = {}) {
              s("ObjectTypeAnnotation", e, t);
            }),
            (r.assertObjectTypeInternalSlot = function(e, t = {}) {
              s("ObjectTypeInternalSlot", e, t);
            }),
            (r.assertObjectTypeCallProperty = function(e, t = {}) {
              s("ObjectTypeCallProperty", e, t);
            }),
            (r.assertObjectTypeIndexer = function(e, t = {}) {
              s("ObjectTypeIndexer", e, t);
            }),
            (r.assertObjectTypeProperty = function(e, t = {}) {
              s("ObjectTypeProperty", e, t);
            }),
            (r.assertObjectTypeSpreadProperty = function(e, t = {}) {
              s("ObjectTypeSpreadProperty", e, t);
            }),
            (r.assertOpaqueType = function(e, t = {}) {
              s("OpaqueType", e, t);
            }),
            (r.assertQualifiedTypeIdentifier = function(e, t = {}) {
              s("QualifiedTypeIdentifier", e, t);
            }),
            (r.assertStringLiteralTypeAnnotation = function(e, t = {}) {
              s("StringLiteralTypeAnnotation", e, t);
            }),
            (r.assertStringTypeAnnotation = function(e, t = {}) {
              s("StringTypeAnnotation", e, t);
            }),
            (r.assertThisTypeAnnotation = function(e, t = {}) {
              s("ThisTypeAnnotation", e, t);
            }),
            (r.assertTupleTypeAnnotation = function(e, t = {}) {
              s("TupleTypeAnnotation", e, t);
            }),
            (r.assertTypeofTypeAnnotation = function(e, t = {}) {
              s("TypeofTypeAnnotation", e, t);
            }),
            (r.assertTypeAlias = function(e, t = {}) {
              s("TypeAlias", e, t);
            }),
            (r.assertTypeAnnotation = function(e, t = {}) {
              s("TypeAnnotation", e, t);
            }),
            (r.assertTypeCastExpression = function(e, t = {}) {
              s("TypeCastExpression", e, t);
            }),
            (r.assertTypeParameter = function(e, t = {}) {
              s("TypeParameter", e, t);
            }),
            (r.assertTypeParameterDeclaration = function(e, t = {}) {
              s("TypeParameterDeclaration", e, t);
            }),
            (r.assertTypeParameterInstantiation = function(e, t = {}) {
              s("TypeParameterInstantiation", e, t);
            }),
            (r.assertUnionTypeAnnotation = function(e, t = {}) {
              s("UnionTypeAnnotation", e, t);
            }),
            (r.assertVariance = function(e, t = {}) {
              s("Variance", e, t);
            }),
            (r.assertVoidTypeAnnotation = function(e, t = {}) {
              s("VoidTypeAnnotation", e, t);
            }),
            (r.assertJSXAttribute = function(e, t = {}) {
              s("JSXAttribute", e, t);
            }),
            (r.assertJSXClosingElement = function(e, t = {}) {
              s("JSXClosingElement", e, t);
            }),
            (r.assertJSXElement = function(e, t = {}) {
              s("JSXElement", e, t);
            }),
            (r.assertJSXEmptyExpression = function(e, t = {}) {
              s("JSXEmptyExpression", e, t);
            }),
            (r.assertJSXExpressionContainer = function(e, t = {}) {
              s("JSXExpressionContainer", e, t);
            }),
            (r.assertJSXSpreadChild = function(e, t = {}) {
              s("JSXSpreadChild", e, t);
            }),
            (r.assertJSXIdentifier = function(e, t = {}) {
              s("JSXIdentifier", e, t);
            }),
            (r.assertJSXMemberExpression = function(e, t = {}) {
              s("JSXMemberExpression", e, t);
            }),
            (r.assertJSXNamespacedName = function(e, t = {}) {
              s("JSXNamespacedName", e, t);
            }),
            (r.assertJSXOpeningElement = function(e, t = {}) {
              s("JSXOpeningElement", e, t);
            }),
            (r.assertJSXSpreadAttribute = function(e, t = {}) {
              s("JSXSpreadAttribute", e, t);
            }),
            (r.assertJSXText = function(e, t = {}) {
              s("JSXText", e, t);
            }),
            (r.assertJSXFragment = function(e, t = {}) {
              s("JSXFragment", e, t);
            }),
            (r.assertJSXOpeningFragment = function(e, t = {}) {
              s("JSXOpeningFragment", e, t);
            }),
            (r.assertJSXClosingFragment = function(e, t = {}) {
              s("JSXClosingFragment", e, t);
            }),
            (r.assertNoop = function(e, t = {}) {
              s("Noop", e, t);
            }),
            (r.assertPlaceholder = function(e, t = {}) {
              s("Placeholder", e, t);
            }),
            (r.assertArgumentPlaceholder = function(e, t = {}) {
              s("ArgumentPlaceholder", e, t);
            }),
            (r.assertAwaitExpression = function(e, t = {}) {
              s("AwaitExpression", e, t);
            }),
            (r.assertBindExpression = function(e, t = {}) {
              s("BindExpression", e, t);
            }),
            (r.assertClassProperty = function(e, t = {}) {
              s("ClassProperty", e, t);
            }),
            (r.assertOptionalMemberExpression = function(e, t = {}) {
              s("OptionalMemberExpression", e, t);
            }),
            (r.assertPipelineTopicExpression = function(e, t = {}) {
              s("PipelineTopicExpression", e, t);
            }),
            (r.assertPipelineBareFunction = function(e, t = {}) {
              s("PipelineBareFunction", e, t);
            }),
            (r.assertPipelinePrimaryTopicReference = function(e, t = {}) {
              s("PipelinePrimaryTopicReference", e, t);
            }),
            (r.assertOptionalCallExpression = function(e, t = {}) {
              s("OptionalCallExpression", e, t);
            }),
            (r.assertClassPrivateProperty = function(e, t = {}) {
              s("ClassPrivateProperty", e, t);
            }),
            (r.assertClassPrivateMethod = function(e, t = {}) {
              s("ClassPrivateMethod", e, t);
            }),
            (r.assertImport = function(e, t = {}) {
              s("Import", e, t);
            }),
            (r.assertDecorator = function(e, t = {}) {
              s("Decorator", e, t);
            }),
            (r.assertDoExpression = function(e, t = {}) {
              s("DoExpression", e, t);
            }),
            (r.assertExportDefaultSpecifier = function(e, t = {}) {
              s("ExportDefaultSpecifier", e, t);
            }),
            (r.assertExportNamespaceSpecifier = function(e, t = {}) {
              s("ExportNamespaceSpecifier", e, t);
            }),
            (r.assertPrivateName = function(e, t = {}) {
              s("PrivateName", e, t);
            }),
            (r.assertBigIntLiteral = function(e, t = {}) {
              s("BigIntLiteral", e, t);
            }),
            (r.assertTSParameterProperty = function(e, t = {}) {
              s("TSParameterProperty", e, t);
            }),
            (r.assertTSDeclareFunction = function(e, t = {}) {
              s("TSDeclareFunction", e, t);
            }),
            (r.assertTSDeclareMethod = function(e, t = {}) {
              s("TSDeclareMethod", e, t);
            }),
            (r.assertTSQualifiedName = function(e, t = {}) {
              s("TSQualifiedName", e, t);
            }),
            (r.assertTSCallSignatureDeclaration = function(e, t = {}) {
              s("TSCallSignatureDeclaration", e, t);
            }),
            (r.assertTSConstructSignatureDeclaration = function(e, t = {}) {
              s("TSConstructSignatureDeclaration", e, t);
            }),
            (r.assertTSPropertySignature = function(e, t = {}) {
              s("TSPropertySignature", e, t);
            }),
            (r.assertTSMethodSignature = function(e, t = {}) {
              s("TSMethodSignature", e, t);
            }),
            (r.assertTSIndexSignature = function(e, t = {}) {
              s("TSIndexSignature", e, t);
            }),
            (r.assertTSAnyKeyword = function(e, t = {}) {
              s("TSAnyKeyword", e, t);
            }),
            (r.assertTSUnknownKeyword = function(e, t = {}) {
              s("TSUnknownKeyword", e, t);
            }),
            (r.assertTSNumberKeyword = function(e, t = {}) {
              s("TSNumberKeyword", e, t);
            }),
            (r.assertTSObjectKeyword = function(e, t = {}) {
              s("TSObjectKeyword", e, t);
            }),
            (r.assertTSBooleanKeyword = function(e, t = {}) {
              s("TSBooleanKeyword", e, t);
            }),
            (r.assertTSStringKeyword = function(e, t = {}) {
              s("TSStringKeyword", e, t);
            }),
            (r.assertTSSymbolKeyword = function(e, t = {}) {
              s("TSSymbolKeyword", e, t);
            }),
            (r.assertTSVoidKeyword = function(e, t = {}) {
              s("TSVoidKeyword", e, t);
            }),
            (r.assertTSUndefinedKeyword = function(e, t = {}) {
              s("TSUndefinedKeyword", e, t);
            }),
            (r.assertTSNullKeyword = function(e, t = {}) {
              s("TSNullKeyword", e, t);
            }),
            (r.assertTSNeverKeyword = function(e, t = {}) {
              s("TSNeverKeyword", e, t);
            }),
            (r.assertTSThisType = function(e, t = {}) {
              s("TSThisType", e, t);
            }),
            (r.assertTSFunctionType = function(e, t = {}) {
              s("TSFunctionType", e, t);
            }),
            (r.assertTSConstructorType = function(e, t = {}) {
              s("TSConstructorType", e, t);
            }),
            (r.assertTSTypeReference = function(e, t = {}) {
              s("TSTypeReference", e, t);
            }),
            (r.assertTSTypePredicate = function(e, t = {}) {
              s("TSTypePredicate", e, t);
            }),
            (r.assertTSTypeQuery = function(e, t = {}) {
              s("TSTypeQuery", e, t);
            }),
            (r.assertTSTypeLiteral = function(e, t = {}) {
              s("TSTypeLiteral", e, t);
            }),
            (r.assertTSArrayType = function(e, t = {}) {
              s("TSArrayType", e, t);
            }),
            (r.assertTSTupleType = function(e, t = {}) {
              s("TSTupleType", e, t);
            }),
            (r.assertTSOptionalType = function(e, t = {}) {
              s("TSOptionalType", e, t);
            }),
            (r.assertTSRestType = function(e, t = {}) {
              s("TSRestType", e, t);
            }),
            (r.assertTSUnionType = function(e, t = {}) {
              s("TSUnionType", e, t);
            }),
            (r.assertTSIntersectionType = function(e, t = {}) {
              s("TSIntersectionType", e, t);
            }),
            (r.assertTSConditionalType = function(e, t = {}) {
              s("TSConditionalType", e, t);
            }),
            (r.assertTSInferType = function(e, t = {}) {
              s("TSInferType", e, t);
            }),
            (r.assertTSParenthesizedType = function(e, t = {}) {
              s("TSParenthesizedType", e, t);
            }),
            (r.assertTSTypeOperator = function(e, t = {}) {
              s("TSTypeOperator", e, t);
            }),
            (r.assertTSIndexedAccessType = function(e, t = {}) {
              s("TSIndexedAccessType", e, t);
            }),
            (r.assertTSMappedType = function(e, t = {}) {
              s("TSMappedType", e, t);
            }),
            (r.assertTSLiteralType = function(e, t = {}) {
              s("TSLiteralType", e, t);
            }),
            (r.assertTSExpressionWithTypeArguments = function(e, t = {}) {
              s("TSExpressionWithTypeArguments", e, t);
            }),
            (r.assertTSInterfaceDeclaration = function(e, t = {}) {
              s("TSInterfaceDeclaration", e, t);
            }),
            (r.assertTSInterfaceBody = function(e, t = {}) {
              s("TSInterfaceBody", e, t);
            }),
            (r.assertTSTypeAliasDeclaration = function(e, t = {}) {
              s("TSTypeAliasDeclaration", e, t);
            }),
            (r.assertTSAsExpression = function(e, t = {}) {
              s("TSAsExpression", e, t);
            }),
            (r.assertTSTypeAssertion = function(e, t = {}) {
              s("TSTypeAssertion", e, t);
            }),
            (r.assertTSEnumDeclaration = function(e, t = {}) {
              s("TSEnumDeclaration", e, t);
            }),
            (r.assertTSEnumMember = function(e, t = {}) {
              s("TSEnumMember", e, t);
            }),
            (r.assertTSModuleDeclaration = function(e, t = {}) {
              s("TSModuleDeclaration", e, t);
            }),
            (r.assertTSModuleBlock = function(e, t = {}) {
              s("TSModuleBlock", e, t);
            }),
            (r.assertTSImportType = function(e, t = {}) {
              s("TSImportType", e, t);
            }),
            (r.assertTSImportEqualsDeclaration = function(e, t = {}) {
              s("TSImportEqualsDeclaration", e, t);
            }),
            (r.assertTSExternalModuleReference = function(e, t = {}) {
              s("TSExternalModuleReference", e, t);
            }),
            (r.assertTSNonNullExpression = function(e, t = {}) {
              s("TSNonNullExpression", e, t);
            }),
            (r.assertTSExportAssignment = function(e, t = {}) {
              s("TSExportAssignment", e, t);
            }),
            (r.assertTSNamespaceExportDeclaration = function(e, t = {}) {
              s("TSNamespaceExportDeclaration", e, t);
            }),
            (r.assertTSTypeAnnotation = function(e, t = {}) {
              s("TSTypeAnnotation", e, t);
            }),
            (r.assertTSTypeParameterInstantiation = function(e, t = {}) {
              s("TSTypeParameterInstantiation", e, t);
            }),
            (r.assertTSTypeParameterDeclaration = function(e, t = {}) {
              s("TSTypeParameterDeclaration", e, t);
            }),
            (r.assertTSTypeParameter = function(e, t = {}) {
              s("TSTypeParameter", e, t);
            }),
            (r.assertExpression = function(e, t = {}) {
              s("Expression", e, t);
            }),
            (r.assertBinary = function(e, t = {}) {
              s("Binary", e, t);
            }),
            (r.assertScopable = function(e, t = {}) {
              s("Scopable", e, t);
            }),
            (r.assertBlockParent = function(e, t = {}) {
              s("BlockParent", e, t);
            }),
            (r.assertBlock = function(e, t = {}) {
              s("Block", e, t);
            }),
            (r.assertStatement = function(e, t = {}) {
              s("Statement", e, t);
            }),
            (r.assertTerminatorless = function(e, t = {}) {
              s("Terminatorless", e, t);
            }),
            (r.assertCompletionStatement = function(e, t = {}) {
              s("CompletionStatement", e, t);
            }),
            (r.assertConditional = function(e, t = {}) {
              s("Conditional", e, t);
            }),
            (r.assertLoop = function(e, t = {}) {
              s("Loop", e, t);
            }),
            (r.assertWhile = function(e, t = {}) {
              s("While", e, t);
            }),
            (r.assertExpressionWrapper = function(e, t = {}) {
              s("ExpressionWrapper", e, t);
            }),
            (r.assertFor = function(e, t = {}) {
              s("For", e, t);
            }),
            (r.assertForXStatement = function(e, t = {}) {
              s("ForXStatement", e, t);
            }),
            (r.assertFunction = function(e, t = {}) {
              s("Function", e, t);
            }),
            (r.assertFunctionParent = function(e, t = {}) {
              s("FunctionParent", e, t);
            }),
            (r.assertPureish = function(e, t = {}) {
              s("Pureish", e, t);
            }),
            (r.assertDeclaration = function(e, t = {}) {
              s("Declaration", e, t);
            }),
            (r.assertPatternLike = function(e, t = {}) {
              s("PatternLike", e, t);
            }),
            (r.assertLVal = function(e, t = {}) {
              s("LVal", e, t);
            }),
            (r.assertTSEntityName = function(e, t = {}) {
              s("TSEntityName", e, t);
            }),
            (r.assertLiteral = function(e, t = {}) {
              s("Literal", e, t);
            }),
            (r.assertImmutable = function(e, t = {}) {
              s("Immutable", e, t);
            }),
            (r.assertUserWhitespacable = function(e, t = {}) {
              s("UserWhitespacable", e, t);
            }),
            (r.assertMethod = function(e, t = {}) {
              s("Method", e, t);
            }),
            (r.assertObjectMember = function(e, t = {}) {
              s("ObjectMember", e, t);
            }),
            (r.assertProperty = function(e, t = {}) {
              s("Property", e, t);
            }),
            (r.assertUnaryLike = function(e, t = {}) {
              s("UnaryLike", e, t);
            }),
            (r.assertPattern = function(e, t = {}) {
              s("Pattern", e, t);
            }),
            (r.assertClass = function(e, t = {}) {
              s("Class", e, t);
            }),
            (r.assertModuleDeclaration = function(e, t = {}) {
              s("ModuleDeclaration", e, t);
            }),
            (r.assertExportDeclaration = function(e, t = {}) {
              s("ExportDeclaration", e, t);
            }),
            (r.assertModuleSpecifier = function(e, t = {}) {
              s("ModuleSpecifier", e, t);
            }),
            (r.assertFlow = function(e, t = {}) {
              s("Flow", e, t);
            }),
            (r.assertFlowType = function(e, t = {}) {
              s("FlowType", e, t);
            }),
            (r.assertFlowBaseAnnotation = function(e, t = {}) {
              s("FlowBaseAnnotation", e, t);
            }),
            (r.assertFlowDeclaration = function(e, t = {}) {
              s("FlowDeclaration", e, t);
            }),
            (r.assertFlowPredicate = function(e, t = {}) {
              s("FlowPredicate", e, t);
            }),
            (r.assertJSX = function(e, t = {}) {
              s("JSX", e, t);
            }),
            (r.assertPrivate = function(e, t = {}) {
              s("Private", e, t);
            }),
            (r.assertTSTypeElement = function(e, t = {}) {
              s("TSTypeElement", e, t);
            }),
            (r.assertTSType = function(e, t = {}) {
              s("TSType", e, t);
            }),
            (r.assertNumberLiteral = function(e, t) {
              console.trace(
                "The node type NumberLiteral has been renamed to NumericLiteral"
              ),
                s("NumberLiteral", e, t);
            }),
            (r.assertRegexLiteral = function(e, t) {
              console.trace(
                "The node type RegexLiteral has been renamed to RegExpLiteral"
              ),
                s("RegexLiteral", e, t);
            }),
            (r.assertRestProperty = function(e, t) {
              console.trace(
                "The node type RestProperty has been renamed to RestElement"
              ),
                s("RestProperty", e, t);
            }),
            (r.assertSpreadProperty = function(e, t) {
              console.trace(
                "The node type SpreadProperty has been renamed to SpreadElement"
              ),
                s("SpreadProperty", e, t);
            });
          var n,
            i =
              (n = e("../../validators/is")) && n.__esModule
                ? n
                : { default: n };
          function s(e, t, r) {
            if (!(0, i.default)(e, t, r))
              throw new Error(
                `Expected type "${e}" with option ${JSON.stringify(
                  r
                )}, but instead got "${t.type}".`
              );
          }
        },
        { "../../validators/is": 116 }
      ],
      61: [
        function(e, t, r) {
          "use strict";
          function n() {
            const t = a(e("lodash/clone"));
            return (
              (n = function() {
                return t;
              }),
              t
            );
          }
          Object.defineProperty(r, "__esModule", { value: !0 }),
            (r.default = function(e, ...t) {
              const r = i.BUILDER_KEYS[e],
                a = t.length;
              if (a > r.length)
                throw new Error(
                  `${e}: Too many arguments passed. Received ${a} but can receive no more than ${r.length}`
                );
              const o = { type: e };
              let u = 0;
              r.forEach(r => {
                const s = i.NODE_FIELDS[e][r];
                let l;
                u < a && (l = t[u]),
                  void 0 === l && (l = (0, n().default)(s.default)),
                  (o[r] = l),
                  u++;
              });
              for (const e of Object.keys(o)) (0, s.default)(o, e, o[e]);
              return o;
            });
          var i = e("../definitions"),
            s = a(e("../validators/validate"));
          function a(e) {
            return e && e.__esModule ? e : { default: e };
          }
        },
        {
          "../definitions": 94,
          "../validators/validate": 134,
          "lodash/clone": 269
        }
      ],
      62: [
        function(e, t, r) {
          "use strict";
          Object.defineProperty(r, "__esModule", { value: !0 }),
            (r.default = function(e) {
              if ("string" === e) return (0, n.stringTypeAnnotation)();
              if ("number" === e) return (0, n.numberTypeAnnotation)();
              if ("undefined" === e) return (0, n.voidTypeAnnotation)();
              if ("boolean" === e) return (0, n.booleanTypeAnnotation)();
              if ("function" === e)
                return (0, n.genericTypeAnnotation)(
                  (0, n.identifier)("Function")
                );
              if ("object" === e)
                return (0, n.genericTypeAnnotation)(
                  (0, n.identifier)("Object")
                );
              if ("symbol" === e)
                return (0, n.genericTypeAnnotation)(
                  (0, n.identifier)("Symbol")
                );
              throw new Error("Invalid typeof value");
            });
          var n = e("../generated");
        },
        { "../generated": 64 }
      ],
      63: [
        function(e, t, r) {
          "use strict";
          Object.defineProperty(r, "__esModule", { value: !0 }),
            (r.default = function(e) {
              const t = (0, s.default)(e);
              return 1 === t.length ? t[0] : (0, i.unionTypeAnnotation)(t);
            });
          var n,
            i = e("../generated"),
            s =
              (n = e("../../modifications/flow/removeTypeDuplicates")) &&
              n.__esModule
                ? n
                : { default: n };
        },
        {
          "../../modifications/flow/removeTypeDuplicates": 102,
          "../generated": 64
        }
      ],
      64: [
        function(e, t, r) {
          "use strict";
          Object.defineProperty(r, "__esModule", { value: !0 }),
            (r.arrayExpression = r.ArrayExpression = function(...e) {
              return (0, i.default)("ArrayExpression", ...e);
            }),
            (r.assignmentExpression = r.AssignmentExpression = function(...e) {
              return (0, i.default)("AssignmentExpression", ...e);
            }),
            (r.binaryExpression = r.BinaryExpression = function(...e) {
              return (0, i.default)("BinaryExpression", ...e);
            }),
            (r.interpreterDirective = r.InterpreterDirective = function(...e) {
              return (0, i.default)("InterpreterDirective", ...e);
            }),
            (r.directive = r.Directive = function(...e) {
              return (0, i.default)("Directive", ...e);
            }),
            (r.directiveLiteral = r.DirectiveLiteral = function(...e) {
              return (0, i.default)("DirectiveLiteral", ...e);
            }),
            (r.blockStatement = r.BlockStatement = function(...e) {
              return (0, i.default)("BlockStatement", ...e);
            }),
            (r.breakStatement = r.BreakStatement = function(...e) {
              return (0, i.default)("BreakStatement", ...e);
            }),
            (r.callExpression = r.CallExpression = function(...e) {
              return (0, i.default)("CallExpression", ...e);
            }),
            (r.catchClause = r.CatchClause = function(...e) {
              return (0, i.default)("CatchClause", ...e);
            }),
            (r.conditionalExpression = r.ConditionalExpression = function(
              ...e
            ) {
              return (0, i.default)("ConditionalExpression", ...e);
            }),
            (r.continueStatement = r.ContinueStatement = function(...e) {
              return (0, i.default)("ContinueStatement", ...e);
            }),
            (r.debuggerStatement = r.DebuggerStatement = function(...e) {
              return (0, i.default)("DebuggerStatement", ...e);
            }),
            (r.doWhileStatement = r.DoWhileStatement = function(...e) {
              return (0, i.default)("DoWhileStatement", ...e);
            }),
            (r.emptyStatement = r.EmptyStatement = function(...e) {
              return (0, i.default)("EmptyStatement", ...e);
            }),
            (r.expressionStatement = r.ExpressionStatement = function(...e) {
              return (0, i.default)("ExpressionStatement", ...e);
            }),
            (r.file = r.File = function(...e) {
              return (0, i.default)("File", ...e);
            }),
            (r.forInStatement = r.ForInStatement = function(...e) {
              return (0, i.default)("ForInStatement", ...e);
            }),
            (r.forStatement = r.ForStatement = function(...e) {
              return (0, i.default)("ForStatement", ...e);
            }),
            (r.functionDeclaration = r.FunctionDeclaration = function(...e) {
              return (0, i.default)("FunctionDeclaration", ...e);
            }),
            (r.functionExpression = r.FunctionExpression = function(...e) {
              return (0, i.default)("FunctionExpression", ...e);
            }),
            (r.identifier = r.Identifier = function(...e) {
              return (0, i.default)("Identifier", ...e);
            }),
            (r.ifStatement = r.IfStatement = function(...e) {
              return (0, i.default)("IfStatement", ...e);
            }),
            (r.labeledStatement = r.LabeledStatement = function(...e) {
              return (0, i.default)("LabeledStatement", ...e);
            }),
            (r.stringLiteral = r.StringLiteral = function(...e) {
              return (0, i.default)("StringLiteral", ...e);
            }),
            (r.numericLiteral = r.NumericLiteral = function(...e) {
              return (0, i.default)("NumericLiteral", ...e);
            }),
            (r.nullLiteral = r.NullLiteral = function(...e) {
              return (0, i.default)("NullLiteral", ...e);
            }),
            (r.booleanLiteral = r.BooleanLiteral = function(...e) {
              return (0, i.default)("BooleanLiteral", ...e);
            }),
            (r.regExpLiteral = r.RegExpLiteral = function(...e) {
              return (0, i.default)("RegExpLiteral", ...e);
            }),
            (r.logicalExpression = r.LogicalExpression = function(...e) {
              return (0, i.default)("LogicalExpression", ...e);
            }),
            (r.memberExpression = r.MemberExpression = function(...e) {
              return (0, i.default)("MemberExpression", ...e);
            }),
            (r.newExpression = r.NewExpression = function(...e) {
              return (0, i.default)("NewExpression", ...e);
            }),
            (r.program = r.Program = function(...e) {
              return (0, i.default)("Program", ...e);
            }),
            (r.objectExpression = r.ObjectExpression = function(...e) {
              return (0, i.default)("ObjectExpression", ...e);
            }),
            (r.objectMethod = r.ObjectMethod = function(...e) {
              return (0, i.default)("ObjectMethod", ...e);
            }),
            (r.objectProperty = r.ObjectProperty = function(...e) {
              return (0, i.default)("ObjectProperty", ...e);
            }),
            (r.restElement = r.RestElement = function(...e) {
              return (0, i.default)("RestElement", ...e);
            }),
            (r.returnStatement = r.ReturnStatement = function(...e) {
              return (0, i.default)("ReturnStatement", ...e);
            }),
            (r.sequenceExpression = r.SequenceExpression = function(...e) {
              return (0, i.default)("SequenceExpression", ...e);
            }),
            (r.parenthesizedExpression = r.ParenthesizedExpression = function(
              ...e
            ) {
              return (0, i.default)("ParenthesizedExpression", ...e);
            }),
            (r.switchCase = r.SwitchCase = function(...e) {
              return (0, i.default)("SwitchCase", ...e);
            }),
            (r.switchStatement = r.SwitchStatement = function(...e) {
              return (0, i.default)("SwitchStatement", ...e);
            }),
            (r.thisExpression = r.ThisExpression = function(...e) {
              return (0, i.default)("ThisExpression", ...e);
            }),
            (r.throwStatement = r.ThrowStatement = function(...e) {
              return (0, i.default)("ThrowStatement", ...e);
            }),
            (r.tryStatement = r.TryStatement = function(...e) {
              return (0, i.default)("TryStatement", ...e);
            }),
            (r.unaryExpression = r.UnaryExpression = function(...e) {
              return (0, i.default)("UnaryExpression", ...e);
            }),
            (r.updateExpression = r.UpdateExpression = function(...e) {
              return (0, i.default)("UpdateExpression", ...e);
            }),
            (r.variableDeclaration = r.VariableDeclaration = function(...e) {
              return (0, i.default)("VariableDeclaration", ...e);
            }),
            (r.variableDeclarator = r.VariableDeclarator = function(...e) {
              return (0, i.default)("VariableDeclarator", ...e);
            }),
            (r.whileStatement = r.WhileStatement = function(...e) {
              return (0, i.default)("WhileStatement", ...e);
            }),
            (r.withStatement = r.WithStatement = function(...e) {
              return (0, i.default)("WithStatement", ...e);
            }),
            (r.assignmentPattern = r.AssignmentPattern = function(...e) {
              return (0, i.default)("AssignmentPattern", ...e);
            }),
            (r.arrayPattern = r.ArrayPattern = function(...e) {
              return (0, i.default)("ArrayPattern", ...e);
            }),
            (r.arrowFunctionExpression = r.ArrowFunctionExpression = function(
              ...e
            ) {
              return (0, i.default)("ArrowFunctionExpression", ...e);
            }),
            (r.classBody = r.ClassBody = function(...e) {
              return (0, i.default)("ClassBody", ...e);
            }),
            (r.classDeclaration = r.ClassDeclaration = function(...e) {
              return (0, i.default)("ClassDeclaration", ...e);
            }),
            (r.classExpression = r.ClassExpression = function(...e) {
              return (0, i.default)("ClassExpression", ...e);
            }),
            (r.exportAllDeclaration = r.ExportAllDeclaration = function(...e) {
              return (0, i.default)("ExportAllDeclaration", ...e);
            }),
            (r.exportDefaultDeclaration = r.ExportDefaultDeclaration = function(
              ...e
            ) {
              return (0, i.default)("ExportDefaultDeclaration", ...e);
            }),
            (r.exportNamedDeclaration = r.ExportNamedDeclaration = function(
              ...e
            ) {
              return (0, i.default)("ExportNamedDeclaration", ...e);
            }),
            (r.exportSpecifier = r.ExportSpecifier = function(...e) {
              return (0, i.default)("ExportSpecifier", ...e);
            }),
            (r.forOfStatement = r.ForOfStatement = function(...e) {
              return (0, i.default)("ForOfStatement", ...e);
            }),
            (r.importDeclaration = r.ImportDeclaration = function(...e) {
              return (0, i.default)("ImportDeclaration", ...e);
            }),
            (r.importDefaultSpecifier = r.ImportDefaultSpecifier = function(
              ...e
            ) {
              return (0, i.default)("ImportDefaultSpecifier", ...e);
            }),
            (r.importNamespaceSpecifier = r.ImportNamespaceSpecifier = function(
              ...e
            ) {
              return (0, i.default)("ImportNamespaceSpecifier", ...e);
            }),
            (r.importSpecifier = r.ImportSpecifier = function(...e) {
              return (0, i.default)("ImportSpecifier", ...e);
            }),
            (r.metaProperty = r.MetaProperty = function(...e) {
              return (0, i.default)("MetaProperty", ...e);
            }),
            (r.classMethod = r.ClassMethod = function(...e) {
              return (0, i.default)("ClassMethod", ...e);
            }),
            (r.objectPattern = r.ObjectPattern = function(...e) {
              return (0, i.default)("ObjectPattern", ...e);
            }),
            (r.spreadElement = r.SpreadElement = function(...e) {
              return (0, i.default)("SpreadElement", ...e);
            }),
            (r.super = r.Super = function(...e) {
              return (0, i.default)("Super", ...e);
            }),
            (r.taggedTemplateExpression = r.TaggedTemplateExpression = function(
              ...e
            ) {
              return (0, i.default)("TaggedTemplateExpression", ...e);
            }),
            (r.templateElement = r.TemplateElement = function(...e) {
              return (0, i.default)("TemplateElement", ...e);
            }),
            (r.templateLiteral = r.TemplateLiteral = function(...e) {
              return (0, i.default)("TemplateLiteral", ...e);
            }),
            (r.yieldExpression = r.YieldExpression = function(...e) {
              return (0, i.default)("YieldExpression", ...e);
            }),
            (r.anyTypeAnnotation = r.AnyTypeAnnotation = function(...e) {
              return (0, i.default)("AnyTypeAnnotation", ...e);
            }),
            (r.arrayTypeAnnotation = r.ArrayTypeAnnotation = function(...e) {
              return (0, i.default)("ArrayTypeAnnotation", ...e);
            }),
            (r.booleanTypeAnnotation = r.BooleanTypeAnnotation = function(
              ...e
            ) {
              return (0, i.default)("BooleanTypeAnnotation", ...e);
            }),
            (r.booleanLiteralTypeAnnotation = r.BooleanLiteralTypeAnnotation = function(
              ...e
            ) {
              return (0, i.default)("BooleanLiteralTypeAnnotation", ...e);
            }),
            (r.nullLiteralTypeAnnotation = r.NullLiteralTypeAnnotation = function(
              ...e
            ) {
              return (0, i.default)("NullLiteralTypeAnnotation", ...e);
            }),
            (r.classImplements = r.ClassImplements = function(...e) {
              return (0, i.default)("ClassImplements", ...e);
            }),
            (r.declareClass = r.DeclareClass = function(...e) {
              return (0, i.default)("DeclareClass", ...e);
            }),
            (r.declareFunction = r.DeclareFunction = function(...e) {
              return (0, i.default)("DeclareFunction", ...e);
            }),
            (r.declareInterface = r.DeclareInterface = function(...e) {
              return (0, i.default)("DeclareInterface", ...e);
            }),
            (r.declareModule = r.DeclareModule = function(...e) {
              return (0, i.default)("DeclareModule", ...e);
            }),
            (r.declareModuleExports = r.DeclareModuleExports = function(...e) {
              return (0, i.default)("DeclareModuleExports", ...e);
            }),
            (r.declareTypeAlias = r.DeclareTypeAlias = function(...e) {
              return (0, i.default)("DeclareTypeAlias", ...e);
            }),
            (r.declareOpaqueType = r.DeclareOpaqueType = function(...e) {
              return (0, i.default)("DeclareOpaqueType", ...e);
            }),
            (r.declareVariable = r.DeclareVariable = function(...e) {
              return (0, i.default)("DeclareVariable", ...e);
            }),
            (r.declareExportDeclaration = r.DeclareExportDeclaration = function(
              ...e
            ) {
              return (0, i.default)("DeclareExportDeclaration", ...e);
            }),
            (r.declareExportAllDeclaration = r.DeclareExportAllDeclaration = function(
              ...e
            ) {
              return (0, i.default)("DeclareExportAllDeclaration", ...e);
            }),
            (r.declaredPredicate = r.DeclaredPredicate = function(...e) {
              return (0, i.default)("DeclaredPredicate", ...e);
            }),
            (r.existsTypeAnnotation = r.ExistsTypeAnnotation = function(...e) {
              return (0, i.default)("ExistsTypeAnnotation", ...e);
            }),
            (r.functionTypeAnnotation = r.FunctionTypeAnnotation = function(
              ...e
            ) {
              return (0, i.default)("FunctionTypeAnnotation", ...e);
            }),
            (r.functionTypeParam = r.FunctionTypeParam = function(...e) {
              return (0, i.default)("FunctionTypeParam", ...e);
            }),
            (r.genericTypeAnnotation = r.GenericTypeAnnotation = function(
              ...e
            ) {
              return (0, i.default)("GenericTypeAnnotation", ...e);
            }),
            (r.inferredPredicate = r.InferredPredicate = function(...e) {
              return (0, i.default)("InferredPredicate", ...e);
            }),
            (r.interfaceExtends = r.InterfaceExtends = function(...e) {
              return (0, i.default)("InterfaceExtends", ...e);
            }),
            (r.interfaceDeclaration = r.InterfaceDeclaration = function(...e) {
              return (0, i.default)("InterfaceDeclaration", ...e);
            }),
            (r.interfaceTypeAnnotation = r.InterfaceTypeAnnotation = function(
              ...e
            ) {
              return (0, i.default)("InterfaceTypeAnnotation", ...e);
            }),
            (r.intersectionTypeAnnotation = r.IntersectionTypeAnnotation = function(
              ...e
            ) {
              return (0, i.default)("IntersectionTypeAnnotation", ...e);
            }),
            (r.mixedTypeAnnotation = r.MixedTypeAnnotation = function(...e) {
              return (0, i.default)("MixedTypeAnnotation", ...e);
            }),
            (r.emptyTypeAnnotation = r.EmptyTypeAnnotation = function(...e) {
              return (0, i.default)("EmptyTypeAnnotation", ...e);
            }),
            (r.nullableTypeAnnotation = r.NullableTypeAnnotation = function(
              ...e
            ) {
              return (0, i.default)("NullableTypeAnnotation", ...e);
            }),
            (r.numberLiteralTypeAnnotation = r.NumberLiteralTypeAnnotation = function(
              ...e
            ) {
              return (0, i.default)("NumberLiteralTypeAnnotation", ...e);
            }),
            (r.numberTypeAnnotation = r.NumberTypeAnnotation = function(...e) {
              return (0, i.default)("NumberTypeAnnotation", ...e);
            }),
            (r.objectTypeAnnotation = r.ObjectTypeAnnotation = function(...e) {
              return (0, i.default)("ObjectTypeAnnotation", ...e);
            }),
            (r.objectTypeInternalSlot = r.ObjectTypeInternalSlot = function(
              ...e
            ) {
              return (0, i.default)("ObjectTypeInternalSlot", ...e);
            }),
            (r.objectTypeCallProperty = r.ObjectTypeCallProperty = function(
              ...e
            ) {
              return (0, i.default)("ObjectTypeCallProperty", ...e);
            }),
            (r.objectTypeIndexer = r.ObjectTypeIndexer = function(...e) {
              return (0, i.default)("ObjectTypeIndexer", ...e);
            }),
            (r.objectTypeProperty = r.ObjectTypeProperty = function(...e) {
              return (0, i.default)("ObjectTypeProperty", ...e);
            }),
            (r.objectTypeSpreadProperty = r.ObjectTypeSpreadProperty = function(
              ...e
            ) {
              return (0, i.default)("ObjectTypeSpreadProperty", ...e);
            }),
            (r.opaqueType = r.OpaqueType = function(...e) {
              return (0, i.default)("OpaqueType", ...e);
            }),
            (r.qualifiedTypeIdentifier = r.QualifiedTypeIdentifier = function(
              ...e
            ) {
              return (0, i.default)("QualifiedTypeIdentifier", ...e);
            }),
            (r.stringLiteralTypeAnnotation = r.StringLiteralTypeAnnotation = function(
              ...e
            ) {
              return (0, i.default)("StringLiteralTypeAnnotation", ...e);
            }),
            (r.stringTypeAnnotation = r.StringTypeAnnotation = function(...e) {
              return (0, i.default)("StringTypeAnnotation", ...e);
            }),
            (r.thisTypeAnnotation = r.ThisTypeAnnotation = function(...e) {
              return (0, i.default)("ThisTypeAnnotation", ...e);
            }),
            (r.tupleTypeAnnotation = r.TupleTypeAnnotation = function(...e) {
              return (0, i.default)("TupleTypeAnnotation", ...e);
            }),
            (r.typeofTypeAnnotation = r.TypeofTypeAnnotation = function(...e) {
              return (0, i.default)("TypeofTypeAnnotation", ...e);
            }),
            (r.typeAlias = r.TypeAlias = function(...e) {
              return (0, i.default)("TypeAlias", ...e);
            }),
            (r.typeAnnotation = r.TypeAnnotation = function(...e) {
              return (0, i.default)("TypeAnnotation", ...e);
            }),
            (r.typeCastExpression = r.TypeCastExpression = function(...e) {
              return (0, i.default)("TypeCastExpression", ...e);
            }),
            (r.typeParameter = r.TypeParameter = function(...e) {
              return (0, i.default)("TypeParameter", ...e);
            }),
            (r.typeParameterDeclaration = r.TypeParameterDeclaration = function(
              ...e
            ) {
              return (0, i.default)("TypeParameterDeclaration", ...e);
            }),
            (r.typeParameterInstantiation = r.TypeParameterInstantiation = function(
              ...e
            ) {
              return (0, i.default)("TypeParameterInstantiation", ...e);
            }),
            (r.unionTypeAnnotation = r.UnionTypeAnnotation = function(...e) {
              return (0, i.default)("UnionTypeAnnotation", ...e);
            }),
            (r.variance = r.Variance = function(...e) {
              return (0, i.default)("Variance", ...e);
            }),
            (r.voidTypeAnnotation = r.VoidTypeAnnotation = function(...e) {
              return (0, i.default)("VoidTypeAnnotation", ...e);
            }),
            (r.jSXAttribute = r.jsxAttribute = r.JSXAttribute = function(...e) {
              return (0, i.default)("JSXAttribute", ...e);
            }),
            (r.jSXClosingElement = r.jsxClosingElement = r.JSXClosingElement = function(
              ...e
            ) {
              return (0, i.default)("JSXClosingElement", ...e);
            }),
            (r.jSXElement = r.jsxElement = r.JSXElement = function(...e) {
              return (0, i.default)("JSXElement", ...e);
            }),
            (r.jSXEmptyExpression = r.jsxEmptyExpression = r.JSXEmptyExpression = function(
              ...e
            ) {
              return (0, i.default)("JSXEmptyExpression", ...e);
            }),
            (r.jSXExpressionContainer = r.jsxExpressionContainer = r.JSXExpressionContainer = function(
              ...e
            ) {
              return (0, i.default)("JSXExpressionContainer", ...e);
            }),
            (r.jSXSpreadChild = r.jsxSpreadChild = r.JSXSpreadChild = function(
              ...e
            ) {
              return (0, i.default)("JSXSpreadChild", ...e);
            }),
            (r.jSXIdentifier = r.jsxIdentifier = r.JSXIdentifier = function(
              ...e
            ) {
              return (0, i.default)("JSXIdentifier", ...e);
            }),
            (r.jSXMemberExpression = r.jsxMemberExpression = r.JSXMemberExpression = function(
              ...e
            ) {
              return (0, i.default)("JSXMemberExpression", ...e);
            }),
            (r.jSXNamespacedName = r.jsxNamespacedName = r.JSXNamespacedName = function(
              ...e
            ) {
              return (0, i.default)("JSXNamespacedName", ...e);
            }),
            (r.jSXOpeningElement = r.jsxOpeningElement = r.JSXOpeningElement = function(
              ...e
            ) {
              return (0, i.default)("JSXOpeningElement", ...e);
            }),
            (r.jSXSpreadAttribute = r.jsxSpreadAttribute = r.JSXSpreadAttribute = function(
              ...e
            ) {
              return (0, i.default)("JSXSpreadAttribute", ...e);
            }),
            (r.jSXText = r.jsxText = r.JSXText = function(...e) {
              return (0, i.default)("JSXText", ...e);
            }),
            (r.jSXFragment = r.jsxFragment = r.JSXFragment = function(...e) {
              return (0, i.default)("JSXFragment", ...e);
            }),
            (r.jSXOpeningFragment = r.jsxOpeningFragment = r.JSXOpeningFragment = function(
              ...e
            ) {
              return (0, i.default)("JSXOpeningFragment", ...e);
            }),
            (r.jSXClosingFragment = r.jsxClosingFragment = r.JSXClosingFragment = function(
              ...e
            ) {
              return (0, i.default)("JSXClosingFragment", ...e);
            }),
            (r.noop = r.Noop = function(...e) {
              return (0, i.default)("Noop", ...e);
            }),
            (r.placeholder = r.Placeholder = function(...e) {
              return (0, i.default)("Placeholder", ...e);
            }),
            (r.argumentPlaceholder = r.ArgumentPlaceholder = function(...e) {
              return (0, i.default)("ArgumentPlaceholder", ...e);
            }),
            (r.awaitExpression = r.AwaitExpression = function(...e) {
              return (0, i.default)("AwaitExpression", ...e);
            }),
            (r.bindExpression = r.BindExpression = function(...e) {
              return (0, i.default)("BindExpression", ...e);
            }),
            (r.classProperty = r.ClassProperty = function(...e) {
              return (0, i.default)("ClassProperty", ...e);
            }),
            (r.optionalMemberExpression = r.OptionalMemberExpression = function(
              ...e
            ) {
              return (0, i.default)("OptionalMemberExpression", ...e);
            }),
            (r.pipelineTopicExpression = r.PipelineTopicExpression = function(
              ...e
            ) {
              return (0, i.default)("PipelineTopicExpression", ...e);
            }),
            (r.pipelineBareFunction = r.PipelineBareFunction = function(...e) {
              return (0, i.default)("PipelineBareFunction", ...e);
            }),
            (r.pipelinePrimaryTopicReference = r.PipelinePrimaryTopicReference = function(
              ...e
            ) {
              return (0, i.default)("PipelinePrimaryTopicReference", ...e);
            }),
            (r.optionalCallExpression = r.OptionalCallExpression = function(
              ...e
            ) {
              return (0, i.default)("OptionalCallExpression", ...e);
            }),
            (r.classPrivateProperty = r.ClassPrivateProperty = function(...e) {
              return (0, i.default)("ClassPrivateProperty", ...e);
            }),
            (r.classPrivateMethod = r.ClassPrivateMethod = function(...e) {
              return (0, i.default)("ClassPrivateMethod", ...e);
            }),
            (r.import = r.Import = function(...e) {
              return (0, i.default)("Import", ...e);
            }),
            (r.decorator = r.Decorator = function(...e) {
              return (0, i.default)("Decorator", ...e);
            }),
            (r.doExpression = r.DoExpression = function(...e) {
              return (0, i.default)("DoExpression", ...e);
            }),
            (r.exportDefaultSpecifier = r.ExportDefaultSpecifier = function(
              ...e
            ) {
              return (0, i.default)("ExportDefaultSpecifier", ...e);
            }),
            (r.exportNamespaceSpecifier = r.ExportNamespaceSpecifier = function(
              ...e
            ) {
              return (0, i.default)("ExportNamespaceSpecifier", ...e);
            }),
            (r.privateName = r.PrivateName = function(...e) {
              return (0, i.default)("PrivateName", ...e);
            }),
            (r.bigIntLiteral = r.BigIntLiteral = function(...e) {
              return (0, i.default)("BigIntLiteral", ...e);
            }),
            (r.tSParameterProperty = r.tsParameterProperty = r.TSParameterProperty = function(
              ...e
            ) {
              return (0, i.default)("TSParameterProperty", ...e);
            }),
            (r.tSDeclareFunction = r.tsDeclareFunction = r.TSDeclareFunction = function(
              ...e
            ) {
              return (0, i.default)("TSDeclareFunction", ...e);
            }),
            (r.tSDeclareMethod = r.tsDeclareMethod = r.TSDeclareMethod = function(
              ...e
            ) {
              return (0, i.default)("TSDeclareMethod", ...e);
            }),
            (r.tSQualifiedName = r.tsQualifiedName = r.TSQualifiedName = function(
              ...e
            ) {
              return (0, i.default)("TSQualifiedName", ...e);
            }),
            (r.tSCallSignatureDeclaration = r.tsCallSignatureDeclaration = r.TSCallSignatureDeclaration = function(
              ...e
            ) {
              return (0, i.default)("TSCallSignatureDeclaration", ...e);
            }),
            (r.tSConstructSignatureDeclaration = r.tsConstructSignatureDeclaration = r.TSConstructSignatureDeclaration = function(
              ...e
            ) {
              return (0, i.default)("TSConstructSignatureDeclaration", ...e);
            }),
            (r.tSPropertySignature = r.tsPropertySignature = r.TSPropertySignature = function(
              ...e
            ) {
              return (0, i.default)("TSPropertySignature", ...e);
            }),
            (r.tSMethodSignature = r.tsMethodSignature = r.TSMethodSignature = function(
              ...e
            ) {
              return (0, i.default)("TSMethodSignature", ...e);
            }),
            (r.tSIndexSignature = r.tsIndexSignature = r.TSIndexSignature = function(
              ...e
            ) {
              return (0, i.default)("TSIndexSignature", ...e);
            }),
            (r.tSAnyKeyword = r.tsAnyKeyword = r.TSAnyKeyword = function(...e) {
              return (0, i.default)("TSAnyKeyword", ...e);
            }),
            (r.tSUnknownKeyword = r.tsUnknownKeyword = r.TSUnknownKeyword = function(
              ...e
            ) {
              return (0, i.default)("TSUnknownKeyword", ...e);
            }),
            (r.tSNumberKeyword = r.tsNumberKeyword = r.TSNumberKeyword = function(
              ...e
            ) {
              return (0, i.default)("TSNumberKeyword", ...e);
            }),
            (r.tSObjectKeyword = r.tsObjectKeyword = r.TSObjectKeyword = function(
              ...e
            ) {
              return (0, i.default)("TSObjectKeyword", ...e);
            }),
            (r.tSBooleanKeyword = r.tsBooleanKeyword = r.TSBooleanKeyword = function(
              ...e
            ) {
              return (0, i.default)("TSBooleanKeyword", ...e);
            }),
            (r.tSStringKeyword = r.tsStringKeyword = r.TSStringKeyword = function(
              ...e
            ) {
              return (0, i.default)("TSStringKeyword", ...e);
            }),
            (r.tSSymbolKeyword = r.tsSymbolKeyword = r.TSSymbolKeyword = function(
              ...e
            ) {
              return (0, i.default)("TSSymbolKeyword", ...e);
            }),
            (r.tSVoidKeyword = r.tsVoidKeyword = r.TSVoidKeyword = function(
              ...e
            ) {
              return (0, i.default)("TSVoidKeyword", ...e);
            }),
            (r.tSUndefinedKeyword = r.tsUndefinedKeyword = r.TSUndefinedKeyword = function(
              ...e
            ) {
              return (0, i.default)("TSUndefinedKeyword", ...e);
            }),
            (r.tSNullKeyword = r.tsNullKeyword = r.TSNullKeyword = function(
              ...e
            ) {
              return (0, i.default)("TSNullKeyword", ...e);
            }),
            (r.tSNeverKeyword = r.tsNeverKeyword = r.TSNeverKeyword = function(
              ...e
            ) {
              return (0, i.default)("TSNeverKeyword", ...e);
            }),
            (r.tSThisType = r.tsThisType = r.TSThisType = function(...e) {
              return (0, i.default)("TSThisType", ...e);
            }),
            (r.tSFunctionType = r.tsFunctionType = r.TSFunctionType = function(
              ...e
            ) {
              return (0, i.default)("TSFunctionType", ...e);
            }),
            (r.tSConstructorType = r.tsConstructorType = r.TSConstructorType = function(
              ...e
            ) {
              return (0, i.default)("TSConstructorType", ...e);
            }),
            (r.tSTypeReference = r.tsTypeReference = r.TSTypeReference = function(
              ...e
            ) {
              return (0, i.default)("TSTypeReference", ...e);
            }),
            (r.tSTypePredicate = r.tsTypePredicate = r.TSTypePredicate = function(
              ...e
            ) {
              return (0, i.default)("TSTypePredicate", ...e);
            }),
            (r.tSTypeQuery = r.tsTypeQuery = r.TSTypeQuery = function(...e) {
              return (0, i.default)("TSTypeQuery", ...e);
            }),
            (r.tSTypeLiteral = r.tsTypeLiteral = r.TSTypeLiteral = function(
              ...e
            ) {
              return (0, i.default)("TSTypeLiteral", ...e);
            }),
            (r.tSArrayType = r.tsArrayType = r.TSArrayType = function(...e) {
              return (0, i.default)("TSArrayType", ...e);
            }),
            (r.tSTupleType = r.tsTupleType = r.TSTupleType = function(...e) {
              return (0, i.default)("TSTupleType", ...e);
            }),
            (r.tSOptionalType = r.tsOptionalType = r.TSOptionalType = function(
              ...e
            ) {
              return (0, i.default)("TSOptionalType", ...e);
            }),
            (r.tSRestType = r.tsRestType = r.TSRestType = function(...e) {
              return (0, i.default)("TSRestType", ...e);
            }),
            (r.tSUnionType = r.tsUnionType = r.TSUnionType = function(...e) {
              return (0, i.default)("TSUnionType", ...e);
            }),
            (r.tSIntersectionType = r.tsIntersectionType = r.TSIntersectionType = function(
              ...e
            ) {
              return (0, i.default)("TSIntersectionType", ...e);
            }),
            (r.tSConditionalType = r.tsConditionalType = r.TSConditionalType = function(
              ...e
            ) {
              return (0, i.default)("TSConditionalType", ...e);
            }),
            (r.tSInferType = r.tsInferType = r.TSInferType = function(...e) {
              return (0, i.default)("TSInferType", ...e);
            }),
            (r.tSParenthesizedType = r.tsParenthesizedType = r.TSParenthesizedType = function(
              ...e
            ) {
              return (0, i.default)("TSParenthesizedType", ...e);
            }),
            (r.tSTypeOperator = r.tsTypeOperator = r.TSTypeOperator = function(
              ...e
            ) {
              return (0, i.default)("TSTypeOperator", ...e);
            }),
            (r.tSIndexedAccessType = r.tsIndexedAccessType = r.TSIndexedAccessType = function(
              ...e
            ) {
              return (0, i.default)("TSIndexedAccessType", ...e);
            }),
            (r.tSMappedType = r.tsMappedType = r.TSMappedType = function(...e) {
              return (0, i.default)("TSMappedType", ...e);
            }),
            (r.tSLiteralType = r.tsLiteralType = r.TSLiteralType = function(
              ...e
            ) {
              return (0, i.default)("TSLiteralType", ...e);
            }),
            (r.tSExpressionWithTypeArguments = r.tsExpressionWithTypeArguments = r.TSExpressionWithTypeArguments = function(
              ...e
            ) {
              return (0, i.default)("TSExpressionWithTypeArguments", ...e);
            }),
            (r.tSInterfaceDeclaration = r.tsInterfaceDeclaration = r.TSInterfaceDeclaration = function(
              ...e
            ) {
              return (0, i.default)("TSInterfaceDeclaration", ...e);
            }),
            (r.tSInterfaceBody = r.tsInterfaceBody = r.TSInterfaceBody = function(
              ...e
            ) {
              return (0, i.default)("TSInterfaceBody", ...e);
            }),
            (r.tSTypeAliasDeclaration = r.tsTypeAliasDeclaration = r.TSTypeAliasDeclaration = function(
              ...e
            ) {
              return (0, i.default)("TSTypeAliasDeclaration", ...e);
            }),
            (r.tSAsExpression = r.tsAsExpression = r.TSAsExpression = function(
              ...e
            ) {
              return (0, i.default)("TSAsExpression", ...e);
            }),
            (r.tSTypeAssertion = r.tsTypeAssertion = r.TSTypeAssertion = function(
              ...e
            ) {
              return (0, i.default)("TSTypeAssertion", ...e);
            }),
            (r.tSEnumDeclaration = r.tsEnumDeclaration = r.TSEnumDeclaration = function(
              ...e
            ) {
              return (0, i.default)("TSEnumDeclaration", ...e);
            }),
            (r.tSEnumMember = r.tsEnumMember = r.TSEnumMember = function(...e) {
              return (0, i.default)("TSEnumMember", ...e);
            }),
            (r.tSModuleDeclaration = r.tsModuleDeclaration = r.TSModuleDeclaration = function(
              ...e
            ) {
              return (0, i.default)("TSModuleDeclaration", ...e);
            }),
            (r.tSModuleBlock = r.tsModuleBlock = r.TSModuleBlock = function(
              ...e
            ) {
              return (0, i.default)("TSModuleBlock", ...e);
            }),
            (r.tSImportType = r.tsImportType = r.TSImportType = function(...e) {
              return (0, i.default)("TSImportType", ...e);
            }),
            (r.tSImportEqualsDeclaration = r.tsImportEqualsDeclaration = r.TSImportEqualsDeclaration = function(
              ...e
            ) {
              return (0, i.default)("TSImportEqualsDeclaration", ...e);
            }),
            (r.tSExternalModuleReference = r.tsExternalModuleReference = r.TSExternalModuleReference = function(
              ...e
            ) {
              return (0, i.default)("TSExternalModuleReference", ...e);
            }),
            (r.tSNonNullExpression = r.tsNonNullExpression = r.TSNonNullExpression = function(
              ...e
            ) {
              return (0, i.default)("TSNonNullExpression", ...e);
            }),
            (r.tSExportAssignment = r.tsExportAssignment = r.TSExportAssignment = function(
              ...e
            ) {
              return (0, i.default)("TSExportAssignment", ...e);
            }),
            (r.tSNamespaceExportDeclaration = r.tsNamespaceExportDeclaration = r.TSNamespaceExportDeclaration = function(
              ...e
            ) {
              return (0, i.default)("TSNamespaceExportDeclaration", ...e);
            }),
            (r.tSTypeAnnotation = r.tsTypeAnnotation = r.TSTypeAnnotation = function(
              ...e
            ) {
              return (0, i.default)("TSTypeAnnotation", ...e);
            }),
            (r.tSTypeParameterInstantiation = r.tsTypeParameterInstantiation = r.TSTypeParameterInstantiation = function(
              ...e
            ) {
              return (0, i.default)("TSTypeParameterInstantiation", ...e);
            }),
            (r.tSTypeParameterDeclaration = r.tsTypeParameterDeclaration = r.TSTypeParameterDeclaration = function(
              ...e
            ) {
              return (0, i.default)("TSTypeParameterDeclaration", ...e);
            }),
            (r.tSTypeParameter = r.tsTypeParameter = r.TSTypeParameter = function(
              ...e
            ) {
              return (0, i.default)("TSTypeParameter", ...e);
            }),
            (r.numberLiteral = r.NumberLiteral = function e(...t) {
              console.trace(
                "The node type NumberLiteral has been renamed to NumericLiteral"
              );
              return e("NumberLiteral", ...t);
            }),
            (r.regexLiteral = r.RegexLiteral = function e(...t) {
              console.trace(
                "The node type RegexLiteral has been renamed to RegExpLiteral"
              );
              return e("RegexLiteral", ...t);
            }),
            (r.restProperty = r.RestProperty = function e(...t) {
              console.trace(
                "The node type RestProperty has been renamed to RestElement"
              );
              return e("RestProperty", ...t);
            }),
            (r.spreadProperty = r.SpreadProperty = function e(...t) {
              console.trace(
                "The node type SpreadProperty has been renamed to SpreadElement"
              );
              return e("SpreadProperty", ...t);
            });
          var n,
            i = (n = e("../builder")) && n.__esModule ? n : { default: n };
        },
        { "../builder": 61 }
      ],
      65: [
        function(e, t, r) {
          "use strict";
          Object.defineProperty(r, "__esModule", { value: !0 }),
            (r.default = function(e) {
              const t = [];
              for (let r = 0; r < e.children.length; r++) {
                let n = e.children[r];
                (0, i.isJSXText)(n)
                  ? (0, s.default)(n, t)
                  : ((0, i.isJSXExpressionContainer)(n) && (n = n.expression),
                    (0, i.isJSXEmptyExpression)(n) || t.push(n));
              }
              return t;
            });
          var n,
            i = e("../../validators/generated"),
            s =
              (n = e("../../utils/react/cleanJSXElementLiteralChild")) &&
              n.__esModule
                ? n
                : { default: n };
        },
        {
          "../../utils/react/cleanJSXElementLiteralChild": 112,
          "../../validators/generated": 115
        }
      ],
      66: [
        function(e, t, r) {
          "use strict";
          Object.defineProperty(r, "__esModule", { value: !0 }),
            (r.default = function(e) {
              return (0, i.default)(e, !1);
            });
          var n,
            i = (n = e("./cloneNode")) && n.__esModule ? n : { default: n };
        },
        { "./cloneNode": 68 }
      ],
      67: [
        function(e, t, r) {
          "use strict";
          Object.defineProperty(r, "__esModule", { value: !0 }),
            (r.default = function(e) {
              return (0, i.default)(e);
            });
          var n,
            i = (n = e("./cloneNode")) && n.__esModule ? n : { default: n };
        },
        { "./cloneNode": 68 }
      ],
      68: [
        function(e, t, r) {
          "use strict";
          Object.defineProperty(r, "__esModule", { value: !0 }),
            (r.default = o);
          var n = e("../definitions");
          const i = Function.call.bind(Object.prototype.hasOwnProperty);
          function s(e, t) {
            return e &&
              "string" == typeof e.type &&
              "CommentLine" !== e.type &&
              "CommentBlock" !== e.type
              ? o(e, t)
              : e;
          }
          function a(e, t) {
            return Array.isArray(e) ? e.map(e => s(e, t)) : s(e, t);
          }
          function o(e, t = !0) {
            if (!e) return e;
            const { type: r } = e,
              s = { type: r };
            if ("Identifier" === r)
              (s.name = e.name),
                i(e, "optional") &&
                  "boolean" == typeof e.optional &&
                  (s.optional = e.optional),
                i(e, "typeAnnotation") &&
                  (s.typeAnnotation = t
                    ? a(e.typeAnnotation, !0)
                    : e.typeAnnotation);
            else {
              if (!i(n.NODE_FIELDS, r))
                throw new Error(`Unknown node type: "${r}"`);
              for (const o of Object.keys(n.NODE_FIELDS[r]))
                i(e, o) && (s[o] = t ? a(e[o], !0) : e[o]);
            }
            return (
              i(e, "loc") && (s.loc = e.loc),
              i(e, "leadingComments") &&
                (s.leadingComments = e.leadingComments),
              i(e, "innerComments") && (s.innerComments = e.innerComments),
              i(e, "trailingComments") &&
                (s.trailingComments = e.trailingComments),
              i(e, "extra") && (s.extra = Object.assign({}, e.extra)),
              s
            );
          }
        },
        { "../definitions": 94 }
      ],
      69: [
        function(e, t, r) {
          "use strict";
          Object.defineProperty(r, "__esModule", { value: !0 }),
            (r.default = function(e) {
              const t = (0, i.default)(e);
              return (t.loc = null), t;
            });
          var n,
            i = (n = e("./clone")) && n.__esModule ? n : { default: n };
        },
        { "./clone": 66 }
      ],
      70: [
        function(e, t, r) {
          "use strict";
          Object.defineProperty(r, "__esModule", { value: !0 }),
            (r.default = function(e, t, r, n) {
              return (0, i.default)(e, t, [
                { type: n ? "CommentLine" : "CommentBlock", value: r }
              ]);
            });
          var n,
            i = (n = e("./addComments")) && n.__esModule ? n : { default: n };
        },
        { "./addComments": 71 }
      ],
      71: [
        function(e, t, r) {
          "use strict";
          Object.defineProperty(r, "__esModule", { value: !0 }),
            (r.default = function(e, t, r) {
              if (!r || !e) return e;
              const n = `${t}Comments`;
              e[n]
                ? (e[n] = "leading" === t ? r.concat(e[n]) : e[n].concat(r))
                : (e[n] = r);
              return e;
            });
        },
        {}
      ],
      72: [
        function(e, t, r) {
          "use strict";
          Object.defineProperty(r, "__esModule", { value: !0 }),
            (r.default = function(e, t) {
              (0, i.default)("innerComments", e, t);
            });
          var n,
            i =
              (n = e("../utils/inherit")) && n.__esModule ? n : { default: n };
        },
        { "../utils/inherit": 111 }
      ],
      73: [
        function(e, t, r) {
          "use strict";
          Object.defineProperty(r, "__esModule", { value: !0 }),
            (r.default = function(e, t) {
              (0, i.default)("leadingComments", e, t);
            });
          var n,
            i =
              (n = e("../utils/inherit")) && n.__esModule ? n : { default: n };
        },
        { "../utils/inherit": 111 }
      ],
      74: [
        function(e, t, r) {
          "use strict";
          Object.defineProperty(r, "__esModule", { value: !0 }),
            (r.default = function(e, t) {
              (0, i.default)("trailingComments", e, t);
            });
          var n,
            i =
              (n = e("../utils/inherit")) && n.__esModule ? n : { default: n };
        },
        { "../utils/inherit": 111 }
      ],
      75: [
        function(e, t, r) {
          "use strict";
          Object.defineProperty(r, "__esModule", { value: !0 }),
            (r.default = function(e, t) {
              return (
                (0, n.default)(e, t),
                (0, i.default)(e, t),
                (0, s.default)(e, t),
                e
              );
            });
          var n = a(e("./inheritTrailingComments")),
            i = a(e("./inheritLeadingComments")),
            s = a(e("./inheritInnerComments"));
          function a(e) {
            return e && e.__esModule ? e : { default: e };
          }
        },
        {
          "./inheritInnerComments": 72,
          "./inheritLeadingComments": 73,
          "./inheritTrailingComments": 74
        }
      ],
      76: [
        function(e, t, r) {
          "use strict";
          Object.defineProperty(r, "__esModule", { value: !0 }),
            (r.default = function(e) {
              return (
                n.COMMENT_KEYS.forEach(t => {
                  e[t] = null;
                }),
                e
              );
            });
          var n = e("../constants");
        },
        { "../constants": 78 }
      ],
      77: [
        function(e, t, r) {
          "use strict";
          Object.defineProperty(r, "__esModule", { value: !0 }),
            (r.TSTYPE_TYPES = r.TSTYPEELEMENT_TYPES = r.PRIVATE_TYPES = r.JSX_TYPES = r.FLOWPREDICATE_TYPES = r.FLOWDECLARATION_TYPES = r.FLOWBASEANNOTATION_TYPES = r.FLOWTYPE_TYPES = r.FLOW_TYPES = r.MODULESPECIFIER_TYPES = r.EXPORTDECLARATION_TYPES = r.MODULEDECLARATION_TYPES = r.CLASS_TYPES = r.PATTERN_TYPES = r.UNARYLIKE_TYPES = r.PROPERTY_TYPES = r.OBJECTMEMBER_TYPES = r.METHOD_TYPES = r.USERWHITESPACABLE_TYPES = r.IMMUTABLE_TYPES = r.LITERAL_TYPES = r.TSENTITYNAME_TYPES = r.LVAL_TYPES = r.PATTERNLIKE_TYPES = r.DECLARATION_TYPES = r.PUREISH_TYPES = r.FUNCTIONPARENT_TYPES = r.FUNCTION_TYPES = r.FORXSTATEMENT_TYPES = r.FOR_TYPES = r.EXPRESSIONWRAPPER_TYPES = r.WHILE_TYPES = r.LOOP_TYPES = r.CONDITIONAL_TYPES = r.COMPLETIONSTATEMENT_TYPES = r.TERMINATORLESS_TYPES = r.STATEMENT_TYPES = r.BLOCK_TYPES = r.BLOCKPARENT_TYPES = r.SCOPABLE_TYPES = r.BINARY_TYPES = r.EXPRESSION_TYPES = void 0);
          var n = e("../../definitions");
          const i = n.FLIPPED_ALIAS_KEYS.Expression;
          r.EXPRESSION_TYPES = i;
          const s = n.FLIPPED_ALIAS_KEYS.Binary;
          r.BINARY_TYPES = s;
          const a = n.FLIPPED_ALIAS_KEYS.Scopable;
          r.SCOPABLE_TYPES = a;
          const o = n.FLIPPED_ALIAS_KEYS.BlockParent;
          r.BLOCKPARENT_TYPES = o;
          const u = n.FLIPPED_ALIAS_KEYS.Block;
          r.BLOCK_TYPES = u;
          const l = n.FLIPPED_ALIAS_KEYS.Statement;
          r.STATEMENT_TYPES = l;
          const c = n.FLIPPED_ALIAS_KEYS.Terminatorless;
          r.TERMINATORLESS_TYPES = c;
          const p = n.FLIPPED_ALIAS_KEYS.CompletionStatement;
          r.COMPLETIONSTATEMENT_TYPES = p;
          const d = n.FLIPPED_ALIAS_KEYS.Conditional;
          r.CONDITIONAL_TYPES = d;
          const h = n.FLIPPED_ALIAS_KEYS.Loop;
          r.LOOP_TYPES = h;
          const f = n.FLIPPED_ALIAS_KEYS.While;
          r.WHILE_TYPES = f;
          const m = n.FLIPPED_ALIAS_KEYS.ExpressionWrapper;
          r.EXPRESSIONWRAPPER_TYPES = m;
          const y = n.FLIPPED_ALIAS_KEYS.For;
          r.FOR_TYPES = y;
          const g = n.FLIPPED_ALIAS_KEYS.ForXStatement;
          r.FORXSTATEMENT_TYPES = g;
          const b = n.FLIPPED_ALIAS_KEYS.Function;
          r.FUNCTION_TYPES = b;
          const v = n.FLIPPED_ALIAS_KEYS.FunctionParent;
          r.FUNCTIONPARENT_TYPES = v;
          const E = n.FLIPPED_ALIAS_KEYS.Pureish;
          r.PUREISH_TYPES = E;
          const T = n.FLIPPED_ALIAS_KEYS.Declaration;
          r.DECLARATION_TYPES = T;
          const x = n.FLIPPED_ALIAS_KEYS.PatternLike;
          r.PATTERNLIKE_TYPES = x;
          const A = n.FLIPPED_ALIAS_KEYS.LVal;
          r.LVAL_TYPES = A;
          const S = n.FLIPPED_ALIAS_KEYS.TSEntityName;
          r.TSENTITYNAME_TYPES = S;
          const D = n.FLIPPED_ALIAS_KEYS.Literal;
          r.LITERAL_TYPES = D;
          const P = n.FLIPPED_ALIAS_KEYS.Immutable;
          r.IMMUTABLE_TYPES = P;
          const C = n.FLIPPED_ALIAS_KEYS.UserWhitespacable;
          r.USERWHITESPACABLE_TYPES = C;
          const w = n.FLIPPED_ALIAS_KEYS.Method;
          r.METHOD_TYPES = w;
          const F = n.FLIPPED_ALIAS_KEYS.ObjectMember;
          r.OBJECTMEMBER_TYPES = F;
          const _ = n.FLIPPED_ALIAS_KEYS.Property;
          r.PROPERTY_TYPES = _;
          const O = n.FLIPPED_ALIAS_KEYS.UnaryLike;
          r.UNARYLIKE_TYPES = O;
          const k = n.FLIPPED_ALIAS_KEYS.Pattern;
          r.PATTERN_TYPES = k;
          const I = n.FLIPPED_ALIAS_KEYS.Class;
          r.CLASS_TYPES = I;
          const N = n.FLIPPED_ALIAS_KEYS.ModuleDeclaration;
          r.MODULEDECLARATION_TYPES = N;
          const L = n.FLIPPED_ALIAS_KEYS.ExportDeclaration;
          r.EXPORTDECLARATION_TYPES = L;
          const B = n.FLIPPED_ALIAS_KEYS.ModuleSpecifier;
          r.MODULESPECIFIER_TYPES = B;
          const M = n.FLIPPED_ALIAS_KEYS.Flow;
          r.FLOW_TYPES = M;
          const j = n.FLIPPED_ALIAS_KEYS.FlowType;
          r.FLOWTYPE_TYPES = j;
          const R = n.FLIPPED_ALIAS_KEYS.FlowBaseAnnotation;
          r.FLOWBASEANNOTATION_TYPES = R;
          const q = n.FLIPPED_ALIAS_KEYS.FlowDeclaration;
          r.FLOWDECLARATION_TYPES = q;
          const V = n.FLIPPED_ALIAS_KEYS.FlowPredicate;
          r.FLOWPREDICATE_TYPES = V;
          const U = n.FLIPPED_ALIAS_KEYS.JSX;
          r.JSX_TYPES = U;
          const K = n.FLIPPED_ALIAS_KEYS.Private;
          r.PRIVATE_TYPES = K;
          const G = n.FLIPPED_ALIAS_KEYS.TSTypeElement;
          r.TSTYPEELEMENT_TYPES = G;
          const W = n.FLIPPED_ALIAS_KEYS.TSType;
          r.TSTYPE_TYPES = W;
        },
        { "../../definitions": 94 }
      ],
      78: [
        function(e, t, r) {
          "use strict";
          Object.defineProperty(r, "__esModule", { value: !0 }),
            (r.NOT_LOCAL_BINDING = r.BLOCK_SCOPED_SYMBOL = r.INHERIT_KEYS = r.UNARY_OPERATORS = r.STRING_UNARY_OPERATORS = r.NUMBER_UNARY_OPERATORS = r.BOOLEAN_UNARY_OPERATORS = r.BINARY_OPERATORS = r.NUMBER_BINARY_OPERATORS = r.BOOLEAN_BINARY_OPERATORS = r.COMPARISON_BINARY_OPERATORS = r.EQUALITY_BINARY_OPERATORS = r.BOOLEAN_NUMBER_BINARY_OPERATORS = r.UPDATE_OPERATORS = r.LOGICAL_OPERATORS = r.COMMENT_KEYS = r.FOR_INIT_KEYS = r.FLATTENABLE_KEYS = r.STATEMENT_OR_BLOCK_KEYS = void 0);
          r.STATEMENT_OR_BLOCK_KEYS = ["consequent", "body", "alternate"];
          r.FLATTENABLE_KEYS = ["body", "expressions"];
          r.FOR_INIT_KEYS = ["left", "init"];
          r.COMMENT_KEYS = [
            "leadingComments",
            "trailingComments",
            "innerComments"
          ];
          r.LOGICAL_OPERATORS = ["||", "&&", "??"];
          r.UPDATE_OPERATORS = ["++", "--"];
          const n = [">", "<", ">=", "<="];
          r.BOOLEAN_NUMBER_BINARY_OPERATORS = n;
          const i = ["==", "===", "!=", "!=="];
          r.EQUALITY_BINARY_OPERATORS = i;
          const s = [...i, "in", "instanceof"];
          r.COMPARISON_BINARY_OPERATORS = s;
          const a = [...s, ...n];
          r.BOOLEAN_BINARY_OPERATORS = a;
          const o = [
            "-",
            "/",
            "%",
            "*",
            "**",
            "&",
            "|",
            ">>",
            ">>>",
            "<<",
            "^"
          ];
          r.NUMBER_BINARY_OPERATORS = o;
          const u = ["+", ...o, ...a];
          r.BINARY_OPERATORS = u;
          const l = ["delete", "!"];
          r.BOOLEAN_UNARY_OPERATORS = l;
          const c = ["+", "-", "~"];
          r.NUMBER_UNARY_OPERATORS = c;
          const p = ["typeof"];
          r.STRING_UNARY_OPERATORS = p;
          const d = ["void", "throw", ...l, ...c, ...p];
          r.UNARY_OPERATORS = d;
          r.INHERIT_KEYS = {
            optional: ["typeAnnotation", "typeParameters", "returnType"],
            force: ["start", "loc", "end"]
          };
          const h = Symbol.for("var used to be block scoped");
          r.BLOCK_SCOPED_SYMBOL = h;
          const f = Symbol.for("should not be considered a local binding");
          r.NOT_LOCAL_BINDING = f;
        },
        {}
      ],
      79: [
        function(e, t, r) {
          "use strict";
          Object.defineProperty(r, "__esModule", { value: !0 }),
            (r.default = function(e, t = "body") {
              return (e[t] = (0, i.default)(e[t], e));
            });
          var n,
            i = (n = e("./toBlock")) && n.__esModule ? n : { default: n };
        },
        { "./toBlock": 82 }
      ],
      80: [
        function(e, t, r) {
          "use strict";
          Object.defineProperty(r, "__esModule", { value: !0 }),
            (r.default = function e(t, r, o) {
              const u = [];
              let l = !0;
              for (const c of t)
                if (((l = !1), (0, i.isExpression)(c))) u.push(c);
                else if ((0, i.isExpressionStatement)(c)) u.push(c.expression);
                else if ((0, i.isVariableDeclaration)(c)) {
                  if ("var" !== c.kind) return;
                  for (const e of c.declarations) {
                    const t = (0, n.default)(e);
                    for (const e of Object.keys(t))
                      o.push({ kind: c.kind, id: (0, a.default)(t[e]) });
                    e.init &&
                      u.push((0, s.assignmentExpression)("=", e.id, e.init));
                  }
                  l = !0;
                } else if ((0, i.isIfStatement)(c)) {
                  const t = c.consequent
                      ? e([c.consequent], r, o)
                      : r.buildUndefinedNode(),
                    n = c.alternate
                      ? e([c.alternate], r, o)
                      : r.buildUndefinedNode();
                  if (!t || !n) return;
                  u.push((0, s.conditionalExpression)(c.test, t, n));
                } else if ((0, i.isBlockStatement)(c)) {
                  const t = e(c.body, r, o);
                  if (!t) return;
                  u.push(t);
                } else {
                  if (!(0, i.isEmptyStatement)(c)) return;
                  l = !0;
                }
              l && u.push(r.buildUndefinedNode());
              return 1 === u.length ? u[0] : (0, s.sequenceExpression)(u);
            });
          var n = o(e("../retrievers/getBindingIdentifiers")),
            i = e("../validators/generated"),
            s = e("../builders/generated"),
            a = o(e("../clone/cloneNode"));
          function o(e) {
            return e && e.__esModule ? e : { default: e };
          }
        },
        {
          "../builders/generated": 64,
          "../clone/cloneNode": 68,
          "../retrievers/getBindingIdentifiers": 107,
          "../validators/generated": 115
        }
      ],
      81: [
        function(e, t, r) {
          "use strict";
          Object.defineProperty(r, "__esModule", { value: !0 }),
            (r.default = function(e) {
              ("eval" !== (e = (0, i.default)(e)) && "arguments" !== e) ||
                (e = "_" + e);
              return e;
            });
          var n,
            i = (n = e("./toIdentifier")) && n.__esModule ? n : { default: n };
        },
        { "./toIdentifier": 85 }
      ],
      82: [
        function(e, t, r) {
          "use strict";
          Object.defineProperty(r, "__esModule", { value: !0 }),
            (r.default = function(e, t) {
              if ((0, n.isBlockStatement)(e)) return e;
              let r = [];
              (0, n.isEmptyStatement)(e)
                ? (r = [])
                : ((0, n.isStatement)(e) ||
                    (e = (0, n.isFunction)(t)
                      ? (0, i.returnStatement)(e)
                      : (0, i.expressionStatement)(e)),
                  (r = [e]));
              return (0, i.blockStatement)(r);
            });
          var n = e("../validators/generated"),
            i = e("../builders/generated");
        },
        { "../builders/generated": 64, "../validators/generated": 115 }
      ],
      83: [
        function(e, t, r) {
          "use strict";
          Object.defineProperty(r, "__esModule", { value: !0 }),
            (r.default = function(e, t = e.key || e.property) {
              !e.computed &&
                (0, n.isIdentifier)(t) &&
                (t = (0, i.stringLiteral)(t.name));
              return t;
            });
          var n = e("../validators/generated"),
            i = e("../builders/generated");
        },
        { "../builders/generated": 64, "../validators/generated": 115 }
      ],
      84: [
        function(e, t, r) {
          "use strict";
          Object.defineProperty(r, "__esModule", { value: !0 }),
            (r.default = function(e) {
              (0, n.isExpressionStatement)(e) && (e = e.expression);
              if ((0, n.isExpression)(e)) return e;
              (0, n.isClass)(e)
                ? (e.type = "ClassExpression")
                : (0, n.isFunction)(e) && (e.type = "FunctionExpression");
              if (!(0, n.isExpression)(e))
                throw new Error(`cannot turn ${e.type} to an expression`);
              return e;
            });
          var n = e("../validators/generated");
        },
        { "../validators/generated": 115 }
      ],
      85: [
        function(e, t, r) {
          "use strict";
          Object.defineProperty(r, "__esModule", { value: !0 }),
            (r.default = function(e) {
              (e = (e = (e = (e += "").replace(/[^a-zA-Z0-9$_]/g, "-")).replace(
                /^[-0-9]+/,
                ""
              )).replace(/[-\s]+(.)?/g, function(e, t) {
                return t ? t.toUpperCase() : "";
              })),
                (0, i.default)(e) || (e = `_${e}`);
              return e || "_";
            });
          var n,
            i =
              (n = e("../validators/isValidIdentifier")) && n.__esModule
                ? n
                : { default: n };
        },
        { "../validators/isValidIdentifier": 129 }
      ],
      86: [
        function(e, t, r) {
          "use strict";
          Object.defineProperty(r, "__esModule", { value: !0 }),
            (r.default = o);
          var n = e("../validators/generated"),
            i = a(e("../clone/cloneNode")),
            s = a(e("../modifications/removePropertiesDeep"));
          function a(e) {
            return e && e.__esModule ? e : { default: e };
          }
          function o(e, t = e.key) {
            let r;
            return "method" === e.kind
              ? o.increment() + ""
              : ((r = (0, n.isIdentifier)(t)
                  ? t.name
                  : (0, n.isStringLiteral)(t)
                  ? JSON.stringify(t.value)
                  : JSON.stringify((0, s.default)((0, i.default)(t)))),
                e.computed && (r = `[${r}]`),
                e.static && (r = `static:${r}`),
                r);
          }
          (o.uid = 0),
            (o.increment = function() {
              return o.uid >= Number.MAX_SAFE_INTEGER ? (o.uid = 0) : o.uid++;
            });
        },
        {
          "../clone/cloneNode": 68,
          "../modifications/removePropertiesDeep": 106,
          "../validators/generated": 115
        }
      ],
      87: [
        function(e, t, r) {
          "use strict";
          Object.defineProperty(r, "__esModule", { value: !0 }),
            (r.default = function(e, t) {
              if (!e || !e.length) return;
              const r = [],
                n = (0, i.default)(e, t, r);
              if (!n) return;
              for (const e of r) t.push(e);
              return n;
            });
          var n,
            i =
              (n = e("./gatherSequenceExpressions")) && n.__esModule
                ? n
                : { default: n };
        },
        { "./gatherSequenceExpressions": 80 }
      ],
      88: [
        function(e, t, r) {
          "use strict";
          Object.defineProperty(r, "__esModule", { value: !0 }),
            (r.default = function(e, t) {
              if ((0, n.isStatement)(e)) return e;
              let r,
                s = !1;
              if ((0, n.isClass)(e)) (s = !0), (r = "ClassDeclaration");
              else if ((0, n.isFunction)(e))
                (s = !0), (r = "FunctionDeclaration");
              else if ((0, n.isAssignmentExpression)(e))
                return (0, i.expressionStatement)(e);
              s && !e.id && (r = !1);
              if (!r) {
                if (t) return !1;
                throw new Error(`cannot turn ${e.type} to a statement`);
              }
              return (e.type = r), e;
            });
          var n = e("../validators/generated"),
            i = e("../builders/generated");
        },
        { "../builders/generated": 64, "../validators/generated": 115 }
      ],
      89: [
        function(e, t, r) {
          "use strict";
          function n() {
            const t = o(e("lodash/isPlainObject"));
            return (
              (n = function() {
                return t;
              }),
              t
            );
          }
          function i() {
            const t = o(e("lodash/isRegExp"));
            return (
              (i = function() {
                return t;
              }),
              t
            );
          }
          Object.defineProperty(r, "__esModule", { value: !0 }),
            (r.default = function e(t) {
              if (void 0 === t) return (0, a.identifier)("undefined");
              if (!0 === t || !1 === t) return (0, a.booleanLiteral)(t);
              if (null === t) return (0, a.nullLiteral)();
              if ("string" == typeof t) return (0, a.stringLiteral)(t);
              if ("number" == typeof t) {
                let e;
                if (Number.isFinite(t)) e = (0, a.numericLiteral)(Math.abs(t));
                else {
                  let r;
                  (r = Number.isNaN(t)
                    ? (0, a.numericLiteral)(0)
                    : (0, a.numericLiteral)(1)),
                    (e = (0, a.binaryExpression)(
                      "/",
                      r,
                      (0, a.numericLiteral)(0)
                    ));
                }
                return (
                  (t < 0 || Object.is(t, -0)) &&
                    (e = (0, a.unaryExpression)("-", e)),
                  e
                );
              }
              if ((0, i().default)(t)) {
                const e = t.source,
                  r = t.toString().match(/\/([a-z]+|)$/)[1];
                return (0, a.regExpLiteral)(e, r);
              }
              if (Array.isArray(t)) return (0, a.arrayExpression)(t.map(e));
              if ((0, n().default)(t)) {
                const r = [];
                for (const n of Object.keys(t)) {
                  let i;
                  (i = (0, s.default)(n)
                    ? (0, a.identifier)(n)
                    : (0, a.stringLiteral)(n)),
                    r.push((0, a.objectProperty)(i, e(t[n])));
                }
                return (0, a.objectExpression)(r);
              }
              throw new Error("don't know how to turn this value into a node");
            });
          var s = o(e("../validators/isValidIdentifier")),
            a = e("../builders/generated");
          function o(e) {
            return e && e.__esModule ? e : { default: e };
          }
        },
        {
          "../builders/generated": 64,
          "../validators/isValidIdentifier": 129,
          "lodash/isPlainObject": 285,
          "lodash/isRegExp": 286
        }
      ],
      90: [
        function(e, t, r) {
          "use strict";
          Object.defineProperty(r, "__esModule", { value: !0 }),
            (r.patternLikeCommon = r.functionDeclarationCommon = r.functionTypeAnnotationCommon = r.functionCommon = void 0);
          var n,
            i =
              (n = e("../validators/isValidIdentifier")) && n.__esModule
                ? n
                : { default: n },
            s = e("../constants"),
            a = (function(e) {
              if (e && e.__esModule) return e;
              var t = {};
              if (null != e)
                for (var r in e)
                  if (Object.prototype.hasOwnProperty.call(e, r)) {
                    var n =
                      Object.defineProperty && Object.getOwnPropertyDescriptor
                        ? Object.getOwnPropertyDescriptor(e, r)
                        : {};
                    n.get || n.set
                      ? Object.defineProperty(t, r, n)
                      : (t[r] = e[r]);
                  }
              return (t.default = e), t;
            })(e("./utils"));
          (0, a.default)("ArrayExpression", {
            fields: {
              elements: {
                validate: (0, a.chain)(
                  (0, a.assertValueType)("array"),
                  (0, a.assertEach)(
                    (0, a.assertNodeOrValueType)(
                      "null",
                      "Expression",
                      "SpreadElement"
                    )
                  )
                ),
                default: []
              }
            },
            visitor: ["elements"],
            aliases: ["Expression"]
          }),
            (0, a.default)("AssignmentExpression", {
              fields: {
                operator: { validate: (0, a.assertValueType)("string") },
                left: { validate: (0, a.assertNodeType)("LVal") },
                right: { validate: (0, a.assertNodeType)("Expression") }
              },
              builder: ["operator", "left", "right"],
              visitor: ["left", "right"],
              aliases: ["Expression"]
            }),
            (0, a.default)("BinaryExpression", {
              builder: ["operator", "left", "right"],
              fields: {
                operator: {
                  validate: (0, a.assertOneOf)(...s.BINARY_OPERATORS)
                },
                left: { validate: (0, a.assertNodeType)("Expression") },
                right: { validate: (0, a.assertNodeType)("Expression") }
              },
              visitor: ["left", "right"],
              aliases: ["Binary", "Expression"]
            }),
            (0, a.default)("InterpreterDirective", {
              builder: ["value"],
              fields: { value: { validate: (0, a.assertValueType)("string") } }
            }),
            (0, a.default)("Directive", {
              visitor: ["value"],
              fields: {
                value: { validate: (0, a.assertNodeType)("DirectiveLiteral") }
              }
            }),
            (0, a.default)("DirectiveLiteral", {
              builder: ["value"],
              fields: { value: { validate: (0, a.assertValueType)("string") } }
            }),
            (0, a.default)("BlockStatement", {
              builder: ["body", "directives"],
              visitor: ["directives", "body"],
              fields: {
                directives: {
                  validate: (0, a.chain)(
                    (0, a.assertValueType)("array"),
                    (0, a.assertEach)((0, a.assertNodeType)("Directive"))
                  ),
                  default: []
                },
                body: {
                  validate: (0, a.chain)(
                    (0, a.assertValueType)("array"),
                    (0, a.assertEach)((0, a.assertNodeType)("Statement"))
                  )
                }
              },
              aliases: ["Scopable", "BlockParent", "Block", "Statement"]
            }),
            (0, a.default)("BreakStatement", {
              visitor: ["label"],
              fields: {
                label: {
                  validate: (0, a.assertNodeType)("Identifier"),
                  optional: !0
                }
              },
              aliases: ["Statement", "Terminatorless", "CompletionStatement"]
            }),
            (0, a.default)("CallExpression", {
              visitor: [
                "callee",
                "arguments",
                "typeParameters",
                "typeArguments"
              ],
              builder: ["callee", "arguments"],
              aliases: ["Expression"],
              fields: {
                callee: { validate: (0, a.assertNodeType)("Expression") },
                arguments: {
                  validate: (0, a.chain)(
                    (0, a.assertValueType)("array"),
                    (0, a.assertEach)(
                      (0, a.assertNodeType)(
                        "Expression",
                        "SpreadElement",
                        "JSXNamespacedName",
                        "ArgumentPlaceholder"
                      )
                    )
                  )
                },
                optional: {
                  validate: (0, a.assertOneOf)(!0, !1),
                  optional: !0
                },
                typeArguments: {
                  validate: (0, a.assertNodeType)("TypeParameterInstantiation"),
                  optional: !0
                },
                typeParameters: {
                  validate: (0, a.assertNodeType)(
                    "TSTypeParameterInstantiation"
                  ),
                  optional: !0
                }
              }
            }),
            (0, a.default)("CatchClause", {
              visitor: ["param", "body"],
              fields: {
                param: {
                  validate: (0, a.assertNodeType)("Identifier"),
                  optional: !0
                },
                body: { validate: (0, a.assertNodeType)("BlockStatement") }
              },
              aliases: ["Scopable", "BlockParent"]
            }),
            (0, a.default)("ConditionalExpression", {
              visitor: ["test", "consequent", "alternate"],
              fields: {
                test: { validate: (0, a.assertNodeType)("Expression") },
                consequent: { validate: (0, a.assertNodeType)("Expression") },
                alternate: { validate: (0, a.assertNodeType)("Expression") }
              },
              aliases: ["Expression", "Conditional"]
            }),
            (0, a.default)("ContinueStatement", {
              visitor: ["label"],
              fields: {
                label: {
                  validate: (0, a.assertNodeType)("Identifier"),
                  optional: !0
                }
              },
              aliases: ["Statement", "Terminatorless", "CompletionStatement"]
            }),
            (0, a.default)("DebuggerStatement", { aliases: ["Statement"] }),
            (0, a.default)("DoWhileStatement", {
              visitor: ["test", "body"],
              fields: {
                test: { validate: (0, a.assertNodeType)("Expression") },
                body: { validate: (0, a.assertNodeType)("Statement") }
              },
              aliases: ["Statement", "BlockParent", "Loop", "While", "Scopable"]
            }),
            (0, a.default)("EmptyStatement", { aliases: ["Statement"] }),
            (0, a.default)("ExpressionStatement", {
              visitor: ["expression"],
              fields: {
                expression: { validate: (0, a.assertNodeType)("Expression") }
              },
              aliases: ["Statement", "ExpressionWrapper"]
            }),
            (0, a.default)("File", {
              builder: ["program", "comments", "tokens"],
              visitor: ["program"],
              fields: {
                program: { validate: (0, a.assertNodeType)("Program") }
              }
            }),
            (0, a.default)("ForInStatement", {
              visitor: ["left", "right", "body"],
              aliases: [
                "Scopable",
                "Statement",
                "For",
                "BlockParent",
                "Loop",
                "ForXStatement"
              ],
              fields: {
                left: {
                  validate: (0, a.assertNodeType)("VariableDeclaration", "LVal")
                },
                right: { validate: (0, a.assertNodeType)("Expression") },
                body: { validate: (0, a.assertNodeType)("Statement") }
              }
            }),
            (0, a.default)("ForStatement", {
              visitor: ["init", "test", "update", "body"],
              aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop"],
              fields: {
                init: {
                  validate: (0, a.assertNodeType)(
                    "VariableDeclaration",
                    "Expression"
                  ),
                  optional: !0
                },
                test: {
                  validate: (0, a.assertNodeType)("Expression"),
                  optional: !0
                },
                update: {
                  validate: (0, a.assertNodeType)("Expression"),
                  optional: !0
                },
                body: { validate: (0, a.assertNodeType)("Statement") }
              }
            });
          const o = {
            params: {
              validate: (0, a.chain)(
                (0, a.assertValueType)("array"),
                (0, a.assertEach)(
                  (0, a.assertNodeType)(
                    "Identifier",
                    "Pattern",
                    "RestElement",
                    "TSParameterProperty"
                  )
                )
              )
            },
            generator: {
              default: !1,
              validate: (0, a.assertValueType)("boolean")
            },
            async: { validate: (0, a.assertValueType)("boolean"), default: !1 }
          };
          r.functionCommon = o;
          const u = {
            returnType: {
              validate: (0, a.assertNodeType)(
                "TypeAnnotation",
                "TSTypeAnnotation",
                "Noop"
              ),
              optional: !0
            },
            typeParameters: {
              validate: (0, a.assertNodeType)(
                "TypeParameterDeclaration",
                "TSTypeParameterDeclaration",
                "Noop"
              ),
              optional: !0
            }
          };
          r.functionTypeAnnotationCommon = u;
          const l = Object.assign({}, o, {
            declare: {
              validate: (0, a.assertValueType)("boolean"),
              optional: !0
            },
            id: { validate: (0, a.assertNodeType)("Identifier"), optional: !0 }
          });
          (r.functionDeclarationCommon = l),
            (0, a.default)("FunctionDeclaration", {
              builder: ["id", "params", "body", "generator", "async"],
              visitor: ["id", "params", "body", "returnType", "typeParameters"],
              fields: Object.assign({}, l, u, {
                body: { validate: (0, a.assertNodeType)("BlockStatement") }
              }),
              aliases: [
                "Scopable",
                "Function",
                "BlockParent",
                "FunctionParent",
                "Statement",
                "Pureish",
                "Declaration"
              ]
            }),
            (0, a.default)("FunctionExpression", {
              inherits: "FunctionDeclaration",
              aliases: [
                "Scopable",
                "Function",
                "BlockParent",
                "FunctionParent",
                "Expression",
                "Pureish"
              ],
              fields: Object.assign({}, o, u, {
                id: {
                  validate: (0, a.assertNodeType)("Identifier"),
                  optional: !0
                },
                body: { validate: (0, a.assertNodeType)("BlockStatement") }
              })
            });
          const c = {
            typeAnnotation: {
              validate: (0, a.assertNodeType)(
                "TypeAnnotation",
                "TSTypeAnnotation",
                "Noop"
              ),
              optional: !0
            },
            decorators: {
              validate: (0, a.chain)(
                (0, a.assertValueType)("array"),
                (0, a.assertEach)((0, a.assertNodeType)("Decorator"))
              )
            }
          };
          (r.patternLikeCommon = c),
            (0, a.default)("Identifier", {
              builder: ["name"],
              visitor: ["typeAnnotation", "decorators"],
              aliases: ["Expression", "PatternLike", "LVal", "TSEntityName"],
              fields: Object.assign({}, c, {
                name: {
                  validate: (0, a.chain)(function(e, t, r) {
                    (0, i.default)(r);
                  }, (0, a.assertValueType)("string"))
                },
                optional: {
                  validate: (0, a.assertValueType)("boolean"),
                  optional: !0
                }
              })
            }),
            (0, a.default)("IfStatement", {
              visitor: ["test", "consequent", "alternate"],
              aliases: ["Statement", "Conditional"],
              fields: {
                test: { validate: (0, a.assertNodeType)("Expression") },
                consequent: { validate: (0, a.assertNodeType)("Statement") },
                alternate: {
                  optional: !0,
                  validate: (0, a.assertNodeType)("Statement")
                }
              }
            }),
            (0, a.default)("LabeledStatement", {
              visitor: ["label", "body"],
              aliases: ["Statement"],
              fields: {
                label: { validate: (0, a.assertNodeType)("Identifier") },
                body: { validate: (0, a.assertNodeType)("Statement") }
              }
            }),
            (0, a.default)("StringLiteral", {
              builder: ["value"],
              fields: { value: { validate: (0, a.assertValueType)("string") } },
              aliases: ["Expression", "Pureish", "Literal", "Immutable"]
            }),
            (0, a.default)("NumericLiteral", {
              builder: ["value"],
              deprecatedAlias: "NumberLiteral",
              fields: { value: { validate: (0, a.assertValueType)("number") } },
              aliases: ["Expression", "Pureish", "Literal", "Immutable"]
            }),
            (0, a.default)("NullLiteral", {
              aliases: ["Expression", "Pureish", "Literal", "Immutable"]
            }),
            (0, a.default)("BooleanLiteral", {
              builder: ["value"],
              fields: {
                value: { validate: (0, a.assertValueType)("boolean") }
              },
              aliases: ["Expression", "Pureish", "Literal", "Immutable"]
            }),
            (0, a.default)("RegExpLiteral", {
              builder: ["pattern", "flags"],
              deprecatedAlias: "RegexLiteral",
              aliases: ["Expression", "Literal"],
              fields: {
                pattern: { validate: (0, a.assertValueType)("string") },
                flags: {
                  validate: (0, a.assertValueType)("string"),
                  default: ""
                }
              }
            }),
            (0, a.default)("LogicalExpression", {
              builder: ["operator", "left", "right"],
              visitor: ["left", "right"],
              aliases: ["Binary", "Expression"],
              fields: {
                operator: {
                  validate: (0, a.assertOneOf)(...s.LOGICAL_OPERATORS)
                },
                left: { validate: (0, a.assertNodeType)("Expression") },
                right: { validate: (0, a.assertNodeType)("Expression") }
              }
            }),
            (0, a.default)("MemberExpression", {
              builder: ["object", "property", "computed", "optional"],
              visitor: ["object", "property"],
              aliases: ["Expression", "LVal"],
              fields: {
                object: { validate: (0, a.assertNodeType)("Expression") },
                property: {
                  validate: (function() {
                    const e = (0, a.assertNodeType)(
                        "Identifier",
                        "PrivateName"
                      ),
                      t = (0, a.assertNodeType)("Expression");
                    return function(r, n, i) {
                      (r.computed ? t : e)(r, n, i);
                    };
                  })()
                },
                computed: { default: !1 },
                optional: { validate: (0, a.assertOneOf)(!0, !1), optional: !0 }
              }
            }),
            (0, a.default)("NewExpression", { inherits: "CallExpression" }),
            (0, a.default)("Program", {
              visitor: ["directives", "body"],
              builder: ["body", "directives", "sourceType", "interpreter"],
              fields: {
                sourceFile: { validate: (0, a.assertValueType)("string") },
                sourceType: {
                  validate: (0, a.assertOneOf)("script", "module"),
                  default: "script"
                },
                interpreter: {
                  validate: (0, a.assertNodeType)("InterpreterDirective"),
                  default: null,
                  optional: !0
                },
                directives: {
                  validate: (0, a.chain)(
                    (0, a.assertValueType)("array"),
                    (0, a.assertEach)((0, a.assertNodeType)("Directive"))
                  ),
                  default: []
                },
                body: {
                  validate: (0, a.chain)(
                    (0, a.assertValueType)("array"),
                    (0, a.assertEach)((0, a.assertNodeType)("Statement"))
                  )
                }
              },
              aliases: ["Scopable", "BlockParent", "Block"]
            }),
            (0, a.default)("ObjectExpression", {
              visitor: ["properties"],
              aliases: ["Expression"],
              fields: {
                properties: {
                  validate: (0, a.chain)(
                    (0, a.assertValueType)("array"),
                    (0, a.assertEach)(
                      (0, a.assertNodeType)(
                        "ObjectMethod",
                        "ObjectProperty",
                        "SpreadElement"
                      )
                    )
                  )
                }
              }
            }),
            (0, a.default)("ObjectMethod", {
              builder: ["kind", "key", "params", "body", "computed"],
              fields: Object.assign({}, o, u, {
                kind: {
                  validate: (0, a.chain)(
                    (0, a.assertValueType)("string"),
                    (0, a.assertOneOf)("method", "get", "set")
                  ),
                  default: "method"
                },
                computed: {
                  validate: (0, a.assertValueType)("boolean"),
                  default: !1
                },
                key: {
                  validate: (function() {
                    const e = (0, a.assertNodeType)(
                        "Identifier",
                        "StringLiteral",
                        "NumericLiteral"
                      ),
                      t = (0, a.assertNodeType)("Expression");
                    return function(r, n, i) {
                      (r.computed ? t : e)(r, n, i);
                    };
                  })()
                },
                decorators: {
                  validate: (0, a.chain)(
                    (0, a.assertValueType)("array"),
                    (0, a.assertEach)((0, a.assertNodeType)("Decorator"))
                  )
                },
                body: { validate: (0, a.assertNodeType)("BlockStatement") }
              }),
              visitor: [
                "key",
                "params",
                "body",
                "decorators",
                "returnType",
                "typeParameters"
              ],
              aliases: [
                "UserWhitespacable",
                "Function",
                "Scopable",
                "BlockParent",
                "FunctionParent",
                "Method",
                "ObjectMember"
              ]
            }),
            (0, a.default)("ObjectProperty", {
              builder: ["key", "value", "computed", "shorthand", "decorators"],
              fields: {
                computed: {
                  validate: (0, a.assertValueType)("boolean"),
                  default: !1
                },
                key: {
                  validate: (function() {
                    const e = (0, a.assertNodeType)(
                        "Identifier",
                        "StringLiteral",
                        "NumericLiteral"
                      ),
                      t = (0, a.assertNodeType)("Expression");
                    return function(r, n, i) {
                      (r.computed ? t : e)(r, n, i);
                    };
                  })()
                },
                value: {
                  validate: (0, a.assertNodeType)("Expression", "PatternLike")
                },
                shorthand: {
                  validate: (0, a.assertValueType)("boolean"),
                  default: !1
                },
                decorators: {
                  validate: (0, a.chain)(
                    (0, a.assertValueType)("array"),
                    (0, a.assertEach)((0, a.assertNodeType)("Decorator"))
                  ),
                  optional: !0
                }
              },
              visitor: ["key", "value", "decorators"],
              aliases: ["UserWhitespacable", "Property", "ObjectMember"]
            }),
            (0, a.default)("RestElement", {
              visitor: ["argument", "typeAnnotation"],
              builder: ["argument"],
              aliases: ["LVal", "PatternLike"],
              deprecatedAlias: "RestProperty",
              fields: Object.assign({}, c, {
                argument: { validate: (0, a.assertNodeType)("LVal") }
              })
            }),
            (0, a.default)("ReturnStatement", {
              visitor: ["argument"],
              aliases: ["Statement", "Terminatorless", "CompletionStatement"],
              fields: {
                argument: {
                  validate: (0, a.assertNodeType)("Expression"),
                  optional: !0
                }
              }
            }),
            (0, a.default)("SequenceExpression", {
              visitor: ["expressions"],
              fields: {
                expressions: {
                  validate: (0, a.chain)(
                    (0, a.assertValueType)("array"),
                    (0, a.assertEach)((0, a.assertNodeType)("Expression"))
                  )
                }
              },
              aliases: ["Expression"]
            }),
            (0, a.default)("ParenthesizedExpression", {
              visitor: ["expression"],
              aliases: ["Expression", "ExpressionWrapper"],
              fields: {
                expression: { validate: (0, a.assertNodeType)("Expression") }
              }
            }),
            (0, a.default)("SwitchCase", {
              visitor: ["test", "consequent"],
              fields: {
                test: {
                  validate: (0, a.assertNodeType)("Expression"),
                  optional: !0
                },
                consequent: {
                  validate: (0, a.chain)(
                    (0, a.assertValueType)("array"),
                    (0, a.assertEach)((0, a.assertNodeType)("Statement"))
                  )
                }
              }
            }),
            (0, a.default)("SwitchStatement", {
              visitor: ["discriminant", "cases"],
              aliases: ["Statement", "BlockParent", "Scopable"],
              fields: {
                discriminant: { validate: (0, a.assertNodeType)("Expression") },
                cases: {
                  validate: (0, a.chain)(
                    (0, a.assertValueType)("array"),
                    (0, a.assertEach)((0, a.assertNodeType)("SwitchCase"))
                  )
                }
              }
            }),
            (0, a.default)("ThisExpression", { aliases: ["Expression"] }),
            (0, a.default)("ThrowStatement", {
              visitor: ["argument"],
              aliases: ["Statement", "Terminatorless", "CompletionStatement"],
              fields: {
                argument: { validate: (0, a.assertNodeType)("Expression") }
              }
            }),
            (0, a.default)("TryStatement", {
              visitor: ["block", "handler", "finalizer"],
              aliases: ["Statement"],
              fields: {
                block: { validate: (0, a.assertNodeType)("BlockStatement") },
                handler: {
                  optional: !0,
                  validate: (0, a.assertNodeType)("CatchClause")
                },
                finalizer: {
                  optional: !0,
                  validate: (0, a.assertNodeType)("BlockStatement")
                }
              }
            }),
            (0, a.default)("UnaryExpression", {
              builder: ["operator", "argument", "prefix"],
              fields: {
                prefix: { default: !0 },
                argument: { validate: (0, a.assertNodeType)("Expression") },
                operator: { validate: (0, a.assertOneOf)(...s.UNARY_OPERATORS) }
              },
              visitor: ["argument"],
              aliases: ["UnaryLike", "Expression"]
            }),
            (0, a.default)("UpdateExpression", {
              builder: ["operator", "argument", "prefix"],
              fields: {
                prefix: { default: !1 },
                argument: { validate: (0, a.assertNodeType)("Expression") },
                operator: {
                  validate: (0, a.assertOneOf)(...s.UPDATE_OPERATORS)
                }
              },
              visitor: ["argument"],
              aliases: ["Expression"]
            }),
            (0, a.default)("VariableDeclaration", {
              builder: ["kind", "declarations"],
              visitor: ["declarations"],
              aliases: ["Statement", "Declaration"],
              fields: {
                declare: {
                  validate: (0, a.assertValueType)("boolean"),
                  optional: !0
                },
                kind: {
                  validate: (0, a.chain)(
                    (0, a.assertValueType)("string"),
                    (0, a.assertOneOf)("var", "let", "const")
                  )
                },
                declarations: {
                  validate: (0, a.chain)(
                    (0, a.assertValueType)("array"),
                    (0, a.assertEach)(
                      (0, a.assertNodeType)("VariableDeclarator")
                    )
                  )
                }
              }
            }),
            (0, a.default)("VariableDeclarator", {
              visitor: ["id", "init"],
              fields: {
                id: { validate: (0, a.assertNodeType)("LVal") },
                definite: {
                  optional: !0,
                  validate: (0, a.assertValueType)("boolean")
                },
                init: {
                  optional: !0,
                  validate: (0, a.assertNodeType)("Expression")
                }
              }
            }),
            (0, a.default)("WhileStatement", {
              visitor: ["test", "body"],
              aliases: [
                "Statement",
                "BlockParent",
                "Loop",
                "While",
                "Scopable"
              ],
              fields: {
                test: { validate: (0, a.assertNodeType)("Expression") },
                body: {
                  validate: (0, a.assertNodeType)("BlockStatement", "Statement")
                }
              }
            }),
            (0, a.default)("WithStatement", {
              visitor: ["object", "body"],
              aliases: ["Statement"],
              fields: {
                object: { validate: (0, a.assertNodeType)("Expression") },
                body: {
                  validate: (0, a.assertNodeType)("BlockStatement", "Statement")
                }
              }
            });
        },
        {
          "../constants": 78,
          "../validators/isValidIdentifier": 129,
          "./utils": 99
        }
      ],
      91: [
        function(e, t, r) {
          "use strict";
          Object.defineProperty(r, "__esModule", { value: !0 }),
            (r.classMethodOrDeclareMethodCommon = r.classMethodOrPropertyCommon = void 0);
          var n = (function(e) {
              if (e && e.__esModule) return e;
              var t = {};
              if (null != e)
                for (var r in e)
                  if (Object.prototype.hasOwnProperty.call(e, r)) {
                    var n =
                      Object.defineProperty && Object.getOwnPropertyDescriptor
                        ? Object.getOwnPropertyDescriptor(e, r)
                        : {};
                    n.get || n.set
                      ? Object.defineProperty(t, r, n)
                      : (t[r] = e[r]);
                  }
              return (t.default = e), t;
            })(e("./utils")),
            i = e("./core");
          (0, n.default)("AssignmentPattern", {
            visitor: ["left", "right", "decorators"],
            builder: ["left", "right"],
            aliases: ["Pattern", "PatternLike", "LVal"],
            fields: Object.assign({}, i.patternLikeCommon, {
              left: {
                validate: (0, n.assertNodeType)(
                  "Identifier",
                  "ObjectPattern",
                  "ArrayPattern",
                  "MemberExpression"
                )
              },
              right: { validate: (0, n.assertNodeType)("Expression") },
              decorators: {
                validate: (0, n.chain)(
                  (0, n.assertValueType)("array"),
                  (0, n.assertEach)((0, n.assertNodeType)("Decorator"))
                )
              }
            })
          }),
            (0, n.default)("ArrayPattern", {
              visitor: ["elements", "typeAnnotation"],
              builder: ["elements"],
              aliases: ["Pattern", "PatternLike", "LVal"],
              fields: Object.assign({}, i.patternLikeCommon, {
                elements: {
                  validate: (0, n.chain)(
                    (0, n.assertValueType)("array"),
                    (0, n.assertEach)((0, n.assertNodeType)("PatternLike"))
                  )
                },
                decorators: {
                  validate: (0, n.chain)(
                    (0, n.assertValueType)("array"),
                    (0, n.assertEach)((0, n.assertNodeType)("Decorator"))
                  )
                }
              })
            }),
            (0, n.default)("ArrowFunctionExpression", {
              builder: ["params", "body", "async"],
              visitor: ["params", "body", "returnType", "typeParameters"],
              aliases: [
                "Scopable",
                "Function",
                "BlockParent",
                "FunctionParent",
                "Expression",
                "Pureish"
              ],
              fields: Object.assign(
                {},
                i.functionCommon,
                i.functionTypeAnnotationCommon,
                {
                  expression: { validate: (0, n.assertValueType)("boolean") },
                  body: {
                    validate: (0, n.assertNodeType)(
                      "BlockStatement",
                      "Expression"
                    )
                  }
                }
              )
            }),
            (0, n.default)("ClassBody", {
              visitor: ["body"],
              fields: {
                body: {
                  validate: (0, n.chain)(
                    (0, n.assertValueType)("array"),
                    (0, n.assertEach)(
                      (0, n.assertNodeType)(
                        "ClassMethod",
                        "ClassPrivateMethod",
                        "ClassProperty",
                        "ClassPrivateProperty",
                        "TSDeclareMethod",
                        "TSIndexSignature"
                      )
                    )
                  )
                }
              }
            });
          const s = {
            typeParameters: {
              validate: (0, n.assertNodeType)(
                "TypeParameterDeclaration",
                "TSTypeParameterDeclaration",
                "Noop"
              ),
              optional: !0
            },
            body: { validate: (0, n.assertNodeType)("ClassBody") },
            superClass: {
              optional: !0,
              validate: (0, n.assertNodeType)("Expression")
            },
            superTypeParameters: {
              validate: (0, n.assertNodeType)(
                "TypeParameterInstantiation",
                "TSTypeParameterInstantiation"
              ),
              optional: !0
            },
            implements: {
              validate: (0, n.chain)(
                (0, n.assertValueType)("array"),
                (0, n.assertEach)(
                  (0, n.assertNodeType)(
                    "TSExpressionWithTypeArguments",
                    "ClassImplements"
                  )
                )
              ),
              optional: !0
            }
          };
          (0, n.default)("ClassDeclaration", {
            builder: ["id", "superClass", "body", "decorators"],
            visitor: [
              "id",
              "body",
              "superClass",
              "mixins",
              "typeParameters",
              "superTypeParameters",
              "implements",
              "decorators"
            ],
            aliases: [
              "Scopable",
              "Class",
              "Statement",
              "Declaration",
              "Pureish"
            ],
            fields: Object.assign({}, s, {
              declare: {
                validate: (0, n.assertValueType)("boolean"),
                optional: !0
              },
              abstract: {
                validate: (0, n.assertValueType)("boolean"),
                optional: !0
              },
              id: {
                validate: (0, n.assertNodeType)("Identifier"),
                optional: !0
              },
              decorators: {
                validate: (0, n.chain)(
                  (0, n.assertValueType)("array"),
                  (0, n.assertEach)((0, n.assertNodeType)("Decorator"))
                ),
                optional: !0
              }
            })
          }),
            (0, n.default)("ClassExpression", {
              inherits: "ClassDeclaration",
              aliases: ["Scopable", "Class", "Expression", "Pureish"],
              fields: Object.assign({}, s, {
                id: {
                  optional: !0,
                  validate: (0, n.assertNodeType)("Identifier")
                },
                body: { validate: (0, n.assertNodeType)("ClassBody") },
                superClass: {
                  optional: !0,
                  validate: (0, n.assertNodeType)("Expression")
                },
                decorators: {
                  validate: (0, n.chain)(
                    (0, n.assertValueType)("array"),
                    (0, n.assertEach)((0, n.assertNodeType)("Decorator"))
                  ),
                  optional: !0
                }
              })
            }),
            (0, n.default)("ExportAllDeclaration", {
              visitor: ["source"],
              aliases: [
                "Statement",
                "Declaration",
                "ModuleDeclaration",
                "ExportDeclaration"
              ],
              fields: {
                source: { validate: (0, n.assertNodeType)("StringLiteral") }
              }
            }),
            (0, n.default)("ExportDefaultDeclaration", {
              visitor: ["declaration"],
              aliases: [
                "Statement",
                "Declaration",
                "ModuleDeclaration",
                "ExportDeclaration"
              ],
              fields: {
                declaration: {
                  validate: (0, n.assertNodeType)(
                    "FunctionDeclaration",
                    "TSDeclareFunction",
                    "ClassDeclaration",
                    "Expression"
                  )
                }
              }
            }),
            (0, n.default)("ExportNamedDeclaration", {
              visitor: ["declaration", "specifiers", "source"],
              aliases: [
                "Statement",
                "Declaration",
                "ModuleDeclaration",
                "ExportDeclaration"
              ],
              fields: {
                declaration: {
                  validate: (0, n.assertNodeType)("Declaration"),
                  optional: !0
                },
                specifiers: {
                  validate: (0, n.chain)(
                    (0, n.assertValueType)("array"),
                    (0, n.assertEach)(
                      (0, n.assertNodeType)(
                        "ExportSpecifier",
                        "ExportDefaultSpecifier",
                        "ExportNamespaceSpecifier"
                      )
                    )
                  )
                },
                source: {
                  validate: (0, n.assertNodeType)("StringLiteral"),
                  optional: !0
                },
                exportKind: (0, n.validateOptional)(
                  (0, n.assertOneOf)("type", "value")
                )
              }
            }),
            (0, n.default)("ExportSpecifier", {
              visitor: ["local", "exported"],
              aliases: ["ModuleSpecifier"],
              fields: {
                local: { validate: (0, n.assertNodeType)("Identifier") },
                exported: { validate: (0, n.assertNodeType)("Identifier") }
              }
            }),
            (0, n.default)("ForOfStatement", {
              visitor: ["left", "right", "body"],
              aliases: [
                "Scopable",
                "Statement",
                "For",
                "BlockParent",
                "Loop",
                "ForXStatement"
              ],
              fields: {
                left: {
                  validate: (0, n.assertNodeType)("VariableDeclaration", "LVal")
                },
                right: { validate: (0, n.assertNodeType)("Expression") },
                body: { validate: (0, n.assertNodeType)("Statement") },
                await: {
                  default: !1,
                  validate: (0, n.assertValueType)("boolean")
                }
              }
            }),
            (0, n.default)("ImportDeclaration", {
              visitor: ["specifiers", "source"],
              aliases: ["Statement", "Declaration", "ModuleDeclaration"],
              fields: {
                specifiers: {
                  validate: (0, n.chain)(
                    (0, n.assertValueType)("array"),
                    (0, n.assertEach)(
                      (0, n.assertNodeType)(
                        "ImportSpecifier",
                        "ImportDefaultSpecifier",
                        "ImportNamespaceSpecifier"
                      )
                    )
                  )
                },
                source: { validate: (0, n.assertNodeType)("StringLiteral") },
                importKind: {
                  validate: (0, n.assertOneOf)("type", "typeof", "value"),
                  optional: !0
                }
              }
            }),
            (0, n.default)("ImportDefaultSpecifier", {
              visitor: ["local"],
              aliases: ["ModuleSpecifier"],
              fields: {
                local: { validate: (0, n.assertNodeType)("Identifier") }
              }
            }),
            (0, n.default)("ImportNamespaceSpecifier", {
              visitor: ["local"],
              aliases: ["ModuleSpecifier"],
              fields: {
                local: { validate: (0, n.assertNodeType)("Identifier") }
              }
            }),
            (0, n.default)("ImportSpecifier", {
              visitor: ["local", "imported"],
              aliases: ["ModuleSpecifier"],
              fields: {
                local: { validate: (0, n.assertNodeType)("Identifier") },
                imported: { validate: (0, n.assertNodeType)("Identifier") },
                importKind: {
                  validate: (0, n.assertOneOf)("type", "typeof"),
                  optional: !0
                }
              }
            }),
            (0, n.default)("MetaProperty", {
              visitor: ["meta", "property"],
              aliases: ["Expression"],
              fields: {
                meta: { validate: (0, n.assertNodeType)("Identifier") },
                property: { validate: (0, n.assertNodeType)("Identifier") }
              }
            });
          const a = {
            abstract: {
              validate: (0, n.assertValueType)("boolean"),
              optional: !0
            },
            accessibility: {
              validate: (0, n.chain)(
                (0, n.assertValueType)("string"),
                (0, n.assertOneOf)("public", "private", "protected")
              ),
              optional: !0
            },
            static: {
              validate: (0, n.assertValueType)("boolean"),
              optional: !0
            },
            computed: {
              default: !1,
              validate: (0, n.assertValueType)("boolean")
            },
            optional: {
              validate: (0, n.assertValueType)("boolean"),
              optional: !0
            },
            key: {
              validate: (0, n.chain)(
                (function() {
                  const e = (0, n.assertNodeType)(
                      "Identifier",
                      "StringLiteral",
                      "NumericLiteral"
                    ),
                    t = (0, n.assertNodeType)("Expression");
                  return function(r, n, i) {
                    (r.computed ? t : e)(r, n, i);
                  };
                })(),
                (0, n.assertNodeType)(
                  "Identifier",
                  "StringLiteral",
                  "NumericLiteral",
                  "Expression"
                )
              )
            }
          };
          r.classMethodOrPropertyCommon = a;
          const o = Object.assign({}, i.functionCommon, a, {
            kind: {
              validate: (0, n.chain)(
                (0, n.assertValueType)("string"),
                (0, n.assertOneOf)("get", "set", "method", "constructor")
              ),
              default: "method"
            },
            access: {
              validate: (0, n.chain)(
                (0, n.assertValueType)("string"),
                (0, n.assertOneOf)("public", "private", "protected")
              ),
              optional: !0
            },
            decorators: {
              validate: (0, n.chain)(
                (0, n.assertValueType)("array"),
                (0, n.assertEach)((0, n.assertNodeType)("Decorator"))
              ),
              optional: !0
            }
          });
          (r.classMethodOrDeclareMethodCommon = o),
            (0, n.default)("ClassMethod", {
              aliases: [
                "Function",
                "Scopable",
                "BlockParent",
                "FunctionParent",
                "Method"
              ],
              builder: ["kind", "key", "params", "body", "computed", "static"],
              visitor: [
                "key",
                "params",
                "body",
                "decorators",
                "returnType",
                "typeParameters"
              ],
              fields: Object.assign({}, o, i.functionTypeAnnotationCommon, {
                body: { validate: (0, n.assertNodeType)("BlockStatement") }
              })
            }),
            (0, n.default)("ObjectPattern", {
              visitor: ["properties", "typeAnnotation", "decorators"],
              builder: ["properties"],
              aliases: ["Pattern", "PatternLike", "LVal"],
              fields: Object.assign({}, i.patternLikeCommon, {
                properties: {
                  validate: (0, n.chain)(
                    (0, n.assertValueType)("array"),
                    (0, n.assertEach)(
                      (0, n.assertNodeType)("RestElement", "ObjectProperty")
                    )
                  )
                }
              })
            }),
            (0, n.default)("SpreadElement", {
              visitor: ["argument"],
              aliases: ["UnaryLike"],
              deprecatedAlias: "SpreadProperty",
              fields: {
                argument: { validate: (0, n.assertNodeType)("Expression") }
              }
            }),
            (0, n.default)("Super", { aliases: ["Expression"] }),
            (0, n.default)("TaggedTemplateExpression", {
              visitor: ["tag", "quasi"],
              aliases: ["Expression"],
              fields: {
                tag: { validate: (0, n.assertNodeType)("Expression") },
                quasi: { validate: (0, n.assertNodeType)("TemplateLiteral") },
                typeParameters: {
                  validate: (0, n.assertNodeType)(
                    "TypeParameterInstantiation",
                    "TSTypeParameterInstantiation"
                  ),
                  optional: !0
                }
              }
            }),
            (0, n.default)("TemplateElement", {
              builder: ["value", "tail"],
              fields: {
                value: {
                  validate: (0, n.assertShape)({
                    raw: { validate: (0, n.assertValueType)("string") },
                    cooked: {
                      validate: (0, n.assertValueType)("string"),
                      optional: !0
                    }
                  })
                },
                tail: {
                  validate: (0, n.assertValueType)("boolean"),
                  default: !1
                }
              }
            }),
            (0, n.default)("TemplateLiteral", {
              visitor: ["quasis", "expressions"],
              aliases: ["Expression", "Literal"],
              fields: {
                quasis: {
                  validate: (0, n.chain)(
                    (0, n.assertValueType)("array"),
                    (0, n.assertEach)((0, n.assertNodeType)("TemplateElement"))
                  )
                },
                expressions: {
                  validate: (0, n.chain)(
                    (0, n.assertValueType)("array"),
                    (0, n.assertEach)((0, n.assertNodeType)("Expression"))
                  )
                }
              }
            }),
            (0, n.default)("YieldExpression", {
              builder: ["argument", "delegate"],
              visitor: ["argument"],
              aliases: ["Expression", "Terminatorless"],
              fields: {
                delegate: {
                  validate: (0, n.assertValueType)("boolean"),
                  default: !1
                },
                argument: {
                  optional: !0,
                  validate: (0, n.assertNodeType)("Expression")
                }
              }
            });
        },
        { "./core": 90, "./utils": 99 }
      ],
      92: [
        function(e, t, r) {
          "use strict";
          var n = (function(e) {
              if (e && e.__esModule) return e;
              var t = {};
              if (null != e)
                for (var r in e)
                  if (Object.prototype.hasOwnProperty.call(e, r)) {
                    var n =
                      Object.defineProperty && Object.getOwnPropertyDescriptor
                        ? Object.getOwnPropertyDescriptor(e, r)
                        : {};
                    n.get || n.set
                      ? Object.defineProperty(t, r, n)
                      : (t[r] = e[r]);
                  }
              return (t.default = e), t;
            })(e("./utils")),
            i = e("./es2015");
          (0, n.default)("ArgumentPlaceholder", {}),
            (0, n.default)("AwaitExpression", {
              builder: ["argument"],
              visitor: ["argument"],
              aliases: ["Expression", "Terminatorless"],
              fields: {
                argument: { validate: (0, n.assertNodeType)("Expression") }
              }
            }),
            (0, n.default)("BindExpression", {
              visitor: ["object", "callee"],
              aliases: ["Expression"],
              fields: {}
            }),
            (0, n.default)("ClassProperty", {
              visitor: ["key", "value", "typeAnnotation", "decorators"],
              builder: [
                "key",
                "value",
                "typeAnnotation",
                "decorators",
                "computed"
              ],
              aliases: ["Property"],
              fields: Object.assign({}, i.classMethodOrPropertyCommon, {
                value: {
                  validate: (0, n.assertNodeType)("Expression"),
                  optional: !0
                },
                definite: {
                  validate: (0, n.assertValueType)("boolean"),
                  optional: !0
                },
                typeAnnotation: {
                  validate: (0, n.assertNodeType)(
                    "TypeAnnotation",
                    "TSTypeAnnotation",
                    "Noop"
                  ),
                  optional: !0
                },
                decorators: {
                  validate: (0, n.chain)(
                    (0, n.assertValueType)("array"),
                    (0, n.assertEach)((0, n.assertNodeType)("Decorator"))
                  ),
                  optional: !0
                },
                readonly: {
                  validate: (0, n.assertValueType)("boolean"),
                  optional: !0
                }
              })
            }),
            (0, n.default)("OptionalMemberExpression", {
              builder: ["object", "property", "computed", "optional"],
              visitor: ["object", "property"],
              aliases: ["Expression"],
              fields: {
                object: { validate: (0, n.assertNodeType)("Expression") },
                property: {
                  validate: (function() {
                    const e = (0, n.assertNodeType)("Identifier"),
                      t = (0, n.assertNodeType)("Expression");
                    return function(r, n, i) {
                      (r.computed ? t : e)(r, n, i);
                    };
                  })()
                },
                computed: { default: !1 },
                optional: { validate: (0, n.assertValueType)("boolean") }
              }
            }),
            (0, n.default)("PipelineTopicExpression", {
              builder: ["expression"],
              visitor: ["expression"],
              fields: {
                expression: { validate: (0, n.assertNodeType)("Expression") }
              }
            }),
            (0, n.default)("PipelineBareFunction", {
              builder: ["callee"],
              visitor: ["callee"],
              fields: {
                callee: { validate: (0, n.assertNodeType)("Expression") }
              }
            }),
            (0, n.default)("PipelinePrimaryTopicReference", {
              aliases: ["Expression"]
            }),
            (0, n.default)("OptionalCallExpression", {
              visitor: [
                "callee",
                "arguments",
                "typeParameters",
                "typeArguments"
              ],
              builder: ["callee", "arguments", "optional"],
              aliases: ["Expression"],
              fields: {
                callee: { validate: (0, n.assertNodeType)("Expression") },
                arguments: {
                  validate: (0, n.chain)(
                    (0, n.assertValueType)("array"),
                    (0, n.assertEach)(
                      (0, n.assertNodeType)(
                        "Expression",
                        "SpreadElement",
                        "JSXNamespacedName"
                      )
                    )
                  )
                },
                optional: { validate: (0, n.assertValueType)("boolean") },
                typeArguments: {
                  validate: (0, n.assertNodeType)("TypeParameterInstantiation"),
                  optional: !0
                },
                typeParameters: {
                  validate: (0, n.assertNodeType)(
                    "TSTypeParameterInstantiation"
                  ),
                  optional: !0
                }
              }
            }),
            (0, n.default)("ClassPrivateProperty", {
              visitor: ["key", "value"],
              builder: ["key", "value"],
              aliases: ["Property", "Private"],
              fields: {
                key: { validate: (0, n.assertNodeType)("PrivateName") },
                value: {
                  validate: (0, n.assertNodeType)("Expression"),
                  optional: !0
                }
              }
            }),
            (0, n.default)("ClassPrivateMethod", {
              builder: ["kind", "key", "params", "body", "static"],
              visitor: [
                "key",
                "params",
                "body",
                "decorators",
                "returnType",
                "typeParameters"
              ],
              aliases: [
                "Function",
                "Scopable",
                "BlockParent",
                "FunctionParent",
                "Method",
                "Private"
              ],
              fields: Object.assign({}, i.classMethodOrDeclareMethodCommon, {
                key: { validate: (0, n.assertNodeType)("PrivateName") },
                body: { validate: (0, n.assertNodeType)("BlockStatement") }
              })
            }),
            (0, n.default)("Import", { aliases: ["Expression"] }),
            (0, n.default)("Decorator", {
              visitor: ["expression"],
              fields: {
                expression: { validate: (0, n.assertNodeType)("Expression") }
              }
            }),
            (0, n.default)("DoExpression", {
              visitor: ["body"],
              aliases: ["Expression"],
              fields: {
                body: { validate: (0, n.assertNodeType)("BlockStatement") }
              }
            }),
            (0, n.default)("ExportDefaultSpecifier", {
              visitor: ["exported"],
              aliases: ["ModuleSpecifier"],
              fields: {
                exported: { validate: (0, n.assertNodeType)("Identifier") }
              }
            }),
            (0, n.default)("ExportNamespaceSpecifier", {
              visitor: ["exported"],
              aliases: ["ModuleSpecifier"],
              fields: {
                exported: { validate: (0, n.assertNodeType)("Identifier") }
              }
            }),
            (0, n.default)("PrivateName", {
              visitor: ["id"],
              aliases: ["Private"],
              fields: { id: { validate: (0, n.assertNodeType)("Identifier") } }
            }),
            (0, n.default)("BigIntLiteral", {
              builder: ["value"],
              fields: { value: { validate: (0, n.assertValueType)("string") } },
              aliases: ["Expression", "Pureish", "Literal", "Immutable"]
            });
        },
        { "./es2015": 91, "./utils": 99 }
      ],
      93: [
        function(e, t, r) {
          "use strict";
          var n = (function(e) {
            if (e && e.__esModule) return e;
            var t = {};
            if (null != e)
              for (var r in e)
                if (Object.prototype.hasOwnProperty.call(e, r)) {
                  var n =
                    Object.defineProperty && Object.getOwnPropertyDescriptor
                      ? Object.getOwnPropertyDescriptor(e, r)
                      : {};
                  n.get || n.set
                    ? Object.defineProperty(t, r, n)
                    : (t[r] = e[r]);
                }
            return (t.default = e), t;
          })(e("./utils"));
          const i = (e, t = "TypeParameterDeclaration") => {
            (0, n.default)(e, {
              builder: ["id", "typeParameters", "extends", "body"],
              visitor: [
                "id",
                "typeParameters",
                "extends",
                "mixins",
                "implements",
                "body"
              ],
              aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
              fields: {
                id: (0, n.validateType)("Identifier"),
                typeParameters: (0, n.validateOptionalType)(t),
                extends: (0, n.validateOptional)(
                  (0, n.arrayOfType)("InterfaceExtends")
                ),
                mixins: (0, n.validateOptional)(
                  (0, n.arrayOfType)("InterfaceExtends")
                ),
                implements: (0, n.validateOptional)(
                  (0, n.arrayOfType)("ClassImplements")
                ),
                body: (0, n.validateType)("ObjectTypeAnnotation")
              }
            });
          };
          (0, n.default)("AnyTypeAnnotation", {
            aliases: ["Flow", "FlowType", "FlowBaseAnnotation"]
          }),
            (0, n.default)("ArrayTypeAnnotation", {
              visitor: ["elementType"],
              aliases: ["Flow", "FlowType"],
              fields: { elementType: (0, n.validateType)("FlowType") }
            }),
            (0, n.default)("BooleanTypeAnnotation", {
              aliases: ["Flow", "FlowType", "FlowBaseAnnotation"]
            }),
            (0, n.default)("BooleanLiteralTypeAnnotation", {
              builder: ["value"],
              aliases: ["Flow", "FlowType"],
              fields: {
                value: (0, n.validate)((0, n.assertValueType)("boolean"))
              }
            }),
            (0, n.default)("NullLiteralTypeAnnotation", {
              aliases: ["Flow", "FlowType", "FlowBaseAnnotation"]
            }),
            (0, n.default)("ClassImplements", {
              visitor: ["id", "typeParameters"],
              aliases: ["Flow"],
              fields: {
                id: (0, n.validateType)("Identifier"),
                typeParameters: (0, n.validateOptionalType)(
                  "TypeParameterInstantiation"
                )
              }
            }),
            i("DeclareClass"),
            (0, n.default)("DeclareFunction", {
              visitor: ["id"],
              aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
              fields: {
                id: (0, n.validateType)("Identifier"),
                predicate: (0, n.validateOptionalType)("DeclaredPredicate")
              }
            }),
            i("DeclareInterface"),
            (0, n.default)("DeclareModule", {
              builder: ["id", "body", "kind"],
              visitor: ["id", "body"],
              aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
              fields: {
                id: (0, n.validateType)(["Identifier", "StringLiteral"]),
                body: (0, n.validateType)("BlockStatement"),
                kind: (0, n.validateOptional)(
                  (0, n.assertOneOf)("CommonJS", "ES")
                )
              }
            }),
            (0, n.default)("DeclareModuleExports", {
              visitor: ["typeAnnotation"],
              aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
              fields: { typeAnnotation: (0, n.validateType)("TypeAnnotation") }
            }),
            (0, n.default)("DeclareTypeAlias", {
              visitor: ["id", "typeParameters", "right"],
              aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
              fields: {
                id: (0, n.validateType)("Identifier"),
                typeParameters: (0, n.validateOptionalType)(
                  "TypeParameterDeclaration"
                ),
                right: (0, n.validateType)("FlowType")
              }
            }),
            (0, n.default)("DeclareOpaqueType", {
              visitor: ["id", "typeParameters", "supertype"],
              aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
              fields: {
                id: (0, n.validateType)("Identifier"),
                typeParameters: (0, n.validateOptionalType)(
                  "TypeParameterDeclaration"
                ),
                supertype: (0, n.validateOptionalType)("FlowType")
              }
            }),
            (0, n.default)("DeclareVariable", {
              visitor: ["id"],
              aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
              fields: { id: (0, n.validateType)("Identifier") }
            }),
            (0, n.default)("DeclareExportDeclaration", {
              visitor: ["declaration", "specifiers", "source"],
              aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
              fields: {
                declaration: (0, n.validateOptionalType)("Flow"),
                specifiers: (0, n.validateOptional)(
                  (0, n.arrayOfType)([
                    "ExportSpecifier",
                    "ExportNamespaceSpecifier"
                  ])
                ),
                source: (0, n.validateOptionalType)("StringLiteral"),
                default: (0, n.validateOptional)(
                  (0, n.assertValueType)("boolean")
                )
              }
            }),
            (0, n.default)("DeclareExportAllDeclaration", {
              visitor: ["source"],
              aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
              fields: {
                source: (0, n.validateType)("StringLiteral"),
                exportKind: (0, n.validateOptional)(
                  (0, n.assertOneOf)("type", "value")
                )
              }
            }),
            (0, n.default)("DeclaredPredicate", {
              visitor: ["value"],
              aliases: ["Flow", "FlowPredicate"],
              fields: { value: (0, n.validateType)("Flow") }
            }),
            (0, n.default)("ExistsTypeAnnotation", {
              aliases: ["Flow", "FlowType"]
            }),
            (0, n.default)("FunctionTypeAnnotation", {
              visitor: ["typeParameters", "params", "rest", "returnType"],
              aliases: ["Flow", "FlowType"],
              fields: {
                typeParameters: (0, n.validateOptionalType)(
                  "TypeParameterDeclaration"
                ),
                params: (0, n.validate)(
                  (0, n.arrayOfType)("FunctionTypeParam")
                ),
                rest: (0, n.validateOptionalType)("FunctionTypeParam"),
                returnType: (0, n.validateType)("FlowType")
              }
            }),
            (0, n.default)("FunctionTypeParam", {
              visitor: ["name", "typeAnnotation"],
              aliases: ["Flow"],
              fields: {
                name: (0, n.validateOptionalType)("Identifier"),
                typeAnnotation: (0, n.validateType)("FlowType"),
                optional: (0, n.validateOptional)(
                  (0, n.assertValueType)("boolean")
                )
              }
            }),
            (0, n.default)("GenericTypeAnnotation", {
              visitor: ["id", "typeParameters"],
              aliases: ["Flow", "FlowType"],
              fields: {
                id: (0, n.validateType)([
                  "Identifier",
                  "QualifiedTypeIdentifier"
                ]),
                typeParameters: (0, n.validateOptionalType)(
                  "TypeParameterInstantiation"
                )
              }
            }),
            (0, n.default)("InferredPredicate", {
              aliases: ["Flow", "FlowPredicate"]
            }),
            (0, n.default)("InterfaceExtends", {
              visitor: ["id", "typeParameters"],
              aliases: ["Flow"],
              fields: {
                id: (0, n.validateType)([
                  "Identifier",
                  "QualifiedTypeIdentifier"
                ]),
                typeParameters: (0, n.validateOptionalType)(
                  "TypeParameterInstantiation"
                )
              }
            }),
            i("InterfaceDeclaration"),
            (0, n.default)("InterfaceTypeAnnotation", {
              visitor: ["extends", "body"],
              aliases: ["Flow", "FlowType"],
              fields: {
                extends: (0, n.validateOptional)(
                  (0, n.arrayOfType)("InterfaceExtends")
                ),
                body: (0, n.validateType)("ObjectTypeAnnotation")
              }
            }),
            (0, n.default)("IntersectionTypeAnnotation", {
              visitor: ["types"],
              aliases: ["Flow", "FlowType"],
              fields: { types: (0, n.validate)((0, n.arrayOfType)("FlowType")) }
            }),
            (0, n.default)("MixedTypeAnnotation", {
              aliases: ["Flow", "FlowType", "FlowBaseAnnotation"]
            }),
            (0, n.default)("EmptyTypeAnnotation", {
              aliases: ["Flow", "FlowType", "FlowBaseAnnotation"]
            }),
            (0, n.default)("NullableTypeAnnotation", {
              visitor: ["typeAnnotation"],
              aliases: ["Flow", "FlowType"],
              fields: { typeAnnotation: (0, n.validateType)("FlowType") }
            }),
            (0, n.default)("NumberLiteralTypeAnnotation", {
              builder: ["value"],
              aliases: ["Flow", "FlowType"],
              fields: {
                value: (0, n.validate)((0, n.assertValueType)("number"))
              }
            }),
            (0, n.default)("NumberTypeAnnotation", {
              aliases: ["Flow", "FlowType", "FlowBaseAnnotation"]
            }),
            (0, n.default)("ObjectTypeAnnotation", {
              visitor: [
                "properties",
                "indexers",
                "callProperties",
                "internalSlots"
              ],
              aliases: ["Flow", "FlowType"],
              builder: [
                "properties",
                "indexers",
                "callProperties",
                "internalSlots",
                "exact"
              ],
              fields: {
                properties: (0, n.validate)(
                  (0, n.arrayOfType)([
                    "ObjectTypeProperty",
                    "ObjectTypeSpreadProperty"
                  ])
                ),
                indexers: (0, n.validateOptional)(
                  (0, n.arrayOfType)("ObjectTypeIndexer")
                ),
                callProperties: (0, n.validateOptional)(
                  (0, n.arrayOfType)("ObjectTypeCallProperty")
                ),
                internalSlots: (0, n.validateOptional)(
                  (0, n.arrayOfType)("ObjectTypeInternalSlot")
                ),
                exact: {
                  validate: (0, n.assertValueType)("boolean"),
                  default: !1
                },
                inexact: (0, n.validateOptional)(
                  (0, n.assertValueType)("boolean")
                )
              }
            }),
            (0, n.default)("ObjectTypeInternalSlot", {
              visitor: ["id", "value", "optional", "static", "method"],
              aliases: ["Flow", "UserWhitespacable"],
              fields: {
                id: (0, n.validateType)("Identifier"),
                value: (0, n.validateType)("FlowType"),
                optional: (0, n.validate)((0, n.assertValueType)("boolean")),
                static: (0, n.validate)((0, n.assertValueType)("boolean")),
                method: (0, n.validate)((0, n.assertValueType)("boolean"))
              }
            }),
            (0, n.default)("ObjectTypeCallProperty", {
              visitor: ["value"],
              aliases: ["Flow", "UserWhitespacable"],
              fields: {
                value: (0, n.validateType)("FlowType"),
                static: (0, n.validate)((0, n.assertValueType)("boolean"))
              }
            }),
            (0, n.default)("ObjectTypeIndexer", {
              visitor: ["id", "key", "value", "variance"],
              aliases: ["Flow", "UserWhitespacable"],
              fields: {
                id: (0, n.validateOptionalType)("Identifier"),
                key: (0, n.validateType)("FlowType"),
                value: (0, n.validateType)("FlowType"),
                static: (0, n.validate)((0, n.assertValueType)("boolean")),
                variance: (0, n.validateOptionalType)("Variance")
              }
            }),
            (0, n.default)("ObjectTypeProperty", {
              visitor: ["key", "value", "variance"],
              aliases: ["Flow", "UserWhitespacable"],
              fields: {
                key: (0, n.validateType)(["Identifier", "StringLiteral"]),
                value: (0, n.validateType)("FlowType"),
                kind: (0, n.validate)((0, n.assertOneOf)("init", "get", "set")),
                static: (0, n.validate)((0, n.assertValueType)("boolean")),
                proto: (0, n.validate)((0, n.assertValueType)("boolean")),
                optional: (0, n.validate)((0, n.assertValueType)("boolean")),
                variance: (0, n.validateOptionalType)("Variance")
              }
            }),
            (0, n.default)("ObjectTypeSpreadProperty", {
              visitor: ["argument"],
              aliases: ["Flow", "UserWhitespacable"],
              fields: { argument: (0, n.validateType)("FlowType") }
            }),
            (0, n.default)("OpaqueType", {
              visitor: ["id", "typeParameters", "supertype", "impltype"],
              aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
              fields: {
                id: (0, n.validateType)("Identifier"),
                typeParameters: (0, n.validateOptionalType)(
                  "TypeParameterDeclaration"
                ),
                supertype: (0, n.validateOptionalType)("FlowType"),
                impltype: (0, n.validateType)("FlowType")
              }
            }),
            (0, n.default)("QualifiedTypeIdentifier", {
              visitor: ["id", "qualification"],
              aliases: ["Flow"],
              fields: {
                id: (0, n.validateType)("Identifier"),
                qualification: (0, n.validateType)([
                  "Identifier",
                  "QualifiedTypeIdentifier"
                ])
              }
            }),
            (0, n.default)("StringLiteralTypeAnnotation", {
              builder: ["value"],
              aliases: ["Flow", "FlowType"],
              fields: {
                value: (0, n.validate)((0, n.assertValueType)("string"))
              }
            }),
            (0, n.default)("StringTypeAnnotation", {
              aliases: ["Flow", "FlowType", "FlowBaseAnnotation"]
            }),
            (0, n.default)("ThisTypeAnnotation", {
              aliases: ["Flow", "FlowType", "FlowBaseAnnotation"]
            }),
            (0, n.default)("TupleTypeAnnotation", {
              visitor: ["types"],
              aliases: ["Flow", "FlowType"],
              fields: { types: (0, n.validate)((0, n.arrayOfType)("FlowType")) }
            }),
            (0, n.default)("TypeofTypeAnnotation", {
              visitor: ["argument"],
              aliases: ["Flow", "FlowType"],
              fields: { argument: (0, n.validateType)("FlowType") }
            }),
            (0, n.default)("TypeAlias", {
              visitor: ["id", "typeParameters", "right"],
              aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
              fields: {
                id: (0, n.validateType)("Identifier"),
                typeParameters: (0, n.validateOptionalType)(
                  "TypeParameterDeclaration"
                ),
                right: (0, n.validateType)("FlowType")
              }
            }),
            (0, n.default)("TypeAnnotation", {
              aliases: ["Flow"],
              visitor: ["typeAnnotation"],
              fields: { typeAnnotation: (0, n.validateType)("FlowType") }
            }),
            (0, n.default)("TypeCastExpression", {
              visitor: ["expression", "typeAnnotation"],
              aliases: ["Flow", "ExpressionWrapper", "Expression"],
              fields: {
                expression: (0, n.validateType)("Expression"),
                typeAnnotation: (0, n.validateType)("TypeAnnotation")
              }
            }),
            (0, n.default)("TypeParameter", {
              aliases: ["Flow"],
              visitor: ["bound", "default", "variance"],
              fields: {
                name: (0, n.validate)((0, n.assertValueType)("string")),
                bound: (0, n.validateOptionalType)("TypeAnnotation"),
                default: (0, n.validateOptionalType)("FlowType"),
                variance: (0, n.validateOptionalType)("Variance")
              }
            }),
            (0, n.default)("TypeParameterDeclaration", {
              aliases: ["Flow"],
              visitor: ["params"],
              fields: {
                params: (0, n.validate)((0, n.arrayOfType)("TypeParameter"))
              }
            }),
            (0, n.default)("TypeParameterInstantiation", {
              aliases: ["Flow"],
              visitor: ["params"],
              fields: {
                params: (0, n.validate)((0, n.arrayOfType)("FlowType"))
              }
            }),
            (0, n.default)("UnionTypeAnnotation", {
              visitor: ["types"],
              aliases: ["Flow", "FlowType"],
              fields: { types: (0, n.validate)((0, n.arrayOfType)("FlowType")) }
            }),
            (0, n.default)("Variance", {
              aliases: ["Flow"],
              builder: ["kind"],
              fields: {
                kind: (0, n.validate)((0, n.assertOneOf)("minus", "plus"))
              }
            }),
            (0, n.default)("VoidTypeAnnotation", {
              aliases: ["Flow", "FlowType", "FlowBaseAnnotation"]
            });
        },
        { "./utils": 99 }
      ],
      94: [
        function(e, t, r) {
          "use strict";
          function n() {
            const t =
              (r = e("to-fast-properties")) && r.__esModule
                ? r
                : { default: r };
            var r;
            return (
              (n = function() {
                return t;
              }),
              t
            );
          }
          Object.defineProperty(r, "__esModule", { value: !0 }),
            Object.defineProperty(r, "VISITOR_KEYS", {
              enumerable: !0,
              get: function() {
                return i.VISITOR_KEYS;
              }
            }),
            Object.defineProperty(r, "ALIAS_KEYS", {
              enumerable: !0,
              get: function() {
                return i.ALIAS_KEYS;
              }
            }),
            Object.defineProperty(r, "FLIPPED_ALIAS_KEYS", {
              enumerable: !0,
              get: function() {
                return i.FLIPPED_ALIAS_KEYS;
              }
            }),
            Object.defineProperty(r, "NODE_FIELDS", {
              enumerable: !0,
              get: function() {
                return i.NODE_FIELDS;
              }
            }),
            Object.defineProperty(r, "BUILDER_KEYS", {
              enumerable: !0,
              get: function() {
                return i.BUILDER_KEYS;
              }
            }),
            Object.defineProperty(r, "DEPRECATED_KEYS", {
              enumerable: !0,
              get: function() {
                return i.DEPRECATED_KEYS;
              }
            }),
            Object.defineProperty(r, "PLACEHOLDERS", {
              enumerable: !0,
              get: function() {
                return s.PLACEHOLDERS;
              }
            }),
            Object.defineProperty(r, "PLACEHOLDERS_ALIAS", {
              enumerable: !0,
              get: function() {
                return s.PLACEHOLDERS_ALIAS;
              }
            }),
            Object.defineProperty(r, "PLACEHOLDERS_FLIPPED_ALIAS", {
              enumerable: !0,
              get: function() {
                return s.PLACEHOLDERS_FLIPPED_ALIAS;
              }
            }),
            (r.TYPES = void 0),
            e("./core"),
            e("./es2015"),
            e("./flow"),
            e("./jsx"),
            e("./misc"),
            e("./experimental"),
            e("./typescript");
          var i = e("./utils"),
            s = e("./placeholders");
          (0, n().default)(i.VISITOR_KEYS),
            (0, n().default)(i.ALIAS_KEYS),
            (0, n().default)(i.FLIPPED_ALIAS_KEYS),
            (0, n().default)(i.NODE_FIELDS),
            (0, n().default)(i.BUILDER_KEYS),
            (0, n().default)(i.DEPRECATED_KEYS),
            (0, n().default)(s.PLACEHOLDERS_ALIAS),
            (0, n().default)(s.PLACEHOLDERS_FLIPPED_ALIAS);
          const a = Object.keys(i.VISITOR_KEYS)
            .concat(Object.keys(i.FLIPPED_ALIAS_KEYS))
            .concat(Object.keys(i.DEPRECATED_KEYS));
          r.TYPES = a;
        },
        {
          "./core": 90,
          "./es2015": 91,
          "./experimental": 92,
          "./flow": 93,
          "./jsx": 95,
          "./misc": 96,
          "./placeholders": 97,
          "./typescript": 98,
          "./utils": 99,
          "to-fast-properties": 316
        }
      ],
      95: [
        function(e, t, r) {
          "use strict";
          var n = (function(e) {
            if (e && e.__esModule) return e;
            var t = {};
            if (null != e)
              for (var r in e)
                if (Object.prototype.hasOwnProperty.call(e, r)) {
                  var n =
                    Object.defineProperty && Object.getOwnPropertyDescriptor
                      ? Object.getOwnPropertyDescriptor(e, r)
                      : {};
                  n.get || n.set
                    ? Object.defineProperty(t, r, n)
                    : (t[r] = e[r]);
                }
            return (t.default = e), t;
          })(e("./utils"));
          (0, n.default)("JSXAttribute", {
            visitor: ["name", "value"],
            aliases: ["JSX", "Immutable"],
            fields: {
              name: {
                validate: (0, n.assertNodeType)(
                  "JSXIdentifier",
                  "JSXNamespacedName"
                )
              },
              value: {
                optional: !0,
                validate: (0, n.assertNodeType)(
                  "JSXElement",
                  "JSXFragment",
                  "StringLiteral",
                  "JSXExpressionContainer"
                )
              }
            }
          }),
            (0, n.default)("JSXClosingElement", {
              visitor: ["name"],
              aliases: ["JSX", "Immutable"],
              fields: {
                name: {
                  validate: (0, n.assertNodeType)(
                    "JSXIdentifier",
                    "JSXMemberExpression"
                  )
                }
              }
            }),
            (0, n.default)("JSXElement", {
              builder: [
                "openingElement",
                "closingElement",
                "children",
                "selfClosing"
              ],
              visitor: ["openingElement", "children", "closingElement"],
              aliases: ["JSX", "Immutable", "Expression"],
              fields: {
                openingElement: {
                  validate: (0, n.assertNodeType)("JSXOpeningElement")
                },
                closingElement: {
                  optional: !0,
                  validate: (0, n.assertNodeType)("JSXClosingElement")
                },
                children: {
                  validate: (0, n.chain)(
                    (0, n.assertValueType)("array"),
                    (0, n.assertEach)(
                      (0, n.assertNodeType)(
                        "JSXText",
                        "JSXExpressionContainer",
                        "JSXSpreadChild",
                        "JSXElement",
                        "JSXFragment"
                      )
                    )
                  )
                }
              }
            }),
            (0, n.default)("JSXEmptyExpression", { aliases: ["JSX"] }),
            (0, n.default)("JSXExpressionContainer", {
              visitor: ["expression"],
              aliases: ["JSX", "Immutable"],
              fields: {
                expression: {
                  validate: (0, n.assertNodeType)(
                    "Expression",
                    "JSXEmptyExpression"
                  )
                }
              }
            }),
            (0, n.default)("JSXSpreadChild", {
              visitor: ["expression"],
              aliases: ["JSX", "Immutable"],
              fields: {
                expression: { validate: (0, n.assertNodeType)("Expression") }
              }
            }),
            (0, n.default)("JSXIdentifier", {
              builder: ["name"],
              aliases: ["JSX"],
              fields: { name: { validate: (0, n.assertValueType)("string") } }
            }),
            (0, n.default)("JSXMemberExpression", {
              visitor: ["object", "property"],
              aliases: ["JSX"],
              fields: {
                object: {
                  validate: (0, n.assertNodeType)(
                    "JSXMemberExpression",
                    "JSXIdentifier"
                  )
                },
                property: { validate: (0, n.assertNodeType)("JSXIdentifier") }
              }
            }),
            (0, n.default)("JSXNamespacedName", {
              visitor: ["namespace", "name"],
              aliases: ["JSX"],
              fields: {
                namespace: { validate: (0, n.assertNodeType)("JSXIdentifier") },
                name: { validate: (0, n.assertNodeType)("JSXIdentifier") }
              }
            }),
            (0, n.default)("JSXOpeningElement", {
              builder: ["name", "attributes", "selfClosing"],
              visitor: ["name", "attributes"],
              aliases: ["JSX", "Immutable"],
              fields: {
                name: {
                  validate: (0, n.assertNodeType)(
                    "JSXIdentifier",
                    "JSXMemberExpression"
                  )
                },
                selfClosing: {
                  default: !1,
                  validate: (0, n.assertValueType)("boolean")
                },
                attributes: {
                  validate: (0, n.chain)(
                    (0, n.assertValueType)("array"),
                    (0, n.assertEach)(
                      (0, n.assertNodeType)(
                        "JSXAttribute",
                        "JSXSpreadAttribute"
                      )
                    )
                  )
                },
                typeParameters: {
                  validate: (0, n.assertNodeType)(
                    "TypeParameterInstantiation",
                    "TSTypeParameterInstantiation"
                  ),
                  optional: !0
                }
              }
            }),
            (0, n.default)("JSXSpreadAttribute", {
              visitor: ["argument"],
              aliases: ["JSX"],
              fields: {
                argument: { validate: (0, n.assertNodeType)("Expression") }
              }
            }),
            (0, n.default)("JSXText", {
              aliases: ["JSX", "Immutable"],
              builder: ["value"],
              fields: { value: { validate: (0, n.assertValueType)("string") } }
            }),
            (0, n.default)("JSXFragment", {
              builder: ["openingFragment", "closingFragment", "children"],
              visitor: ["openingFragment", "children", "closingFragment"],
              aliases: ["JSX", "Immutable", "Expression"],
              fields: {
                openingFragment: {
                  validate: (0, n.assertNodeType)("JSXOpeningFragment")
                },
                closingFragment: {
                  validate: (0, n.assertNodeType)("JSXClosingFragment")
                },
                children: {
                  validate: (0, n.chain)(
                    (0, n.assertValueType)("array"),
                    (0, n.assertEach)(
                      (0, n.assertNodeType)(
                        "JSXText",
                        "JSXExpressionContainer",
                        "JSXSpreadChild",
                        "JSXElement",
                        "JSXFragment"
                      )
                    )
                  )
                }
              }
            }),
            (0, n.default)("JSXOpeningFragment", {
              aliases: ["JSX", "Immutable"]
            }),
            (0, n.default)("JSXClosingFragment", {
              aliases: ["JSX", "Immutable"]
            });
        },
        { "./utils": 99 }
      ],
      96: [
        function(e, t, r) {
          "use strict";
          var n = (function(e) {
              if (e && e.__esModule) return e;
              var t = {};
              if (null != e)
                for (var r in e)
                  if (Object.prototype.hasOwnProperty.call(e, r)) {
                    var n =
                      Object.defineProperty && Object.getOwnPropertyDescriptor
                        ? Object.getOwnPropertyDescriptor(e, r)
                        : {};
                    n.get || n.set
                      ? Object.defineProperty(t, r, n)
                      : (t[r] = e[r]);
                  }
              return (t.default = e), t;
            })(e("./utils")),
            i = e("./placeholders");
          (0, n.default)("Noop", { visitor: [] }),
            (0, n.default)("Placeholder", {
              visitor: [],
              builder: ["expectedNode", "name"],
              fields: {
                name: { validate: (0, n.assertNodeType)("Identifier") },
                expectedNode: {
                  validate: (0, n.assertOneOf)(...i.PLACEHOLDERS)
                }
              }
            });
        },
        { "./placeholders": 97, "./utils": 99 }
      ],
      97: [
        function(e, t, r) {
          "use strict";
          Object.defineProperty(r, "__esModule", { value: !0 }),
            (r.PLACEHOLDERS_FLIPPED_ALIAS = r.PLACEHOLDERS_ALIAS = r.PLACEHOLDERS = void 0);
          var n = e("./utils");
          const i = [
            "Identifier",
            "StringLiteral",
            "Expression",
            "Statement",
            "Declaration",
            "BlockStatement",
            "ClassBody",
            "Pattern"
          ];
          r.PLACEHOLDERS = i;
          const s = {
            Declaration: ["Statement"],
            Pattern: ["PatternLike", "LVal"]
          };
          r.PLACEHOLDERS_ALIAS = s;
          for (const e of i) {
            const t = n.ALIAS_KEYS[e];
            t && t.length && (s[e] = t);
          }
          const a = {};
          (r.PLACEHOLDERS_FLIPPED_ALIAS = a),
            Object.keys(s).forEach(e => {
              s[e].forEach(t => {
                Object.hasOwnProperty.call(a, t) || (a[t] = []), a[t].push(e);
              });
            });
        },
        { "./utils": 99 }
      ],
      98: [
        function(e, t, r) {
          "use strict";
          var n = (function(e) {
              if (e && e.__esModule) return e;
              var t = {};
              if (null != e)
                for (var r in e)
                  if (Object.prototype.hasOwnProperty.call(e, r)) {
                    var n =
                      Object.defineProperty && Object.getOwnPropertyDescriptor
                        ? Object.getOwnPropertyDescriptor(e, r)
                        : {};
                    n.get || n.set
                      ? Object.defineProperty(t, r, n)
                      : (t[r] = e[r]);
                  }
              return (t.default = e), t;
            })(e("./utils")),
            i = e("./core"),
            s = e("./es2015");
          const a = (0, n.assertValueType)("boolean"),
            o = {
              returnType: {
                validate: (0, n.assertNodeType)("TSTypeAnnotation", "Noop"),
                optional: !0
              },
              typeParameters: {
                validate: (0, n.assertNodeType)(
                  "TSTypeParameterDeclaration",
                  "Noop"
                ),
                optional: !0
              }
            };
          (0, n.default)("TSParameterProperty", {
            aliases: ["LVal"],
            visitor: ["parameter"],
            fields: {
              accessibility: {
                validate: (0, n.assertOneOf)("public", "private", "protected"),
                optional: !0
              },
              readonly: {
                validate: (0, n.assertValueType)("boolean"),
                optional: !0
              },
              parameter: {
                validate: (0, n.assertNodeType)(
                  "Identifier",
                  "AssignmentPattern"
                )
              }
            }
          }),
            (0, n.default)("TSDeclareFunction", {
              aliases: ["Statement", "Declaration"],
              visitor: ["id", "typeParameters", "params", "returnType"],
              fields: Object.assign({}, i.functionDeclarationCommon, o)
            }),
            (0, n.default)("TSDeclareMethod", {
              visitor: [
                "decorators",
                "key",
                "typeParameters",
                "params",
                "returnType"
              ],
              fields: Object.assign({}, s.classMethodOrDeclareMethodCommon, o)
            }),
            (0, n.default)("TSQualifiedName", {
              aliases: ["TSEntityName"],
              visitor: ["left", "right"],
              fields: {
                left: (0, n.validateType)("TSEntityName"),
                right: (0, n.validateType)("Identifier")
              }
            });
          const u = {
              typeParameters: (0, n.validateOptionalType)(
                "TSTypeParameterDeclaration"
              ),
              parameters: (0, n.validateArrayOfType)([
                "Identifier",
                "RestElement"
              ]),
              typeAnnotation: (0, n.validateOptionalType)("TSTypeAnnotation")
            },
            l = {
              aliases: ["TSTypeElement"],
              visitor: ["typeParameters", "parameters", "typeAnnotation"],
              fields: u
            };
          (0, n.default)("TSCallSignatureDeclaration", l),
            (0, n.default)("TSConstructSignatureDeclaration", l);
          const c = {
            key: (0, n.validateType)("Expression"),
            computed: (0, n.validate)(a),
            optional: (0, n.validateOptional)(a)
          };
          (0, n.default)("TSPropertySignature", {
            aliases: ["TSTypeElement"],
            visitor: ["key", "typeAnnotation", "initializer"],
            fields: Object.assign({}, c, {
              readonly: (0, n.validateOptional)(a),
              typeAnnotation: (0, n.validateOptionalType)("TSTypeAnnotation"),
              initializer: (0, n.validateOptionalType)("Expression")
            })
          }),
            (0, n.default)("TSMethodSignature", {
              aliases: ["TSTypeElement"],
              visitor: [
                "key",
                "typeParameters",
                "parameters",
                "typeAnnotation"
              ],
              fields: Object.assign({}, u, c)
            }),
            (0, n.default)("TSIndexSignature", {
              aliases: ["TSTypeElement"],
              visitor: ["parameters", "typeAnnotation"],
              fields: {
                readonly: (0, n.validateOptional)(a),
                parameters: (0, n.validateArrayOfType)("Identifier"),
                typeAnnotation: (0, n.validateOptionalType)("TSTypeAnnotation")
              }
            });
          const p = [
            "TSAnyKeyword",
            "TSUnknownKeyword",
            "TSNumberKeyword",
            "TSObjectKeyword",
            "TSBooleanKeyword",
            "TSStringKeyword",
            "TSSymbolKeyword",
            "TSVoidKeyword",
            "TSUndefinedKeyword",
            "TSNullKeyword",
            "TSNeverKeyword"
          ];
          for (const e of p)
            (0, n.default)(e, { aliases: ["TSType"], visitor: [], fields: {} });
          (0, n.default)("TSThisType", {
            aliases: ["TSType"],
            visitor: [],
            fields: {}
          });
          const d = {
            aliases: ["TSType"],
            visitor: ["typeParameters", "parameters", "typeAnnotation"],
            fields: u
          };
          (0, n.default)("TSFunctionType", d),
            (0, n.default)("TSConstructorType", d),
            (0, n.default)("TSTypeReference", {
              aliases: ["TSType"],
              visitor: ["typeName", "typeParameters"],
              fields: {
                typeName: (0, n.validateType)("TSEntityName"),
                typeParameters: (0, n.validateOptionalType)(
                  "TSTypeParameterInstantiation"
                )
              }
            }),
            (0, n.default)("TSTypePredicate", {
              aliases: ["TSType"],
              visitor: ["parameterName", "typeAnnotation"],
              fields: {
                parameterName: (0, n.validateType)([
                  "Identifier",
                  "TSThisType"
                ]),
                typeAnnotation: (0, n.validateType)("TSTypeAnnotation")
              }
            }),
            (0, n.default)("TSTypeQuery", {
              aliases: ["TSType"],
              visitor: ["exprName"],
              fields: {
                exprName: (0, n.validateType)(["TSEntityName", "TSImportType"])
              }
            }),
            (0, n.default)("TSTypeLiteral", {
              aliases: ["TSType"],
              visitor: ["members"],
              fields: { members: (0, n.validateArrayOfType)("TSTypeElement") }
            }),
            (0, n.default)("TSArrayType", {
              aliases: ["TSType"],
              visitor: ["elementType"],
              fields: { elementType: (0, n.validateType)("TSType") }
            }),
            (0, n.default)("TSTupleType", {
              aliases: ["TSType"],
              visitor: ["elementTypes"],
              fields: { elementTypes: (0, n.validateArrayOfType)("TSType") }
            }),
            (0, n.default)("TSOptionalType", {
              aliases: ["TSType"],
              visitor: ["typeAnnotation"],
              fields: { typeAnnotation: (0, n.validateType)("TSType") }
            }),
            (0, n.default)("TSRestType", {
              aliases: ["TSType"],
              visitor: ["typeAnnotation"],
              fields: { typeAnnotation: (0, n.validateType)("TSType") }
            });
          const h = {
            aliases: ["TSType"],
            visitor: ["types"],
            fields: { types: (0, n.validateArrayOfType)("TSType") }
          };
          (0, n.default)("TSUnionType", h),
            (0, n.default)("TSIntersectionType", h),
            (0, n.default)("TSConditionalType", {
              aliases: ["TSType"],
              visitor: ["checkType", "extendsType", "trueType", "falseType"],
              fields: {
                checkType: (0, n.validateType)("TSType"),
                extendsType: (0, n.validateType)("TSType"),
                trueType: (0, n.validateType)("TSType"),
                falseType: (0, n.validateType)("TSType")
              }
            }),
            (0, n.default)("TSInferType", {
              aliases: ["TSType"],
              visitor: ["typeParameter"],
              fields: { typeParameter: (0, n.validateType)("TSTypeParameter") }
            }),
            (0, n.default)("TSParenthesizedType", {
              aliases: ["TSType"],
              visitor: ["typeAnnotation"],
              fields: { typeAnnotation: (0, n.validateType)("TSType") }
            }),
            (0, n.default)("TSTypeOperator", {
              aliases: ["TSType"],
              visitor: ["typeAnnotation"],
              fields: {
                operator: (0, n.validate)((0, n.assertValueType)("string")),
                typeAnnotation: (0, n.validateType)("TSType")
              }
            }),
            (0, n.default)("TSIndexedAccessType", {
              aliases: ["TSType"],
              visitor: ["objectType", "indexType"],
              fields: {
                objectType: (0, n.validateType)("TSType"),
                indexType: (0, n.validateType)("TSType")
              }
            }),
            (0, n.default)("TSMappedType", {
              aliases: ["TSType"],
              visitor: ["typeParameter", "typeAnnotation"],
              fields: {
                readonly: (0, n.validateOptional)(a),
                typeParameter: (0, n.validateType)("TSTypeParameter"),
                optional: (0, n.validateOptional)(a),
                typeAnnotation: (0, n.validateOptionalType)("TSType")
              }
            }),
            (0, n.default)("TSLiteralType", {
              aliases: ["TSType"],
              visitor: ["literal"],
              fields: {
                literal: (0, n.validateType)([
                  "NumericLiteral",
                  "StringLiteral",
                  "BooleanLiteral"
                ])
              }
            }),
            (0, n.default)("TSExpressionWithTypeArguments", {
              aliases: ["TSType"],
              visitor: ["expression", "typeParameters"],
              fields: {
                expression: (0, n.validateType)("TSEntityName"),
                typeParameters: (0, n.validateOptionalType)(
                  "TSTypeParameterInstantiation"
                )
              }
            }),
            (0, n.default)("TSInterfaceDeclaration", {
              aliases: ["Statement", "Declaration"],
              visitor: ["id", "typeParameters", "extends", "body"],
              fields: {
                declare: (0, n.validateOptional)(a),
                id: (0, n.validateType)("Identifier"),
                typeParameters: (0, n.validateOptionalType)(
                  "TSTypeParameterDeclaration"
                ),
                extends: (0, n.validateOptional)(
                  (0, n.arrayOfType)("TSExpressionWithTypeArguments")
                ),
                body: (0, n.validateType)("TSInterfaceBody")
              }
            }),
            (0, n.default)("TSInterfaceBody", {
              visitor: ["body"],
              fields: { body: (0, n.validateArrayOfType)("TSTypeElement") }
            }),
            (0, n.default)("TSTypeAliasDeclaration", {
              aliases: ["Statement", "Declaration"],
              visitor: ["id", "typeParameters", "typeAnnotation"],
              fields: {
                declare: (0, n.validateOptional)(a),
                id: (0, n.validateType)("Identifier"),
                typeParameters: (0, n.validateOptionalType)(
                  "TSTypeParameterDeclaration"
                ),
                typeAnnotation: (0, n.validateType)("TSType")
              }
            }),
            (0, n.default)("TSAsExpression", {
              aliases: ["Expression"],
              visitor: ["expression", "typeAnnotation"],
              fields: {
                expression: (0, n.validateType)("Expression"),
                typeAnnotation: (0, n.validateType)("TSType")
              }
            }),
            (0, n.default)("TSTypeAssertion", {
              aliases: ["Expression"],
              visitor: ["typeAnnotation", "expression"],
              fields: {
                typeAnnotation: (0, n.validateType)("TSType"),
                expression: (0, n.validateType)("Expression")
              }
            }),
            (0, n.default)("TSEnumDeclaration", {
              aliases: ["Statement", "Declaration"],
              visitor: ["id", "members"],
              fields: {
                declare: (0, n.validateOptional)(a),
                const: (0, n.validateOptional)(a),
                id: (0, n.validateType)("Identifier"),
                members: (0, n.validateArrayOfType)("TSEnumMember"),
                initializer: (0, n.validateOptionalType)("Expression")
              }
            }),
            (0, n.default)("TSEnumMember", {
              visitor: ["id", "initializer"],
              fields: {
                id: (0, n.validateType)(["Identifier", "StringLiteral"]),
                initializer: (0, n.validateOptionalType)("Expression")
              }
            }),
            (0, n.default)("TSModuleDeclaration", {
              aliases: ["Statement", "Declaration"],
              visitor: ["id", "body"],
              fields: {
                declare: (0, n.validateOptional)(a),
                global: (0, n.validateOptional)(a),
                id: (0, n.validateType)(["Identifier", "StringLiteral"]),
                body: (0, n.validateType)([
                  "TSModuleBlock",
                  "TSModuleDeclaration"
                ])
              }
            }),
            (0, n.default)("TSModuleBlock", {
              aliases: ["Scopable", "Block", "BlockParent"],
              visitor: ["body"],
              fields: { body: (0, n.validateArrayOfType)("Statement") }
            }),
            (0, n.default)("TSImportType", {
              aliases: ["TSType"],
              visitor: ["argument", "qualifier", "typeParameters"],
              fields: {
                argument: (0, n.validateType)("StringLiteral"),
                qualifier: (0, n.validateOptionalType)("TSEntityName"),
                typeParameters: (0, n.validateOptionalType)(
                  "TSTypeParameterInstantiation"
                )
              }
            }),
            (0, n.default)("TSImportEqualsDeclaration", {
              aliases: ["Statement"],
              visitor: ["id", "moduleReference"],
              fields: {
                isExport: (0, n.validate)(a),
                id: (0, n.validateType)("Identifier"),
                moduleReference: (0, n.validateType)([
                  "TSEntityName",
                  "TSExternalModuleReference"
                ])
              }
            }),
            (0, n.default)("TSExternalModuleReference", {
              visitor: ["expression"],
              fields: { expression: (0, n.validateType)("StringLiteral") }
            }),
            (0, n.default)("TSNonNullExpression", {
              aliases: ["Expression"],
              visitor: ["expression"],
              fields: { expression: (0, n.validateType)("Expression") }
            }),
            (0, n.default)("TSExportAssignment", {
              aliases: ["Statement"],
              visitor: ["expression"],
              fields: { expression: (0, n.validateType)("Expression") }
            }),
            (0, n.default)("TSNamespaceExportDeclaration", {
              aliases: ["Statement"],
              visitor: ["id"],
              fields: { id: (0, n.validateType)("Identifier") }
            }),
            (0, n.default)("TSTypeAnnotation", {
              visitor: ["typeAnnotation"],
              fields: {
                typeAnnotation: { validate: (0, n.assertNodeType)("TSType") }
              }
            }),
            (0, n.default)("TSTypeParameterInstantiation", {
              visitor: ["params"],
              fields: {
                params: {
                  validate: (0, n.chain)(
                    (0, n.assertValueType)("array"),
                    (0, n.assertEach)((0, n.assertNodeType)("TSType"))
                  )
                }
              }
            }),
            (0, n.default)("TSTypeParameterDeclaration", {
              visitor: ["params"],
              fields: {
                params: {
                  validate: (0, n.chain)(
                    (0, n.assertValueType)("array"),
                    (0, n.assertEach)((0, n.assertNodeType)("TSTypeParameter"))
                  )
                }
              }
            }),
            (0, n.default)("TSTypeParameter", {
              visitor: ["constraint", "default"],
              fields: {
                name: { validate: (0, n.assertValueType)("string") },
                constraint: {
                  validate: (0, n.assertNodeType)("TSType"),
                  optional: !0
                },
                default: {
                  validate: (0, n.assertNodeType)("TSType"),
                  optional: !0
                }
              }
            });
        },
        { "./core": 90, "./es2015": 91, "./utils": 99 }
      ],
      99: [
        function(e, t, r) {
          "use strict";
          Object.defineProperty(r, "__esModule", { value: !0 }),
            (r.validate = h),
            (r.typeIs = f),
            (r.validateType = function(e) {
              return h(f(e));
            }),
            (r.validateOptional = function(e) {
              return { validate: e, optional: !0 };
            }),
            (r.validateOptionalType = function(e) {
              return { validate: f(e), optional: !0 };
            }),
            (r.arrayOf = m),
            (r.arrayOfType = y),
            (r.validateArrayOfType = function(e) {
              return h(y(e));
            }),
            (r.assertEach = g),
            (r.assertOneOf = function(...e) {
              function t(t, r, n) {
                if (e.indexOf(n) < 0)
                  throw new TypeError(
                    `Property ${r} expected value to be one of ${JSON.stringify(
                      e
                    )} but got ${JSON.stringify(n)}`
                  );
              }
              return (t.oneOf = e), t;
            }),
            (r.assertNodeType = b),
            (r.assertNodeOrValueType = function(...e) {
              function t(t, r, n) {
                let s = !1;
                for (const t of e)
                  if (d(n) === t || (0, i.default)(t, n)) {
                    s = !0;
                    break;
                  }
                if (!s)
                  throw new TypeError(
                    `Property ${r} of ${
                      t.type
                    } expected node to be of a type ${JSON.stringify(e)} ` +
                      `but instead got ${JSON.stringify(n && n.type)}`
                  );
              }
              return (t.oneOfNodeOrValueTypes = e), t;
            }),
            (r.assertValueType = v),
            (r.assertShape = function(e) {
              function t(t, r, n) {
                const i = [];
                for (const r of Object.keys(e))
                  try {
                    (0, s.validateField)(t, r, n[r], e[r]);
                  } catch (e) {
                    if (e instanceof TypeError) {
                      i.push(e.message);
                      continue;
                    }
                    throw e;
                  }
                if (i.length)
                  throw new TypeError(
                    `Property ${r} of ${
                      t.type
                    } expected to have the following:\n${i.join("\n")}`
                  );
              }
              return (t.shapeOf = e), t;
            }),
            (r.chain = E),
            (r.default = function(e, t = {}) {
              const r = (t.inherits && T[t.inherits]) || {},
                n = t.fields || r.fields || {},
                i = t.visitor || r.visitor || [],
                s = t.aliases || r.aliases || [],
                h = t.builder || r.builder || t.visitor || [];
              t.deprecatedAlias && (p[t.deprecatedAlias] = e);
              for (const e of i.concat(h)) n[e] = n[e] || {};
              for (const e of Object.keys(n)) {
                const t = n[e];
                -1 === h.indexOf(e) && (t.optional = !0),
                  void 0 === t.default
                    ? (t.default = null)
                    : t.validate || (t.validate = v(d(t.default)));
              }
              (a[e] = t.visitor = i),
                (c[e] = t.builder = h),
                (l[e] = t.fields = n),
                (o[e] = t.aliases = s),
                s.forEach(t => {
                  (u[t] = u[t] || []), u[t].push(e);
                }),
                (T[e] = t);
            }),
            (r.DEPRECATED_KEYS = r.BUILDER_KEYS = r.NODE_FIELDS = r.FLIPPED_ALIAS_KEYS = r.ALIAS_KEYS = r.VISITOR_KEYS = void 0);
          var n,
            i =
              (n = e("../validators/is")) && n.__esModule ? n : { default: n },
            s = e("../validators/validate");
          const a = {};
          r.VISITOR_KEYS = a;
          const o = {};
          r.ALIAS_KEYS = o;
          const u = {};
          r.FLIPPED_ALIAS_KEYS = u;
          const l = {};
          r.NODE_FIELDS = l;
          const c = {};
          r.BUILDER_KEYS = c;
          const p = {};
          function d(e) {
            return Array.isArray(e)
              ? "array"
              : null === e
              ? "null"
              : void 0 === e
              ? "undefined"
              : typeof e;
          }
          function h(e) {
            return { validate: e };
          }
          function f(e) {
            return "string" == typeof e ? b(e) : b(...e);
          }
          function m(e) {
            return E(v("array"), g(e));
          }
          function y(e) {
            return m(f(e));
          }
          function g(e) {
            function t(t, r, n) {
              if (Array.isArray(n))
                for (let i = 0; i < n.length; i++) e(t, `${r}[${i}]`, n[i]);
            }
            return (t.each = e), t;
          }
          function b(...e) {
            function t(t, r, n) {
              let s = !1;
              for (const t of e)
                if ((0, i.default)(t, n)) {
                  s = !0;
                  break;
                }
              if (!s)
                throw new TypeError(
                  `Property ${r} of ${
                    t.type
                  } expected node to be of a type ${JSON.stringify(e)} ` +
                    `but instead got ${JSON.stringify(n && n.type)}`
                );
            }
            return (t.oneOfNodeTypes = e), t;
          }
          function v(e) {
            function t(t, r, n) {
              if (!(d(n) === e))
                throw new TypeError(
                  `Property ${r} expected type of ${e} but got ${d(n)}`
                );
            }
            return (t.type = e), t;
          }
          function E(...e) {
            function t(...t) {
              for (const r of e) r(...t);
            }
            return (t.chainOf = e), t;
          }
          r.DEPRECATED_KEYS = p;
          const T = {};
        },
        { "../validators/is": 116, "../validators/validate": 134 }
      ],
      100: [
        function(e, t, r) {
          "use strict";
          Object.defineProperty(r, "__esModule", { value: !0 });
          var n = {
            react: !0,
            assertNode: !0,
            createTypeAnnotationBasedOnTypeof: !0,
            createUnionTypeAnnotation: !0,
            cloneNode: !0,
            clone: !0,
            cloneDeep: !0,
            cloneWithoutLoc: !0,
            addComment: !0,
            addComments: !0,
            inheritInnerComments: !0,
            inheritLeadingComments: !0,
            inheritsComments: !0,
            inheritTrailingComments: !0,
            removeComments: !0,
            ensureBlock: !0,
            toBindingIdentifierName: !0,
            toBlock: !0,
            toComputedKey: !0,
            toExpression: !0,
            toIdentifier: !0,
            toKeyAlias: !0,
            toSequenceExpression: !0,
            toStatement: !0,
            valueToNode: !0,
            appendToMemberExpression: !0,
            inherits: !0,
            prependToMemberExpression: !0,
            removeProperties: !0,
            removePropertiesDeep: !0,
            removeTypeDuplicates: !0,
            getBindingIdentifiers: !0,
            getOuterBindingIdentifiers: !0,
            traverse: !0,
            traverseFast: !0,
            shallowEqual: !0,
            is: !0,
            isBinding: !0,
            isBlockScoped: !0,
            isImmutable: !0,
            isLet: !0,
            isNode: !0,
            isNodesEquivalent: !0,
            isPlaceholderType: !0,
            isReferenced: !0,
            isScope: !0,
            isSpecifierDefault: !0,
            isType: !0,
            isValidES3Identifier: !0,
            isValidIdentifier: !0,
            isVar: !0,
            matchesPattern: !0,
            validate: !0,
            buildMatchMemberExpression: !0
          };
          Object.defineProperty(r, "assertNode", {
            enumerable: !0,
            get: function() {
              return o.default;
            }
          }),
            Object.defineProperty(r, "createTypeAnnotationBasedOnTypeof", {
              enumerable: !0,
              get: function() {
                return l.default;
              }
            }),
            Object.defineProperty(r, "createUnionTypeAnnotation", {
              enumerable: !0,
              get: function() {
                return c.default;
              }
            }),
            Object.defineProperty(r, "cloneNode", {
              enumerable: !0,
              get: function() {
                return d.default;
              }
            }),
            Object.defineProperty(r, "clone", {
              enumerable: !0,
              get: function() {
                return h.default;
              }
            }),
            Object.defineProperty(r, "cloneDeep", {
              enumerable: !0,
              get: function() {
                return f.default;
              }
            }),
            Object.defineProperty(r, "cloneWithoutLoc", {
              enumerable: !0,
              get: function() {
                return m.default;
              }
            }),
            Object.defineProperty(r, "addComment", {
              enumerable: !0,
              get: function() {
                return y.default;
              }
            }),
            Object.defineProperty(r, "addComments", {
              enumerable: !0,
              get: function() {
                return g.default;
              }
            }),
            Object.defineProperty(r, "inheritInnerComments", {
              enumerable: !0,
              get: function() {
                return b.default;
              }
            }),
            Object.defineProperty(r, "inheritLeadingComments", {
              enumerable: !0,
              get: function() {
                return v.default;
              }
            }),
            Object.defineProperty(r, "inheritsComments", {
              enumerable: !0,
              get: function() {
                return E.default;
              }
            }),
            Object.defineProperty(r, "inheritTrailingComments", {
              enumerable: !0,
              get: function() {
                return T.default;
              }
            }),
            Object.defineProperty(r, "removeComments", {
              enumerable: !0,
              get: function() {
                return x.default;
              }
            }),
            Object.defineProperty(r, "ensureBlock", {
              enumerable: !0,
              get: function() {
                return D.default;
              }
            }),
            Object.defineProperty(r, "toBindingIdentifierName", {
              enumerable: !0,
              get: function() {
                return P.default;
              }
            }),
            Object.defineProperty(r, "toBlock", {
              enumerable: !0,
              get: function() {
                return C.default;
              }
            }),
            Object.defineProperty(r, "toComputedKey", {
              enumerable: !0,
              get: function() {
                return w.default;
              }
            }),
            Object.defineProperty(r, "toExpression", {
              enumerable: !0,
              get: function() {
                return F.default;
              }
            }),
            Object.defineProperty(r, "toIdentifier", {
              enumerable: !0,
              get: function() {
                return _.default;
              }
            }),
            Object.defineProperty(r, "toKeyAlias", {
              enumerable: !0,
              get: function() {
                return O.default;
              }
            }),
            Object.defineProperty(r, "toSequenceExpression", {
              enumerable: !0,
              get: function() {
                return k.default;
              }
            }),
            Object.defineProperty(r, "toStatement", {
              enumerable: !0,
              get: function() {
                return I.default;
              }
            }),
            Object.defineProperty(r, "valueToNode", {
              enumerable: !0,
              get: function() {
                return N.default;
              }
            }),
            Object.defineProperty(r, "appendToMemberExpression", {
              enumerable: !0,
              get: function() {
                return B.default;
              }
            }),
            Object.defineProperty(r, "inherits", {
              enumerable: !0,
              get: function() {
                return M.default;
              }
            }),
            Object.defineProperty(r, "prependToMemberExpression", {
              enumerable: !0,
              get: function() {
                return j.default;
              }
            }),
            Object.defineProperty(r, "removeProperties", {
              enumerable: !0,
              get: function() {
                return R.default;
              }
            }),
            Object.defineProperty(r, "removePropertiesDeep", {
              enumerable: !0,
              get: function() {
                return q.default;
              }
            }),
            Object.defineProperty(r, "removeTypeDuplicates", {
              enumerable: !0,
              get: function() {
                return V.default;
              }
            }),
            Object.defineProperty(r, "getBindingIdentifiers", {
              enumerable: !0,
              get: function() {
                return U.default;
              }
            }),
            Object.defineProperty(r, "getOuterBindingIdentifiers", {
              enumerable: !0,
              get: function() {
                return K.default;
              }
            }),
            Object.defineProperty(r, "traverse", {
              enumerable: !0,
              get: function() {
                return G.default;
              }
            }),
            Object.defineProperty(r, "traverseFast", {
              enumerable: !0,
              get: function() {
                return W.default;
              }
            }),
            Object.defineProperty(r, "shallowEqual", {
              enumerable: !0,
              get: function() {
                return J.default;
              }
            }),
            Object.defineProperty(r, "is", {
              enumerable: !0,
              get: function() {
                return X.default;
              }
            }),
            Object.defineProperty(r, "isBinding", {
              enumerable: !0,
              get: function() {
                return $.default;
              }
            }),
            Object.defineProperty(r, "isBlockScoped", {
              enumerable: !0,
              get: function() {
                return H.default;
              }
            }),
            Object.defineProperty(r, "isImmutable", {
              enumerable: !0,
              get: function() {
                return Y.default;
              }
            }),
            Object.defineProperty(r, "isLet", {
              enumerable: !0,
              get: function() {
                return z.default;
              }
            }),
            Object.defineProperty(r, "isNode", {
              enumerable: !0,
              get: function() {
                return Q.default;
              }
            }),
            Object.defineProperty(r, "isNodesEquivalent", {
              enumerable: !0,
              get: function() {
                return Z.default;
              }
            }),
            Object.defineProperty(r, "isPlaceholderType", {
              enumerable: !0,
              get: function() {
                return ee.default;
              }
            }),
            Object.defineProperty(r, "isReferenced", {
              enumerable: !0,
              get: function() {
                return te.default;
              }
            }),
            Object.defineProperty(r, "isScope", {
              enumerable: !0,
              get: function() {
                return re.default;
              }
            }),
            Object.defineProperty(r, "isSpecifierDefault", {
              enumerable: !0,
              get: function() {
                return ne.default;
              }
            }),
            Object.defineProperty(r, "isType", {
              enumerable: !0,
              get: function() {
                return ie.default;
              }
            }),
            Object.defineProperty(r, "isValidES3Identifier", {
              enumerable: !0,
              get: function() {
                return se.default;
              }
            }),
            Object.defineProperty(r, "isValidIdentifier", {
              enumerable: !0,
              get: function() {
                return ae.default;
              }
            }),
            Object.defineProperty(r, "isVar", {
              enumerable: !0,
              get: function() {
                return oe.default;
              }
            }),
            Object.defineProperty(r, "matchesPattern", {
              enumerable: !0,
              get: function() {
                return ue.default;
              }
            }),
            Object.defineProperty(r, "validate", {
              enumerable: !0,
              get: function() {
                return le.default;
              }
            }),
            Object.defineProperty(r, "buildMatchMemberExpression", {
              enumerable: !0,
              get: function() {
                return ce.default;
              }
            }),
            (r.react = void 0);
          var i = de(e("./validators/react/isReactComponent")),
            s = de(e("./validators/react/isCompatTag")),
            a = de(e("./builders/react/buildChildren")),
            o = de(e("./asserts/assertNode")),
            u = e("./asserts/generated");
          Object.keys(u).forEach(function(e) {
            "default" !== e &&
              "__esModule" !== e &&
              (Object.prototype.hasOwnProperty.call(n, e) ||
                Object.defineProperty(r, e, {
                  enumerable: !0,
                  get: function() {
                    return u[e];
                  }
                }));
          });
          var l = de(e("./builders/flow/createTypeAnnotationBasedOnTypeof")),
            c = de(e("./builders/flow/createUnionTypeAnnotation")),
            p = e("./builders/generated");
          Object.keys(p).forEach(function(e) {
            "default" !== e &&
              "__esModule" !== e &&
              (Object.prototype.hasOwnProperty.call(n, e) ||
                Object.defineProperty(r, e, {
                  enumerable: !0,
                  get: function() {
                    return p[e];
                  }
                }));
          });
          var d = de(e("./clone/cloneNode")),
            h = de(e("./clone/clone")),
            f = de(e("./clone/cloneDeep")),
            m = de(e("./clone/cloneWithoutLoc")),
            y = de(e("./comments/addComment")),
            g = de(e("./comments/addComments")),
            b = de(e("./comments/inheritInnerComments")),
            v = de(e("./comments/inheritLeadingComments")),
            E = de(e("./comments/inheritsComments")),
            T = de(e("./comments/inheritTrailingComments")),
            x = de(e("./comments/removeComments")),
            A = e("./constants/generated");
          Object.keys(A).forEach(function(e) {
            "default" !== e &&
              "__esModule" !== e &&
              (Object.prototype.hasOwnProperty.call(n, e) ||
                Object.defineProperty(r, e, {
                  enumerable: !0,
                  get: function() {
                    return A[e];
                  }
                }));
          });
          var S = e("./constants");
          Object.keys(S).forEach(function(e) {
            "default" !== e &&
              "__esModule" !== e &&
              (Object.prototype.hasOwnProperty.call(n, e) ||
                Object.defineProperty(r, e, {
                  enumerable: !0,
                  get: function() {
                    return S[e];
                  }
                }));
          });
          var D = de(e("./converters/ensureBlock")),
            P = de(e("./converters/toBindingIdentifierName")),
            C = de(e("./converters/toBlock")),
            w = de(e("./converters/toComputedKey")),
            F = de(e("./converters/toExpression")),
            _ = de(e("./converters/toIdentifier")),
            O = de(e("./converters/toKeyAlias")),
            k = de(e("./converters/toSequenceExpression")),
            I = de(e("./converters/toStatement")),
            N = de(e("./converters/valueToNode")),
            L = e("./definitions");
          Object.keys(L).forEach(function(e) {
            "default" !== e &&
              "__esModule" !== e &&
              (Object.prototype.hasOwnProperty.call(n, e) ||
                Object.defineProperty(r, e, {
                  enumerable: !0,
                  get: function() {
                    return L[e];
                  }
                }));
          });
          var B = de(e("./modifications/appendToMemberExpression")),
            M = de(e("./modifications/inherits")),
            j = de(e("./modifications/prependToMemberExpression")),
            R = de(e("./modifications/removeProperties")),
            q = de(e("./modifications/removePropertiesDeep")),
            V = de(e("./modifications/flow/removeTypeDuplicates")),
            U = de(e("./retrievers/getBindingIdentifiers")),
            K = de(e("./retrievers/getOuterBindingIdentifiers")),
            G = de(e("./traverse/traverse")),
            W = de(e("./traverse/traverseFast")),
            J = de(e("./utils/shallowEqual")),
            X = de(e("./validators/is")),
            $ = de(e("./validators/isBinding")),
            H = de(e("./validators/isBlockScoped")),
            Y = de(e("./validators/isImmutable")),
            z = de(e("./validators/isLet")),
            Q = de(e("./validators/isNode")),
            Z = de(e("./validators/isNodesEquivalent")),
            ee = de(e("./validators/isPlaceholderType")),
            te = de(e("./validators/isReferenced")),
            re = de(e("./validators/isScope")),
            ne = de(e("./validators/isSpecifierDefault")),
            ie = de(e("./validators/isType")),
            se = de(e("./validators/isValidES3Identifier")),
            ae = de(e("./validators/isValidIdentifier")),
            oe = de(e("./validators/isVar")),
            ue = de(e("./validators/matchesPattern")),
            le = de(e("./validators/validate")),
            ce = de(e("./validators/buildMatchMemberExpression")),
            pe = e("./validators/generated");
          function de(e) {
            return e && e.__esModule ? e : { default: e };
          }
          Object.keys(pe).forEach(function(e) {
            "default" !== e &&
              "__esModule" !== e &&
              (Object.prototype.hasOwnProperty.call(n, e) ||
                Object.defineProperty(r, e, {
                  enumerable: !0,
                  get: function() {
                    return pe[e];
                  }
                }));
          });
          const he = {
            isReactComponent: i.default,
            isCompatTag: s.default,
            buildChildren: a.default
          };
          r.react = he;
        },
        {
          "./asserts/assertNode": 59,
          "./asserts/generated": 60,
          "./builders/flow/createTypeAnnotationBasedOnTypeof": 62,
          "./builders/flow/createUnionTypeAnnotation": 63,
          "./builders/generated": 64,
          "./builders/react/buildChildren": 65,
          "./clone/clone": 66,
          "./clone/cloneDeep": 67,
          "./clone/cloneNode": 68,
          "./clone/cloneWithoutLoc": 69,
          "./comments/addComment": 70,
          "./comments/addComments": 71,
          "./comments/inheritInnerComments": 72,
          "./comments/inheritLeadingComments": 73,
          "./comments/inheritTrailingComments": 74,
          "./comments/inheritsComments": 75,
          "./comments/removeComments": 76,
          "./constants": 78,
          "./constants/generated": 77,
          "./converters/ensureBlock": 79,
          "./converters/toBindingIdentifierName": 81,
          "./converters/toBlock": 82,
          "./converters/toComputedKey": 83,
          "./converters/toExpression": 84,
          "./converters/toIdentifier": 85,
          "./converters/toKeyAlias": 86,
          "./converters/toSequenceExpression": 87,
          "./converters/toStatement": 88,
          "./converters/valueToNode": 89,
          "./definitions": 94,
          "./modifications/appendToMemberExpression": 101,
          "./modifications/flow/removeTypeDuplicates": 102,
          "./modifications/inherits": 103,
          "./modifications/prependToMemberExpression": 104,
          "./modifications/removeProperties": 105,
          "./modifications/removePropertiesDeep": 106,
          "./retrievers/getBindingIdentifiers": 107,
          "./retrievers/getOuterBindingIdentifiers": 108,
          "./traverse/traverse": 109,
          "./traverse/traverseFast": 110,
          "./utils/shallowEqual": 113,
          "./validators/buildMatchMemberExpression": 114,
          "./validators/generated": 115,
          "./validators/is": 116,
          "./validators/isBinding": 117,
          "./validators/isBlockScoped": 118,
          "./validators/isImmutable": 119,
          "./validators/isLet": 120,
          "./validators/isNode": 121,
          "./validators/isNodesEquivalent": 122,
          "./validators/isPlaceholderType": 123,
          "./validators/isReferenced": 124,
          "./validators/isScope": 125,
          "./validators/isSpecifierDefault": 126,
          "./validators/isType": 127,
          "./validators/isValidES3Identifier": 128,
          "./validators/isValidIdentifier": 129,
          "./validators/isVar": 130,
          "./validators/matchesPattern": 131,
          "./validators/react/isCompatTag": 132,
          "./validators/react/isReactComponent": 133,
          "./validators/validate": 134
        }
      ],
      101: [
        function(e, t, r) {
          "use strict";
          Object.defineProperty(r, "__esModule", { value: !0 }),
            (r.default = function(e, t, r = !1) {
              return (
                (e.object = (0, n.memberExpression)(
                  e.object,
                  e.property,
                  e.computed
                )),
                (e.property = t),
                (e.computed = !!r),
                e
              );
            });
          var n = e("../builders/generated");
        },
        { "../builders/generated": 64 }
      ],
      102: [
        function(e, t, r) {
          "use strict";
          Object.defineProperty(r, "__esModule", { value: !0 }),
            (r.default = function e(t) {
              const r = {};
              const i = {};
              const s = [];
              const a = [];
              for (let o = 0; o < t.length; o++) {
                const u = t[o];
                if (u && !(a.indexOf(u) >= 0)) {
                  if ((0, n.isAnyTypeAnnotation)(u)) return [u];
                  if ((0, n.isFlowBaseAnnotation)(u)) i[u.type] = u;
                  else if ((0, n.isUnionTypeAnnotation)(u))
                    s.indexOf(u.types) < 0 &&
                      ((t = t.concat(u.types)), s.push(u.types));
                  else if ((0, n.isGenericTypeAnnotation)(u)) {
                    const t = u.id.name;
                    if (r[t]) {
                      let n = r[t];
                      n.typeParameters
                        ? u.typeParameters &&
                          (n.typeParameters.params = e(
                            n.typeParameters.params.concat(
                              u.typeParameters.params
                            )
                          ))
                        : (n = u.typeParameters);
                    } else r[t] = u;
                  } else a.push(u);
                }
              }
              for (const e of Object.keys(i)) a.push(i[e]);
              for (const e of Object.keys(r)) a.push(r[e]);
              return a;
            });
          var n = e("../../validators/generated");
        },
        { "../../validators/generated": 115 }
      ],
      103: [
        function(e, t, r) {
          "use strict";
          Object.defineProperty(r, "__esModule", { value: !0 }),
            (r.default = function(e, t) {
              if (!e || !t) return e;
              for (const r of i.INHERIT_KEYS.optional)
                null == e[r] && (e[r] = t[r]);
              for (const r of Object.keys(t))
                "_" === r[0] && "__clone" !== r && (e[r] = t[r]);
              for (const r of i.INHERIT_KEYS.force) e[r] = t[r];
              return (0, s.default)(e, t), e;
            });
          var n,
            i = e("../constants"),
            s =
              (n = e("../comments/inheritsComments")) && n.__esModule
                ? n
                : { default: n };
        },
        { "../comments/inheritsComments": 75, "../constants": 78 }
      ],
      104: [
        function(e, t, r) {
          "use strict";
          Object.defineProperty(r, "__esModule", { value: !0 }),
            (r.default = function(e, t) {
              return (e.object = (0, n.memberExpression)(t, e.object)), e;
            });
          var n = e("../builders/generated");
        },
        { "../builders/generated": 64 }
      ],
      105: [
        function(e, t, r) {
          "use strict";
          Object.defineProperty(r, "__esModule", { value: !0 }),
            (r.default = function(e, t = {}) {
              const r = t.preserveComments ? i : s;
              for (const t of r) null != e[t] && (e[t] = void 0);
              for (const t of Object.keys(e))
                "_" === t[0] && null != e[t] && (e[t] = void 0);
              const n = Object.getOwnPropertySymbols(e);
              for (const t of n) e[t] = null;
            });
          var n = e("../constants");
          const i = ["tokens", "start", "end", "loc", "raw", "rawValue"],
            s = n.COMMENT_KEYS.concat(["comments"]).concat(i);
        },
        { "../constants": 78 }
      ],
      106: [
        function(e, t, r) {
          "use strict";
          Object.defineProperty(r, "__esModule", { value: !0 }),
            (r.default = function(e, t) {
              return (0, n.default)(e, i.default, t), e;
            });
          var n = s(e("../traverse/traverseFast")),
            i = s(e("./removeProperties"));
          function s(e) {
            return e && e.__esModule ? e : { default: e };
          }
        },
        { "../traverse/traverseFast": 110, "./removeProperties": 105 }
      ],
      107: [
        function(e, t, r) {
          "use strict";
          Object.defineProperty(r, "__esModule", { value: !0 }),
            (r.default = i);
          var n = e("../validators/generated");
          function i(e, t, r) {
            let s = [].concat(e);
            const a = Object.create(null);
            for (; s.length; ) {
              const e = s.shift();
              if (!e) continue;
              const o = i.keys[e.type];
              if ((0, n.isIdentifier)(e))
                if (t) {
                  (a[e.name] = a[e.name] || []).push(e);
                } else a[e.name] = e;
              else if ((0, n.isExportDeclaration)(e))
                (0, n.isDeclaration)(e.declaration) && s.push(e.declaration);
              else {
                if (r) {
                  if ((0, n.isFunctionDeclaration)(e)) {
                    s.push(e.id);
                    continue;
                  }
                  if ((0, n.isFunctionExpression)(e)) continue;
                }
                if (o)
                  for (let t = 0; t < o.length; t++) {
                    const r = o[t];
                    e[r] && (s = s.concat(e[r]));
                  }
              }
            }
            return a;
          }
          i.keys = {
            DeclareClass: ["id"],
            DeclareFunction: ["id"],
            DeclareModule: ["id"],
            DeclareVariable: ["id"],
            DeclareInterface: ["id"],
            DeclareTypeAlias: ["id"],
            DeclareOpaqueType: ["id"],
            InterfaceDeclaration: ["id"],
            TypeAlias: ["id"],
            OpaqueType: ["id"],
            CatchClause: ["param"],
            LabeledStatement: ["label"],
            UnaryExpression: ["argument"],
            AssignmentExpression: ["left"],
            ImportSpecifier: ["local"],
            ImportNamespaceSpecifier: ["local"],
            ImportDefaultSpecifier: ["local"],
            ImportDeclaration: ["specifiers"],
            ExportSpecifier: ["exported"],
            ExportNamespaceSpecifier: ["exported"],
            ExportDefaultSpecifier: ["exported"],
            FunctionDeclaration: ["id", "params"],
            FunctionExpression: ["id", "params"],
            ArrowFunctionExpression: ["params"],
            ObjectMethod: ["params"],
            ClassMethod: ["params"],
            ForInStatement: ["left"],
            ForOfStatement: ["left"],
            ClassDeclaration: ["id"],
            ClassExpression: ["id"],
            RestElement: ["argument"],
            UpdateExpression: ["argument"],
            ObjectProperty: ["value"],
            AssignmentPattern: ["left"],
            ArrayPattern: ["elements"],
            ObjectPattern: ["properties"],
            VariableDeclaration: ["declarations"],
            VariableDeclarator: ["id"]
          };
        },
        { "../validators/generated": 115 }
      ],
      108: [
        function(e, t, r) {
          "use strict";
          Object.defineProperty(r, "__esModule", { value: !0 }),
            (r.default = function(e, t) {
              return (0, i.default)(e, t, !0);
            });
          var n,
            i =
              (n = e("./getBindingIdentifiers")) && n.__esModule
                ? n
                : { default: n };
        },
        { "./getBindingIdentifiers": 107 }
      ],
      109: [
        function(e, t, r) {
          "use strict";
          Object.defineProperty(r, "__esModule", { value: !0 }),
            (r.default = function(e, t, r) {
              "function" == typeof t && (t = { enter: t });
              const { enter: i, exit: s } = t;
              !(function e(t, r, i, s, a) {
                const o = n.VISITOR_KEYS[t.type];
                if (!o) return;
                r && r(t, a, s);
                for (const n of o) {
                  const o = t[n];
                  if (Array.isArray(o))
                    for (let u = 0; u < o.length; u++) {
                      const l = o[u];
                      l &&
                        (a.push({ node: t, key: n, index: u }),
                        e(l, r, i, s, a),
                        a.pop());
                    }
                  else
                    o &&
                      (a.push({ node: t, key: n }), e(o, r, i, s, a), a.pop());
                }
                i && i(t, a, s);
              })(e, i, s, r, []);
            });
          var n = e("../definitions");
        },
        { "../definitions": 94 }
      ],
      110: [
        function(e, t, r) {
          "use strict";
          Object.defineProperty(r, "__esModule", { value: !0 }),
            (r.default = function e(t, r, i) {
              if (!t) return;
              const s = n.VISITOR_KEYS[t.type];
              if (!s) return;
              i = i || {};
              r(t, i);
              for (const n of s) {
                const s = t[n];
                if (Array.isArray(s)) for (const t of s) e(t, r, i);
                else e(s, r, i);
              }
            });
          var n = e("../definitions");
        },
        { "../definitions": 94 }
      ],
      111: [
        function(e, t, r) {
          "use strict";
          function n() {
            const t =
              (r = e("lodash/uniq")) && r.__esModule ? r : { default: r };
            var r;
            return (
              (n = function() {
                return t;
              }),
              t
            );
          }
          Object.defineProperty(r, "__esModule", { value: !0 }),
            (r.default = function(e, t, r) {
              t &&
                r &&
                (t[e] = (0, n().default)(
                  [].concat(t[e], r[e]).filter(Boolean)
                ));
            });
        },
        { "lodash/uniq": 301 }
      ],
      112: [
        function(e, t, r) {
          "use strict";
          Object.defineProperty(r, "__esModule", { value: !0 }),
            (r.default = function(e, t) {
              const r = e.value.split(/\r\n|\n|\r/);
              let i = 0;
              for (let e = 0; e < r.length; e++)
                r[e].match(/[^ \t]/) && (i = e);
              let s = "";
              for (let e = 0; e < r.length; e++) {
                const t = r[e],
                  n = 0 === e,
                  a = e === r.length - 1,
                  o = e === i;
                let u = t.replace(/\t/g, " ");
                n || (u = u.replace(/^[ ]+/, "")),
                  a || (u = u.replace(/[ ]+$/, "")),
                  u && (o || (u += " "), (s += u));
              }
              s && t.push((0, n.stringLiteral)(s));
            });
          var n = e("../../builders/generated");
        },
        { "../../builders/generated": 64 }
      ],
      113: [
        function(e, t, r) {
          "use strict";
          Object.defineProperty(r, "__esModule", { value: !0 }),
            (r.default = function(e, t) {
              const r = Object.keys(t);
              for (const n of r) if (e[n] !== t[n]) return !1;
              return !0;
            });
        },
        {}
      ],
      114: [
        function(e, t, r) {
          "use strict";
          Object.defineProperty(r, "__esModule", { value: !0 }),
            (r.default = function(e, t) {
              const r = e.split(".");
              return e => (0, i.default)(e, r, t);
            });
          var n,
            i =
              (n = e("./matchesPattern")) && n.__esModule ? n : { default: n };
        },
        { "./matchesPattern": 131 }
      ],
      115: [
        function(e, t, r) {
          "use strict";
          Object.defineProperty(r, "__esModule", { value: !0 }),
            (r.isArrayExpression = function(e, t) {
              if (!e) return !1;
              if ("ArrayExpression" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isAssignmentExpression = function(e, t) {
              if (!e) return !1;
              if ("AssignmentExpression" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isBinaryExpression = function(e, t) {
              if (!e) return !1;
              if ("BinaryExpression" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isInterpreterDirective = function(e, t) {
              if (!e) return !1;
              if ("InterpreterDirective" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isDirective = function(e, t) {
              if (!e) return !1;
              if ("Directive" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isDirectiveLiteral = function(e, t) {
              if (!e) return !1;
              if ("DirectiveLiteral" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isBlockStatement = function(e, t) {
              if (!e) return !1;
              if ("BlockStatement" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isBreakStatement = function(e, t) {
              if (!e) return !1;
              if ("BreakStatement" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isCallExpression = function(e, t) {
              if (!e) return !1;
              if ("CallExpression" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isCatchClause = function(e, t) {
              if (!e) return !1;
              if ("CatchClause" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isConditionalExpression = function(e, t) {
              if (!e) return !1;
              if ("ConditionalExpression" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isContinueStatement = function(e, t) {
              if (!e) return !1;
              if ("ContinueStatement" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isDebuggerStatement = function(e, t) {
              if (!e) return !1;
              if ("DebuggerStatement" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isDoWhileStatement = function(e, t) {
              if (!e) return !1;
              if ("DoWhileStatement" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isEmptyStatement = function(e, t) {
              if (!e) return !1;
              if ("EmptyStatement" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isExpressionStatement = function(e, t) {
              if (!e) return !1;
              if ("ExpressionStatement" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isFile = function(e, t) {
              if (!e) return !1;
              if ("File" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isForInStatement = function(e, t) {
              if (!e) return !1;
              if ("ForInStatement" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isForStatement = function(e, t) {
              if (!e) return !1;
              if ("ForStatement" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isFunctionDeclaration = function(e, t) {
              if (!e) return !1;
              if ("FunctionDeclaration" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isFunctionExpression = function(e, t) {
              if (!e) return !1;
              if ("FunctionExpression" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isIdentifier = function(e, t) {
              if (!e) return !1;
              if ("Identifier" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isIfStatement = function(e, t) {
              if (!e) return !1;
              if ("IfStatement" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isLabeledStatement = function(e, t) {
              if (!e) return !1;
              if ("LabeledStatement" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isStringLiteral = function(e, t) {
              if (!e) return !1;
              if ("StringLiteral" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isNumericLiteral = function(e, t) {
              if (!e) return !1;
              if ("NumericLiteral" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isNullLiteral = function(e, t) {
              if (!e) return !1;
              if ("NullLiteral" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isBooleanLiteral = function(e, t) {
              if (!e) return !1;
              if ("BooleanLiteral" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isRegExpLiteral = function(e, t) {
              if (!e) return !1;
              if ("RegExpLiteral" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isLogicalExpression = function(e, t) {
              if (!e) return !1;
              if ("LogicalExpression" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isMemberExpression = function(e, t) {
              if (!e) return !1;
              if ("MemberExpression" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isNewExpression = function(e, t) {
              if (!e) return !1;
              if ("NewExpression" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isProgram = function(e, t) {
              if (!e) return !1;
              if ("Program" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isObjectExpression = function(e, t) {
              if (!e) return !1;
              if ("ObjectExpression" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isObjectMethod = function(e, t) {
              if (!e) return !1;
              if ("ObjectMethod" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isObjectProperty = function(e, t) {
              if (!e) return !1;
              if ("ObjectProperty" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isRestElement = function(e, t) {
              if (!e) return !1;
              if ("RestElement" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isReturnStatement = function(e, t) {
              if (!e) return !1;
              if ("ReturnStatement" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isSequenceExpression = function(e, t) {
              if (!e) return !1;
              if ("SequenceExpression" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isParenthesizedExpression = function(e, t) {
              if (!e) return !1;
              if ("ParenthesizedExpression" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isSwitchCase = function(e, t) {
              if (!e) return !1;
              if ("SwitchCase" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isSwitchStatement = function(e, t) {
              if (!e) return !1;
              if ("SwitchStatement" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isThisExpression = function(e, t) {
              if (!e) return !1;
              if ("ThisExpression" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isThrowStatement = function(e, t) {
              if (!e) return !1;
              if ("ThrowStatement" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isTryStatement = function(e, t) {
              if (!e) return !1;
              if ("TryStatement" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isUnaryExpression = function(e, t) {
              if (!e) return !1;
              if ("UnaryExpression" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isUpdateExpression = function(e, t) {
              if (!e) return !1;
              if ("UpdateExpression" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isVariableDeclaration = function(e, t) {
              if (!e) return !1;
              if ("VariableDeclaration" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isVariableDeclarator = function(e, t) {
              if (!e) return !1;
              if ("VariableDeclarator" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isWhileStatement = function(e, t) {
              if (!e) return !1;
              if ("WhileStatement" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isWithStatement = function(e, t) {
              if (!e) return !1;
              if ("WithStatement" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isAssignmentPattern = function(e, t) {
              if (!e) return !1;
              if ("AssignmentPattern" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isArrayPattern = function(e, t) {
              if (!e) return !1;
              if ("ArrayPattern" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isArrowFunctionExpression = function(e, t) {
              if (!e) return !1;
              if ("ArrowFunctionExpression" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isClassBody = function(e, t) {
              if (!e) return !1;
              if ("ClassBody" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isClassDeclaration = function(e, t) {
              if (!e) return !1;
              if ("ClassDeclaration" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isClassExpression = function(e, t) {
              if (!e) return !1;
              if ("ClassExpression" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isExportAllDeclaration = function(e, t) {
              if (!e) return !1;
              if ("ExportAllDeclaration" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isExportDefaultDeclaration = function(e, t) {
              if (!e) return !1;
              if ("ExportDefaultDeclaration" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isExportNamedDeclaration = function(e, t) {
              if (!e) return !1;
              if ("ExportNamedDeclaration" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isExportSpecifier = function(e, t) {
              if (!e) return !1;
              if ("ExportSpecifier" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isForOfStatement = function(e, t) {
              if (!e) return !1;
              if ("ForOfStatement" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isImportDeclaration = function(e, t) {
              if (!e) return !1;
              if ("ImportDeclaration" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isImportDefaultSpecifier = function(e, t) {
              if (!e) return !1;
              if ("ImportDefaultSpecifier" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isImportNamespaceSpecifier = function(e, t) {
              if (!e) return !1;
              if ("ImportNamespaceSpecifier" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isImportSpecifier = function(e, t) {
              if (!e) return !1;
              if ("ImportSpecifier" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isMetaProperty = function(e, t) {
              if (!e) return !1;
              if ("MetaProperty" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isClassMethod = function(e, t) {
              if (!e) return !1;
              if ("ClassMethod" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isObjectPattern = function(e, t) {
              if (!e) return !1;
              if ("ObjectPattern" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isSpreadElement = function(e, t) {
              if (!e) return !1;
              if ("SpreadElement" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isSuper = function(e, t) {
              if (!e) return !1;
              if ("Super" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isTaggedTemplateExpression = function(e, t) {
              if (!e) return !1;
              if ("TaggedTemplateExpression" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isTemplateElement = function(e, t) {
              if (!e) return !1;
              if ("TemplateElement" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isTemplateLiteral = function(e, t) {
              if (!e) return !1;
              if ("TemplateLiteral" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isYieldExpression = function(e, t) {
              if (!e) return !1;
              if ("YieldExpression" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isAnyTypeAnnotation = function(e, t) {
              if (!e) return !1;
              if ("AnyTypeAnnotation" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isArrayTypeAnnotation = function(e, t) {
              if (!e) return !1;
              if ("ArrayTypeAnnotation" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isBooleanTypeAnnotation = function(e, t) {
              if (!e) return !1;
              if ("BooleanTypeAnnotation" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isBooleanLiteralTypeAnnotation = function(e, t) {
              if (!e) return !1;
              if ("BooleanLiteralTypeAnnotation" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isNullLiteralTypeAnnotation = function(e, t) {
              if (!e) return !1;
              if ("NullLiteralTypeAnnotation" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isClassImplements = function(e, t) {
              if (!e) return !1;
              if ("ClassImplements" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isDeclareClass = function(e, t) {
              if (!e) return !1;
              if ("DeclareClass" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isDeclareFunction = function(e, t) {
              if (!e) return !1;
              if ("DeclareFunction" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isDeclareInterface = function(e, t) {
              if (!e) return !1;
              if ("DeclareInterface" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isDeclareModule = function(e, t) {
              if (!e) return !1;
              if ("DeclareModule" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isDeclareModuleExports = function(e, t) {
              if (!e) return !1;
              if ("DeclareModuleExports" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isDeclareTypeAlias = function(e, t) {
              if (!e) return !1;
              if ("DeclareTypeAlias" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isDeclareOpaqueType = function(e, t) {
              if (!e) return !1;
              if ("DeclareOpaqueType" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isDeclareVariable = function(e, t) {
              if (!e) return !1;
              if ("DeclareVariable" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isDeclareExportDeclaration = function(e, t) {
              if (!e) return !1;
              if ("DeclareExportDeclaration" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isDeclareExportAllDeclaration = function(e, t) {
              if (!e) return !1;
              if ("DeclareExportAllDeclaration" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isDeclaredPredicate = function(e, t) {
              if (!e) return !1;
              if ("DeclaredPredicate" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isExistsTypeAnnotation = function(e, t) {
              if (!e) return !1;
              if ("ExistsTypeAnnotation" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isFunctionTypeAnnotation = function(e, t) {
              if (!e) return !1;
              if ("FunctionTypeAnnotation" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isFunctionTypeParam = function(e, t) {
              if (!e) return !1;
              if ("FunctionTypeParam" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isGenericTypeAnnotation = function(e, t) {
              if (!e) return !1;
              if ("GenericTypeAnnotation" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isInferredPredicate = function(e, t) {
              if (!e) return !1;
              if ("InferredPredicate" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isInterfaceExtends = function(e, t) {
              if (!e) return !1;
              if ("InterfaceExtends" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isInterfaceDeclaration = function(e, t) {
              if (!e) return !1;
              if ("InterfaceDeclaration" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isInterfaceTypeAnnotation = function(e, t) {
              if (!e) return !1;
              if ("InterfaceTypeAnnotation" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isIntersectionTypeAnnotation = function(e, t) {
              if (!e) return !1;
              if ("IntersectionTypeAnnotation" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isMixedTypeAnnotation = function(e, t) {
              if (!e) return !1;
              if ("MixedTypeAnnotation" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isEmptyTypeAnnotation = function(e, t) {
              if (!e) return !1;
              if ("EmptyTypeAnnotation" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isNullableTypeAnnotation = function(e, t) {
              if (!e) return !1;
              if ("NullableTypeAnnotation" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isNumberLiteralTypeAnnotation = function(e, t) {
              if (!e) return !1;
              if ("NumberLiteralTypeAnnotation" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isNumberTypeAnnotation = function(e, t) {
              if (!e) return !1;
              if ("NumberTypeAnnotation" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isObjectTypeAnnotation = function(e, t) {
              if (!e) return !1;
              if ("ObjectTypeAnnotation" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isObjectTypeInternalSlot = function(e, t) {
              if (!e) return !1;
              if ("ObjectTypeInternalSlot" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isObjectTypeCallProperty = function(e, t) {
              if (!e) return !1;
              if ("ObjectTypeCallProperty" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isObjectTypeIndexer = function(e, t) {
              if (!e) return !1;
              if ("ObjectTypeIndexer" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isObjectTypeProperty = function(e, t) {
              if (!e) return !1;
              if ("ObjectTypeProperty" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isObjectTypeSpreadProperty = function(e, t) {
              if (!e) return !1;
              if ("ObjectTypeSpreadProperty" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isOpaqueType = function(e, t) {
              if (!e) return !1;
              if ("OpaqueType" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isQualifiedTypeIdentifier = function(e, t) {
              if (!e) return !1;
              if ("QualifiedTypeIdentifier" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isStringLiteralTypeAnnotation = function(e, t) {
              if (!e) return !1;
              if ("StringLiteralTypeAnnotation" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isStringTypeAnnotation = function(e, t) {
              if (!e) return !1;
              if ("StringTypeAnnotation" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isThisTypeAnnotation = function(e, t) {
              if (!e) return !1;
              if ("ThisTypeAnnotation" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isTupleTypeAnnotation = function(e, t) {
              if (!e) return !1;
              if ("TupleTypeAnnotation" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isTypeofTypeAnnotation = function(e, t) {
              if (!e) return !1;
              if ("TypeofTypeAnnotation" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isTypeAlias = function(e, t) {
              if (!e) return !1;
              if ("TypeAlias" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isTypeAnnotation = function(e, t) {
              if (!e) return !1;
              if ("TypeAnnotation" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isTypeCastExpression = function(e, t) {
              if (!e) return !1;
              if ("TypeCastExpression" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isTypeParameter = function(e, t) {
              if (!e) return !1;
              if ("TypeParameter" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isTypeParameterDeclaration = function(e, t) {
              if (!e) return !1;
              if ("TypeParameterDeclaration" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isTypeParameterInstantiation = function(e, t) {
              if (!e) return !1;
              if ("TypeParameterInstantiation" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isUnionTypeAnnotation = function(e, t) {
              if (!e) return !1;
              if ("UnionTypeAnnotation" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isVariance = function(e, t) {
              if (!e) return !1;
              if ("Variance" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isVoidTypeAnnotation = function(e, t) {
              if (!e) return !1;
              if ("VoidTypeAnnotation" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isJSXAttribute = function(e, t) {
              if (!e) return !1;
              if ("JSXAttribute" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isJSXClosingElement = function(e, t) {
              if (!e) return !1;
              if ("JSXClosingElement" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isJSXElement = function(e, t) {
              if (!e) return !1;
              if ("JSXElement" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isJSXEmptyExpression = function(e, t) {
              if (!e) return !1;
              if ("JSXEmptyExpression" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isJSXExpressionContainer = function(e, t) {
              if (!e) return !1;
              if ("JSXExpressionContainer" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isJSXSpreadChild = function(e, t) {
              if (!e) return !1;
              if ("JSXSpreadChild" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isJSXIdentifier = function(e, t) {
              if (!e) return !1;
              if ("JSXIdentifier" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isJSXMemberExpression = function(e, t) {
              if (!e) return !1;
              if ("JSXMemberExpression" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isJSXNamespacedName = function(e, t) {
              if (!e) return !1;
              if ("JSXNamespacedName" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isJSXOpeningElement = function(e, t) {
              if (!e) return !1;
              if ("JSXOpeningElement" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isJSXSpreadAttribute = function(e, t) {
              if (!e) return !1;
              if ("JSXSpreadAttribute" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isJSXText = function(e, t) {
              if (!e) return !1;
              if ("JSXText" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isJSXFragment = function(e, t) {
              if (!e) return !1;
              if ("JSXFragment" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isJSXOpeningFragment = function(e, t) {
              if (!e) return !1;
              if ("JSXOpeningFragment" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isJSXClosingFragment = function(e, t) {
              if (!e) return !1;
              if ("JSXClosingFragment" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isNoop = function(e, t) {
              if (!e) return !1;
              if ("Noop" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isPlaceholder = function(e, t) {
              if (!e) return !1;
              if ("Placeholder" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isArgumentPlaceholder = function(e, t) {
              if (!e) return !1;
              if ("ArgumentPlaceholder" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isAwaitExpression = function(e, t) {
              if (!e) return !1;
              if ("AwaitExpression" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isBindExpression = function(e, t) {
              if (!e) return !1;
              if ("BindExpression" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isClassProperty = function(e, t) {
              if (!e) return !1;
              if ("ClassProperty" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isOptionalMemberExpression = function(e, t) {
              if (!e) return !1;
              if ("OptionalMemberExpression" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isPipelineTopicExpression = function(e, t) {
              if (!e) return !1;
              if ("PipelineTopicExpression" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isPipelineBareFunction = function(e, t) {
              if (!e) return !1;
              if ("PipelineBareFunction" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isPipelinePrimaryTopicReference = function(e, t) {
              if (!e) return !1;
              if ("PipelinePrimaryTopicReference" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isOptionalCallExpression = function(e, t) {
              if (!e) return !1;
              if ("OptionalCallExpression" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isClassPrivateProperty = function(e, t) {
              if (!e) return !1;
              if ("ClassPrivateProperty" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isClassPrivateMethod = function(e, t) {
              if (!e) return !1;
              if ("ClassPrivateMethod" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isImport = function(e, t) {
              if (!e) return !1;
              if ("Import" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isDecorator = function(e, t) {
              if (!e) return !1;
              if ("Decorator" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isDoExpression = function(e, t) {
              if (!e) return !1;
              if ("DoExpression" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isExportDefaultSpecifier = function(e, t) {
              if (!e) return !1;
              if ("ExportDefaultSpecifier" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isExportNamespaceSpecifier = function(e, t) {
              if (!e) return !1;
              if ("ExportNamespaceSpecifier" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isPrivateName = function(e, t) {
              if (!e) return !1;
              if ("PrivateName" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isBigIntLiteral = function(e, t) {
              if (!e) return !1;
              if ("BigIntLiteral" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isTSParameterProperty = function(e, t) {
              if (!e) return !1;
              if ("TSParameterProperty" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isTSDeclareFunction = function(e, t) {
              if (!e) return !1;
              if ("TSDeclareFunction" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isTSDeclareMethod = function(e, t) {
              if (!e) return !1;
              if ("TSDeclareMethod" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isTSQualifiedName = function(e, t) {
              if (!e) return !1;
              if ("TSQualifiedName" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isTSCallSignatureDeclaration = function(e, t) {
              if (!e) return !1;
              if ("TSCallSignatureDeclaration" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isTSConstructSignatureDeclaration = function(e, t) {
              if (!e) return !1;
              if ("TSConstructSignatureDeclaration" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isTSPropertySignature = function(e, t) {
              if (!e) return !1;
              if ("TSPropertySignature" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isTSMethodSignature = function(e, t) {
              if (!e) return !1;
              if ("TSMethodSignature" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isTSIndexSignature = function(e, t) {
              if (!e) return !1;
              if ("TSIndexSignature" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isTSAnyKeyword = function(e, t) {
              if (!e) return !1;
              if ("TSAnyKeyword" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isTSUnknownKeyword = function(e, t) {
              if (!e) return !1;
              if ("TSUnknownKeyword" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isTSNumberKeyword = function(e, t) {
              if (!e) return !1;
              if ("TSNumberKeyword" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isTSObjectKeyword = function(e, t) {
              if (!e) return !1;
              if ("TSObjectKeyword" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isTSBooleanKeyword = function(e, t) {
              if (!e) return !1;
              if ("TSBooleanKeyword" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isTSStringKeyword = function(e, t) {
              if (!e) return !1;
              if ("TSStringKeyword" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isTSSymbolKeyword = function(e, t) {
              if (!e) return !1;
              if ("TSSymbolKeyword" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isTSVoidKeyword = function(e, t) {
              if (!e) return !1;
              if ("TSVoidKeyword" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isTSUndefinedKeyword = function(e, t) {
              if (!e) return !1;
              if ("TSUndefinedKeyword" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isTSNullKeyword = function(e, t) {
              if (!e) return !1;
              if ("TSNullKeyword" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isTSNeverKeyword = function(e, t) {
              if (!e) return !1;
              if ("TSNeverKeyword" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isTSThisType = function(e, t) {
              if (!e) return !1;
              if ("TSThisType" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isTSFunctionType = function(e, t) {
              if (!e) return !1;
              if ("TSFunctionType" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isTSConstructorType = function(e, t) {
              if (!e) return !1;
              if ("TSConstructorType" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isTSTypeReference = function(e, t) {
              if (!e) return !1;
              if ("TSTypeReference" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isTSTypePredicate = function(e, t) {
              if (!e) return !1;
              if ("TSTypePredicate" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isTSTypeQuery = function(e, t) {
              if (!e) return !1;
              if ("TSTypeQuery" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isTSTypeLiteral = function(e, t) {
              if (!e) return !1;
              if ("TSTypeLiteral" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isTSArrayType = function(e, t) {
              if (!e) return !1;
              if ("TSArrayType" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isTSTupleType = function(e, t) {
              if (!e) return !1;
              if ("TSTupleType" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isTSOptionalType = function(e, t) {
              if (!e) return !1;
              if ("TSOptionalType" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isTSRestType = function(e, t) {
              if (!e) return !1;
              if ("TSRestType" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isTSUnionType = function(e, t) {
              if (!e) return !1;
              if ("TSUnionType" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isTSIntersectionType = function(e, t) {
              if (!e) return !1;
              if ("TSIntersectionType" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isTSConditionalType = function(e, t) {
              if (!e) return !1;
              if ("TSConditionalType" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isTSInferType = function(e, t) {
              if (!e) return !1;
              if ("TSInferType" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isTSParenthesizedType = function(e, t) {
              if (!e) return !1;
              if ("TSParenthesizedType" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isTSTypeOperator = function(e, t) {
              if (!e) return !1;
              if ("TSTypeOperator" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isTSIndexedAccessType = function(e, t) {
              if (!e) return !1;
              if ("TSIndexedAccessType" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isTSMappedType = function(e, t) {
              if (!e) return !1;
              if ("TSMappedType" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isTSLiteralType = function(e, t) {
              if (!e) return !1;
              if ("TSLiteralType" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isTSExpressionWithTypeArguments = function(e, t) {
              if (!e) return !1;
              if ("TSExpressionWithTypeArguments" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isTSInterfaceDeclaration = function(e, t) {
              if (!e) return !1;
              if ("TSInterfaceDeclaration" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isTSInterfaceBody = function(e, t) {
              if (!e) return !1;
              if ("TSInterfaceBody" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isTSTypeAliasDeclaration = function(e, t) {
              if (!e) return !1;
              if ("TSTypeAliasDeclaration" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isTSAsExpression = function(e, t) {
              if (!e) return !1;
              if ("TSAsExpression" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isTSTypeAssertion = function(e, t) {
              if (!e) return !1;
              if ("TSTypeAssertion" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isTSEnumDeclaration = function(e, t) {
              if (!e) return !1;
              if ("TSEnumDeclaration" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isTSEnumMember = function(e, t) {
              if (!e) return !1;
              if ("TSEnumMember" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isTSModuleDeclaration = function(e, t) {
              if (!e) return !1;
              if ("TSModuleDeclaration" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isTSModuleBlock = function(e, t) {
              if (!e) return !1;
              if ("TSModuleBlock" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isTSImportType = function(e, t) {
              if (!e) return !1;
              if ("TSImportType" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isTSImportEqualsDeclaration = function(e, t) {
              if (!e) return !1;
              if ("TSImportEqualsDeclaration" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isTSExternalModuleReference = function(e, t) {
              if (!e) return !1;
              if ("TSExternalModuleReference" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isTSNonNullExpression = function(e, t) {
              if (!e) return !1;
              if ("TSNonNullExpression" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isTSExportAssignment = function(e, t) {
              if (!e) return !1;
              if ("TSExportAssignment" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isTSNamespaceExportDeclaration = function(e, t) {
              if (!e) return !1;
              if ("TSNamespaceExportDeclaration" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isTSTypeAnnotation = function(e, t) {
              if (!e) return !1;
              if ("TSTypeAnnotation" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isTSTypeParameterInstantiation = function(e, t) {
              if (!e) return !1;
              if ("TSTypeParameterInstantiation" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isTSTypeParameterDeclaration = function(e, t) {
              if (!e) return !1;
              if ("TSTypeParameterDeclaration" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isTSTypeParameter = function(e, t) {
              if (!e) return !1;
              if ("TSTypeParameter" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isExpression = function(e, t) {
              if (!e) return !1;
              const r = e.type;
              if (
                "Expression" === r ||
                "ArrayExpression" === r ||
                "AssignmentExpression" === r ||
                "BinaryExpression" === r ||
                "CallExpression" === r ||
                "ConditionalExpression" === r ||
                "FunctionExpression" === r ||
                "Identifier" === r ||
                "StringLiteral" === r ||
                "NumericLiteral" === r ||
                "NullLiteral" === r ||
                "BooleanLiteral" === r ||
                "RegExpLiteral" === r ||
                "LogicalExpression" === r ||
                "MemberExpression" === r ||
                "NewExpression" === r ||
                "ObjectExpression" === r ||
                "SequenceExpression" === r ||
                "ParenthesizedExpression" === r ||
                "ThisExpression" === r ||
                "UnaryExpression" === r ||
                "UpdateExpression" === r ||
                "ArrowFunctionExpression" === r ||
                "ClassExpression" === r ||
                "MetaProperty" === r ||
                "Super" === r ||
                "TaggedTemplateExpression" === r ||
                "TemplateLiteral" === r ||
                "YieldExpression" === r ||
                "TypeCastExpression" === r ||
                "JSXElement" === r ||
                "JSXFragment" === r ||
                "AwaitExpression" === r ||
                "BindExpression" === r ||
                "OptionalMemberExpression" === r ||
                "PipelinePrimaryTopicReference" === r ||
                "OptionalCallExpression" === r ||
                "Import" === r ||
                "DoExpression" === r ||
                "BigIntLiteral" === r ||
                "TSAsExpression" === r ||
                "TSTypeAssertion" === r ||
                "TSNonNullExpression" === r ||
                ("Placeholder" === r &&
                  ("Expression" === e.expectedNode ||
                    "Identifier" === e.expectedNode ||
                    "StringLiteral" === e.expectedNode))
              )
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isBinary = function(e, t) {
              if (!e) return !1;
              const r = e.type;
              if (
                "Binary" === r ||
                "BinaryExpression" === r ||
                "LogicalExpression" === r
              )
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isScopable = function(e, t) {
              if (!e) return !1;
              const r = e.type;
              if (
                "Scopable" === r ||
                "BlockStatement" === r ||
                "CatchClause" === r ||
                "DoWhileStatement" === r ||
                "ForInStatement" === r ||
                "ForStatement" === r ||
                "FunctionDeclaration" === r ||
                "FunctionExpression" === r ||
                "Program" === r ||
                "ObjectMethod" === r ||
                "SwitchStatement" === r ||
                "WhileStatement" === r ||
                "ArrowFunctionExpression" === r ||
                "ClassDeclaration" === r ||
                "ClassExpression" === r ||
                "ForOfStatement" === r ||
                "ClassMethod" === r ||
                "ClassPrivateMethod" === r ||
                "TSModuleBlock" === r ||
                ("Placeholder" === r && "BlockStatement" === e.expectedNode)
              )
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isBlockParent = function(e, t) {
              if (!e) return !1;
              const r = e.type;
              if (
                "BlockParent" === r ||
                "BlockStatement" === r ||
                "CatchClause" === r ||
                "DoWhileStatement" === r ||
                "ForInStatement" === r ||
                "ForStatement" === r ||
                "FunctionDeclaration" === r ||
                "FunctionExpression" === r ||
                "Program" === r ||
                "ObjectMethod" === r ||
                "SwitchStatement" === r ||
                "WhileStatement" === r ||
                "ArrowFunctionExpression" === r ||
                "ForOfStatement" === r ||
                "ClassMethod" === r ||
                "ClassPrivateMethod" === r ||
                "TSModuleBlock" === r ||
                ("Placeholder" === r && "BlockStatement" === e.expectedNode)
              )
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isBlock = function(e, t) {
              if (!e) return !1;
              const r = e.type;
              if (
                "Block" === r ||
                "BlockStatement" === r ||
                "Program" === r ||
                "TSModuleBlock" === r ||
                ("Placeholder" === r && "BlockStatement" === e.expectedNode)
              )
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isStatement = function(e, t) {
              if (!e) return !1;
              const r = e.type;
              if (
                "Statement" === r ||
                "BlockStatement" === r ||
                "BreakStatement" === r ||
                "ContinueStatement" === r ||
                "DebuggerStatement" === r ||
                "DoWhileStatement" === r ||
                "EmptyStatement" === r ||
                "ExpressionStatement" === r ||
                "ForInStatement" === r ||
                "ForStatement" === r ||
                "FunctionDeclaration" === r ||
                "IfStatement" === r ||
                "LabeledStatement" === r ||
                "ReturnStatement" === r ||
                "SwitchStatement" === r ||
                "ThrowStatement" === r ||
                "TryStatement" === r ||
                "VariableDeclaration" === r ||
                "WhileStatement" === r ||
                "WithStatement" === r ||
                "ClassDeclaration" === r ||
                "ExportAllDeclaration" === r ||
                "ExportDefaultDeclaration" === r ||
                "ExportNamedDeclaration" === r ||
                "ForOfStatement" === r ||
                "ImportDeclaration" === r ||
                "DeclareClass" === r ||
                "DeclareFunction" === r ||
                "DeclareInterface" === r ||
                "DeclareModule" === r ||
                "DeclareModuleExports" === r ||
                "DeclareTypeAlias" === r ||
                "DeclareOpaqueType" === r ||
                "DeclareVariable" === r ||
                "DeclareExportDeclaration" === r ||
                "DeclareExportAllDeclaration" === r ||
                "InterfaceDeclaration" === r ||
                "OpaqueType" === r ||
                "TypeAlias" === r ||
                "TSDeclareFunction" === r ||
                "TSInterfaceDeclaration" === r ||
                "TSTypeAliasDeclaration" === r ||
                "TSEnumDeclaration" === r ||
                "TSModuleDeclaration" === r ||
                "TSImportEqualsDeclaration" === r ||
                "TSExportAssignment" === r ||
                "TSNamespaceExportDeclaration" === r ||
                ("Placeholder" === r &&
                  ("Statement" === e.expectedNode ||
                    "Declaration" === e.expectedNode ||
                    "BlockStatement" === e.expectedNode))
              )
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isTerminatorless = function(e, t) {
              if (!e) return !1;
              const r = e.type;
              if (
                "Terminatorless" === r ||
                "BreakStatement" === r ||
                "ContinueStatement" === r ||
                "ReturnStatement" === r ||
                "ThrowStatement" === r ||
                "YieldExpression" === r ||
                "AwaitExpression" === r
              )
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isCompletionStatement = function(e, t) {
              if (!e) return !1;
              const r = e.type;
              if (
                "CompletionStatement" === r ||
                "BreakStatement" === r ||
                "ContinueStatement" === r ||
                "ReturnStatement" === r ||
                "ThrowStatement" === r
              )
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isConditional = function(e, t) {
              if (!e) return !1;
              const r = e.type;
              if (
                "Conditional" === r ||
                "ConditionalExpression" === r ||
                "IfStatement" === r
              )
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isLoop = function(e, t) {
              if (!e) return !1;
              const r = e.type;
              if (
                "Loop" === r ||
                "DoWhileStatement" === r ||
                "ForInStatement" === r ||
                "ForStatement" === r ||
                "WhileStatement" === r ||
                "ForOfStatement" === r
              )
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isWhile = function(e, t) {
              if (!e) return !1;
              const r = e.type;
              if (
                "While" === r ||
                "DoWhileStatement" === r ||
                "WhileStatement" === r
              )
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isExpressionWrapper = function(e, t) {
              if (!e) return !1;
              const r = e.type;
              if (
                "ExpressionWrapper" === r ||
                "ExpressionStatement" === r ||
                "ParenthesizedExpression" === r ||
                "TypeCastExpression" === r
              )
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isFor = function(e, t) {
              if (!e) return !1;
              const r = e.type;
              if (
                "For" === r ||
                "ForInStatement" === r ||
                "ForStatement" === r ||
                "ForOfStatement" === r
              )
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isForXStatement = function(e, t) {
              if (!e) return !1;
              const r = e.type;
              if (
                "ForXStatement" === r ||
                "ForInStatement" === r ||
                "ForOfStatement" === r
              )
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isFunction = function(e, t) {
              if (!e) return !1;
              const r = e.type;
              if (
                "Function" === r ||
                "FunctionDeclaration" === r ||
                "FunctionExpression" === r ||
                "ObjectMethod" === r ||
                "ArrowFunctionExpression" === r ||
                "ClassMethod" === r ||
                "ClassPrivateMethod" === r
              )
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isFunctionParent = function(e, t) {
              if (!e) return !1;
              const r = e.type;
              if (
                "FunctionParent" === r ||
                "FunctionDeclaration" === r ||
                "FunctionExpression" === r ||
                "ObjectMethod" === r ||
                "ArrowFunctionExpression" === r ||
                "ClassMethod" === r ||
                "ClassPrivateMethod" === r
              )
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isPureish = function(e, t) {
              if (!e) return !1;
              const r = e.type;
              if (
                "Pureish" === r ||
                "FunctionDeclaration" === r ||
                "FunctionExpression" === r ||
                "StringLiteral" === r ||
                "NumericLiteral" === r ||
                "NullLiteral" === r ||
                "BooleanLiteral" === r ||
                "ArrowFunctionExpression" === r ||
                "ClassDeclaration" === r ||
                "ClassExpression" === r ||
                "BigIntLiteral" === r ||
                ("Placeholder" === r && "StringLiteral" === e.expectedNode)
              )
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isDeclaration = function(e, t) {
              if (!e) return !1;
              const r = e.type;
              if (
                "Declaration" === r ||
                "FunctionDeclaration" === r ||
                "VariableDeclaration" === r ||
                "ClassDeclaration" === r ||
                "ExportAllDeclaration" === r ||
                "ExportDefaultDeclaration" === r ||
                "ExportNamedDeclaration" === r ||
                "ImportDeclaration" === r ||
                "DeclareClass" === r ||
                "DeclareFunction" === r ||
                "DeclareInterface" === r ||
                "DeclareModule" === r ||
                "DeclareModuleExports" === r ||
                "DeclareTypeAlias" === r ||
                "DeclareOpaqueType" === r ||
                "DeclareVariable" === r ||
                "DeclareExportDeclaration" === r ||
                "DeclareExportAllDeclaration" === r ||
                "InterfaceDeclaration" === r ||
                "OpaqueType" === r ||
                "TypeAlias" === r ||
                "TSDeclareFunction" === r ||
                "TSInterfaceDeclaration" === r ||
                "TSTypeAliasDeclaration" === r ||
                "TSEnumDeclaration" === r ||
                "TSModuleDeclaration" === r ||
                ("Placeholder" === r && "Declaration" === e.expectedNode)
              )
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isPatternLike = function(e, t) {
              if (!e) return !1;
              const r = e.type;
              if (
                "PatternLike" === r ||
                "Identifier" === r ||
                "RestElement" === r ||
                "AssignmentPattern" === r ||
                "ArrayPattern" === r ||
                "ObjectPattern" === r ||
                ("Placeholder" === r &&
                  ("Pattern" === e.expectedNode ||
                    "Identifier" === e.expectedNode))
              )
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isLVal = function(e, t) {
              if (!e) return !1;
              const r = e.type;
              if (
                "LVal" === r ||
                "Identifier" === r ||
                "MemberExpression" === r ||
                "RestElement" === r ||
                "AssignmentPattern" === r ||
                "ArrayPattern" === r ||
                "ObjectPattern" === r ||
                "TSParameterProperty" === r ||
                ("Placeholder" === r &&
                  ("Pattern" === e.expectedNode ||
                    "Identifier" === e.expectedNode))
              )
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isTSEntityName = function(e, t) {
              if (!e) return !1;
              const r = e.type;
              if (
                "TSEntityName" === r ||
                "Identifier" === r ||
                "TSQualifiedName" === r ||
                ("Placeholder" === r && "Identifier" === e.expectedNode)
              )
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isLiteral = function(e, t) {
              if (!e) return !1;
              const r = e.type;
              if (
                "Literal" === r ||
                "StringLiteral" === r ||
                "NumericLiteral" === r ||
                "NullLiteral" === r ||
                "BooleanLiteral" === r ||
                "RegExpLiteral" === r ||
                "TemplateLiteral" === r ||
                "BigIntLiteral" === r ||
                ("Placeholder" === r && "StringLiteral" === e.expectedNode)
              )
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isImmutable = function(e, t) {
              if (!e) return !1;
              const r = e.type;
              if (
                "Immutable" === r ||
                "StringLiteral" === r ||
                "NumericLiteral" === r ||
                "NullLiteral" === r ||
                "BooleanLiteral" === r ||
                "JSXAttribute" === r ||
                "JSXClosingElement" === r ||
                "JSXElement" === r ||
                "JSXExpressionContainer" === r ||
                "JSXSpreadChild" === r ||
                "JSXOpeningElement" === r ||
                "JSXText" === r ||
                "JSXFragment" === r ||
                "JSXOpeningFragment" === r ||
                "JSXClosingFragment" === r ||
                "BigIntLiteral" === r ||
                ("Placeholder" === r && "StringLiteral" === e.expectedNode)
              )
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isUserWhitespacable = function(e, t) {
              if (!e) return !1;
              const r = e.type;
              if (
                "UserWhitespacable" === r ||
                "ObjectMethod" === r ||
                "ObjectProperty" === r ||
                "ObjectTypeInternalSlot" === r ||
                "ObjectTypeCallProperty" === r ||
                "ObjectTypeIndexer" === r ||
                "ObjectTypeProperty" === r ||
                "ObjectTypeSpreadProperty" === r
              )
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isMethod = function(e, t) {
              if (!e) return !1;
              const r = e.type;
              if (
                "Method" === r ||
                "ObjectMethod" === r ||
                "ClassMethod" === r ||
                "ClassPrivateMethod" === r
              )
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isObjectMember = function(e, t) {
              if (!e) return !1;
              const r = e.type;
              if (
                "ObjectMember" === r ||
                "ObjectMethod" === r ||
                "ObjectProperty" === r
              )
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isProperty = function(e, t) {
              if (!e) return !1;
              const r = e.type;
              if (
                "Property" === r ||
                "ObjectProperty" === r ||
                "ClassProperty" === r ||
                "ClassPrivateProperty" === r
              )
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isUnaryLike = function(e, t) {
              if (!e) return !1;
              const r = e.type;
              if (
                "UnaryLike" === r ||
                "UnaryExpression" === r ||
                "SpreadElement" === r
              )
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isPattern = function(e, t) {
              if (!e) return !1;
              const r = e.type;
              if (
                "Pattern" === r ||
                "AssignmentPattern" === r ||
                "ArrayPattern" === r ||
                "ObjectPattern" === r ||
                ("Placeholder" === r && "Pattern" === e.expectedNode)
              )
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isClass = function(e, t) {
              if (!e) return !1;
              const r = e.type;
              if (
                "Class" === r ||
                "ClassDeclaration" === r ||
                "ClassExpression" === r
              )
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isModuleDeclaration = function(e, t) {
              if (!e) return !1;
              const r = e.type;
              if (
                "ModuleDeclaration" === r ||
                "ExportAllDeclaration" === r ||
                "ExportDefaultDeclaration" === r ||
                "ExportNamedDeclaration" === r ||
                "ImportDeclaration" === r
              )
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isExportDeclaration = function(e, t) {
              if (!e) return !1;
              const r = e.type;
              if (
                "ExportDeclaration" === r ||
                "ExportAllDeclaration" === r ||
                "ExportDefaultDeclaration" === r ||
                "ExportNamedDeclaration" === r
              )
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isModuleSpecifier = function(e, t) {
              if (!e) return !1;
              const r = e.type;
              if (
                "ModuleSpecifier" === r ||
                "ExportSpecifier" === r ||
                "ImportDefaultSpecifier" === r ||
                "ImportNamespaceSpecifier" === r ||
                "ImportSpecifier" === r ||
                "ExportDefaultSpecifier" === r ||
                "ExportNamespaceSpecifier" === r
              )
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isFlow = function(e, t) {
              if (!e) return !1;
              const r = e.type;
              if (
                "Flow" === r ||
                "AnyTypeAnnotation" === r ||
                "ArrayTypeAnnotation" === r ||
                "BooleanTypeAnnotation" === r ||
                "BooleanLiteralTypeAnnotation" === r ||
                "NullLiteralTypeAnnotation" === r ||
                "ClassImplements" === r ||
                "DeclareClass" === r ||
                "DeclareFunction" === r ||
                "DeclareInterface" === r ||
                "DeclareModule" === r ||
                "DeclareModuleExports" === r ||
                "DeclareTypeAlias" === r ||
                "DeclareOpaqueType" === r ||
                "DeclareVariable" === r ||
                "DeclareExportDeclaration" === r ||
                "DeclareExportAllDeclaration" === r ||
                "DeclaredPredicate" === r ||
                "ExistsTypeAnnotation" === r ||
                "FunctionTypeAnnotation" === r ||
                "FunctionTypeParam" === r ||
                "GenericTypeAnnotation" === r ||
                "InferredPredicate" === r ||
                "InterfaceExtends" === r ||
                "InterfaceDeclaration" === r ||
                "InterfaceTypeAnnotation" === r ||
                "IntersectionTypeAnnotation" === r ||
                "MixedTypeAnnotation" === r ||
                "EmptyTypeAnnotation" === r ||
                "NullableTypeAnnotation" === r ||
                "NumberLiteralTypeAnnotation" === r ||
                "NumberTypeAnnotation" === r ||
                "ObjectTypeAnnotation" === r ||
                "ObjectTypeInternalSlot" === r ||
                "ObjectTypeCallProperty" === r ||
                "ObjectTypeIndexer" === r ||
                "ObjectTypeProperty" === r ||
                "ObjectTypeSpreadProperty" === r ||
                "OpaqueType" === r ||
                "QualifiedTypeIdentifier" === r ||
                "StringLiteralTypeAnnotation" === r ||
                "StringTypeAnnotation" === r ||
                "ThisTypeAnnotation" === r ||
                "TupleTypeAnnotation" === r ||
                "TypeofTypeAnnotation" === r ||
                "TypeAlias" === r ||
                "TypeAnnotation" === r ||
                "TypeCastExpression" === r ||
                "TypeParameter" === r ||
                "TypeParameterDeclaration" === r ||
                "TypeParameterInstantiation" === r ||
                "UnionTypeAnnotation" === r ||
                "Variance" === r ||
                "VoidTypeAnnotation" === r
              )
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isFlowType = function(e, t) {
              if (!e) return !1;
              const r = e.type;
              if (
                "FlowType" === r ||
                "AnyTypeAnnotation" === r ||
                "ArrayTypeAnnotation" === r ||
                "BooleanTypeAnnotation" === r ||
                "BooleanLiteralTypeAnnotation" === r ||
                "NullLiteralTypeAnnotation" === r ||
                "ExistsTypeAnnotation" === r ||
                "FunctionTypeAnnotation" === r ||
                "GenericTypeAnnotation" === r ||
                "InterfaceTypeAnnotation" === r ||
                "IntersectionTypeAnnotation" === r ||
                "MixedTypeAnnotation" === r ||
                "EmptyTypeAnnotation" === r ||
                "NullableTypeAnnotation" === r ||
                "NumberLiteralTypeAnnotation" === r ||
                "NumberTypeAnnotation" === r ||
                "ObjectTypeAnnotation" === r ||
                "StringLiteralTypeAnnotation" === r ||
                "StringTypeAnnotation" === r ||
                "ThisTypeAnnotation" === r ||
                "TupleTypeAnnotation" === r ||
                "TypeofTypeAnnotation" === r ||
                "UnionTypeAnnotation" === r ||
                "VoidTypeAnnotation" === r
              )
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isFlowBaseAnnotation = function(e, t) {
              if (!e) return !1;
              const r = e.type;
              if (
                "FlowBaseAnnotation" === r ||
                "AnyTypeAnnotation" === r ||
                "BooleanTypeAnnotation" === r ||
                "NullLiteralTypeAnnotation" === r ||
                "MixedTypeAnnotation" === r ||
                "EmptyTypeAnnotation" === r ||
                "NumberTypeAnnotation" === r ||
                "StringTypeAnnotation" === r ||
                "ThisTypeAnnotation" === r ||
                "VoidTypeAnnotation" === r
              )
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isFlowDeclaration = function(e, t) {
              if (!e) return !1;
              const r = e.type;
              if (
                "FlowDeclaration" === r ||
                "DeclareClass" === r ||
                "DeclareFunction" === r ||
                "DeclareInterface" === r ||
                "DeclareModule" === r ||
                "DeclareModuleExports" === r ||
                "DeclareTypeAlias" === r ||
                "DeclareOpaqueType" === r ||
                "DeclareVariable" === r ||
                "DeclareExportDeclaration" === r ||
                "DeclareExportAllDeclaration" === r ||
                "InterfaceDeclaration" === r ||
                "OpaqueType" === r ||
                "TypeAlias" === r
              )
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isFlowPredicate = function(e, t) {
              if (!e) return !1;
              const r = e.type;
              if (
                "FlowPredicate" === r ||
                "DeclaredPredicate" === r ||
                "InferredPredicate" === r
              )
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isJSX = function(e, t) {
              if (!e) return !1;
              const r = e.type;
              if (
                "JSX" === r ||
                "JSXAttribute" === r ||
                "JSXClosingElement" === r ||
                "JSXElement" === r ||
                "JSXEmptyExpression" === r ||
                "JSXExpressionContainer" === r ||
                "JSXSpreadChild" === r ||
                "JSXIdentifier" === r ||
                "JSXMemberExpression" === r ||
                "JSXNamespacedName" === r ||
                "JSXOpeningElement" === r ||
                "JSXSpreadAttribute" === r ||
                "JSXText" === r ||
                "JSXFragment" === r ||
                "JSXOpeningFragment" === r ||
                "JSXClosingFragment" === r
              )
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isPrivate = function(e, t) {
              if (!e) return !1;
              const r = e.type;
              if (
                "Private" === r ||
                "ClassPrivateProperty" === r ||
                "ClassPrivateMethod" === r ||
                "PrivateName" === r
              )
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isTSTypeElement = function(e, t) {
              if (!e) return !1;
              const r = e.type;
              if (
                "TSTypeElement" === r ||
                "TSCallSignatureDeclaration" === r ||
                "TSConstructSignatureDeclaration" === r ||
                "TSPropertySignature" === r ||
                "TSMethodSignature" === r ||
                "TSIndexSignature" === r
              )
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isTSType = function(e, t) {
              if (!e) return !1;
              const r = e.type;
              if (
                "TSType" === r ||
                "TSAnyKeyword" === r ||
                "TSUnknownKeyword" === r ||
                "TSNumberKeyword" === r ||
                "TSObjectKeyword" === r ||
                "TSBooleanKeyword" === r ||
                "TSStringKeyword" === r ||
                "TSSymbolKeyword" === r ||
                "TSVoidKeyword" === r ||
                "TSUndefinedKeyword" === r ||
                "TSNullKeyword" === r ||
                "TSNeverKeyword" === r ||
                "TSThisType" === r ||
                "TSFunctionType" === r ||
                "TSConstructorType" === r ||
                "TSTypeReference" === r ||
                "TSTypePredicate" === r ||
                "TSTypeQuery" === r ||
                "TSTypeLiteral" === r ||
                "TSArrayType" === r ||
                "TSTupleType" === r ||
                "TSOptionalType" === r ||
                "TSRestType" === r ||
                "TSUnionType" === r ||
                "TSIntersectionType" === r ||
                "TSConditionalType" === r ||
                "TSInferType" === r ||
                "TSParenthesizedType" === r ||
                "TSTypeOperator" === r ||
                "TSIndexedAccessType" === r ||
                "TSMappedType" === r ||
                "TSLiteralType" === r ||
                "TSExpressionWithTypeArguments" === r ||
                "TSImportType" === r
              )
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isNumberLiteral = function(e, t) {
              if (
                (console.trace(
                  "The node type NumberLiteral has been renamed to NumericLiteral"
                ),
                !e)
              )
                return !1;
              if ("NumberLiteral" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isRegexLiteral = function(e, t) {
              if (
                (console.trace(
                  "The node type RegexLiteral has been renamed to RegExpLiteral"
                ),
                !e)
              )
                return !1;
              if ("RegexLiteral" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isRestProperty = function(e, t) {
              if (
                (console.trace(
                  "The node type RestProperty has been renamed to RestElement"
                ),
                !e)
              )
                return !1;
              if ("RestProperty" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            }),
            (r.isSpreadProperty = function(e, t) {
              if (
                (console.trace(
                  "The node type SpreadProperty has been renamed to SpreadElement"
                ),
                !e)
              )
                return !1;
              if ("SpreadProperty" === e.type)
                return void 0 === t || (0, i.default)(e, t);
              return !1;
            });
          var n,
            i =
              (n = e("../../utils/shallowEqual")) && n.__esModule
                ? n
                : { default: n };
        },
        { "../../utils/shallowEqual": 113 }
      ],
      116: [
        function(e, t, r) {
          "use strict";
          Object.defineProperty(r, "__esModule", { value: !0 }),
            (r.default = function(e, t, r) {
              if (!t) return !1;
              if (!(0, i.default)(t.type, e))
                return (
                  !r &&
                  "Placeholder" === t.type &&
                  e in a.FLIPPED_ALIAS_KEYS &&
                  (0, s.default)(t.expectedNode, e)
                );
              return void 0 === r || (0, n.default)(t, r);
            });
          var n = o(e("../utils/shallowEqual")),
            i = o(e("./isType")),
            s = o(e("./isPlaceholderType")),
            a = e("../definitions");
          function o(e) {
            return e && e.__esModule ? e : { default: e };
          }
        },
        {
          "../definitions": 94,
          "../utils/shallowEqual": 113,
          "./isPlaceholderType": 123,
          "./isType": 127
        }
      ],
      117: [
        function(e, t, r) {
          "use strict";
          Object.defineProperty(r, "__esModule", { value: !0 }),
            (r.default = function(e, t, r) {
              if (
                r &&
                "Identifier" === e.type &&
                "ObjectProperty" === t.type &&
                "ObjectExpression" === r.type
              )
                return !1;
              const n = i.default.keys[t.type];
              if (n)
                for (let r = 0; r < n.length; r++) {
                  const i = n[r],
                    s = t[i];
                  if (Array.isArray(s)) {
                    if (s.indexOf(e) >= 0) return !0;
                  } else if (s === e) return !0;
                }
              return !1;
            });
          var n,
            i =
              (n = e("../retrievers/getBindingIdentifiers")) && n.__esModule
                ? n
                : { default: n };
        },
        { "../retrievers/getBindingIdentifiers": 107 }
      ],
      118: [
        function(e, t, r) {
          "use strict";
          Object.defineProperty(r, "__esModule", { value: !0 }),
            (r.default = function(e) {
              return (
                (0, i.isFunctionDeclaration)(e) ||
                (0, i.isClassDeclaration)(e) ||
                (0, s.default)(e)
              );
            });
          var n,
            i = e("./generated"),
            s = (n = e("./isLet")) && n.__esModule ? n : { default: n };
        },
        { "./generated": 115, "./isLet": 120 }
      ],
      119: [
        function(e, t, r) {
          "use strict";
          Object.defineProperty(r, "__esModule", { value: !0 }),
            (r.default = function(e) {
              if ((0, i.default)(e.type, "Immutable")) return !0;
              if ((0, s.isIdentifier)(e)) return "undefined" === e.name;
              return !1;
            });
          var n,
            i = (n = e("./isType")) && n.__esModule ? n : { default: n },
            s = e("./generated");
        },
        { "./generated": 115, "./isType": 127 }
      ],
      120: [
        function(e, t, r) {
          "use strict";
          Object.defineProperty(r, "__esModule", { value: !0 }),
            (r.default = function(e) {
              return (
                (0, n.isVariableDeclaration)(e) &&
                ("var" !== e.kind || e[i.BLOCK_SCOPED_SYMBOL])
              );
            });
          var n = e("./generated"),
            i = e("../constants");
        },
        { "../constants": 78, "./generated": 115 }
      ],
      121: [
        function(e, t, r) {
          "use strict";
          Object.defineProperty(r, "__esModule", { value: !0 }),
            (r.default = function(e) {
              return !(!e || !n.VISITOR_KEYS[e.type]);
            });
          var n = e("../definitions");
        },
        { "../definitions": 94 }
      ],
      122: [
        function(e, t, r) {
          "use strict";
          Object.defineProperty(r, "__esModule", { value: !0 }),
            (r.default = function e(t, r) {
              if (
                "object" != typeof t ||
                "object" != typeof r ||
                null == t ||
                null == r
              )
                return t === r;
              if (t.type !== r.type) return !1;
              const i = Object.keys(n.NODE_FIELDS[t.type] || t.type);
              const s = n.VISITOR_KEYS[t.type];
              for (const n of i) {
                if (typeof t[n] != typeof r[n]) return !1;
                if (null != t[n] || null != r[n]) {
                  if (null == t[n] || null == r[n]) return !1;
                  if (Array.isArray(t[n])) {
                    if (!Array.isArray(r[n])) return !1;
                    if (t[n].length !== r[n].length) return !1;
                    for (let i = 0; i < t[n].length; i++)
                      if (!e(t[n][i], r[n][i])) return !1;
                  } else if ("object" != typeof t[n] || (s && s.includes(n))) {
                    if (!e(t[n], r[n])) return !1;
                  } else
                    for (const e of Object.keys(t[n]))
                      if (t[n][e] !== r[n][e]) return !1;
                }
              }
              return !0;
            });
          var n = e("../definitions");
        },
        { "../definitions": 94 }
      ],
      123: [
        function(e, t, r) {
          "use strict";
          Object.defineProperty(r, "__esModule", { value: !0 }),
            (r.default = function(e, t) {
              if (e === t) return !0;
              const r = n.PLACEHOLDERS_ALIAS[e];
              if (r) for (const e of r) if (t === e) return !0;
              return !1;
            });
          var n = e("../definitions");
        },
        { "../definitions": 94 }
      ],
      124: [
        function(e, t, r) {
          "use strict";
          Object.defineProperty(r, "__esModule", { value: !0 }),
            (r.default = function(e, t, r) {
              switch (t.type) {
                case "MemberExpression":
                case "JSXMemberExpression":
                case "OptionalMemberExpression":
                  return t.property === e ? !!t.computed : t.object === e;
                case "VariableDeclarator":
                  return t.init === e;
                case "ArrowFunctionExpression":
                  return t.body === e;
                case "ExportSpecifier":
                  return !t.source && t.local === e;
                case "PrivateName":
                  return !1;
                case "ObjectProperty":
                case "ClassProperty":
                case "ClassPrivateProperty":
                case "ClassMethod":
                case "ClassPrivateMethod":
                case "ObjectMethod":
                  return t.key === e
                    ? !!t.computed
                    : t.value !== e || (!r || "ObjectPattern" !== r.type);
                case "ClassDeclaration":
                case "ClassExpression":
                  return t.superClass === e;
                case "AssignmentExpression":
                case "AssignmentPattern":
                  return t.right === e;
                case "LabeledStatement":
                case "CatchClause":
                case "RestElement":
                  return !1;
                case "BreakStatement":
                case "ContinueStatement":
                  return !1;
                case "FunctionDeclaration":
                case "FunctionExpression":
                  return !1;
                case "ExportNamespaceSpecifier":
                case "ExportDefaultSpecifier":
                  return !1;
                case "ImportDefaultSpecifier":
                case "ImportNamespaceSpecifier":
                case "ImportSpecifier":
                case "JSXAttribute":
                  return !1;
                case "ObjectPattern":
                case "ArrayPattern":
                case "MetaProperty":
                  return !1;
                case "ObjectTypeProperty":
                  return t.key !== e;
                case "TSEnumMember":
                  return t.id !== e;
                case "TSPropertySignature":
                  return t.key !== e || !!t.computed;
              }
              return !0;
            });
        },
        {}
      ],
      125: [
        function(e, t, r) {
          "use strict";
          Object.defineProperty(r, "__esModule", { value: !0 }),
            (r.default = function(e, t) {
              if (
                (0, n.isBlockStatement)(e) &&
                (0, n.isFunction)(t, { body: e })
              )
                return !1;
              if (
                (0, n.isBlockStatement)(e) &&
                (0, n.isCatchClause)(t, { body: e })
              )
                return !1;
              return (0, n.isScopable)(e);
            });
          var n = e("./generated");
        },
        { "./generated": 115 }
      ],
      126: [
        function(e, t, r) {
          "use strict";
          Object.defineProperty(r, "__esModule", { value: !0 }),
            (r.default = function(e) {
              return (
                (0, n.isImportDefaultSpecifier)(e) ||
                (0, n.isIdentifier)(e.imported || e.exported, {
                  name: "default"
                })
              );
            });
          var n = e("./generated");
        },
        { "./generated": 115 }
      ],
      127: [
        function(e, t, r) {
          "use strict";
          Object.defineProperty(r, "__esModule", { value: !0 }),
            (r.default = function(e, t) {
              if (e === t) return !0;
              if (n.ALIAS_KEYS[t]) return !1;
              const r = n.FLIPPED_ALIAS_KEYS[t];
              if (r) {
                if (r[0] === e) return !0;
                for (const t of r) if (e === t) return !0;
              }
              return !1;
            });
          var n = e("../definitions");
        },
        { "../definitions": 94 }
      ],
      128: [
        function(e, t, r) {
          "use strict";
          Object.defineProperty(r, "__esModule", { value: !0 }),
            (r.default = function(e) {
              return (0, i.default)(e) && !s.has(e);
            });
          var n,
            i =
              (n = e("./isValidIdentifier")) && n.__esModule
                ? n
                : { default: n };
          const s = new Set([
            "abstract",
            "boolean",
            "byte",
            "char",
            "double",
            "enum",
            "final",
            "float",
            "goto",
            "implements",
            "int",
            "interface",
            "long",
            "native",
            "package",
            "private",
            "protected",
            "public",
            "short",
            "static",
            "synchronized",
            "throws",
            "transient",
            "volatile"
          ]);
        },
        { "./isValidIdentifier": 129 }
      ],
      129: [
        function(e, t, r) {
          "use strict";
          function n() {
            const t = (r = e("esutils")) && r.__esModule ? r : { default: r };
            var r;
            return (
              (n = function() {
                return t;
              }),
              t
            );
          }
          Object.defineProperty(r, "__esModule", { value: !0 }),
            (r.default = function(e) {
              return (
                "string" == typeof e &&
                !n().default.keyword.isReservedWordES6(e, !0) &&
                ("await" !== e && n().default.keyword.isIdentifierNameES6(e))
              );
            });
        },
        { esutils: 148 }
      ],
      130: [
        function(e, t, r) {
          "use strict";
          Object.defineProperty(r, "__esModule", { value: !0 }),
            (r.default = function(e) {
              return (
                (0, n.isVariableDeclaration)(e, { kind: "var" }) &&
                !e[i.BLOCK_SCOPED_SYMBOL]
              );
            });
          var n = e("./generated"),
            i = e("../constants");
        },
        { "../constants": 78, "./generated": 115 }
      ],
      131: [
        function(e, t, r) {
          "use strict";
          Object.defineProperty(r, "__esModule", { value: !0 }),
            (r.default = function(e, t, r) {
              if (!(0, n.isMemberExpression)(e)) return !1;
              const i = Array.isArray(t) ? t : t.split("."),
                s = [];
              let a;
              for (a = e; (0, n.isMemberExpression)(a); a = a.object)
                s.push(a.property);
              if ((s.push(a), s.length < i.length)) return !1;
              if (!r && s.length > i.length) return !1;
              for (let e = 0, t = s.length - 1; e < i.length; e++, t--) {
                const r = s[t];
                let a;
                if ((0, n.isIdentifier)(r)) a = r.name;
                else {
                  if (!(0, n.isStringLiteral)(r)) return !1;
                  a = r.value;
                }
                if (i[e] !== a) return !1;
              }
              return !0;
            });
          var n = e("./generated");
        },
        { "./generated": 115 }
      ],
      132: [
        function(e, t, r) {
          "use strict";
          Object.defineProperty(r, "__esModule", { value: !0 }),
            (r.default = function(e) {
              return !!e && /^[a-z]/.test(e);
            });
        },
        {}
      ],
      133: [
        function(e, t, r) {
          "use strict";
          var n;
          Object.defineProperty(r, "__esModule", { value: !0 }),
            (r.default = void 0);
          var i = (0,
          ((n = e("../buildMatchMemberExpression")) && n.__esModule
            ? n
            : { default: n }
          ).default)("React.Component");
          r.default = i;
        },
        { "../buildMatchMemberExpression": 114 }
      ],
      134: [
        function(e, t, r) {
          "use strict";
          Object.defineProperty(r, "__esModule", { value: !0 }),
            (r.default = function(e, t, r) {
              if (!e) return;
              const s = n.NODE_FIELDS[e.type];
              if (!s) return;
              const a = s[t];
              i(e, t, r, a);
            }),
            (r.validateField = i);
          var n = e("../definitions");
          function i(e, t, r, n) {
            n &&
              n.validate &&
              ((n.optional && null == r) || n.validate(e, t, r));
          }
        },
        { "../definitions": 94 }
      ],
      135: [
        function(e, t, r) {
          "use strict";
          const n = e("color-convert"),
            i = (e, t) =>
              function() {
                return `[${e.apply(n, arguments) + t}m`;
              },
            s = (e, t) =>
              function() {
                const r = e.apply(n, arguments);
                return `[${38 + t};5;${r}m`;
              },
            a = (e, t) =>
              function() {
                const r = e.apply(n, arguments);
                return `[${38 + t};2;${r[0]};${r[1]};${r[2]}m`;
              };
          Object.defineProperty(t, "exports", {
            enumerable: !0,
            get: function() {
              const e = new Map(),
                t = {
                  modifier: {
                    reset: [0, 0],
                    bold: [1, 22],
                    dim: [2, 22],
                    italic: [3, 23],
                    underline: [4, 24],
                    inverse: [7, 27],
                    hidden: [8, 28],
                    strikethrough: [9, 29]
                  },
                  color: {
                    black: [30, 39],
                    red: [31, 39],
                    green: [32, 39],
                    yellow: [33, 39],
                    blue: [34, 39],
                    magenta: [35, 39],
                    cyan: [36, 39],
                    white: [37, 39],
                    gray: [90, 39],
                    redBright: [91, 39],
                    greenBright: [92, 39],
                    yellowBright: [93, 39],
                    blueBright: [94, 39],
                    magentaBright: [95, 39],
                    cyanBright: [96, 39],
                    whiteBright: [97, 39]
                  },
                  bgColor: {
                    bgBlack: [40, 49],
                    bgRed: [41, 49],
                    bgGreen: [42, 49],
                    bgYellow: [43, 49],
                    bgBlue: [44, 49],
                    bgMagenta: [45, 49],
                    bgCyan: [46, 49],
                    bgWhite: [47, 49],
                    bgBlackBright: [100, 49],
                    bgRedBright: [101, 49],
                    bgGreenBright: [102, 49],
                    bgYellowBright: [103, 49],
                    bgBlueBright: [104, 49],
                    bgMagentaBright: [105, 49],
                    bgCyanBright: [106, 49],
                    bgWhiteBright: [107, 49]
                  }
                };
              t.color.grey = t.color.gray;
              for (const r of Object.keys(t)) {
                const n = t[r];
                for (const r of Object.keys(n)) {
                  const i = n[r];
                  (t[r] = { open: `[${i[0]}m`, close: `[${i[1]}m` }),
                    (n[r] = t[r]),
                    e.set(i[0], i[1]);
                }
                Object.defineProperty(t, r, { value: n, enumerable: !1 }),
                  Object.defineProperty(t, "codes", {
                    value: e,
                    enumerable: !1
                  });
              }
              const r = e => e,
                o = (e, t, r) => [e, t, r];
              (t.color.close = "[39m"),
                (t.bgColor.close = "[49m"),
                (t.color.ansi = { ansi: i(r, 0) }),
                (t.color.ansi256 = { ansi256: s(r, 0) }),
                (t.color.ansi16m = { rgb: a(o, 0) }),
                (t.bgColor.ansi = { ansi: i(r, 10) }),
                (t.bgColor.ansi256 = { ansi256: s(r, 10) }),
                (t.bgColor.ansi16m = { rgb: a(o, 10) });
              for (let e of Object.keys(n)) {
                if ("object" != typeof n[e]) continue;
                const r = n[e];
                "ansi16" === e && (e = "ansi"),
                  "ansi16" in r &&
                    ((t.color.ansi[e] = i(r.ansi16, 0)),
                    (t.bgColor.ansi[e] = i(r.ansi16, 10))),
                  "ansi256" in r &&
                    ((t.color.ansi256[e] = s(r.ansi256, 0)),
                    (t.bgColor.ansi256[e] = s(r.ansi256, 10))),
                  "rgb" in r &&
                    ((t.color.ansi16m[e] = a(r.rgb, 0)),
                    (t.bgColor.ansi16m[e] = a(r.rgb, 10)));
              }
              return t;
            }
          });
        },
        { "color-convert": 139 }
      ],
      136: [
        function(e, t, r) {
          (function(r) {
            "use strict";
            const n = e("escape-string-regexp"),
              i = e("ansi-styles"),
              s = e("supports-color").stdout,
              a = e("./templates.js"),
              o =
                "win32" === r.platform &&
                !(r.env.TERM || "").toLowerCase().startsWith("xterm"),
              u = ["ansi", "ansi", "ansi256", "ansi16m"],
              l = new Set(["gray"]),
              c = Object.create(null);
            function p(e, t) {
              t = t || {};
              const r = s ? s.level : 0;
              (e.level = void 0 === t.level ? r : t.level),
                (e.enabled = "enabled" in t ? t.enabled : e.level > 0);
            }
            function d(e) {
              if (!this || !(this instanceof d) || this.template) {
                const t = {};
                return (
                  p(t, e),
                  (t.template = function() {
                    const e = [].slice.call(arguments);
                    return function(e, t) {
                      if (!Array.isArray(t))
                        return [].slice.call(arguments, 1).join(" ");
                      const r = [].slice.call(arguments, 2),
                        n = [t.raw[0]];
                      for (let e = 1; e < t.length; e++)
                        n.push(String(r[e - 1]).replace(/[{}\\]/g, "\\$&")),
                          n.push(String(t.raw[e]));
                      return a(e, n.join(""));
                    }.apply(null, [t.template].concat(e));
                  }),
                  Object.setPrototypeOf(t, d.prototype),
                  Object.setPrototypeOf(t.template, t),
                  (t.template.constructor = d),
                  t.template
                );
              }
              p(this, e);
            }
            o && (i.blue.open = "[94m");
            for (const e of Object.keys(i))
              (i[e].closeRe = new RegExp(n(i[e].close), "g")),
                (c[e] = {
                  get() {
                    const t = i[e];
                    return f.call(
                      this,
                      this._styles ? this._styles.concat(t) : [t],
                      this._empty,
                      e
                    );
                  }
                });
            (c.visible = {
              get() {
                return f.call(this, this._styles || [], !0, "visible");
              }
            }),
              (i.color.closeRe = new RegExp(n(i.color.close), "g"));
            for (const e of Object.keys(i.color.ansi))
              l.has(e) ||
                (c[e] = {
                  get() {
                    const t = this.level;
                    return function() {
                      const r = {
                        open: i.color[u[t]][e].apply(null, arguments),
                        close: i.color.close,
                        closeRe: i.color.closeRe
                      };
                      return f.call(
                        this,
                        this._styles ? this._styles.concat(r) : [r],
                        this._empty,
                        e
                      );
                    };
                  }
                });
            i.bgColor.closeRe = new RegExp(n(i.bgColor.close), "g");
            for (const e of Object.keys(i.bgColor.ansi)) {
              if (l.has(e)) continue;
              c["bg" + e[0].toUpperCase() + e.slice(1)] = {
                get() {
                  const t = this.level;
                  return function() {
                    const r = {
                      open: i.bgColor[u[t]][e].apply(null, arguments),
                      close: i.bgColor.close,
                      closeRe: i.bgColor.closeRe
                    };
                    return f.call(
                      this,
                      this._styles ? this._styles.concat(r) : [r],
                      this._empty,
                      e
                    );
                  };
                }
              };
            }
            const h = Object.defineProperties(() => {}, c);
            function f(e, t, r) {
              const n = function() {
                return function() {
                  const e = arguments,
                    t = e.length;
                  let r = String(arguments[0]);
                  if (0 === t) return "";
                  if (t > 1) for (let n = 1; n < t; n++) r += " " + e[n];
                  if (!this.enabled || this.level <= 0 || !r)
                    return this._empty ? "" : r;
                  const n = i.dim.open;
                  o && this.hasGrey && (i.dim.open = "");
                  for (const e of this._styles.slice().reverse())
                    r = (r =
                      e.open + r.replace(e.closeRe, e.open) + e.close).replace(
                      /\r?\n/g,
                      `${e.close}$&${e.open}`
                    );
                  return (i.dim.open = n), r;
                }.apply(n, arguments);
              };
              (n._styles = e), (n._empty = t);
              const s = this;
              return (
                Object.defineProperty(n, "level", {
                  enumerable: !0,
                  get: () => s.level,
                  set(e) {
                    s.level = e;
                  }
                }),
                Object.defineProperty(n, "enabled", {
                  enumerable: !0,
                  get: () => s.enabled,
                  set(e) {
                    s.enabled = e;
                  }
                }),
                (n.hasGrey = this.hasGrey || "gray" === r || "grey" === r),
                (n.__proto__ = h),
                n
              );
            }
            Object.defineProperties(d.prototype, c),
              (t.exports = d()),
              (t.exports.supportsColor = s),
              (t.exports.default = t.exports);
          }.call(this, e("_process")));
        },
        {
          "./templates.js": 137,
          _process: 331,
          "ansi-styles": 135,
          "escape-string-regexp": 144,
          "supports-color": 315
        }
      ],
      137: [
        function(e, t, r) {
          "use strict";
          const n = /(?:\\(u[a-f\d]{4}|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi,
            i = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g,
            s = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/,
            a = /\\(u[a-f\d]{4}|x[a-f\d]{2}|.)|([^\\])/gi,
            o = new Map([
              ["n", "\n"],
              ["r", "\r"],
              ["t", "\t"],
              ["b", "\b"],
              ["f", "\f"],
              ["v", "\v"],
              ["0", "\0"],
              ["\\", "\\"],
              ["e", ""],
              ["a", ""]
            ]);
          function u(e) {
            return ("u" === e[0] && 5 === e.length) ||
              ("x" === e[0] && 3 === e.length)
              ? String.fromCharCode(parseInt(e.slice(1), 16))
              : o.get(e) || e;
          }
          function l(e, t) {
            const r = [],
              n = t.trim().split(/\s*,\s*/g);
            let i;
            for (const t of n)
              if (isNaN(t)) {
                if (!(i = t.match(s)))
                  throw new Error(
                    `Invalid Chalk template style argument: ${t} (in style '${e}')`
                  );
                r.push(i[2].replace(a, (e, t, r) => (t ? u(t) : r)));
              } else r.push(Number(t));
            return r;
          }
          function c(e) {
            i.lastIndex = 0;
            const t = [];
            let r;
            for (; null !== (r = i.exec(e)); ) {
              const e = r[1];
              if (r[2]) {
                const n = l(e, r[2]);
                t.push([e].concat(n));
              } else t.push([e]);
            }
            return t;
          }
          function p(e, t) {
            const r = {};
            for (const e of t)
              for (const t of e.styles) r[t[0]] = e.inverse ? null : t.slice(1);
            let n = e;
            for (const e of Object.keys(r))
              if (Array.isArray(r[e])) {
                if (!(e in n)) throw new Error(`Unknown Chalk style: ${e}`);
                n = r[e].length > 0 ? n[e].apply(n, r[e]) : n[e];
              }
            return n;
          }
          t.exports = (e, t) => {
            const r = [],
              i = [];
            let s = [];
            if (
              (t.replace(n, (t, n, a, o, l, d) => {
                if (n) s.push(u(n));
                else if (o) {
                  const t = s.join("");
                  (s = []),
                    i.push(0 === r.length ? t : p(e, r)(t)),
                    r.push({ inverse: a, styles: c(o) });
                } else if (l) {
                  if (0 === r.length)
                    throw new Error(
                      "Found extraneous } in Chalk template literal"
                    );
                  i.push(p(e, r)(s.join(""))), (s = []), r.pop();
                } else s.push(d);
              }),
              i.push(s.join("")),
              r.length > 0)
            ) {
              const e = `Chalk template literal is missing ${
                r.length
              } closing bracket${1 === r.length ? "" : "s"} (\`}\`)`;
              throw new Error(e);
            }
            return i.join("");
          };
        },
        {}
      ],
      138: [
        function(e, t, r) {
          var n = e("color-name"),
            i = {};
          for (var s in n) n.hasOwnProperty(s) && (i[n[s]] = s);
          var a = (t.exports = {
            rgb: { channels: 3, labels: "rgb" },
            hsl: { channels: 3, labels: "hsl" },
            hsv: { channels: 3, labels: "hsv" },
            hwb: { channels: 3, labels: "hwb" },
            cmyk: { channels: 4, labels: "cmyk" },
            xyz: { channels: 3, labels: "xyz" },
            lab: { channels: 3, labels: "lab" },
            lch: { channels: 3, labels: "lch" },
            hex: { channels: 1, labels: ["hex"] },
            keyword: { channels: 1, labels: ["keyword"] },
            ansi16: { channels: 1, labels: ["ansi16"] },
            ansi256: { channels: 1, labels: ["ansi256"] },
            hcg: { channels: 3, labels: ["h", "c", "g"] },
            apple: { channels: 3, labels: ["r16", "g16", "b16"] },
            gray: { channels: 1, labels: ["gray"] }
          });
          for (var o in a)
            if (a.hasOwnProperty(o)) {
              if (!("channels" in a[o]))
                throw new Error("missing channels property: " + o);
              if (!("labels" in a[o]))
                throw new Error("missing channel labels property: " + o);
              if (a[o].labels.length !== a[o].channels)
                throw new Error("channel and label counts mismatch: " + o);
              var u = a[o].channels,
                l = a[o].labels;
              delete a[o].channels,
                delete a[o].labels,
                Object.defineProperty(a[o], "channels", { value: u }),
                Object.defineProperty(a[o], "labels", { value: l });
            }
          (a.rgb.hsl = function(e) {
            var t,
              r,
              n = e[0] / 255,
              i = e[1] / 255,
              s = e[2] / 255,
              a = Math.min(n, i, s),
              o = Math.max(n, i, s),
              u = o - a;
            return (
              o === a
                ? (t = 0)
                : n === o
                ? (t = (i - s) / u)
                : i === o
                ? (t = 2 + (s - n) / u)
                : s === o && (t = 4 + (n - i) / u),
              (t = Math.min(60 * t, 360)) < 0 && (t += 360),
              (r = (a + o) / 2),
              [
                t,
                100 * (o === a ? 0 : r <= 0.5 ? u / (o + a) : u / (2 - o - a)),
                100 * r
              ]
            );
          }),
            (a.rgb.hsv = function(e) {
              var t,
                r,
                n,
                i,
                s,
                a = e[0] / 255,
                o = e[1] / 255,
                u = e[2] / 255,
                l = Math.max(a, o, u),
                c = l - Math.min(a, o, u),
                p = function(e) {
                  return (l - e) / 6 / c + 0.5;
                };
              return (
                0 === c
                  ? (i = s = 0)
                  : ((s = c / l),
                    (t = p(a)),
                    (r = p(o)),
                    (n = p(u)),
                    a === l
                      ? (i = n - r)
                      : o === l
                      ? (i = 1 / 3 + t - n)
                      : u === l && (i = 2 / 3 + r - t),
                    i < 0 ? (i += 1) : i > 1 && (i -= 1)),
                [360 * i, 100 * s, 100 * l]
              );
            }),
            (a.rgb.hwb = function(e) {
              var t = e[0],
                r = e[1],
                n = e[2];
              return [
                a.rgb.hsl(e)[0],
                100 * ((1 / 255) * Math.min(t, Math.min(r, n))),
                100 * (n = 1 - (1 / 255) * Math.max(t, Math.max(r, n)))
              ];
            }),
            (a.rgb.cmyk = function(e) {
              var t,
                r = e[0] / 255,
                n = e[1] / 255,
                i = e[2] / 255;
              return [
                100 *
                  ((1 - r - (t = Math.min(1 - r, 1 - n, 1 - i))) / (1 - t) ||
                    0),
                100 * ((1 - n - t) / (1 - t) || 0),
                100 * ((1 - i - t) / (1 - t) || 0),
                100 * t
              ];
            }),
            (a.rgb.keyword = function(e) {
              var t = i[e];
              if (t) return t;
              var r,
                s,
                a,
                o = 1 / 0;
              for (var u in n)
                if (n.hasOwnProperty(u)) {
                  var l = n[u],
                    c =
                      ((s = e),
                      (a = l),
                      Math.pow(s[0] - a[0], 2) +
                        Math.pow(s[1] - a[1], 2) +
                        Math.pow(s[2] - a[2], 2));
                  c < o && ((o = c), (r = u));
                }
              return r;
            }),
            (a.keyword.rgb = function(e) {
              return n[e];
            }),
            (a.rgb.xyz = function(e) {
              var t = e[0] / 255,
                r = e[1] / 255,
                n = e[2] / 255;
              return [
                100 *
                  (0.4124 *
                    (t =
                      t > 0.04045
                        ? Math.pow((t + 0.055) / 1.055, 2.4)
                        : t / 12.92) +
                    0.3576 *
                      (r =
                        r > 0.04045
                          ? Math.pow((r + 0.055) / 1.055, 2.4)
                          : r / 12.92) +
                    0.1805 *
                      (n =
                        n > 0.04045
                          ? Math.pow((n + 0.055) / 1.055, 2.4)
                          : n / 12.92)),
                100 * (0.2126 * t + 0.7152 * r + 0.0722 * n),
                100 * (0.0193 * t + 0.1192 * r + 0.9505 * n)
              ];
            }),
            (a.rgb.lab = function(e) {
              var t = a.rgb.xyz(e),
                r = t[0],
                n = t[1],
                i = t[2];
              return (
                (n /= 100),
                (i /= 108.883),
                (r =
                  (r /= 95.047) > 0.008856
                    ? Math.pow(r, 1 / 3)
                    : 7.787 * r + 16 / 116),
                [
                  116 *
                    (n =
                      n > 0.008856
                        ? Math.pow(n, 1 / 3)
                        : 7.787 * n + 16 / 116) -
                    16,
                  500 * (r - n),
                  200 *
                    (n -
                      (i =
                        i > 0.008856
                          ? Math.pow(i, 1 / 3)
                          : 7.787 * i + 16 / 116))
                ]
              );
            }),
            (a.hsl.rgb = function(e) {
              var t,
                r,
                n,
                i,
                s,
                a = e[0] / 360,
                o = e[1] / 100,
                u = e[2] / 100;
              if (0 === o) return [(s = 255 * u), s, s];
              (t = 2 * u - (r = u < 0.5 ? u * (1 + o) : u + o - u * o)),
                (i = [0, 0, 0]);
              for (var l = 0; l < 3; l++)
                (n = a + (1 / 3) * -(l - 1)) < 0 && n++,
                  n > 1 && n--,
                  (s =
                    6 * n < 1
                      ? t + 6 * (r - t) * n
                      : 2 * n < 1
                      ? r
                      : 3 * n < 2
                      ? t + (r - t) * (2 / 3 - n) * 6
                      : t),
                  (i[l] = 255 * s);
              return i;
            }),
            (a.hsl.hsv = function(e) {
              var t = e[0],
                r = e[1] / 100,
                n = e[2] / 100,
                i = r,
                s = Math.max(n, 0.01);
              return (
                (r *= (n *= 2) <= 1 ? n : 2 - n),
                (i *= s <= 1 ? s : 2 - s),
                [
                  t,
                  100 * (0 === n ? (2 * i) / (s + i) : (2 * r) / (n + r)),
                  100 * ((n + r) / 2)
                ]
              );
            }),
            (a.hsv.rgb = function(e) {
              var t = e[0] / 60,
                r = e[1] / 100,
                n = e[2] / 100,
                i = Math.floor(t) % 6,
                s = t - Math.floor(t),
                a = 255 * n * (1 - r),
                o = 255 * n * (1 - r * s),
                u = 255 * n * (1 - r * (1 - s));
              switch (((n *= 255), i)) {
                case 0:
                  return [n, u, a];
                case 1:
                  return [o, n, a];
                case 2:
                  return [a, n, u];
                case 3:
                  return [a, o, n];
                case 4:
                  return [u, a, n];
                case 5:
                  return [n, a, o];
              }
            }),
            (a.hsv.hsl = function(e) {
              var t,
                r,
                n,
                i = e[0],
                s = e[1] / 100,
                a = e[2] / 100,
                o = Math.max(a, 0.01);
              return (
                (n = (2 - s) * a),
                (r = s * o),
                [
                  i,
                  100 * (r = (r /= (t = (2 - s) * o) <= 1 ? t : 2 - t) || 0),
                  100 * (n /= 2)
                ]
              );
            }),
            (a.hwb.rgb = function(e) {
              var t,
                r,
                n,
                i,
                s,
                a,
                o,
                u = e[0] / 360,
                l = e[1] / 100,
                c = e[2] / 100,
                p = l + c;
              switch (
                (p > 1 && ((l /= p), (c /= p)),
                (n = 6 * u - (t = Math.floor(6 * u))),
                0 != (1 & t) && (n = 1 - n),
                (i = l + n * ((r = 1 - c) - l)),
                t)
              ) {
                default:
                case 6:
                case 0:
                  (s = r), (a = i), (o = l);
                  break;
                case 1:
                  (s = i), (a = r), (o = l);
                  break;
                case 2:
                  (s = l), (a = r), (o = i);
                  break;
                case 3:
                  (s = l), (a = i), (o = r);
                  break;
                case 4:
                  (s = i), (a = l), (o = r);
                  break;
                case 5:
                  (s = r), (a = l), (o = i);
              }
              return [255 * s, 255 * a, 255 * o];
            }),
            (a.cmyk.rgb = function(e) {
              var t = e[0] / 100,
                r = e[1] / 100,
                n = e[2] / 100,
                i = e[3] / 100;
              return [
                255 * (1 - Math.min(1, t * (1 - i) + i)),
                255 * (1 - Math.min(1, r * (1 - i) + i)),
                255 * (1 - Math.min(1, n * (1 - i) + i))
              ];
            }),
            (a.xyz.rgb = function(e) {
              var t,
                r,
                n,
                i = e[0] / 100,
                s = e[1] / 100,
                a = e[2] / 100;
              return (
                (r = -0.9689 * i + 1.8758 * s + 0.0415 * a),
                (n = 0.0557 * i + -0.204 * s + 1.057 * a),
                (t =
                  (t = 3.2406 * i + -1.5372 * s + -0.4986 * a) > 0.0031308
                    ? 1.055 * Math.pow(t, 1 / 2.4) - 0.055
                    : 12.92 * t),
                (r =
                  r > 0.0031308
                    ? 1.055 * Math.pow(r, 1 / 2.4) - 0.055
                    : 12.92 * r),
                (n =
                  n > 0.0031308
                    ? 1.055 * Math.pow(n, 1 / 2.4) - 0.055
                    : 12.92 * n),
                [
                  255 * (t = Math.min(Math.max(0, t), 1)),
                  255 * (r = Math.min(Math.max(0, r), 1)),
                  255 * (n = Math.min(Math.max(0, n), 1))
                ]
              );
            }),
            (a.xyz.lab = function(e) {
              var t = e[0],
                r = e[1],
                n = e[2];
              return (
                (r /= 100),
                (n /= 108.883),
                (t =
                  (t /= 95.047) > 0.008856
                    ? Math.pow(t, 1 / 3)
                    : 7.787 * t + 16 / 116),
                [
                  116 *
                    (r =
                      r > 0.008856
                        ? Math.pow(r, 1 / 3)
                        : 7.787 * r + 16 / 116) -
                    16,
                  500 * (t - r),
                  200 *
                    (r -
                      (n =
                        n > 0.008856
                          ? Math.pow(n, 1 / 3)
                          : 7.787 * n + 16 / 116))
                ]
              );
            }),
            (a.lab.xyz = function(e) {
              var t,
                r,
                n,
                i = e[0];
              (t = e[1] / 500 + (r = (i + 16) / 116)), (n = r - e[2] / 200);
              var s = Math.pow(r, 3),
                a = Math.pow(t, 3),
                o = Math.pow(n, 3);
              return (
                (r = s > 0.008856 ? s : (r - 16 / 116) / 7.787),
                (t = a > 0.008856 ? a : (t - 16 / 116) / 7.787),
                (n = o > 0.008856 ? o : (n - 16 / 116) / 7.787),
                [(t *= 95.047), (r *= 100), (n *= 108.883)]
              );
            }),
            (a.lab.lch = function(e) {
              var t,
                r = e[0],
                n = e[1],
                i = e[2];
              return (
                (t = (360 * Math.atan2(i, n)) / 2 / Math.PI) < 0 && (t += 360),
                [r, Math.sqrt(n * n + i * i), t]
              );
            }),
            (a.lch.lab = function(e) {
              var t,
                r = e[0],
                n = e[1];
              return (
                (t = (e[2] / 360) * 2 * Math.PI),
                [r, n * Math.cos(t), n * Math.sin(t)]
              );
            }),
            (a.rgb.ansi16 = function(e) {
              var t = e[0],
                r = e[1],
                n = e[2],
                i = 1 in arguments ? arguments[1] : a.rgb.hsv(e)[2];
              if (0 === (i = Math.round(i / 50))) return 30;
              var s =
                30 +
                ((Math.round(n / 255) << 2) |
                  (Math.round(r / 255) << 1) |
                  Math.round(t / 255));
              return 2 === i && (s += 60), s;
            }),
            (a.hsv.ansi16 = function(e) {
              return a.rgb.ansi16(a.hsv.rgb(e), e[2]);
            }),
            (a.rgb.ansi256 = function(e) {
              var t = e[0],
                r = e[1],
                n = e[2];
              return t === r && r === n
                ? t < 8
                  ? 16
                  : t > 248
                  ? 231
                  : Math.round(((t - 8) / 247) * 24) + 232
                : 16 +
                    36 * Math.round((t / 255) * 5) +
                    6 * Math.round((r / 255) * 5) +
                    Math.round((n / 255) * 5);
            }),
            (a.ansi16.rgb = function(e) {
              var t = e % 10;
              if (0 === t || 7 === t)
                return e > 50 && (t += 3.5), [(t = (t / 10.5) * 255), t, t];
              var r = 0.5 * (1 + ~~(e > 50));
              return [
                (1 & t) * r * 255,
                ((t >> 1) & 1) * r * 255,
                ((t >> 2) & 1) * r * 255
              ];
            }),
            (a.ansi256.rgb = function(e) {
              if (e >= 232) {
                var t = 10 * (e - 232) + 8;
                return [t, t, t];
              }
              var r;
              return (
                (e -= 16),
                [
                  (Math.floor(e / 36) / 5) * 255,
                  (Math.floor((r = e % 36) / 6) / 5) * 255,
                  ((r % 6) / 5) * 255
                ]
              );
            }),
            (a.rgb.hex = function(e) {
              var t = (
                ((255 & Math.round(e[0])) << 16) +
                ((255 & Math.round(e[1])) << 8) +
                (255 & Math.round(e[2]))
              )
                .toString(16)
                .toUpperCase();
              return "000000".substring(t.length) + t;
            }),
            (a.hex.rgb = function(e) {
              var t = e.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
              if (!t) return [0, 0, 0];
              var r = t[0];
              3 === t[0].length &&
                (r = r
                  .split("")
                  .map(function(e) {
                    return e + e;
                  })
                  .join(""));
              var n = parseInt(r, 16);
              return [(n >> 16) & 255, (n >> 8) & 255, 255 & n];
            }),
            (a.rgb.hcg = function(e) {
              var t,
                r = e[0] / 255,
                n = e[1] / 255,
                i = e[2] / 255,
                s = Math.max(Math.max(r, n), i),
                a = Math.min(Math.min(r, n), i),
                o = s - a;
              return (
                (t =
                  o <= 0
                    ? 0
                    : s === r
                    ? ((n - i) / o) % 6
                    : s === n
                    ? 2 + (i - r) / o
                    : 4 + (r - n) / o + 4),
                (t /= 6),
                [360 * (t %= 1), 100 * o, 100 * (o < 1 ? a / (1 - o) : 0)]
              );
            }),
            (a.hsl.hcg = function(e) {
              var t = e[1] / 100,
                r = e[2] / 100,
                n = 1,
                i = 0;
              return (
                (n = r < 0.5 ? 2 * t * r : 2 * t * (1 - r)) < 1 &&
                  (i = (r - 0.5 * n) / (1 - n)),
                [e[0], 100 * n, 100 * i]
              );
            }),
            (a.hsv.hcg = function(e) {
              var t = e[1] / 100,
                r = e[2] / 100,
                n = t * r,
                i = 0;
              return n < 1 && (i = (r - n) / (1 - n)), [e[0], 100 * n, 100 * i];
            }),
            (a.hcg.rgb = function(e) {
              var t = e[0] / 360,
                r = e[1] / 100,
                n = e[2] / 100;
              if (0 === r) return [255 * n, 255 * n, 255 * n];
              var i,
                s = [0, 0, 0],
                a = (t % 1) * 6,
                o = a % 1,
                u = 1 - o;
              switch (Math.floor(a)) {
                case 0:
                  (s[0] = 1), (s[1] = o), (s[2] = 0);
                  break;
                case 1:
                  (s[0] = u), (s[1] = 1), (s[2] = 0);
                  break;
                case 2:
                  (s[0] = 0), (s[1] = 1), (s[2] = o);
                  break;
                case 3:
                  (s[0] = 0), (s[1] = u), (s[2] = 1);
                  break;
                case 4:
                  (s[0] = o), (s[1] = 0), (s[2] = 1);
                  break;
                default:
                  (s[0] = 1), (s[1] = 0), (s[2] = u);
              }
              return (
                (i = (1 - r) * n),
                [
                  255 * (r * s[0] + i),
                  255 * (r * s[1] + i),
                  255 * (r * s[2] + i)
                ]
              );
            }),
            (a.hcg.hsv = function(e) {
              var t = e[1] / 100,
                r = t + (e[2] / 100) * (1 - t),
                n = 0;
              return r > 0 && (n = t / r), [e[0], 100 * n, 100 * r];
            }),
            (a.hcg.hsl = function(e) {
              var t = e[1] / 100,
                r = (e[2] / 100) * (1 - t) + 0.5 * t,
                n = 0;
              return (
                r > 0 && r < 0.5
                  ? (n = t / (2 * r))
                  : r >= 0.5 && r < 1 && (n = t / (2 * (1 - r))),
                [e[0], 100 * n, 100 * r]
              );
            }),
            (a.hcg.hwb = function(e) {
              var t = e[1] / 100,
                r = t + (e[2] / 100) * (1 - t);
              return [e[0], 100 * (r - t), 100 * (1 - r)];
            }),
            (a.hwb.hcg = function(e) {
              var t = e[1] / 100,
                r = 1 - e[2] / 100,
                n = r - t,
                i = 0;
              return n < 1 && (i = (r - n) / (1 - n)), [e[0], 100 * n, 100 * i];
            }),
            (a.apple.rgb = function(e) {
              return [
                (e[0] / 65535) * 255,
                (e[1] / 65535) * 255,
                (e[2] / 65535) * 255
              ];
            }),
            (a.rgb.apple = function(e) {
              return [
                (e[0] / 255) * 65535,
                (e[1] / 255) * 65535,
                (e[2] / 255) * 65535
              ];
            }),
            (a.gray.rgb = function(e) {
              return [
                (e[0] / 100) * 255,
                (e[0] / 100) * 255,
                (e[0] / 100) * 255
              ];
            }),
            (a.gray.hsl = a.gray.hsv = function(e) {
              return [0, 0, e[0]];
            }),
            (a.gray.hwb = function(e) {
              return [0, 100, e[0]];
            }),
            (a.gray.cmyk = function(e) {
              return [0, 0, 0, e[0]];
            }),
            (a.gray.lab = function(e) {
              return [e[0], 0, 0];
            }),
            (a.gray.hex = function(e) {
              var t = 255 & Math.round((e[0] / 100) * 255),
                r = ((t << 16) + (t << 8) + t).toString(16).toUpperCase();
              return "000000".substring(r.length) + r;
            }),
            (a.rgb.gray = function(e) {
              return [((e[0] + e[1] + e[2]) / 3 / 255) * 100];
            });
        },
        { "color-name": 141 }
      ],
      139: [
        function(e, t, r) {
          var n = e("./conversions"),
            i = e("./route"),
            s = {};
          Object.keys(n).forEach(function(e) {
            (s[e] = {}),
              Object.defineProperty(s[e], "channels", { value: n[e].channels }),
              Object.defineProperty(s[e], "labels", { value: n[e].labels });
            var t = i(e);
            Object.keys(t).forEach(function(r) {
              var n = t[r];
              (s[e][r] = (function(e) {
                var t = function(t) {
                  if (null == t) return t;
                  arguments.length > 1 &&
                    (t = Array.prototype.slice.call(arguments));
                  var r = e(t);
                  if ("object" == typeof r)
                    for (var n = r.length, i = 0; i < n; i++)
                      r[i] = Math.round(r[i]);
                  return r;
                };
                return "conversion" in e && (t.conversion = e.conversion), t;
              })(n)),
                (s[e][r].raw = (function(e) {
                  var t = function(t) {
                    return null == t
                      ? t
                      : (arguments.length > 1 &&
                          (t = Array.prototype.slice.call(arguments)),
                        e(t));
                  };
                  return "conversion" in e && (t.conversion = e.conversion), t;
                })(n));
            });
          }),
            (t.exports = s);
        },
        { "./conversions": 138, "./route": 140 }
      ],
      140: [
        function(e, t, r) {
          var n = e("./conversions");
          function i(e) {
            var t = (function() {
                for (
                  var e = {}, t = Object.keys(n), r = t.length, i = 0;
                  i < r;
                  i++
                )
                  e[t[i]] = { distance: -1, parent: null };
                return e;
              })(),
              r = [e];
            for (t[e].distance = 0; r.length; )
              for (
                var i = r.pop(), s = Object.keys(n[i]), a = s.length, o = 0;
                o < a;
                o++
              ) {
                var u = s[o],
                  l = t[u];
                -1 === l.distance &&
                  ((l.distance = t[i].distance + 1),
                  (l.parent = i),
                  r.unshift(u));
              }
            return t;
          }
          function s(e, t) {
            return function(r) {
              return t(e(r));
            };
          }
          function a(e, t) {
            for (
              var r = [t[e].parent, e], i = n[t[e].parent][e], a = t[e].parent;
              t[a].parent;

            )
              r.unshift(t[a].parent),
                (i = s(n[t[a].parent][a], i)),
                (a = t[a].parent);
            return (i.conversion = r), i;
          }
          t.exports = function(e) {
            for (
              var t = i(e), r = {}, n = Object.keys(t), s = n.length, o = 0;
              o < s;
              o++
            ) {
              var u = n[o];
              null !== t[u].parent && (r[u] = a(u, t));
            }
            return r;
          };
        },
        { "./conversions": 138 }
      ],
      141: [
        function(e, t, r) {
          "use strict";
          t.exports = {
            aliceblue: [240, 248, 255],
            antiquewhite: [250, 235, 215],
            aqua: [0, 255, 255],
            aquamarine: [127, 255, 212],
            azure: [240, 255, 255],
            beige: [245, 245, 220],
            bisque: [255, 228, 196],
            black: [0, 0, 0],
            blanchedalmond: [255, 235, 205],
            blue: [0, 0, 255],
            blueviolet: [138, 43, 226],
            brown: [165, 42, 42],
            burlywood: [222, 184, 135],
            cadetblue: [95, 158, 160],
            chartreuse: [127, 255, 0],
            chocolate: [210, 105, 30],
            coral: [255, 127, 80],
            cornflowerblue: [100, 149, 237],
            cornsilk: [255, 248, 220],
            crimson: [220, 20, 60],
            cyan: [0, 255, 255],
            darkblue: [0, 0, 139],
            darkcyan: [0, 139, 139],
            darkgoldenrod: [184, 134, 11],
            darkgray: [169, 169, 169],
            darkgreen: [0, 100, 0],
            darkgrey: [169, 169, 169],
            darkkhaki: [189, 183, 107],
            darkmagenta: [139, 0, 139],
            darkolivegreen: [85, 107, 47],
            darkorange: [255, 140, 0],
            darkorchid: [153, 50, 204],
            darkred: [139, 0, 0],
            darksalmon: [233, 150, 122],
            darkseagreen: [143, 188, 143],
            darkslateblue: [72, 61, 139],
            darkslategray: [47, 79, 79],
            darkslategrey: [47, 79, 79],
            darkturquoise: [0, 206, 209],
            darkviolet: [148, 0, 211],
            deeppink: [255, 20, 147],
            deepskyblue: [0, 191, 255],
            dimgray: [105, 105, 105],
            dimgrey: [105, 105, 105],
            dodgerblue: [30, 144, 255],
            firebrick: [178, 34, 34],
            floralwhite: [255, 250, 240],
            forestgreen: [34, 139, 34],
            fuchsia: [255, 0, 255],
            gainsboro: [220, 220, 220],
            ghostwhite: [248, 248, 255],
            gold: [255, 215, 0],
            goldenrod: [218, 165, 32],
            gray: [128, 128, 128],
            green: [0, 128, 0],
            greenyellow: [173, 255, 47],
            grey: [128, 128, 128],
            honeydew: [240, 255, 240],
            hotpink: [255, 105, 180],
            indianred: [205, 92, 92],
            indigo: [75, 0, 130],
            ivory: [255, 255, 240],
            khaki: [240, 230, 140],
            lavender: [230, 230, 250],
            lavenderblush: [255, 240, 245],
            lawngreen: [124, 252, 0],
            lemonchiffon: [255, 250, 205],
            lightblue: [173, 216, 230],
            lightcoral: [240, 128, 128],
            lightcyan: [224, 255, 255],
            lightgoldenrodyellow: [250, 250, 210],
            lightgray: [211, 211, 211],
            lightgreen: [144, 238, 144],
            lightgrey: [211, 211, 211],
            lightpink: [255, 182, 193],
            lightsalmon: [255, 160, 122],
            lightseagreen: [32, 178, 170],
            lightskyblue: [135, 206, 250],
            lightslategray: [119, 136, 153],
            lightslategrey: [119, 136, 153],
            lightsteelblue: [176, 196, 222],
            lightyellow: [255, 255, 224],
            lime: [0, 255, 0],
            limegreen: [50, 205, 50],
            linen: [250, 240, 230],
            magenta: [255, 0, 255],
            maroon: [128, 0, 0],
            mediumaquamarine: [102, 205, 170],
            mediumblue: [0, 0, 205],
            mediumorchid: [186, 85, 211],
            mediumpurple: [147, 112, 219],
            mediumseagreen: [60, 179, 113],
            mediumslateblue: [123, 104, 238],
            mediumspringgreen: [0, 250, 154],
            mediumturquoise: [72, 209, 204],
            mediumvioletred: [199, 21, 133],
            midnightblue: [25, 25, 112],
            mintcream: [245, 255, 250],
            mistyrose: [255, 228, 225],
            moccasin: [255, 228, 181],
            navajowhite: [255, 222, 173],
            navy: [0, 0, 128],
            oldlace: [253, 245, 230],
            olive: [128, 128, 0],
            olivedrab: [107, 142, 35],
            orange: [255, 165, 0],
            orangered: [255, 69, 0],
            orchid: [218, 112, 214],
            palegoldenrod: [238, 232, 170],
            palegreen: [152, 251, 152],
            paleturquoise: [175, 238, 238],
            palevioletred: [219, 112, 147],
            papayawhip: [255, 239, 213],
            peachpuff: [255, 218, 185],
            peru: [205, 133, 63],
            pink: [255, 192, 203],
            plum: [221, 160, 221],
            powderblue: [176, 224, 230],
            purple: [128, 0, 128],
            rebeccapurple: [102, 51, 153],
            red: [255, 0, 0],
            rosybrown: [188, 143, 143],
            royalblue: [65, 105, 225],
            saddlebrown: [139, 69, 19],
            salmon: [250, 128, 114],
            sandybrown: [244, 164, 96],
            seagreen: [46, 139, 87],
            seashell: [255, 245, 238],
            sienna: [160, 82, 45],
            silver: [192, 192, 192],
            skyblue: [135, 206, 235],
            slateblue: [106, 90, 205],
            slategray: [112, 128, 144],
            slategrey: [112, 128, 144],
            snow: [255, 250, 250],
            springgreen: [0, 255, 127],
            steelblue: [70, 130, 180],
            tan: [210, 180, 140],
            teal: [0, 128, 128],
            thistle: [216, 191, 216],
            tomato: [255, 99, 71],
            turquoise: [64, 224, 208],
            violet: [238, 130, 238],
            wheat: [245, 222, 179],
            white: [255, 255, 255],
            whitesmoke: [245, 245, 245],
            yellow: [255, 255, 0],
            yellowgreen: [154, 205, 50]
          };
        },
        {}
      ],
      142: [
        function(e, t, r) {
          (function(n) {
            (r.log = function(...e) {
              return (
                "object" == typeof console && console.log && console.log(...e)
              );
            }),
              (r.formatArgs = function(e) {
                if (
                  ((e[0] =
                    (this.useColors ? "%c" : "") +
                    this.namespace +
                    (this.useColors ? " %c" : " ") +
                    e[0] +
                    (this.useColors ? "%c " : " ") +
                    "+" +
                    t.exports.humanize(this.diff)),
                  !this.useColors)
                )
                  return;
                const r = "color: " + this.color;
                e.splice(1, 0, r, "color: inherit");
                let n = 0,
                  i = 0;
                e[0].replace(/%[a-zA-Z%]/g, e => {
                  "%%" !== e && (n++, "%c" === e && (i = n));
                }),
                  e.splice(i, 0, r);
              }),
              (r.save = function(e) {
                try {
                  e
                    ? r.storage.setItem("debug", e)
                    : r.storage.removeItem("debug");
                } catch (e) {}
              }),
              (r.load = function() {
                let e;
                try {
                  e = r.storage.getItem("debug");
                } catch (e) {}
                !e && void 0 !== n && "env" in n && (e = n.env.DEBUG);
                return e;
              }),
              (r.useColors = function() {
                if (
                  "undefined" != typeof window &&
                  window.process &&
                  ("renderer" === window.process.type || window.process.__nwjs)
                )
                  return !0;
                if (
                  "undefined" != typeof navigator &&
                  navigator.userAgent &&
                  navigator.userAgent
                    .toLowerCase()
                    .match(/(edge|trident)\/(\d+)/)
                )
                  return !1;
                return (
                  ("undefined" != typeof document &&
                    document.documentElement &&
                    document.documentElement.style &&
                    document.documentElement.style.WebkitAppearance) ||
                  ("undefined" != typeof window &&
                    window.console &&
                    (window.console.firebug ||
                      (window.console.exception && window.console.table))) ||
                  ("undefined" != typeof navigator &&
                    navigator.userAgent &&
                    navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) &&
                    parseInt(RegExp.$1, 10) >= 31) ||
                  ("undefined" != typeof navigator &&
                    navigator.userAgent &&
                    navigator.userAgent
                      .toLowerCase()
                      .match(/applewebkit\/(\d+)/))
                );
              }),
              (r.storage = (function() {
                try {
                  return localStorage;
                } catch (e) {}
              })()),
              (r.colors = [
                "#0000CC",
                "#0000FF",
                "#0033CC",
                "#0033FF",
                "#0066CC",
                "#0066FF",
                "#0099CC",
                "#0099FF",
                "#00CC00",
                "#00CC33",
                "#00CC66",
                "#00CC99",
                "#00CCCC",
                "#00CCFF",
                "#3300CC",
                "#3300FF",
                "#3333CC",
                "#3333FF",
                "#3366CC",
                "#3366FF",
                "#3399CC",
                "#3399FF",
                "#33CC00",
                "#33CC33",
                "#33CC66",
                "#33CC99",
                "#33CCCC",
                "#33CCFF",
                "#6600CC",
                "#6600FF",
                "#6633CC",
                "#6633FF",
                "#66CC00",
                "#66CC33",
                "#9900CC",
                "#9900FF",
                "#9933CC",
                "#9933FF",
                "#99CC00",
                "#99CC33",
                "#CC0000",
                "#CC0033",
                "#CC0066",
                "#CC0099",
                "#CC00CC",
                "#CC00FF",
                "#CC3300",
                "#CC3333",
                "#CC3366",
                "#CC3399",
                "#CC33CC",
                "#CC33FF",
                "#CC6600",
                "#CC6633",
                "#CC9900",
                "#CC9933",
                "#CCCC00",
                "#CCCC33",
                "#FF0000",
                "#FF0033",
                "#FF0066",
                "#FF0099",
                "#FF00CC",
                "#FF00FF",
                "#FF3300",
                "#FF3333",
                "#FF3366",
                "#FF3399",
                "#FF33CC",
                "#FF33FF",
                "#FF6600",
                "#FF6633",
                "#FF9900",
                "#FF9933",
                "#FFCC00",
                "#FFCC33"
              ]),
              (t.exports = e("./common")(r));
            const { formatters: i } = t.exports;
            i.j = function(e) {
              try {
                return JSON.stringify(e);
              } catch (e) {
                return "[UnexpectedJSONParseError]: " + e.message;
              }
            };
          }.call(this, e("_process")));
        },
        { "./common": 143, _process: 331 }
      ],
      143: [
        function(e, t, r) {
          t.exports = function(t) {
            function r(e) {
              let t = 0;
              for (let r = 0; r < e.length; r++)
                (t = (t << 5) - t + e.charCodeAt(r)), (t |= 0);
              return n.colors[Math.abs(t) % n.colors.length];
            }
            function n(e) {
              let t;
              function a(...e) {
                if (!a.enabled) return;
                const r = a,
                  i = Number(new Date()),
                  s = i - (t || i);
                (r.diff = s),
                  (r.prev = t),
                  (r.curr = i),
                  (t = i),
                  (e[0] = n.coerce(e[0])),
                  "string" != typeof e[0] && e.unshift("%O");
                let o = 0;
                (e[0] = e[0].replace(/%([a-zA-Z%])/g, (t, i) => {
                  if ("%%" === t) return t;
                  o++;
                  const s = n.formatters[i];
                  if ("function" == typeof s) {
                    const n = e[o];
                    (t = s.call(r, n)), e.splice(o, 1), o--;
                  }
                  return t;
                })),
                  n.formatArgs.call(r, e),
                  (r.log || n.log).apply(r, e);
              }
              return (
                (a.namespace = e),
                (a.enabled = n.enabled(e)),
                (a.useColors = n.useColors()),
                (a.color = r(e)),
                (a.destroy = i),
                (a.extend = s),
                "function" == typeof n.init && n.init(a),
                n.instances.push(a),
                a
              );
            }
            function i() {
              const e = n.instances.indexOf(this);
              return -1 !== e && (n.instances.splice(e, 1), !0);
            }
            function s(e, t) {
              const r = n(this.namespace + (void 0 === t ? ":" : t) + e);
              return (r.log = this.log), r;
            }
            function a(e) {
              return e
                .toString()
                .substring(2, e.toString().length - 2)
                .replace(/\.\*\?$/, "*");
            }
            return (
              (n.debug = n),
              (n.default = n),
              (n.coerce = function(e) {
                return e instanceof Error ? e.stack || e.message : e;
              }),
              (n.disable = function() {
                const e = [
                  ...n.names.map(a),
                  ...n.skips.map(a).map(e => "-" + e)
                ].join(",");
                return n.enable(""), e;
              }),
              (n.enable = function(e) {
                let t;
                n.save(e), (n.names = []), (n.skips = []);
                const r = ("string" == typeof e ? e : "").split(/[\s,]+/),
                  i = r.length;
                for (t = 0; t < i; t++)
                  r[t] &&
                    ("-" === (e = r[t].replace(/\*/g, ".*?"))[0]
                      ? n.skips.push(new RegExp("^" + e.substr(1) + "$"))
                      : n.names.push(new RegExp("^" + e + "$")));
                for (t = 0; t < n.instances.length; t++) {
                  const e = n.instances[t];
                  e.enabled = n.enabled(e.namespace);
                }
              }),
              (n.enabled = function(e) {
                if ("*" === e[e.length - 1]) return !0;
                let t, r;
                for (t = 0, r = n.skips.length; t < r; t++)
                  if (n.skips[t].test(e)) return !1;
                for (t = 0, r = n.names.length; t < r; t++)
                  if (n.names[t].test(e)) return !0;
                return !1;
              }),
              (n.humanize = e("ms")),
              Object.keys(t).forEach(e => {
                n[e] = t[e];
              }),
              (n.instances = []),
              (n.names = []),
              (n.skips = []),
              (n.formatters = {}),
              (n.selectColor = r),
              n.enable(n.load()),
              n
            );
          };
        },
        { ms: 303 }
      ],
      144: [
        function(e, t, r) {
          "use strict";
          var n = /[|\\{}()[\]^$+*?.]/g;
          t.exports = function(e) {
            if ("string" != typeof e) throw new TypeError("Expected a string");
            return e.replace(n, "\\$&");
          };
        },
        {}
      ],
      145: [
        function(e, t, r) {
          !(function() {
            "use strict";
            function e(e) {
              if (null == e) return !1;
              switch (e.type) {
                case "BlockStatement":
                case "BreakStatement":
                case "ContinueStatement":
                case "DebuggerStatement":
                case "DoWhileStatement":
                case "EmptyStatement":
                case "ExpressionStatement":
                case "ForInStatement":
                case "ForStatement":
                case "IfStatement":
                case "LabeledStatement":
                case "ReturnStatement":
                case "SwitchStatement":
                case "ThrowStatement":
                case "TryStatement":
                case "VariableDeclaration":
                case "WhileStatement":
                case "WithStatement":
                  return !0;
              }
              return !1;
            }
            function r(e) {
              switch (e.type) {
                case "IfStatement":
                  return null != e.alternate ? e.alternate : e.consequent;
                case "LabeledStatement":
                case "ForStatement":
                case "ForInStatement":
                case "WhileStatement":
                case "WithStatement":
                  return e.body;
              }
              return null;
            }
            t.exports = {
              isExpression: function(e) {
                if (null == e) return !1;
                switch (e.type) {
                  case "ArrayExpression":
                  case "AssignmentExpression":
                  case "BinaryExpression":
                  case "CallExpression":
                  case "ConditionalExpression":
                  case "FunctionExpression":
                  case "Identifier":
                  case "Literal":
                  case "LogicalExpression":
                  case "MemberExpression":
                  case "NewExpression":
                  case "ObjectExpression":
                  case "SequenceExpression":
                  case "ThisExpression":
                  case "UnaryExpression":
                  case "UpdateExpression":
                    return !0;
                }
                return !1;
              },
              isStatement: e,
              isIterationStatement: function(e) {
                if (null == e) return !1;
                switch (e.type) {
                  case "DoWhileStatement":
                  case "ForInStatement":
                  case "ForStatement":
                  case "WhileStatement":
                    return !0;
                }
                return !1;
              },
              isSourceElement: function(t) {
                return e(t) || (null != t && "FunctionDeclaration" === t.type);
              },
              isProblematicIfStatement: function(e) {
                var t;
                if ("IfStatement" !== e.type) return !1;
                if (null == e.alternate) return !1;
                t = e.consequent;
                do {
                  if ("IfStatement" === t.type && null == t.alternate)
                    return !0;
                  t = r(t);
                } while (t);
                return !1;
              },
              trailingStatement: r
            };
          })();
        },
        {}
      ],
      146: [
        function(e, t, r) {
          !(function() {
            "use strict";
            var e, r, n, i, s, a;
            function o(e) {
              return e <= 65535
                ? String.fromCharCode(e)
                : String.fromCharCode(Math.floor((e - 65536) / 1024) + 55296) +
                    String.fromCharCode(((e - 65536) % 1024) + 56320);
            }
            for (
              r = {
                NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/,
                NonAsciiIdentifierPart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/
              },
                e = {
                  NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F\uDFE0]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]/,
                  NonAsciiIdentifierPart: /[\xAA\xB5\xB7\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u1371\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE3E\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC00-\uDC4A\uDC50-\uDC59\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC36\uDC38-\uDC40\uDC50-\uDC59\uDC72-\uDC8F\uDC92-\uDCA7\uDCA9-\uDCB6]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F\uDFE0]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6\uDD00-\uDD4A\uDD50-\uDD59]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/
                },
                n = [
                  5760,
                  8192,
                  8193,
                  8194,
                  8195,
                  8196,
                  8197,
                  8198,
                  8199,
                  8200,
                  8201,
                  8202,
                  8239,
                  8287,
                  12288,
                  65279
                ],
                i = new Array(128),
                a = 0;
              a < 128;
              ++a
            )
              i[a] =
                (a >= 97 && a <= 122) ||
                (a >= 65 && a <= 90) ||
                36 === a ||
                95 === a;
            for (s = new Array(128), a = 0; a < 128; ++a)
              s[a] =
                (a >= 97 && a <= 122) ||
                (a >= 65 && a <= 90) ||
                (a >= 48 && a <= 57) ||
                36 === a ||
                95 === a;
            t.exports = {
              isDecimalDigit: function(e) {
                return 48 <= e && e <= 57;
              },
              isHexDigit: function(e) {
                return (
                  (48 <= e && e <= 57) ||
                  (97 <= e && e <= 102) ||
                  (65 <= e && e <= 70)
                );
              },
              isOctalDigit: function(e) {
                return e >= 48 && e <= 55;
              },
              isWhiteSpace: function(e) {
                return (
                  32 === e ||
                  9 === e ||
                  11 === e ||
                  12 === e ||
                  160 === e ||
                  (e >= 5760 && n.indexOf(e) >= 0)
                );
              },
              isLineTerminator: function(e) {
                return 10 === e || 13 === e || 8232 === e || 8233 === e;
              },
              isIdentifierStartES5: function(e) {
                return e < 128 ? i[e] : r.NonAsciiIdentifierStart.test(o(e));
              },
              isIdentifierPartES5: function(e) {
                return e < 128 ? s[e] : r.NonAsciiIdentifierPart.test(o(e));
              },
              isIdentifierStartES6: function(t) {
                return t < 128 ? i[t] : e.NonAsciiIdentifierStart.test(o(t));
              },
              isIdentifierPartES6: function(t) {
                return t < 128 ? s[t] : e.NonAsciiIdentifierPart.test(o(t));
              }
            };
          })();
        },
        {}
      ],
      147: [
        function(e, t, r) {
          !(function() {
            "use strict";
            var r = e("./code");
            function n(e, t) {
              return !(!t && "yield" === e) && i(e, t);
            }
            function i(e, t) {
              if (
                t &&
                (function(e) {
                  switch (e) {
                    case "implements":
                    case "interface":
                    case "package":
                    case "private":
                    case "protected":
                    case "public":
                    case "static":
                    case "let":
                      return !0;
                    default:
                      return !1;
                  }
                })(e)
              )
                return !0;
              switch (e.length) {
                case 2:
                  return "if" === e || "in" === e || "do" === e;
                case 3:
                  return (
                    "var" === e || "for" === e || "new" === e || "try" === e
                  );
                case 4:
                  return (
                    "this" === e ||
                    "else" === e ||
                    "case" === e ||
                    "void" === e ||
                    "with" === e ||
                    "enum" === e
                  );
                case 5:
                  return (
                    "while" === e ||
                    "break" === e ||
                    "catch" === e ||
                    "throw" === e ||
                    "const" === e ||
                    "yield" === e ||
                    "class" === e ||
                    "super" === e
                  );
                case 6:
                  return (
                    "return" === e ||
                    "typeof" === e ||
                    "delete" === e ||
                    "switch" === e ||
                    "export" === e ||
                    "import" === e
                  );
                case 7:
                  return "default" === e || "finally" === e || "extends" === e;
                case 8:
                  return (
                    "function" === e || "continue" === e || "debugger" === e
                  );
                case 10:
                  return "instanceof" === e;
                default:
                  return !1;
              }
            }
            function s(e, t) {
              return "null" === e || "true" === e || "false" === e || n(e, t);
            }
            function a(e, t) {
              return "null" === e || "true" === e || "false" === e || i(e, t);
            }
            function o(e) {
              var t, n, i;
              if (0 === e.length) return !1;
              if (((i = e.charCodeAt(0)), !r.isIdentifierStartES5(i)))
                return !1;
              for (t = 1, n = e.length; t < n; ++t)
                if (((i = e.charCodeAt(t)), !r.isIdentifierPartES5(i)))
                  return !1;
              return !0;
            }
            function u(e) {
              var t, n, i, s, a;
              if (0 === e.length) return !1;
              for (
                a = r.isIdentifierStartES6, t = 0, n = e.length;
                t < n;
                ++t
              ) {
                if (55296 <= (i = e.charCodeAt(t)) && i <= 56319) {
                  if (++t >= n) return !1;
                  if (!(56320 <= (s = e.charCodeAt(t)) && s <= 57343))
                    return !1;
                  i = 1024 * (i - 55296) + (s - 56320) + 65536;
                }
                if (!a(i)) return !1;
                a = r.isIdentifierPartES6;
              }
              return !0;
            }
            t.exports = {
              isKeywordES5: n,
              isKeywordES6: i,
              isReservedWordES5: s,
              isReservedWordES6: a,
              isRestrictedWord: function(e) {
                return "eval" === e || "arguments" === e;
              },
              isIdentifierNameES5: o,
              isIdentifierNameES6: u,
              isIdentifierES5: function(e, t) {
                return o(e) && !s(e, t);
              },
              isIdentifierES6: function(e, t) {
                return u(e) && !a(e, t);
              }
            };
          })();
        },
        { "./code": 146 }
      ],
      148: [
        function(e, t, r) {
          !(function() {
            "use strict";
            (r.ast = e("./ast")),
              (r.code = e("./code")),
              (r.keyword = e("./keyword"));
          })();
        },
        { "./ast": 145, "./code": 146, "./keyword": 147 }
      ],
      149: [
        function(e, t, r) {
          t.exports = {
            builtin: {
              Array: !1,
              ArrayBuffer: !1,
              Atomics: !1,
              BigInt: !1,
              BigInt64Array: !1,
              BigUint64Array: !1,
              Boolean: !1,
              constructor: !1,
              DataView: !1,
              Date: !1,
              decodeURI: !1,
              decodeURIComponent: !1,
              encodeURI: !1,
              encodeURIComponent: !1,
              Error: !1,
              escape: !1,
              eval: !1,
              EvalError: !1,
              Float32Array: !1,
              Float64Array: !1,
              Function: !1,
              globalThis: !1,
              hasOwnProperty: !1,
              Infinity: !1,
              Int16Array: !1,
              Int32Array: !1,
              Int8Array: !1,
              isFinite: !1,
              isNaN: !1,
              isPrototypeOf: !1,
              JSON: !1,
              Map: !1,
              Math: !1,
              NaN: !1,
              Number: !1,
              Object: !1,
              parseFloat: !1,
              parseInt: !1,
              Promise: !1,
              propertyIsEnumerable: !1,
              Proxy: !1,
              RangeError: !1,
              ReferenceError: !1,
              Reflect: !1,
              RegExp: !1,
              Set: !1,
              SharedArrayBuffer: !1,
              String: !1,
              Symbol: !1,
              SyntaxError: !1,
              toLocaleString: !1,
              toString: !1,
              TypeError: !1,
              Uint16Array: !1,
              Uint32Array: !1,
              Uint8Array: !1,
              Uint8ClampedArray: !1,
              undefined: !1,
              unescape: !1,
              URIError: !1,
              valueOf: !1,
              WeakMap: !1,
              WeakSet: !1
            },
            es5: {
              Array: !1,
              Boolean: !1,
              constructor: !1,
              Date: !1,
              decodeURI: !1,
              decodeURIComponent: !1,
              encodeURI: !1,
              encodeURIComponent: !1,
              Error: !1,
              escape: !1,
              eval: !1,
              EvalError: !1,
              Function: !1,
              hasOwnProperty: !1,
              Infinity: !1,
              isFinite: !1,
              isNaN: !1,
              isPrototypeOf: !1,
              JSON: !1,
              Math: !1,
              NaN: !1,
              Number: !1,
              Object: !1,
              parseFloat: !1,
              parseInt: !1,
              propertyIsEnumerable: !1,
              RangeError: !1,
              ReferenceError: !1,
              RegExp: !1,
              String: !1,
              SyntaxError: !1,
              toLocaleString: !1,
              toString: !1,
              TypeError: !1,
              undefined: !1,
              unescape: !1,
              URIError: !1,
              valueOf: !1
            },
            es2015: {
              Array: !1,
              ArrayBuffer: !1,
              Boolean: !1,
              constructor: !1,
              DataView: !1,
              Date: !1,
              decodeURI: !1,
              decodeURIComponent: !1,
              encodeURI: !1,
              encodeURIComponent: !1,
              Error: !1,
              escape: !1,
              eval: !1,
              EvalError: !1,
              Float32Array: !1,
              Float64Array: !1,
              Function: !1,
              hasOwnProperty: !1,
              Infinity: !1,
              Int16Array: !1,
              Int32Array: !1,
              Int8Array: !1,
              isFinite: !1,
              isNaN: !1,
              isPrototypeOf: !1,
              JSON: !1,
              Map: !1,
              Math: !1,
              NaN: !1,
              Number: !1,
              Object: !1,
              parseFloat: !1,
              parseInt: !1,
              Promise: !1,
              propertyIsEnumerable: !1,
              Proxy: !1,
              RangeError: !1,
              ReferenceError: !1,
              Reflect: !1,
              RegExp: !1,
              Set: !1,
              String: !1,
              Symbol: !1,
              SyntaxError: !1,
              toLocaleString: !1,
              toString: !1,
              TypeError: !1,
              Uint16Array: !1,
              Uint32Array: !1,
              Uint8Array: !1,
              Uint8ClampedArray: !1,
              undefined: !1,
              unescape: !1,
              URIError: !1,
              valueOf: !1,
              WeakMap: !1,
              WeakSet: !1
            },
            es2017: {
              Array: !1,
              ArrayBuffer: !1,
              Atomics: !1,
              Boolean: !1,
              constructor: !1,
              DataView: !1,
              Date: !1,
              decodeURI: !1,
              decodeURIComponent: !1,
              encodeURI: !1,
              encodeURIComponent: !1,
              Error: !1,
              escape: !1,
              eval: !1,
              EvalError: !1,
              Float32Array: !1,
              Float64Array: !1,
              Function: !1,
              hasOwnProperty: !1,
              Infinity: !1,
              Int16Array: !1,
              Int32Array: !1,
              Int8Array: !1,
              isFinite: !1,
              isNaN: !1,
              isPrototypeOf: !1,
              JSON: !1,
              Map: !1,
              Math: !1,
              NaN: !1,
              Number: !1,
              Object: !1,
              parseFloat: !1,
              parseInt: !1,
              Promise: !1,
              propertyIsEnumerable: !1,
              Proxy: !1,
              RangeError: !1,
              ReferenceError: !1,
              Reflect: !1,
              RegExp: !1,
              Set: !1,
              SharedArrayBuffer: !1,
              String: !1,
              Symbol: !1,
              SyntaxError: !1,
              toLocaleString: !1,
              toString: !1,
              TypeError: !1,
              Uint16Array: !1,
              Uint32Array: !1,
              Uint8Array: !1,
              Uint8ClampedArray: !1,
              undefined: !1,
              unescape: !1,
              URIError: !1,
              valueOf: !1,
              WeakMap: !1,
              WeakSet: !1
            },
            browser: {
              AbortController: !1,
              AbortSignal: !1,
              addEventListener: !1,
              alert: !1,
              AnalyserNode: !1,
              Animation: !1,
              AnimationEffectReadOnly: !1,
              AnimationEffectTiming: !1,
              AnimationEffectTimingReadOnly: !1,
              AnimationEvent: !1,
              AnimationPlaybackEvent: !1,
              AnimationTimeline: !1,
              applicationCache: !1,
              ApplicationCache: !1,
              ApplicationCacheErrorEvent: !1,
              atob: !1,
              Attr: !1,
              Audio: !1,
              AudioBuffer: !1,
              AudioBufferSourceNode: !1,
              AudioContext: !1,
              AudioDestinationNode: !1,
              AudioListener: !1,
              AudioNode: !1,
              AudioParam: !1,
              AudioProcessingEvent: !1,
              AudioScheduledSourceNode: !1,
              "AudioWorkletGlobalScope ": !1,
              AudioWorkletNode: !1,
              AudioWorkletProcessor: !1,
              BarProp: !1,
              BaseAudioContext: !1,
              BatteryManager: !1,
              BeforeUnloadEvent: !1,
              BiquadFilterNode: !1,
              Blob: !1,
              BlobEvent: !1,
              blur: !1,
              BroadcastChannel: !1,
              btoa: !1,
              BudgetService: !1,
              ByteLengthQueuingStrategy: !1,
              Cache: !1,
              caches: !1,
              CacheStorage: !1,
              cancelAnimationFrame: !1,
              cancelIdleCallback: !1,
              CanvasCaptureMediaStreamTrack: !1,
              CanvasGradient: !1,
              CanvasPattern: !1,
              CanvasRenderingContext2D: !1,
              ChannelMergerNode: !1,
              ChannelSplitterNode: !1,
              CharacterData: !1,
              clearInterval: !1,
              clearTimeout: !1,
              clientInformation: !1,
              ClipboardEvent: !1,
              close: !1,
              closed: !1,
              CloseEvent: !1,
              Comment: !1,
              CompositionEvent: !1,
              confirm: !1,
              console: !1,
              ConstantSourceNode: !1,
              ConvolverNode: !1,
              CountQueuingStrategy: !1,
              createImageBitmap: !1,
              Credential: !1,
              CredentialsContainer: !1,
              crypto: !1,
              Crypto: !1,
              CryptoKey: !1,
              CSS: !1,
              CSSConditionRule: !1,
              CSSFontFaceRule: !1,
              CSSGroupingRule: !1,
              CSSImportRule: !1,
              CSSKeyframeRule: !1,
              CSSKeyframesRule: !1,
              CSSMediaRule: !1,
              CSSNamespaceRule: !1,
              CSSPageRule: !1,
              CSSRule: !1,
              CSSRuleList: !1,
              CSSStyleDeclaration: !1,
              CSSStyleRule: !1,
              CSSStyleSheet: !1,
              CSSSupportsRule: !1,
              CustomElementRegistry: !1,
              customElements: !1,
              CustomEvent: !1,
              DataTransfer: !1,
              DataTransferItem: !1,
              DataTransferItemList: !1,
              defaultstatus: !1,
              defaultStatus: !1,
              DelayNode: !1,
              DeviceMotionEvent: !1,
              DeviceOrientationEvent: !1,
              devicePixelRatio: !1,
              dispatchEvent: !1,
              document: !1,
              Document: !1,
              DocumentFragment: !1,
              DocumentType: !1,
              DOMError: !1,
              DOMException: !1,
              DOMImplementation: !1,
              DOMMatrix: !1,
              DOMMatrixReadOnly: !1,
              DOMParser: !1,
              DOMPoint: !1,
              DOMPointReadOnly: !1,
              DOMQuad: !1,
              DOMRect: !1,
              DOMRectReadOnly: !1,
              DOMStringList: !1,
              DOMStringMap: !1,
              DOMTokenList: !1,
              DragEvent: !1,
              DynamicsCompressorNode: !1,
              Element: !1,
              ErrorEvent: !1,
              event: !1,
              Event: !1,
              EventSource: !1,
              EventTarget: !1,
              external: !1,
              fetch: !1,
              File: !1,
              FileList: !1,
              FileReader: !1,
              find: !1,
              focus: !1,
              FocusEvent: !1,
              FontFace: !1,
              FontFaceSetLoadEvent: !1,
              FormData: !1,
              frameElement: !1,
              frames: !1,
              GainNode: !1,
              Gamepad: !1,
              GamepadButton: !1,
              GamepadEvent: !1,
              getComputedStyle: !1,
              getSelection: !1,
              HashChangeEvent: !1,
              Headers: !1,
              history: !1,
              History: !1,
              HTMLAllCollection: !1,
              HTMLAnchorElement: !1,
              HTMLAreaElement: !1,
              HTMLAudioElement: !1,
              HTMLBaseElement: !1,
              HTMLBodyElement: !1,
              HTMLBRElement: !1,
              HTMLButtonElement: !1,
              HTMLCanvasElement: !1,
              HTMLCollection: !1,
              HTMLContentElement: !1,
              HTMLDataElement: !1,
              HTMLDataListElement: !1,
              HTMLDetailsElement: !1,
              HTMLDialogElement: !1,
              HTMLDirectoryElement: !1,
              HTMLDivElement: !1,
              HTMLDListElement: !1,
              HTMLDocument: !1,
              HTMLElement: !1,
              HTMLEmbedElement: !1,
              HTMLFieldSetElement: !1,
              HTMLFontElement: !1,
              HTMLFormControlsCollection: !1,
              HTMLFormElement: !1,
              HTMLFrameElement: !1,
              HTMLFrameSetElement: !1,
              HTMLHeadElement: !1,
              HTMLHeadingElement: !1,
              HTMLHRElement: !1,
              HTMLHtmlElement: !1,
              HTMLIFrameElement: !1,
              HTMLImageElement: !1,
              HTMLInputElement: !1,
              HTMLLabelElement: !1,
              HTMLLegendElement: !1,
              HTMLLIElement: !1,
              HTMLLinkElement: !1,
              HTMLMapElement: !1,
              HTMLMarqueeElement: !1,
              HTMLMediaElement: !1,
              HTMLMenuElement: !1,
              HTMLMetaElement: !1,
              HTMLMeterElement: !1,
              HTMLModElement: !1,
              HTMLObjectElement: !1,
              HTMLOListElement: !1,
              HTMLOptGroupElement: !1,
              HTMLOptionElement: !1,
              HTMLOptionsCollection: !1,
              HTMLOutputElement: !1,
              HTMLParagraphElement: !1,
              HTMLParamElement: !1,
              HTMLPictureElement: !1,
              HTMLPreElement: !1,
              HTMLProgressElement: !1,
              HTMLQuoteElement: !1,
              HTMLScriptElement: !1,
              HTMLSelectElement: !1,
              HTMLShadowElement: !1,
              HTMLSlotElement: !1,
              HTMLSourceElement: !1,
              HTMLSpanElement: !1,
              HTMLStyleElement: !1,
              HTMLTableCaptionElement: !1,
              HTMLTableCellElement: !1,
              HTMLTableColElement: !1,
              HTMLTableElement: !1,
              HTMLTableRowElement: !1,
              HTMLTableSectionElement: !1,
              HTMLTemplateElement: !1,
              HTMLTextAreaElement: !1,
              HTMLTimeElement: !1,
              HTMLTitleElement: !1,
              HTMLTrackElement: !1,
              HTMLUListElement: !1,
              HTMLUnknownElement: !1,
              HTMLVideoElement: !1,
              IDBCursor: !1,
              IDBCursorWithValue: !1,
              IDBDatabase: !1,
              IDBFactory: !1,
              IDBIndex: !1,
              IDBKeyRange: !1,
              IDBObjectStore: !1,
              IDBOpenDBRequest: !1,
              IDBRequest: !1,
              IDBTransaction: !1,
              IDBVersionChangeEvent: !1,
              IdleDeadline: !1,
              IIRFilterNode: !1,
              Image: !1,
              ImageBitmap: !1,
              ImageBitmapRenderingContext: !1,
              ImageCapture: !1,
              ImageData: !1,
              indexedDB: !1,
              innerHeight: !1,
              innerWidth: !1,
              InputEvent: !1,
              IntersectionObserver: !1,
              IntersectionObserverEntry: !1,
              Intl: !1,
              isSecureContext: !1,
              KeyboardEvent: !1,
              KeyframeEffect: !1,
              KeyframeEffectReadOnly: !1,
              length: !1,
              localStorage: !1,
              location: !0,
              Location: !1,
              locationbar: !1,
              matchMedia: !1,
              MediaDeviceInfo: !1,
              MediaDevices: !1,
              MediaElementAudioSourceNode: !1,
              MediaEncryptedEvent: !1,
              MediaError: !1,
              MediaKeyMessageEvent: !1,
              MediaKeySession: !1,
              MediaKeyStatusMap: !1,
              MediaKeySystemAccess: !1,
              MediaList: !1,
              MediaQueryList: !1,
              MediaQueryListEvent: !1,
              MediaRecorder: !1,
              MediaSettingsRange: !1,
              MediaSource: !1,
              MediaStream: !1,
              MediaStreamAudioDestinationNode: !1,
              MediaStreamAudioSourceNode: !1,
              MediaStreamEvent: !1,
              MediaStreamTrack: !1,
              MediaStreamTrackEvent: !1,
              menubar: !1,
              MessageChannel: !1,
              MessageEvent: !1,
              MessagePort: !1,
              MIDIAccess: !1,
              MIDIConnectionEvent: !1,
              MIDIInput: !1,
              MIDIInputMap: !1,
              MIDIMessageEvent: !1,
              MIDIOutput: !1,
              MIDIOutputMap: !1,
              MIDIPort: !1,
              MimeType: !1,
              MimeTypeArray: !1,
              MouseEvent: !1,
              moveBy: !1,
              moveTo: !1,
              MutationEvent: !1,
              MutationObserver: !1,
              MutationRecord: !1,
              name: !1,
              NamedNodeMap: !1,
              NavigationPreloadManager: !1,
              navigator: !1,
              Navigator: !1,
              NetworkInformation: !1,
              Node: !1,
              NodeFilter: !1,
              NodeIterator: !1,
              NodeList: !1,
              Notification: !1,
              OfflineAudioCompletionEvent: !1,
              OfflineAudioContext: !1,
              offscreenBuffering: !1,
              OffscreenCanvas: !0,
              onabort: !0,
              onafterprint: !0,
              onanimationend: !0,
              onanimationiteration: !0,
              onanimationstart: !0,
              onappinstalled: !0,
              onauxclick: !0,
              onbeforeinstallprompt: !0,
              onbeforeprint: !0,
              onbeforeunload: !0,
              onblur: !0,
              oncancel: !0,
              oncanplay: !0,
              oncanplaythrough: !0,
              onchange: !0,
              onclick: !0,
              onclose: !0,
              oncontextmenu: !0,
              oncuechange: !0,
              ondblclick: !0,
              ondevicemotion: !0,
              ondeviceorientation: !0,
              ondeviceorientationabsolute: !0,
              ondrag: !0,
              ondragend: !0,
              ondragenter: !0,
              ondragleave: !0,
              ondragover: !0,
              ondragstart: !0,
              ondrop: !0,
              ondurationchange: !0,
              onemptied: !0,
              onended: !0,
              onerror: !0,
              onfocus: !0,
              ongotpointercapture: !0,
              onhashchange: !0,
              oninput: !0,
              oninvalid: !0,
              onkeydown: !0,
              onkeypress: !0,
              onkeyup: !0,
              onlanguagechange: !0,
              onload: !0,
              onloadeddata: !0,
              onloadedmetadata: !0,
              onloadstart: !0,
              onlostpointercapture: !0,
              onmessage: !0,
              onmessageerror: !0,
              onmousedown: !0,
              onmouseenter: !0,
              onmouseleave: !0,
              onmousemove: !0,
              onmouseout: !0,
              onmouseover: !0,
              onmouseup: !0,
              onmousewheel: !0,
              onoffline: !0,
              ononline: !0,
              onpagehide: !0,
              onpageshow: !0,
              onpause: !0,
              onplay: !0,
              onplaying: !0,
              onpointercancel: !0,
              onpointerdown: !0,
              onpointerenter: !0,
              onpointerleave: !0,
              onpointermove: !0,
              onpointerout: !0,
              onpointerover: !0,
              onpointerup: !0,
              onpopstate: !0,
              onprogress: !0,
              onratechange: !0,
              onrejectionhandled: !0,
              onreset: !0,
              onresize: !0,
              onscroll: !0,
              onsearch: !0,
              onseeked: !0,
              onseeking: !0,
              onselect: !0,
              onstalled: !0,
              onstorage: !0,
              onsubmit: !0,
              onsuspend: !0,
              ontimeupdate: !0,
              ontoggle: !0,
              ontransitionend: !0,
              onunhandledrejection: !0,
              onunload: !0,
              onvolumechange: !0,
              onwaiting: !0,
              onwheel: !0,
              open: !1,
              openDatabase: !1,
              opener: !1,
              Option: !1,
              origin: !1,
              OscillatorNode: !1,
              outerHeight: !1,
              outerWidth: !1,
              PageTransitionEvent: !1,
              pageXOffset: !1,
              pageYOffset: !1,
              PannerNode: !1,
              parent: !1,
              Path2D: !1,
              PaymentAddress: !1,
              PaymentRequest: !1,
              PaymentRequestUpdateEvent: !1,
              PaymentResponse: !1,
              performance: !1,
              Performance: !1,
              PerformanceEntry: !1,
              PerformanceLongTaskTiming: !1,
              PerformanceMark: !1,
              PerformanceMeasure: !1,
              PerformanceNavigation: !1,
              PerformanceNavigationTiming: !1,
              PerformanceObserver: !1,
              PerformanceObserverEntryList: !1,
              PerformancePaintTiming: !1,
              PerformanceResourceTiming: !1,
              PerformanceTiming: !1,
              PeriodicWave: !1,
              Permissions: !1,
              PermissionStatus: !1,
              personalbar: !1,
              PhotoCapabilities: !1,
              Plugin: !1,
              PluginArray: !1,
              PointerEvent: !1,
              PopStateEvent: !1,
              postMessage: !1,
              Presentation: !1,
              PresentationAvailability: !1,
              PresentationConnection: !1,
              PresentationConnectionAvailableEvent: !1,
              PresentationConnectionCloseEvent: !1,
              PresentationConnectionList: !1,
              PresentationReceiver: !1,
              PresentationRequest: !1,
              print: !1,
              ProcessingInstruction: !1,
              ProgressEvent: !1,
              PromiseRejectionEvent: !1,
              prompt: !1,
              PushManager: !1,
              PushSubscription: !1,
              PushSubscriptionOptions: !1,
              queueMicrotask: !1,
              RadioNodeList: !1,
              Range: !1,
              ReadableStream: !1,
              registerProcessor: !1,
              RemotePlayback: !1,
              removeEventListener: !1,
              Request: !1,
              requestAnimationFrame: !1,
              requestIdleCallback: !1,
              resizeBy: !1,
              ResizeObserver: !1,
              ResizeObserverEntry: !1,
              resizeTo: !1,
              Response: !1,
              RTCCertificate: !1,
              RTCDataChannel: !1,
              RTCDataChannelEvent: !1,
              RTCDtlsTransport: !1,
              RTCIceCandidate: !1,
              RTCIceGatherer: !1,
              RTCIceTransport: !1,
              RTCPeerConnection: !1,
              RTCPeerConnectionIceEvent: !1,
              RTCRtpContributingSource: !1,
              RTCRtpReceiver: !1,
              RTCRtpSender: !1,
              RTCSctpTransport: !1,
              RTCSessionDescription: !1,
              RTCStatsReport: !1,
              RTCTrackEvent: !1,
              screen: !1,
              Screen: !1,
              screenLeft: !1,
              ScreenOrientation: !1,
              screenTop: !1,
              screenX: !1,
              screenY: !1,
              ScriptProcessorNode: !1,
              scroll: !1,
              scrollbars: !1,
              scrollBy: !1,
              scrollTo: !1,
              scrollX: !1,
              scrollY: !1,
              SecurityPolicyViolationEvent: !1,
              Selection: !1,
              self: !1,
              ServiceWorker: !1,
              ServiceWorkerContainer: !1,
              ServiceWorkerRegistration: !1,
              sessionStorage: !1,
              setInterval: !1,
              setTimeout: !1,
              ShadowRoot: !1,
              SharedWorker: !1,
              SourceBuffer: !1,
              SourceBufferList: !1,
              speechSynthesis: !1,
              SpeechSynthesisEvent: !1,
              SpeechSynthesisUtterance: !1,
              StaticRange: !1,
              status: !1,
              statusbar: !1,
              StereoPannerNode: !1,
              stop: !1,
              Storage: !1,
              StorageEvent: !1,
              StorageManager: !1,
              styleMedia: !1,
              StyleSheet: !1,
              StyleSheetList: !1,
              SubtleCrypto: !1,
              SVGAElement: !1,
              SVGAngle: !1,
              SVGAnimatedAngle: !1,
              SVGAnimatedBoolean: !1,
              SVGAnimatedEnumeration: !1,
              SVGAnimatedInteger: !1,
              SVGAnimatedLength: !1,
              SVGAnimatedLengthList: !1,
              SVGAnimatedNumber: !1,
              SVGAnimatedNumberList: !1,
              SVGAnimatedPreserveAspectRatio: !1,
              SVGAnimatedRect: !1,
              SVGAnimatedString: !1,
              SVGAnimatedTransformList: !1,
              SVGAnimateElement: !1,
              SVGAnimateMotionElement: !1,
              SVGAnimateTransformElement: !1,
              SVGAnimationElement: !1,
              SVGCircleElement: !1,
              SVGClipPathElement: !1,
              SVGComponentTransferFunctionElement: !1,
              SVGDefsElement: !1,
              SVGDescElement: !1,
              SVGDiscardElement: !1,
              SVGElement: !1,
              SVGEllipseElement: !1,
              SVGFEBlendElement: !1,
              SVGFEColorMatrixElement: !1,
              SVGFEComponentTransferElement: !1,
              SVGFECompositeElement: !1,
              SVGFEConvolveMatrixElement: !1,
              SVGFEDiffuseLightingElement: !1,
              SVGFEDisplacementMapElement: !1,
              SVGFEDistantLightElement: !1,
              SVGFEDropShadowElement: !1,
              SVGFEFloodElement: !1,
              SVGFEFuncAElement: !1,
              SVGFEFuncBElement: !1,
              SVGFEFuncGElement: !1,
              SVGFEFuncRElement: !1,
              SVGFEGaussianBlurElement: !1,
              SVGFEImageElement: !1,
              SVGFEMergeElement: !1,
              SVGFEMergeNodeElement: !1,
              SVGFEMorphologyElement: !1,
              SVGFEOffsetElement: !1,
              SVGFEPointLightElement: !1,
              SVGFESpecularLightingElement: !1,
              SVGFESpotLightElement: !1,
              SVGFETileElement: !1,
              SVGFETurbulenceElement: !1,
              SVGFilterElement: !1,
              SVGForeignObjectElement: !1,
              SVGGElement: !1,
              SVGGeometryElement: !1,
              SVGGradientElement: !1,
              SVGGraphicsElement: !1,
              SVGImageElement: !1,
              SVGLength: !1,
              SVGLengthList: !1,
              SVGLinearGradientElement: !1,
              SVGLineElement: !1,
              SVGMarkerElement: !1,
              SVGMaskElement: !1,
              SVGMatrix: !1,
              SVGMetadataElement: !1,
              SVGMPathElement: !1,
              SVGNumber: !1,
              SVGNumberList: !1,
              SVGPathElement: !1,
              SVGPatternElement: !1,
              SVGPoint: !1,
              SVGPointList: !1,
              SVGPolygonElement: !1,
              SVGPolylineElement: !1,
              SVGPreserveAspectRatio: !1,
              SVGRadialGradientElement: !1,
              SVGRect: !1,
              SVGRectElement: !1,
              SVGScriptElement: !1,
              SVGSetElement: !1,
              SVGStopElement: !1,
              SVGStringList: !1,
              SVGStyleElement: !1,
              SVGSVGElement: !1,
              SVGSwitchElement: !1,
              SVGSymbolElement: !1,
              SVGTextContentElement: !1,
              SVGTextElement: !1,
              SVGTextPathElement: !1,
              SVGTextPositioningElement: !1,
              SVGTitleElement: !1,
              SVGTransform: !1,
              SVGTransformList: !1,
              SVGTSpanElement: !1,
              SVGUnitTypes: !1,
              SVGUseElement: !1,
              SVGViewElement: !1,
              TaskAttributionTiming: !1,
              Text: !1,
              TextDecoder: !1,
              TextEncoder: !1,
              TextEvent: !1,
              TextMetrics: !1,
              TextTrack: !1,
              TextTrackCue: !1,
              TextTrackCueList: !1,
              TextTrackList: !1,
              TimeRanges: !1,
              toolbar: !1,
              top: !1,
              Touch: !1,
              TouchEvent: !1,
              TouchList: !1,
              TrackEvent: !1,
              TransitionEvent: !1,
              TreeWalker: !1,
              UIEvent: !1,
              URL: !1,
              URLSearchParams: !1,
              ValidityState: !1,
              visualViewport: !1,
              VisualViewport: !1,
              VTTCue: !1,
              WaveShaperNode: !1,
              WebAssembly: !1,
              WebGL2RenderingContext: !1,
              WebGLActiveInfo: !1,
              WebGLBuffer: !1,
              WebGLContextEvent: !1,
              WebGLFramebuffer: !1,
              WebGLProgram: !1,
              WebGLQuery: !1,
              WebGLRenderbuffer: !1,
              WebGLRenderingContext: !1,
              WebGLSampler: !1,
              WebGLShader: !1,
              WebGLShaderPrecisionFormat: !1,
              WebGLSync: !1,
              WebGLTexture: !1,
              WebGLTransformFeedback: !1,
              WebGLUniformLocation: !1,
              WebGLVertexArrayObject: !1,
              WebSocket: !1,
              WheelEvent: !1,
              window: !1,
              Window: !1,
              Worker: !1,
              WritableStream: !1,
              XMLDocument: !1,
              XMLHttpRequest: !1,
              XMLHttpRequestEventTarget: !1,
              XMLHttpRequestUpload: !1,
              XMLSerializer: !1,
              XPathEvaluator: !1,
              XPathExpression: !1,
              XPathResult: !1,
              XSLTProcessor: !1
            },
            worker: {
              addEventListener: !1,
              applicationCache: !1,
              atob: !1,
              Blob: !1,
              BroadcastChannel: !1,
              btoa: !1,
              Cache: !1,
              caches: !1,
              clearInterval: !1,
              clearTimeout: !1,
              close: !0,
              console: !1,
              fetch: !1,
              FileReaderSync: !1,
              FormData: !1,
              Headers: !1,
              IDBCursor: !1,
              IDBCursorWithValue: !1,
              IDBDatabase: !1,
              IDBFactory: !1,
              IDBIndex: !1,
              IDBKeyRange: !1,
              IDBObjectStore: !1,
              IDBOpenDBRequest: !1,
              IDBRequest: !1,
              IDBTransaction: !1,
              IDBVersionChangeEvent: !1,
              ImageData: !1,
              importScripts: !0,
              indexedDB: !1,
              location: !1,
              MessageChannel: !1,
              MessagePort: !1,
              name: !1,
              navigator: !1,
              Notification: !1,
              onclose: !0,
              onconnect: !0,
              onerror: !0,
              onlanguagechange: !0,
              onmessage: !0,
              onoffline: !0,
              ononline: !0,
              onrejectionhandled: !0,
              onunhandledrejection: !0,
              performance: !1,
              Performance: !1,
              PerformanceEntry: !1,
              PerformanceMark: !1,
              PerformanceMeasure: !1,
              PerformanceNavigation: !1,
              PerformanceResourceTiming: !1,
              PerformanceTiming: !1,
              postMessage: !0,
              Promise: !1,
              queueMicrotask: !1,
              removeEventListener: !1,
              Request: !1,
              Response: !1,
              self: !0,
              ServiceWorkerRegistration: !1,
              setInterval: !1,
              setTimeout: !1,
              TextDecoder: !1,
              TextEncoder: !1,
              URL: !1,
              URLSearchParams: !1,
              WebSocket: !1,
              Worker: !1,
              WorkerGlobalScope: !1,
              XMLHttpRequest: !1
            },
            node: {
              __dirname: !1,
              __filename: !1,
              Buffer: !1,
              clearImmediate: !1,
              clearInterval: !1,
              clearTimeout: !1,
              console: !1,
              exports: !0,
              global: !1,
              Intl: !1,
              module: !1,
              process: !1,
              queueMicrotask: !1,
              require: !1,
              setImmediate: !1,
              setInterval: !1,
              setTimeout: !1,
              TextDecoder: !1,
              TextEncoder: !1,
              URL: !1,
              URLSearchParams: !1
            },
            commonjs: { exports: !0, global: !1, module: !1, require: !1 },
            amd: { define: !1, require: !1 },
            mocha: {
              after: !1,
              afterEach: !1,
              before: !1,
              beforeEach: !1,
              context: !1,
              describe: !1,
              it: !1,
              mocha: !1,
              run: !1,
              setup: !1,
              specify: !1,
              suite: !1,
              suiteSetup: !1,
              suiteTeardown: !1,
              teardown: !1,
              test: !1,
              xcontext: !1,
              xdescribe: !1,
              xit: !1,
              xspecify: !1
            },
            jasmine: {
              afterAll: !1,
              afterEach: !1,
              beforeAll: !1,
              beforeEach: !1,
              describe: !1,
              expect: !1,
              fail: !1,
              fdescribe: !1,
              fit: !1,
              it: !1,
              jasmine: !1,
              pending: !1,
              runs: !1,
              spyOn: !1,
              spyOnProperty: !1,
              waits: !1,
              waitsFor: !1,
              xdescribe: !1,
              xit: !1
            },
            jest: {
              afterAll: !1,
              afterEach: !1,
              beforeAll: !1,
              beforeEach: !1,
              describe: !1,
              expect: !1,
              fdescribe: !1,
              fit: !1,
              it: !1,
              jest: !1,
              pit: !1,
              require: !1,
              test: !1,
              xdescribe: !1,
              xit: !1,
              xtest: !1
            },
            qunit: {
              asyncTest: !1,
              deepEqual: !1,
              equal: !1,
              expect: !1,
              module: !1,
              notDeepEqual: !1,
              notEqual: !1,
              notOk: !1,
              notPropEqual: !1,
              notStrictEqual: !1,
              ok: !1,
              propEqual: !1,
              QUnit: !1,
              raises: !1,
              start: !1,
              stop: !1,
              strictEqual: !1,
              test: !1,
              throws: !1
            },
            phantomjs: {
              console: !0,
              exports: !0,
              phantom: !0,
              require: !0,
              WebPage: !0
            },
            couch: {
              emit: !1,
              exports: !1,
              getRow: !1,
              log: !1,
              module: !1,
              provides: !1,
              require: !1,
              respond: !1,
              send: !1,
              start: !1,
              sum: !1
            },
            rhino: {
              defineClass: !1,
              deserialize: !1,
              gc: !1,
              help: !1,
              importClass: !1,
              importPackage: !1,
              java: !1,
              load: !1,
              loadClass: !1,
              Packages: !1,
              print: !1,
              quit: !1,
              readFile: !1,
              readUrl: !1,
              runCommand: !1,
              seal: !1,
              serialize: !1,
              spawn: !1,
              sync: !1,
              toint32: !1,
              version: !1
            },
            nashorn: {
              __DIR__: !1,
              __FILE__: !1,
              __LINE__: !1,
              com: !1,
              edu: !1,
              exit: !1,
              java: !1,
              Java: !1,
              javafx: !1,
              JavaImporter: !1,
              javax: !1,
              JSAdapter: !1,
              load: !1,
              loadWithNewGlobal: !1,
              org: !1,
              Packages: !1,
              print: !1,
              quit: !1
            },
            wsh: {
              ActiveXObject: !0,
              Enumerator: !0,
              GetObject: !0,
              ScriptEngine: !0,
              ScriptEngineBuildVersion: !0,
              ScriptEngineMajorVersion: !0,
              ScriptEngineMinorVersion: !0,
              VBArray: !0,
              WScript: !0,
              WSH: !0,
              XDomainRequest: !0
            },
            jquery: { $: !1, jQuery: !1 },
            yui: { YAHOO: !1, YAHOO_config: !1, YUI: !1, YUI_config: !1 },
            shelljs: {
              cat: !1,
              cd: !1,
              chmod: !1,
              config: !1,
              cp: !1,
              dirs: !1,
              echo: !1,
              env: !1,
              error: !1,
              exec: !1,
              exit: !1,
              find: !1,
              grep: !1,
              ln: !1,
              ls: !1,
              mkdir: !1,
              mv: !1,
              popd: !1,
              pushd: !1,
              pwd: !1,
              rm: !1,
              sed: !1,
              set: !1,
              target: !1,
              tempdir: !1,
              test: !1,
              touch: !1,
              which: !1
            },
            prototypejs: {
              $: !1,
              $$: !1,
              $A: !1,
              $break: !1,
              $continue: !1,
              $F: !1,
              $H: !1,
              $R: !1,
              $w: !1,
              Abstract: !1,
              Ajax: !1,
              Autocompleter: !1,
              Builder: !1,
              Class: !1,
              Control: !1,
              Draggable: !1,
              Draggables: !1,
              Droppables: !1,
              Effect: !1,
              Element: !1,
              Enumerable: !1,
              Event: !1,
              Field: !1,
              Form: !1,
              Hash: !1,
              Insertion: !1,
              ObjectRange: !1,
              PeriodicalExecuter: !1,
              Position: !1,
              Prototype: !1,
              Scriptaculous: !1,
              Selector: !1,
              Sortable: !1,
              SortableObserver: !1,
              Sound: !1,
              Template: !1,
              Toggle: !1,
              Try: !1
            },
            meteor: {
              _: !1,
              $: !1,
              Accounts: !1,
              AccountsClient: !1,
              AccountsCommon: !1,
              AccountsServer: !1,
              App: !1,
              Assets: !1,
              Blaze: !1,
              check: !1,
              Cordova: !1,
              DDP: !1,
              DDPRateLimiter: !1,
              DDPServer: !1,
              Deps: !1,
              EJSON: !1,
              Email: !1,
              HTTP: !1,
              Log: !1,
              Match: !1,
              Meteor: !1,
              Mongo: !1,
              MongoInternals: !1,
              Npm: !1,
              Package: !1,
              Plugin: !1,
              process: !1,
              Random: !1,
              ReactiveDict: !1,
              ReactiveVar: !1,
              Router: !1,
              ServiceConfiguration: !1,
              Session: !1,
              share: !1,
              Spacebars: !1,
              Template: !1,
              Tinytest: !1,
              Tracker: !1,
              UI: !1,
              Utils: !1,
              WebApp: !1,
              WebAppInternals: !1
            },
            mongo: {
              _isWindows: !1,
              _rand: !1,
              BulkWriteResult: !1,
              cat: !1,
              cd: !1,
              connect: !1,
              db: !1,
              getHostName: !1,
              getMemInfo: !1,
              hostname: !1,
              ISODate: !1,
              listFiles: !1,
              load: !1,
              ls: !1,
              md5sumFile: !1,
              mkdir: !1,
              Mongo: !1,
              NumberInt: !1,
              NumberLong: !1,
              ObjectId: !1,
              PlanCache: !1,
              print: !1,
              printjson: !1,
              pwd: !1,
              quit: !1,
              removeFile: !1,
              rs: !1,
              sh: !1,
              UUID: !1,
              version: !1,
              WriteResult: !1
            },
            applescript: {
              $: !1,
              Application: !1,
              Automation: !1,
              console: !1,
              delay: !1,
              Library: !1,
              ObjC: !1,
              ObjectSpecifier: !1,
              Path: !1,
              Progress: !1,
              Ref: !1
            },
            serviceworker: {
              addEventListener: !1,
              applicationCache: !1,
              atob: !1,
              Blob: !1,
              BroadcastChannel: !1,
              btoa: !1,
              Cache: !1,
              caches: !1,
              CacheStorage: !1,
              clearInterval: !1,
              clearTimeout: !1,
              Client: !1,
              clients: !1,
              Clients: !1,
              close: !0,
              console: !1,
              ExtendableEvent: !1,
              ExtendableMessageEvent: !1,
              fetch: !1,
              FetchEvent: !1,
              FileReaderSync: !1,
              FormData: !1,
              Headers: !1,
              IDBCursor: !1,
              IDBCursorWithValue: !1,
              IDBDatabase: !1,
              IDBFactory: !1,
              IDBIndex: !1,
              IDBKeyRange: !1,
              IDBObjectStore: !1,
              IDBOpenDBRequest: !1,
              IDBRequest: !1,
              IDBTransaction: !1,
              IDBVersionChangeEvent: !1,
              ImageData: !1,
              importScripts: !1,
              indexedDB: !1,
              location: !1,
              MessageChannel: !1,
              MessagePort: !1,
              name: !1,
              navigator: !1,
              Notification: !1,
              onclose: !0,
              onconnect: !0,
              onerror: !0,
              onfetch: !0,
              oninstall: !0,
              onlanguagechange: !0,
              onmessage: !0,
              onmessageerror: !0,
              onnotificationclick: !0,
              onnotificationclose: !0,
              onoffline: !0,
              ononline: !0,
              onpush: !0,
              onpushsubscriptionchange: !0,
              onrejectionhandled: !0,
              onsync: !0,
              onunhandledrejection: !0,
              performance: !1,
              Performance: !1,
              PerformanceEntry: !1,
              PerformanceMark: !1,
              PerformanceMeasure: !1,
              PerformanceNavigation: !1,
              PerformanceResourceTiming: !1,
              PerformanceTiming: !1,
              postMessage: !0,
              Promise: !1,
              queueMicrotask: !1,
              registration: !1,
              removeEventListener: !1,
              Request: !1,
              Response: !1,
              self: !1,
              ServiceWorker: !1,
              ServiceWorkerContainer: !1,
              ServiceWorkerGlobalScope: !1,
              ServiceWorkerMessageEvent: !1,
              ServiceWorkerRegistration: !1,
              setInterval: !1,
              setTimeout: !1,
              skipWaiting: !1,
              TextDecoder: !1,
              TextEncoder: !1,
              URL: !1,
              URLSearchParams: !1,
              WebSocket: !1,
              WindowClient: !1,
              Worker: !1,
              WorkerGlobalScope: !1,
              XMLHttpRequest: !1
            },
            atomtest: {
              advanceClock: !1,
              fakeClearInterval: !1,
              fakeClearTimeout: !1,
              fakeSetInterval: !1,
              fakeSetTimeout: !1,
              resetTimeouts: !1,
              waitsForPromise: !1
            },
            embertest: {
              andThen: !1,
              click: !1,
              currentPath: !1,
              currentRouteName: !1,
              currentURL: !1,
              fillIn: !1,
              find: !1,
              findAll: !1,
              findWithAssert: !1,
              keyEvent: !1,
              pauseTest: !1,
              resumeTest: !1,
              triggerEvent: !1,
              visit: !1,
              wait: !1
            },
            protractor: {
              $: !1,
              $$: !1,
              browser: !1,
              by: !1,
              By: !1,
              DartObject: !1,
              element: !1,
              protractor: !1
            },
            "shared-node-browser": {
              clearInterval: !1,
              clearTimeout: !1,
              console: !1,
              setInterval: !1,
              setTimeout: !1,
              URL: !1,
              URLSearchParams: !1
            },
            webextensions: { browser: !1, chrome: !1, opr: !1 },
            greasemonkey: {
              cloneInto: !1,
              createObjectIn: !1,
              exportFunction: !1,
              GM: !1,
              GM_addStyle: !1,
              GM_deleteValue: !1,
              GM_getResourceText: !1,
              GM_getResourceURL: !1,
              GM_getValue: !1,
              GM_info: !1,
              GM_listValues: !1,
              GM_log: !1,
              GM_openInTab: !1,
              GM_registerMenuCommand: !1,
              GM_setClipboard: !1,
              GM_setValue: !1,
              GM_xmlhttpRequest: !1,
              unsafeWindow: !1
            },
            devtools: {
              $: !1,
              $_: !1,
              $$: !1,
              $0: !1,
              $1: !1,
              $2: !1,
              $3: !1,
              $4: !1,
              $x: !1,
              chrome: !1,
              clear: !1,
              copy: !1,
              debug: !1,
              dir: !1,
              dirxml: !1,
              getEventListeners: !1,
              inspect: !1,
              keys: !1,
              monitor: !1,
              monitorEvents: !1,
              profile: !1,
              profileEnd: !1,
              queryObjects: !1,
              table: !1,
              undebug: !1,
              unmonitor: !1,
              unmonitorEvents: !1,
              values: !1
            }
          };
        },
        {}
      ],
      150: [
        function(e, t, r) {
          "use strict";
          t.exports = e("./globals.json");
        },
        { "./globals.json": 149 }
      ],
      151: [
        function(e, t, r) {
          Object.defineProperty(r, "__esModule", { value: !0 }),
            (r.default = /((['"])(?:(?!\2|\\).|\\(?:\r\n|[\s\S]))*(\2)?|`(?:[^`\\$]|\\[\s\S]|\$(?!\{)|\$\{(?:[^{}]|\{[^}]*\}?)*\}?)*(`)?)|(\/\/.*)|(\/\*(?:[^*]|\*(?!\/))*(\*\/)?)|(\/(?!\*)(?:\[(?:(?![\]\\]).|\\.)*\]|(?![\/\]\\]).|\\.)+\/(?:(?!\s*(?:\b|[\u0080-\uFFFF$\\'"~({]|[+\-!](?!=)|\.?\d))|[gmiyus]{1,6}\b(?![\u0080-\uFFFF$\\]|\s*(?:[+\-*%&|^<>!=?({]|\/(?![\/*])))))|(0[xX][\da-fA-F]+|0[oO][0-7]+|0[bB][01]+|(?:\d*\.\d+|\d+\.?)(?:[eE][+-]?\d+)?)|((?!\d)(?:(?!\s)[$\w\u0080-\uFFFF]|\\u[\da-fA-F]{4}|\\u\{[\da-fA-F]+\})+)|(--|\+\+|&&|\|\||=>|\.{3}|(?:[+\-\/%&|^]|\*{1,2}|<{1,2}|>{1,3}|!=?|={1,2})=?|[?~.,:;[\](){}])|(\s+)|(^$|[\s\S])/g),
            (r.matchToToken = function(e) {
              var t = { type: "invalid", value: e[0], closed: void 0 };
              return (
                e[1]
                  ? ((t.type = "string"), (t.closed = !(!e[3] && !e[4])))
                  : e[5]
                  ? (t.type = "comment")
                  : e[6]
                  ? ((t.type = "comment"), (t.closed = !!e[7]))
                  : e[8]
                  ? (t.type = "regex")
                  : e[9]
                  ? (t.type = "number")
                  : e[10]
                  ? (t.type = "name")
                  : e[11]
                  ? (t.type = "punctuator")
                  : e[12] && (t.type = "whitespace"),
                t
              );
            });
        },
        {}
      ],
      152: [
        function(e, t, r) {
          (function(e) {
            "use strict";
            const r = {},
              n = r.hasOwnProperty,
              i = (e, t) => {
                for (const r in e) n.call(e, r) && t(r, e[r]);
              },
              s = r.toString,
              a = Array.isArray,
              o = e.isBuffer,
              u = {
                '"': '\\"',
                "'": "\\'",
                "\\": "\\\\",
                "\b": "\\b",
                "\f": "\\f",
                "\n": "\\n",
                "\r": "\\r",
                "\t": "\\t"
              },
              l = /["'\\\b\f\n\r\t]/,
              c = /[0-9]/,
              p = /[ !#-&\(-\[\]-_a-~]/,
              d = (e, t) => {
                const r = () => {
                    (b = g),
                      ++t.indentLevel,
                      (g = t.indent.repeat(t.indentLevel));
                  },
                  n = {
                    escapeEverything: !1,
                    minimal: !1,
                    isScriptContext: !1,
                    quotes: "single",
                    wrap: !1,
                    es6: !1,
                    json: !1,
                    compact: !0,
                    lowercaseHex: !1,
                    numbers: "decimal",
                    indent: "\t",
                    indentLevel: 0,
                    __inline1__: !1,
                    __inline2__: !1
                  },
                  h = t && t.json;
                h && ((n.quotes = "double"), (n.wrap = !0)),
                  "single" !=
                    (t = ((e, t) =>
                      t
                        ? (i(t, (t, r) => {
                            e[t] = r;
                          }),
                          e)
                        : e)(n, t)).quotes &&
                    "double" != t.quotes &&
                    "backtick" != t.quotes &&
                    (t.quotes = "single");
                const f =
                    "double" == t.quotes
                      ? '"'
                      : "backtick" == t.quotes
                      ? "`"
                      : "'",
                  m = t.compact,
                  y = t.lowercaseHex;
                let g = t.indent.repeat(t.indentLevel),
                  b = "";
                const v = t.__inline1__,
                  E = t.__inline2__,
                  T = m ? "" : "\n";
                let x,
                  A = !0;
                const S = "binary" == t.numbers,
                  D = "octal" == t.numbers,
                  P = "decimal" == t.numbers,
                  C = "hexadecimal" == t.numbers;
                if (
                  (h &&
                    e &&
                    (e => "function" == typeof e)(e.toJSON) &&
                    (e = e.toJSON()),
                  !(e =>
                    "string" == typeof e || "[object String]" == s.call(e))(e))
                ) {
                  if ((e => "[object Map]" == s.call(e))(e))
                    return 0 == e.size
                      ? "new Map()"
                      : (m || ((t.__inline1__ = !0), (t.__inline2__ = !1)),
                        "new Map(" + d(Array.from(e), t) + ")");
                  if ((e => "[object Set]" == s.call(e))(e))
                    return 0 == e.size
                      ? "new Set()"
                      : "new Set(" + d(Array.from(e), t) + ")";
                  if (o(e))
                    return 0 == e.length
                      ? "Buffer.from([])"
                      : "Buffer.from(" + d(Array.from(e), t) + ")";
                  if (a(e))
                    return (
                      (x = []),
                      (t.wrap = !0),
                      v && ((t.__inline1__ = !1), (t.__inline2__ = !0)),
                      E || r(),
                      ((e, t) => {
                        const r = e.length;
                        let n = -1;
                        for (; ++n < r; ) t(e[n]);
                      })(e, e => {
                        (A = !1),
                          E && (t.__inline2__ = !1),
                          x.push((m || E ? "" : g) + d(e, t));
                      }),
                      A
                        ? "[]"
                        : E
                        ? "[" + x.join(", ") + "]"
                        : "[" + T + x.join("," + T) + T + (m ? "" : b) + "]"
                    );
                  if (
                    !(e =>
                      "number" == typeof e || "[object Number]" == s.call(e))(e)
                  )
                    return (e => "[object Object]" == s.call(e))(e)
                      ? ((x = []),
                        (t.wrap = !0),
                        r(),
                        i(e, (e, r) => {
                          (A = !1),
                            x.push(
                              (m ? "" : g) +
                                d(e, t) +
                                ":" +
                                (m ? "" : " ") +
                                d(r, t)
                            );
                        }),
                        A
                          ? "{}"
                          : "{" + T + x.join("," + T) + T + (m ? "" : b) + "}")
                      : h
                      ? JSON.stringify(e) || "null"
                      : String(e);
                  if (h) return JSON.stringify(e);
                  if (P) return String(e);
                  if (C) {
                    let t = e.toString(16);
                    return y || (t = t.toUpperCase()), "0x" + t;
                  }
                  if (S) return "0b" + e.toString(2);
                  if (D) return "0o" + e.toString(8);
                }
                const w = e;
                let F = -1;
                const _ = w.length;
                for (x = ""; ++F < _; ) {
                  const e = w.charAt(F);
                  if (t.es6) {
                    const e = w.charCodeAt(F);
                    if (e >= 55296 && e <= 56319 && _ > F + 1) {
                      const t = w.charCodeAt(F + 1);
                      if (t >= 56320 && t <= 57343) {
                        let r = (
                          1024 * (e - 55296) +
                          t -
                          56320 +
                          65536
                        ).toString(16);
                        y || (r = r.toUpperCase()),
                          (x += "\\u{" + r + "}"),
                          ++F;
                        continue;
                      }
                    }
                  }
                  if (!t.escapeEverything) {
                    if (p.test(e)) {
                      x += e;
                      continue;
                    }
                    if ('"' == e) {
                      x += f == e ? '\\"' : e;
                      continue;
                    }
                    if ("`" == e) {
                      x += f == e ? "\\`" : e;
                      continue;
                    }
                    if ("'" == e) {
                      x += f == e ? "\\'" : e;
                      continue;
                    }
                  }
                  if ("\0" == e && !h && !c.test(w.charAt(F + 1))) {
                    x += "\\0";
                    continue;
                  }
                  if (l.test(e)) {
                    x += u[e];
                    continue;
                  }
                  const r = e.charCodeAt(0);
                  if (t.minimal && 8232 != r && 8233 != r) {
                    x += e;
                    continue;
                  }
                  let n = r.toString(16);
                  y || (n = n.toUpperCase());
                  const i = n.length > 2 || h,
                    s =
                      "\\" + (i ? "u" : "x") + ("0000" + n).slice(i ? -4 : -2);
                  x += s;
                }
                return (
                  t.wrap && (x = f + x + f),
                  "`" == f && (x = x.replace(/\$\{/g, "\\${")),
                  t.isScriptContext
                    ? x
                        .replace(/<\/(script|style)/gi, "<\\/$1")
                        .replace(/<!--/g, h ? "\\u003C!--" : "\\x3C!--")
                    : x
                );
              };
            (d.version = "2.5.2"), (t.exports = d);
          }.call(this, {
            isBuffer: e("../../../../../node_modules/is-buffer/index.js")
          }));
        },
        { "../../../../../node_modules/is-buffer/index.js": 330 }
      ],
      153: [
        function(e, t, r) {
          var n = e("./_getNative")(e("./_root"), "DataView");
          t.exports = n;
        },
        { "./_getNative": 219, "./_root": 256 }
      ],
      154: [
        function(e, t, r) {
          var n = e("./_hashClear"),
            i = e("./_hashDelete"),
            s = e("./_hashGet"),
            a = e("./_hashHas"),
            o = e("./_hashSet");
          function u(e) {
            var t = -1,
              r = null == e ? 0 : e.length;
            for (this.clear(); ++t < r; ) {
              var n = e[t];
              this.set(n[0], n[1]);
            }
          }
          (u.prototype.clear = n),
            (u.prototype.delete = i),
            (u.prototype.get = s),
            (u.prototype.has = a),
            (u.prototype.set = o),
            (t.exports = u);
        },
        {
          "./_hashClear": 226,
          "./_hashDelete": 227,
          "./_hashGet": 228,
          "./_hashHas": 229,
          "./_hashSet": 230
        }
      ],
      155: [
        function(e, t, r) {
          var n = e("./_listCacheClear"),
            i = e("./_listCacheDelete"),
            s = e("./_listCacheGet"),
            a = e("./_listCacheHas"),
            o = e("./_listCacheSet");
          function u(e) {
            var t = -1,
              r = null == e ? 0 : e.length;
            for (this.clear(); ++t < r; ) {
              var n = e[t];
              this.set(n[0], n[1]);
            }
          }
          (u.prototype.clear = n),
            (u.prototype.delete = i),
            (u.prototype.get = s),
            (u.prototype.has = a),
            (u.prototype.set = o),
            (t.exports = u);
        },
        {
          "./_listCacheClear": 239,
          "./_listCacheDelete": 240,
          "./_listCacheGet": 241,
          "./_listCacheHas": 242,
          "./_listCacheSet": 243
        }
      ],
      156: [
        function(e, t, r) {
          var n = e("./_getNative")(e("./_root"), "Map");
          t.exports = n;
        },
        { "./_getNative": 219, "./_root": 256 }
      ],
      157: [
        function(e, t, r) {
          var n = e("./_mapCacheClear"),
            i = e("./_mapCacheDelete"),
            s = e("./_mapCacheGet"),
            a = e("./_mapCacheHas"),
            o = e("./_mapCacheSet");
          function u(e) {
            var t = -1,
              r = null == e ? 0 : e.length;
            for (this.clear(); ++t < r; ) {
              var n = e[t];
              this.set(n[0], n[1]);
            }
          }
          (u.prototype.clear = n),
            (u.prototype.delete = i),
            (u.prototype.get = s),
            (u.prototype.has = a),
            (u.prototype.set = o),
            (t.exports = u);
        },
        {
          "./_mapCacheClear": 244,
          "./_mapCacheDelete": 245,
          "./_mapCacheGet": 246,
          "./_mapCacheHas": 247,
          "./_mapCacheSet": 248
        }
      ],
      158: [
        function(e, t, r) {
          var n = e("./_getNative")(e("./_root"), "Promise");
          t.exports = n;
        },
        { "./_getNative": 219, "./_root": 256 }
      ],
      159: [
        function(e, t, r) {
          var n = e("./_getNative")(e("./_root"), "Set");
          t.exports = n;
        },
        { "./_getNative": 219, "./_root": 256 }
      ],
      160: [
        function(e, t, r) {
          var n = e("./_MapCache"),
            i = e("./_setCacheAdd"),
            s = e("./_setCacheHas");
          function a(e) {
            var t = -1,
              r = null == e ? 0 : e.length;
            for (this.__data__ = new n(); ++t < r; ) this.add(e[t]);
          }
          (a.prototype.add = a.prototype.push = i),
            (a.prototype.has = s),
            (t.exports = a);
        },
        { "./_MapCache": 157, "./_setCacheAdd": 257, "./_setCacheHas": 258 }
      ],
      161: [
        function(e, t, r) {
          var n = e("./_ListCache"),
            i = e("./_stackClear"),
            s = e("./_stackDelete"),
            a = e("./_stackGet"),
            o = e("./_stackHas"),
            u = e("./_stackSet");
          function l(e) {
            var t = (this.__data__ = new n(e));
            this.size = t.size;
          }
          (l.prototype.clear = i),
            (l.prototype.delete = s),
            (l.prototype.get = a),
            (l.prototype.has = o),
            (l.prototype.set = u),
            (t.exports = l);
        },
        {
          "./_ListCache": 155,
          "./_stackClear": 262,
          "./_stackDelete": 263,
          "./_stackGet": 264,
          "./_stackHas": 265,
          "./_stackSet": 266
        }
      ],
      162: [
        function(e, t, r) {
          var n = e("./_root").Symbol;
          t.exports = n;
        },
        { "./_root": 256 }
      ],
      163: [
        function(e, t, r) {
          var n = e("./_root").Uint8Array;
          t.exports = n;
        },
        { "./_root": 256 }
      ],
      164: [
        function(e, t, r) {
          var n = e("./_getNative")(e("./_root"), "WeakMap");
          t.exports = n;
        },
        { "./_getNative": 219, "./_root": 256 }
      ],
      165: [
        function(e, t, r) {
          t.exports = function(e, t, r) {
            switch (r.length) {
              case 0:
                return e.call(t);
              case 1:
                return e.call(t, r[0]);
              case 2:
                return e.call(t, r[0], r[1]);
              case 3:
                return e.call(t, r[0], r[1], r[2]);
            }
            return e.apply(t, r);
          };
        },
        {}
      ],
      166: [
        function(e, t, r) {
          t.exports = function(e, t) {
            for (
              var r = -1, n = null == e ? 0 : e.length;
              ++r < n && !1 !== t(e[r], r, e);

            );
            return e;
          };
        },
        {}
      ],
      167: [
        function(e, t, r) {
          t.exports = function(e, t) {
            for (
              var r = -1, n = null == e ? 0 : e.length, i = 0, s = [];
              ++r < n;

            ) {
              var a = e[r];
              t(a, r, e) && (s[i++] = a);
            }
            return s;
          };
        },
        {}
      ],
      168: [
        function(e, t, r) {
          var n = e("./_baseIndexOf");
          t.exports = function(e, t) {
            return !(null == e || !e.length) && n(e, t, 0) > -1;
          };
        },
        { "./_baseIndexOf": 183 }
      ],
      169: [
        function(e, t, r) {
          t.exports = function(e, t, r) {
            for (var n = -1, i = null == e ? 0 : e.length; ++n < i; )
              if (r(t, e[n])) return !0;
            return !1;
          };
        },
        {}
      ],
      170: [
        function(e, t, r) {
          var n = e("./_baseTimes"),
            i = e("./isArguments"),
            s = e("./isArray"),
            a = e("./isBuffer"),
            o = e("./_isIndex"),
            u = e("./isTypedArray"),
            l = Object.prototype.hasOwnProperty;
          t.exports = function(e, t) {
            var r = s(e),
              c = !r && i(e),
              p = !r && !c && a(e),
              d = !r && !c && !p && u(e),
              h = r || c || p || d,
              f = h ? n(e.length, String) : [],
              m = f.length;
            for (var y in e)
              (!t && !l.call(e, y)) ||
                (h &&
                  ("length" == y ||
                    (p && ("offset" == y || "parent" == y)) ||
                    (d &&
                      ("buffer" == y ||
                        "byteLength" == y ||
                        "byteOffset" == y)) ||
                    o(y, m))) ||
                f.push(y);
            return f;
          };
        },
        {
          "./_baseTimes": 196,
          "./_isIndex": 234,
          "./isArguments": 275,
          "./isArray": 276,
          "./isBuffer": 278,
          "./isTypedArray": 290
        }
      ],
      171: [
        function(e, t, r) {
          t.exports = function(e, t) {
            for (
              var r = -1, n = null == e ? 0 : e.length, i = Array(n);
              ++r < n;

            )
              i[r] = t(e[r], r, e);
            return i;
          };
        },
        {}
      ],
      172: [
        function(e, t, r) {
          t.exports = function(e, t) {
            for (var r = -1, n = t.length, i = e.length; ++r < n; )
              e[i + r] = t[r];
            return e;
          };
        },
        {}
      ],
      173: [
        function(e, t, r) {
          var n = e("./_baseAssignValue"),
            i = e("./eq"),
            s = Object.prototype.hasOwnProperty;
          t.exports = function(e, t, r) {
            var a = e[t];
            (s.call(e, t) && i(a, r) && (void 0 !== r || t in e)) || n(e, t, r);
          };
        },
        { "./_baseAssignValue": 177, "./eq": 272 }
      ],
      174: [
        function(e, t, r) {
          var n = e("./eq");
          t.exports = function(e, t) {
            for (var r = e.length; r--; ) if (n(e[r][0], t)) return r;
            return -1;
          };
        },
        { "./eq": 272 }
      ],
      175: [
        function(e, t, r) {
          var n = e("./_copyObject"),
            i = e("./keys");
          t.exports = function(e, t) {
            return e && n(t, i(t), e);
          };
        },
        { "./_copyObject": 209, "./keys": 291 }
      ],
      176: [
        function(e, t, r) {
          var n = e("./_copyObject"),
            i = e("./keysIn");
          t.exports = function(e, t) {
            return e && n(t, i(t), e);
          };
        },
        { "./_copyObject": 209, "./keysIn": 292 }
      ],
      177: [
        function(e, t, r) {
          var n = e("./_defineProperty");
          t.exports = function(e, t, r) {
            "__proto__" == t && n
              ? n(e, t, {
                  configurable: !0,
                  enumerable: !0,
                  value: r,
                  writable: !0
                })
              : (e[t] = r);
          };
        },
        { "./_defineProperty": 214 }
      ],
      178: [
        function(e, t, r) {
          var n = e("./_Stack"),
            i = e("./_arrayEach"),
            s = e("./_assignValue"),
            a = e("./_baseAssign"),
            o = e("./_baseAssignIn"),
            u = e("./_cloneBuffer"),
            l = e("./_copyArray"),
            c = e("./_copySymbols"),
            p = e("./_copySymbolsIn"),
            d = e("./_getAllKeys"),
            h = e("./_getAllKeysIn"),
            f = e("./_getTag"),
            m = e("./_initCloneArray"),
            y = e("./_initCloneByTag"),
            g = e("./_initCloneObject"),
            b = e("./isArray"),
            v = e("./isBuffer"),
            E = e("./isMap"),
            T = e("./isObject"),
            x = e("./isSet"),
            A = e("./keys"),
            S = 1,
            D = 2,
            P = 4,
            C = "[object Arguments]",
            w = "[object Function]",
            F = "[object GeneratorFunction]",
            _ = "[object Object]",
            O = {};
          (O[C] = O["[object Array]"] = O["[object ArrayBuffer]"] = O[
            "[object DataView]"
          ] = O["[object Boolean]"] = O["[object Date]"] = O[
            "[object Float32Array]"
          ] = O["[object Float64Array]"] = O["[object Int8Array]"] = O[
            "[object Int16Array]"
          ] = O["[object Int32Array]"] = O["[object Map]"] = O[
            "[object Number]"
          ] = O[_] = O["[object RegExp]"] = O["[object Set]"] = O[
            "[object String]"
          ] = O["[object Symbol]"] = O["[object Uint8Array]"] = O[
            "[object Uint8ClampedArray]"
          ] = O["[object Uint16Array]"] = O["[object Uint32Array]"] = !0),
            (O["[object Error]"] = O[w] = O["[object WeakMap]"] = !1),
            (t.exports = function e(t, r, k, I, N, L) {
              var B,
                M = r & S,
                j = r & D,
                R = r & P;
              if ((k && (B = N ? k(t, I, N, L) : k(t)), void 0 !== B)) return B;
              if (!T(t)) return t;
              var q = b(t);
              if (q) {
                if (((B = m(t)), !M)) return l(t, B);
              } else {
                var V = f(t),
                  U = V == w || V == F;
                if (v(t)) return u(t, M);
                if (V == _ || V == C || (U && !N)) {
                  if (((B = j || U ? {} : g(t)), !M))
                    return j ? p(t, o(B, t)) : c(t, a(B, t));
                } else {
                  if (!O[V]) return N ? t : {};
                  B = y(t, V, M);
                }
              }
              L || (L = new n());
              var K = L.get(t);
              if (K) return K;
              L.set(t, B),
                x(t)
                  ? t.forEach(function(n) {
                      B.add(e(n, r, k, n, t, L));
                    })
                  : E(t) &&
                    t.forEach(function(n, i) {
                      B.set(i, e(n, r, k, i, t, L));
                    });
              var G = R ? (j ? h : d) : j ? keysIn : A,
                W = q ? void 0 : G(t);
              return (
                i(W || t, function(n, i) {
                  W && (n = t[(i = n)]), s(B, i, e(n, r, k, i, t, L));
                }),
                B
              );
            });
        },
        {
          "./_Stack": 161,
          "./_arrayEach": 166,
          "./_assignValue": 173,
          "./_baseAssign": 175,
          "./_baseAssignIn": 176,
          "./_cloneBuffer": 203,
          "./_copyArray": 208,
          "./_copySymbols": 210,
          "./_copySymbolsIn": 211,
          "./_getAllKeys": 216,
          "./_getAllKeysIn": 217,
          "./_getTag": 224,
          "./_initCloneArray": 231,
          "./_initCloneByTag": 232,
          "./_initCloneObject": 233,
          "./isArray": 276,
          "./isBuffer": 278,
          "./isMap": 282,
          "./isObject": 283,
          "./isSet": 287,
          "./keys": 291
        }
      ],
      179: [
        function(e, t, r) {
          var n = e("./isObject"),
            i = Object.create,
            s = (function() {
              function e() {}
              return function(t) {
                if (!n(t)) return {};
                if (i) return i(t);
                e.prototype = t;
                var r = new e();
                return (e.prototype = void 0), r;
              };
            })();
          t.exports = s;
        },
        { "./isObject": 283 }
      ],
      180: [
        function(e, t, r) {
          t.exports = function(e, t, r, n) {
            for (var i = e.length, s = r + (n ? 1 : -1); n ? s-- : ++s < i; )
              if (t(e[s], s, e)) return s;
            return -1;
          };
        },
        {}
      ],
      181: [
        function(e, t, r) {
          var n = e("./_arrayPush"),
            i = e("./isArray");
          t.exports = function(e, t, r) {
            var s = t(e);
            return i(e) ? s : n(s, r(e));
          };
        },
        { "./_arrayPush": 172, "./isArray": 276 }
      ],
      182: [
        function(e, t, r) {
          var n = e("./_Symbol"),
            i = e("./_getRawTag"),
            s = e("./_objectToString"),
            a = "[object Null]",
            o = "[object Undefined]",
            u = n ? n.toStringTag : void 0;
          t.exports = function(e) {
            return null == e
              ? void 0 === e
                ? o
                : a
              : u && u in Object(e)
              ? i(e)
              : s(e);
          };
        },
        { "./_Symbol": 162, "./_getRawTag": 221, "./_objectToString": 253 }
      ],
      183: [
        function(e, t, r) {
          var n = e("./_baseFindIndex"),
            i = e("./_baseIsNaN"),
            s = e("./_strictIndexOf");
          t.exports = function(e, t, r) {
            return t == t ? s(e, t, r) : n(e, i, r);
          };
        },
        {
          "./_baseFindIndex": 180,
          "./_baseIsNaN": 186,
          "./_strictIndexOf": 267
        }
      ],
      184: [
        function(e, t, r) {
          var n = e("./_baseGetTag"),
            i = e("./isObjectLike"),
            s = "[object Arguments]";
          t.exports = function(e) {
            return i(e) && n(e) == s;
          };
        },
        { "./_baseGetTag": 182, "./isObjectLike": 284 }
      ],
      185: [
        function(e, t, r) {
          var n = e("./_getTag"),
            i = e("./isObjectLike"),
            s = "[object Map]";
          t.exports = function(e) {
            return i(e) && n(e) == s;
          };
        },
        { "./_getTag": 224, "./isObjectLike": 284 }
      ],
      186: [
        function(e, t, r) {
          t.exports = function(e) {
            return e != e;
          };
        },
        {}
      ],
      187: [
        function(e, t, r) {
          var n = e("./isFunction"),
            i = e("./_isMasked"),
            s = e("./isObject"),
            a = e("./_toSource"),
            o = /^\[object .+?Constructor\]$/,
            u = Function.prototype,
            l = Object.prototype,
            c = u.toString,
            p = l.hasOwnProperty,
            d = RegExp(
              "^" +
                c
                  .call(p)
                  .replace(/[\\^$.*+?()[\]{}|]/g, "\\$&")
                  .replace(
                    /hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,
                    "$1.*?"
                  ) +
                "$"
            );
          t.exports = function(e) {
            return !(!s(e) || i(e)) && (n(e) ? d : o).test(a(e));
          };
        },
        {
          "./_isMasked": 237,
          "./_toSource": 268,
          "./isFunction": 279,
          "./isObject": 283
        }
      ],
      188: [
        function(e, t, r) {
          var n = e("./_baseGetTag"),
            i = e("./isObjectLike"),
            s = "[object RegExp]";
          t.exports = function(e) {
            return i(e) && n(e) == s;
          };
        },
        { "./_baseGetTag": 182, "./isObjectLike": 284 }
      ],
      189: [
        function(e, t, r) {
          var n = e("./_getTag"),
            i = e("./isObjectLike"),
            s = "[object Set]";
          t.exports = function(e) {
            return i(e) && n(e) == s;
          };
        },
        { "./_getTag": 224, "./isObjectLike": 284 }
      ],
      190: [
        function(e, t, r) {
          var n = e("./_baseGetTag"),
            i = e("./isLength"),
            s = e("./isObjectLike"),
            a = {};
          (a["[object Float32Array]"] = a["[object Float64Array]"] = a[
            "[object Int8Array]"
          ] = a["[object Int16Array]"] = a["[object Int32Array]"] = a[
            "[object Uint8Array]"
          ] = a["[object Uint8ClampedArray]"] = a["[object Uint16Array]"] = a[
            "[object Uint32Array]"
          ] = !0),
            (a["[object Arguments]"] = a["[object Array]"] = a[
              "[object ArrayBuffer]"
            ] = a["[object Boolean]"] = a["[object DataView]"] = a[
              "[object Date]"
            ] = a["[object Error]"] = a["[object Function]"] = a[
              "[object Map]"
            ] = a["[object Number]"] = a["[object Object]"] = a[
              "[object RegExp]"
            ] = a["[object Set]"] = a["[object String]"] = a[
              "[object WeakMap]"
            ] = !1),
            (t.exports = function(e) {
              return s(e) && i(e.length) && !!a[n(e)];
            });
        },
        { "./_baseGetTag": 182, "./isLength": 281, "./isObjectLike": 284 }
      ],
      191: [
        function(e, t, r) {
          var n = e("./_isPrototype"),
            i = e("./_nativeKeys"),
            s = Object.prototype.hasOwnProperty;
          t.exports = function(e) {
            if (!n(e)) return i(e);
            var t = [];
            for (var r in Object(e))
              s.call(e, r) && "constructor" != r && t.push(r);
            return t;
          };
        },
        { "./_isPrototype": 238, "./_nativeKeys": 250 }
      ],
      192: [
        function(e, t, r) {
          var n = e("./isObject"),
            i = e("./_isPrototype"),
            s = e("./_nativeKeysIn"),
            a = Object.prototype.hasOwnProperty;
          t.exports = function(e) {
            if (!n(e)) return s(e);
            var t = i(e),
              r = [];
            for (var o in e)
              ("constructor" != o || (!t && a.call(e, o))) && r.push(o);
            return r;
          };
        },
        { "./_isPrototype": 238, "./_nativeKeysIn": 251, "./isObject": 283 }
      ],
      193: [
        function(e, t, r) {
          var n = 9007199254740991,
            i = Math.floor;
          t.exports = function(e, t) {
            var r = "";
            if (!e || t < 1 || t > n) return r;
            do {
              t % 2 && (r += e), (t = i(t / 2)) && (e += e);
            } while (t);
            return r;
          };
        },
        {}
      ],
      194: [
        function(e, t, r) {
          var n = e("./identity"),
            i = e("./_overRest"),
            s = e("./_setToString");
          t.exports = function(e, t) {
            return s(i(e, t, n), e + "");
          };
        },
        { "./_overRest": 255, "./_setToString": 260, "./identity": 273 }
      ],
      195: [
        function(e, t, r) {
          var n = e("./constant"),
            i = e("./_defineProperty"),
            s = e("./identity"),
            a = i
              ? function(e, t) {
                  return i(e, "toString", {
                    configurable: !0,
                    enumerable: !1,
                    value: n(t),
                    writable: !0
                  });
                }
              : s;
          t.exports = a;
        },
        { "./_defineProperty": 214, "./constant": 270, "./identity": 273 }
      ],
      196: [
        function(e, t, r) {
          t.exports = function(e, t) {
            for (var r = -1, n = Array(e); ++r < e; ) n[r] = t(r);
            return n;
          };
        },
        {}
      ],
      197: [
        function(e, t, r) {
          var n = e("./_Symbol"),
            i = e("./_arrayMap"),
            s = e("./isArray"),
            a = e("./isSymbol"),
            o = 1 / 0,
            u = n ? n.prototype : void 0,
            l = u ? u.toString : void 0;
          t.exports = function e(t) {
            if ("string" == typeof t) return t;
            if (s(t)) return i(t, e) + "";
            if (a(t)) return l ? l.call(t) : "";
            var r = t + "";
            return "0" == r && 1 / t == -o ? "-0" : r;
          };
        },
        {
          "./_Symbol": 162,
          "./_arrayMap": 171,
          "./isArray": 276,
          "./isSymbol": 289
        }
      ],
      198: [
        function(e, t, r) {
          t.exports = function(e) {
            return function(t) {
              return e(t);
            };
          };
        },
        {}
      ],
      199: [
        function(e, t, r) {
          var n = e("./_SetCache"),
            i = e("./_arrayIncludes"),
            s = e("./_arrayIncludesWith"),
            a = e("./_cacheHas"),
            o = e("./_createSet"),
            u = e("./_setToArray"),
            l = 200;
          t.exports = function(e, t, r) {
            var c = -1,
              p = i,
              d = e.length,
              h = !0,
              f = [],
              m = f;
            if (r) (h = !1), (p = s);
            else if (d >= l) {
              var y = t ? null : o(e);
              if (y) return u(y);
              (h = !1), (p = a), (m = new n());
            } else m = t ? [] : f;
            e: for (; ++c < d; ) {
              var g = e[c],
                b = t ? t(g) : g;
              if (((g = r || 0 !== g ? g : 0), h && b == b)) {
                for (var v = m.length; v--; ) if (m[v] === b) continue e;
                t && m.push(b), f.push(g);
              } else p(m, b, r) || (m !== f && m.push(b), f.push(g));
            }
            return f;
          };
        },
        {
          "./_SetCache": 160,
          "./_arrayIncludes": 168,
          "./_arrayIncludesWith": 169,
          "./_cacheHas": 201,
          "./_createSet": 213,
          "./_setToArray": 259
        }
      ],
      200: [
        function(e, t, r) {
          var n = e("./_arrayMap");
          t.exports = function(e, t) {
            return n(t, function(t) {
              return e[t];
            });
          };
        },
        { "./_arrayMap": 171 }
      ],
      201: [
        function(e, t, r) {
          t.exports = function(e, t) {
            return e.has(t);
          };
        },
        {}
      ],
      202: [
        function(e, t, r) {
          var n = e("./_Uint8Array");
          t.exports = function(e) {
            var t = new e.constructor(e.byteLength);
            return new n(t).set(new n(e)), t;
          };
        },
        { "./_Uint8Array": 163 }
      ],
      203: [
        function(e, t, r) {
          var n = e("./_root"),
            i = "object" == typeof r && r && !r.nodeType && r,
            s = i && "object" == typeof t && t && !t.nodeType && t,
            a = s && s.exports === i ? n.Buffer : void 0,
            o = a ? a.allocUnsafe : void 0;
          t.exports = function(e, t) {
            if (t) return e.slice();
            var r = e.length,
              n = o ? o(r) : new e.constructor(r);
            return e.copy(n), n;
          };
        },
        { "./_root": 256 }
      ],
      204: [
        function(e, t, r) {
          var n = e("./_cloneArrayBuffer");
          t.exports = function(e, t) {
            var r = t ? n(e.buffer) : e.buffer;
            return new e.constructor(r, e.byteOffset, e.byteLength);
          };
        },
        { "./_cloneArrayBuffer": 202 }
      ],
      205: [
        function(e, t, r) {
          var n = /\w*$/;
          t.exports = function(e) {
            var t = new e.constructor(e.source, n.exec(e));
            return (t.lastIndex = e.lastIndex), t;
          };
        },
        {}
      ],
      206: [
        function(e, t, r) {
          var n = e("./_Symbol"),
            i = n ? n.prototype : void 0,
            s = i ? i.valueOf : void 0;
          t.exports = function(e) {
            return s ? Object(s.call(e)) : {};
          };
        },
        { "./_Symbol": 162 }
      ],
      207: [
        function(e, t, r) {
          var n = e("./_cloneArrayBuffer");
          t.exports = function(e, t) {
            var r = t ? n(e.buffer) : e.buffer;
            return new e.constructor(r, e.byteOffset, e.length);
          };
        },
        { "./_cloneArrayBuffer": 202 }
      ],
      208: [
        function(e, t, r) {
          t.exports = function(e, t) {
            var r = -1,
              n = e.length;
            for (t || (t = Array(n)); ++r < n; ) t[r] = e[r];
            return t;
          };
        },
        {}
      ],
      209: [
        function(e, t, r) {
          var n = e("./_assignValue"),
            i = e("./_baseAssignValue");
          t.exports = function(e, t, r, s) {
            var a = !r;
            r || (r = {});
            for (var o = -1, u = t.length; ++o < u; ) {
              var l = t[o],
                c = s ? s(r[l], e[l], l, r, e) : void 0;
              void 0 === c && (c = e[l]), a ? i(r, l, c) : n(r, l, c);
            }
            return r;
          };
        },
        { "./_assignValue": 173, "./_baseAssignValue": 177 }
      ],
      210: [
        function(e, t, r) {
          var n = e("./_copyObject"),
            i = e("./_getSymbols");
          t.exports = function(e, t) {
            return n(e, i(e), t);
          };
        },
        { "./_copyObject": 209, "./_getSymbols": 222 }
      ],
      211: [
        function(e, t, r) {
          var n = e("./_copyObject"),
            i = e("./_getSymbolsIn");
          t.exports = function(e, t) {
            return n(e, i(e), t);
          };
        },
        { "./_copyObject": 209, "./_getSymbolsIn": 223 }
      ],
      212: [
        function(e, t, r) {
          var n = e("./_root")["__core-js_shared__"];
          t.exports = n;
        },
        { "./_root": 256 }
      ],
      213: [
        function(e, t, r) {
          var n = e("./_Set"),
            i = e("./noop"),
            s = e("./_setToArray"),
            a =
              n && 1 / s(new n([, -0]))[1] == 1 / 0
                ? function(e) {
                    return new n(e);
                  }
                : i;
          t.exports = a;
        },
        { "./_Set": 159, "./_setToArray": 259, "./noop": 293 }
      ],
      214: [
        function(e, t, r) {
          var n = e("./_getNative"),
            i = (function() {
              try {
                var e = n(Object, "defineProperty");
                return e({}, "", {}), e;
              } catch (e) {}
            })();
          t.exports = i;
        },
        { "./_getNative": 219 }
      ],
      215: [
        function(e, t, r) {
          (function(e) {
            var r = "object" == typeof e && e && e.Object === Object && e;
            t.exports = r;
          }.call(
            this,
            "undefined" != typeof global
              ? global
              : "undefined" != typeof self
              ? self
              : "undefined" != typeof window
              ? window
              : {}
          ));
        },
        {}
      ],
      216: [
        function(e, t, r) {
          var n = e("./_baseGetAllKeys"),
            i = e("./_getSymbols"),
            s = e("./keys");
          t.exports = function(e) {
            return n(e, s, i);
          };
        },
        { "./_baseGetAllKeys": 181, "./_getSymbols": 222, "./keys": 291 }
      ],
      217: [
        function(e, t, r) {
          var n = e("./_baseGetAllKeys"),
            i = e("./_getSymbolsIn"),
            s = e("./keysIn");
          t.exports = function(e) {
            return n(e, s, i);
          };
        },
        { "./_baseGetAllKeys": 181, "./_getSymbolsIn": 223, "./keysIn": 292 }
      ],
      218: [
        function(e, t, r) {
          var n = e("./_isKeyable");
          t.exports = function(e, t) {
            var r = e.__data__;
            return n(t) ? r["string" == typeof t ? "string" : "hash"] : r.map;
          };
        },
        { "./_isKeyable": 236 }
      ],
      219: [
        function(e, t, r) {
          var n = e("./_baseIsNative"),
            i = e("./_getValue");
          t.exports = function(e, t) {
            var r = i(e, t);
            return n(r) ? r : void 0;
          };
        },
        { "./_baseIsNative": 187, "./_getValue": 225 }
      ],
      220: [
        function(e, t, r) {
          var n = e("./_overArg")(Object.getPrototypeOf, Object);
          t.exports = n;
        },
        { "./_overArg": 254 }
      ],
      221: [
        function(e, t, r) {
          var n = e("./_Symbol"),
            i = Object.prototype,
            s = i.hasOwnProperty,
            a = i.toString,
            o = n ? n.toStringTag : void 0;
          t.exports = function(e) {
            var t = s.call(e, o),
              r = e[o];
            try {
              e[o] = void 0;
              var n = !0;
            } catch (e) {}
            var i = a.call(e);
            return n && (t ? (e[o] = r) : delete e[o]), i;
          };
        },
        { "./_Symbol": 162 }
      ],
      222: [
        function(e, t, r) {
          var n = e("./_arrayFilter"),
            i = e("./stubArray"),
            s = Object.prototype.propertyIsEnumerable,
            a = Object.getOwnPropertySymbols,
            o = a
              ? function(e) {
                  return null == e
                    ? []
                    : ((e = Object(e)),
                      n(a(e), function(t) {
                        return s.call(e, t);
                      }));
                }
              : i;
          t.exports = o;
        },
        { "./_arrayFilter": 167, "./stubArray": 295 }
      ],
      223: [
        function(e, t, r) {
          var n = e("./_arrayPush"),
            i = e("./_getPrototype"),
            s = e("./_getSymbols"),
            a = e("./stubArray"),
            o = Object.getOwnPropertySymbols
              ? function(e) {
                  for (var t = []; e; ) n(t, s(e)), (e = i(e));
                  return t;
                }
              : a;
          t.exports = o;
        },
        {
          "./_arrayPush": 172,
          "./_getPrototype": 220,
          "./_getSymbols": 222,
          "./stubArray": 295
        }
      ],
      224: [
        function(e, t, r) {
          var n = e("./_DataView"),
            i = e("./_Map"),
            s = e("./_Promise"),
            a = e("./_Set"),
            o = e("./_WeakMap"),
            u = e("./_baseGetTag"),
            l = e("./_toSource"),
            c = l(n),
            p = l(i),
            d = l(s),
            h = l(a),
            f = l(o),
            m = u;
          ((n && "[object DataView]" != m(new n(new ArrayBuffer(1)))) ||
            (i && "[object Map]" != m(new i())) ||
            (s && "[object Promise]" != m(s.resolve())) ||
            (a && "[object Set]" != m(new a())) ||
            (o && "[object WeakMap]" != m(new o()))) &&
            (m = function(e) {
              var t = u(e),
                r = "[object Object]" == t ? e.constructor : void 0,
                n = r ? l(r) : "";
              if (n)
                switch (n) {
                  case c:
                    return "[object DataView]";
                  case p:
                    return "[object Map]";
                  case d:
                    return "[object Promise]";
                  case h:
                    return "[object Set]";
                  case f:
                    return "[object WeakMap]";
                }
              return t;
            }),
            (t.exports = m);
        },
        {
          "./_DataView": 153,
          "./_Map": 156,
          "./_Promise": 158,
          "./_Set": 159,
          "./_WeakMap": 164,
          "./_baseGetTag": 182,
          "./_toSource": 268
        }
      ],
      225: [
        function(e, t, r) {
          t.exports = function(e, t) {
            return null == e ? void 0 : e[t];
          };
        },
        {}
      ],
      226: [
        function(e, t, r) {
          var n = e("./_nativeCreate");
          t.exports = function() {
            (this.__data__ = n ? n(null) : {}), (this.size = 0);
          };
        },
        { "./_nativeCreate": 249 }
      ],
      227: [
        function(e, t, r) {
          t.exports = function(e) {
            var t = this.has(e) && delete this.__data__[e];
            return (this.size -= t ? 1 : 0), t;
          };
        },
        {}
      ],
      228: [
        function(e, t, r) {
          var n = e("./_nativeCreate"),
            i = "__lodash_hash_undefined__",
            s = Object.prototype.hasOwnProperty;
          t.exports = function(e) {
            var t = this.__data__;
            if (n) {
              var r = t[e];
              return r === i ? void 0 : r;
            }
            return s.call(t, e) ? t[e] : void 0;
          };
        },
        { "./_nativeCreate": 249 }
      ],
      229: [
        function(e, t, r) {
          var n = e("./_nativeCreate"),
            i = Object.prototype.hasOwnProperty;
          t.exports = function(e) {
            var t = this.__data__;
            return n ? void 0 !== t[e] : i.call(t, e);
          };
        },
        { "./_nativeCreate": 249 }
      ],
      230: [
        function(e, t, r) {
          var n = e("./_nativeCreate"),
            i = "__lodash_hash_undefined__";
          t.exports = function(e, t) {
            var r = this.__data__;
            return (
              (this.size += this.has(e) ? 0 : 1),
              (r[e] = n && void 0 === t ? i : t),
              this
            );
          };
        },
        { "./_nativeCreate": 249 }
      ],
      231: [
        function(e, t, r) {
          var n = Object.prototype.hasOwnProperty;
          t.exports = function(e) {
            var t = e.length,
              r = new e.constructor(t);
            return (
              t &&
                "string" == typeof e[0] &&
                n.call(e, "index") &&
                ((r.index = e.index), (r.input = e.input)),
              r
            );
          };
        },
        {}
      ],
      232: [
        function(e, t, r) {
          var n = e("./_cloneArrayBuffer"),
            i = e("./_cloneDataView"),
            s = e("./_cloneRegExp"),
            a = e("./_cloneSymbol"),
            o = e("./_cloneTypedArray"),
            u = "[object Boolean]",
            l = "[object Date]",
            c = "[object Map]",
            p = "[object Number]",
            d = "[object RegExp]",
            h = "[object Set]",
            f = "[object String]",
            m = "[object Symbol]",
            y = "[object ArrayBuffer]",
            g = "[object DataView]",
            b = "[object Float32Array]",
            v = "[object Float64Array]",
            E = "[object Int8Array]",
            T = "[object Int16Array]",
            x = "[object Int32Array]",
            A = "[object Uint8Array]",
            S = "[object Uint8ClampedArray]",
            D = "[object Uint16Array]",
            P = "[object Uint32Array]";
          t.exports = function(e, t, r) {
            var C = e.constructor;
            switch (t) {
              case y:
                return n(e);
              case u:
              case l:
                return new C(+e);
              case g:
                return i(e, r);
              case b:
              case v:
              case E:
              case T:
              case x:
              case A:
              case S:
              case D:
              case P:
                return o(e, r);
              case c:
                return new C();
              case p:
              case f:
                return new C(e);
              case d:
                return s(e);
              case h:
                return new C();
              case m:
                return a(e);
            }
          };
        },
        {
          "./_cloneArrayBuffer": 202,
          "./_cloneDataView": 204,
          "./_cloneRegExp": 205,
          "./_cloneSymbol": 206,
          "./_cloneTypedArray": 207
        }
      ],
      233: [
        function(e, t, r) {
          var n = e("./_baseCreate"),
            i = e("./_getPrototype"),
            s = e("./_isPrototype");
          t.exports = function(e) {
            return "function" != typeof e.constructor || s(e) ? {} : n(i(e));
          };
        },
        { "./_baseCreate": 179, "./_getPrototype": 220, "./_isPrototype": 238 }
      ],
      234: [
        function(e, t, r) {
          var n = 9007199254740991,
            i = /^(?:0|[1-9]\d*)$/;
          t.exports = function(e, t) {
            var r = typeof e;
            return (
              !!(t = null == t ? n : t) &&
              ("number" == r || ("symbol" != r && i.test(e))) &&
              e > -1 &&
              e % 1 == 0 &&
              e < t
            );
          };
        },
        {}
      ],
      235: [
        function(e, t, r) {
          var n = e("./eq"),
            i = e("./isArrayLike"),
            s = e("./_isIndex"),
            a = e("./isObject");
          t.exports = function(e, t, r) {
            if (!a(r)) return !1;
            var o = typeof t;
            return (
              !!("number" == o
                ? i(r) && s(t, r.length)
                : "string" == o && t in r) && n(r[t], e)
            );
          };
        },
        {
          "./_isIndex": 234,
          "./eq": 272,
          "./isArrayLike": 277,
          "./isObject": 283
        }
      ],
      236: [
        function(e, t, r) {
          t.exports = function(e) {
            var t = typeof e;
            return "string" == t ||
              "number" == t ||
              "symbol" == t ||
              "boolean" == t
              ? "__proto__" !== e
              : null === e;
          };
        },
        {}
      ],
      237: [
        function(e, t, r) {
          var n,
            i = e("./_coreJsData"),
            s = (n = /[^.]+$/.exec((i && i.keys && i.keys.IE_PROTO) || ""))
              ? "Symbol(src)_1." + n
              : "";
          t.exports = function(e) {
            return !!s && s in e;
          };
        },
        { "./_coreJsData": 212 }
      ],
      238: [
        function(e, t, r) {
          var n = Object.prototype;
          t.exports = function(e) {
            var t = e && e.constructor;
            return e === (("function" == typeof t && t.prototype) || n);
          };
        },
        {}
      ],
      239: [
        function(e, t, r) {
          t.exports = function() {
            (this.__data__ = []), (this.size = 0);
          };
        },
        {}
      ],
      240: [
        function(e, t, r) {
          var n = e("./_assocIndexOf"),
            i = Array.prototype.splice;
          t.exports = function(e) {
            var t = this.__data__,
              r = n(t, e);
            return !(
              r < 0 ||
              (r == t.length - 1 ? t.pop() : i.call(t, r, 1), --this.size, 0)
            );
          };
        },
        { "./_assocIndexOf": 174 }
      ],
      241: [
        function(e, t, r) {
          var n = e("./_assocIndexOf");
          t.exports = function(e) {
            var t = this.__data__,
              r = n(t, e);
            return r < 0 ? void 0 : t[r][1];
          };
        },
        { "./_assocIndexOf": 174 }
      ],
      242: [
        function(e, t, r) {
          var n = e("./_assocIndexOf");
          t.exports = function(e) {
            return n(this.__data__, e) > -1;
          };
        },
        { "./_assocIndexOf": 174 }
      ],
      243: [
        function(e, t, r) {
          var n = e("./_assocIndexOf");
          t.exports = function(e, t) {
            var r = this.__data__,
              i = n(r, e);
            return i < 0 ? (++this.size, r.push([e, t])) : (r[i][1] = t), this;
          };
        },
        { "./_assocIndexOf": 174 }
      ],
      244: [
        function(e, t, r) {
          var n = e("./_Hash"),
            i = e("./_ListCache"),
            s = e("./_Map");
          t.exports = function() {
            (this.size = 0),
              (this.__data__ = {
                hash: new n(),
                map: new (s || i)(),
                string: new n()
              });
          };
        },
        { "./_Hash": 154, "./_ListCache": 155, "./_Map": 156 }
      ],
      245: [
        function(e, t, r) {
          var n = e("./_getMapData");
          t.exports = function(e) {
            var t = n(this, e).delete(e);
            return (this.size -= t ? 1 : 0), t;
          };
        },
        { "./_getMapData": 218 }
      ],
      246: [
        function(e, t, r) {
          var n = e("./_getMapData");
          t.exports = function(e) {
            return n(this, e).get(e);
          };
        },
        { "./_getMapData": 218 }
      ],
      247: [
        function(e, t, r) {
          var n = e("./_getMapData");
          t.exports = function(e) {
            return n(this, e).has(e);
          };
        },
        { "./_getMapData": 218 }
      ],
      248: [
        function(e, t, r) {
          var n = e("./_getMapData");
          t.exports = function(e, t) {
            var r = n(this, e),
              i = r.size;
            return r.set(e, t), (this.size += r.size == i ? 0 : 1), this;
          };
        },
        { "./_getMapData": 218 }
      ],
      249: [
        function(e, t, r) {
          var n = e("./_getNative")(Object, "create");
          t.exports = n;
        },
        { "./_getNative": 219 }
      ],
      250: [
        function(e, t, r) {
          var n = e("./_overArg")(Object.keys, Object);
          t.exports = n;
        },
        { "./_overArg": 254 }
      ],
      251: [
        function(e, t, r) {
          t.exports = function(e) {
            var t = [];
            if (null != e) for (var r in Object(e)) t.push(r);
            return t;
          };
        },
        {}
      ],
      252: [
        function(e, t, r) {
          var n = e("./_freeGlobal"),
            i = "object" == typeof r && r && !r.nodeType && r,
            s = i && "object" == typeof t && t && !t.nodeType && t,
            a = s && s.exports === i && n.process,
            o = (function() {
              try {
                var e = s && s.require && s.require("util").types;
                return e || (a && a.binding && a.binding("util"));
              } catch (e) {}
            })();
          t.exports = o;
        },
        { "./_freeGlobal": 215 }
      ],
      253: [
        function(e, t, r) {
          var n = Object.prototype.toString;
          t.exports = function(e) {
            return n.call(e);
          };
        },
        {}
      ],
      254: [
        function(e, t, r) {
          t.exports = function(e, t) {
            return function(r) {
              return e(t(r));
            };
          };
        },
        {}
      ],
      255: [
        function(e, t, r) {
          var n = e("./_apply"),
            i = Math.max;
          t.exports = function(e, t, r) {
            return (
              (t = i(void 0 === t ? e.length - 1 : t, 0)),
              function() {
                for (
                  var s = arguments,
                    a = -1,
                    o = i(s.length - t, 0),
                    u = Array(o);
                  ++a < o;

                )
                  u[a] = s[t + a];
                a = -1;
                for (var l = Array(t + 1); ++a < t; ) l[a] = s[a];
                return (l[t] = r(u)), n(e, this, l);
              }
            );
          };
        },
        { "./_apply": 165 }
      ],
      256: [
        function(e, t, r) {
          var n = e("./_freeGlobal"),
            i =
              "object" == typeof self && self && self.Object === Object && self,
            s = n || i || Function("return this")();
          t.exports = s;
        },
        { "./_freeGlobal": 215 }
      ],
      257: [
        function(e, t, r) {
          var n = "__lodash_hash_undefined__";
          t.exports = function(e) {
            return this.__data__.set(e, n), this;
          };
        },
        {}
      ],
      258: [
        function(e, t, r) {
          t.exports = function(e) {
            return this.__data__.has(e);
          };
        },
        {}
      ],
      259: [
        function(e, t, r) {
          t.exports = function(e) {
            var t = -1,
              r = Array(e.size);
            return (
              e.forEach(function(e) {
                r[++t] = e;
              }),
              r
            );
          };
        },
        {}
      ],
      260: [
        function(e, t, r) {
          var n = e("./_baseSetToString"),
            i = e("./_shortOut")(n);
          t.exports = i;
        },
        { "./_baseSetToString": 195, "./_shortOut": 261 }
      ],
      261: [
        function(e, t, r) {
          var n = 800,
            i = 16,
            s = Date.now;
          t.exports = function(e) {
            var t = 0,
              r = 0;
            return function() {
              var a = s(),
                o = i - (a - r);
              if (((r = a), o > 0)) {
                if (++t >= n) return arguments[0];
              } else t = 0;
              return e.apply(void 0, arguments);
            };
          };
        },
        {}
      ],
      262: [
        function(e, t, r) {
          var n = e("./_ListCache");
          t.exports = function() {
            (this.__data__ = new n()), (this.size = 0);
          };
        },
        { "./_ListCache": 155 }
      ],
      263: [
        function(e, t, r) {
          t.exports = function(e) {
            var t = this.__data__,
              r = t.delete(e);
            return (this.size = t.size), r;
          };
        },
        {}
      ],
      264: [
        function(e, t, r) {
          t.exports = function(e) {
            return this.__data__.get(e);
          };
        },
        {}
      ],
      265: [
        function(e, t, r) {
          t.exports = function(e) {
            return this.__data__.has(e);
          };
        },
        {}
      ],
      266: [
        function(e, t, r) {
          var n = e("./_ListCache"),
            i = e("./_Map"),
            s = e("./_MapCache"),
            a = 200;
          t.exports = function(e, t) {
            var r = this.__data__;
            if (r instanceof n) {
              var o = r.__data__;
              if (!i || o.length < a - 1)
                return o.push([e, t]), (this.size = ++r.size), this;
              r = this.__data__ = new s(o);
            }
            return r.set(e, t), (this.size = r.size), this;
          };
        },
        { "./_ListCache": 155, "./_Map": 156, "./_MapCache": 157 }
      ],
      267: [
        function(e, t, r) {
          t.exports = function(e, t, r) {
            for (var n = r - 1, i = e.length; ++n < i; )
              if (e[n] === t) return n;
            return -1;
          };
        },
        {}
      ],
      268: [
        function(e, t, r) {
          var n = Function.prototype.toString;
          t.exports = function(e) {
            if (null != e) {
              try {
                return n.call(e);
              } catch (e) {}
              try {
                return e + "";
              } catch (e) {}
            }
            return "";
          };
        },
        {}
      ],
      269: [
        function(e, t, r) {
          var n = e("./_baseClone"),
            i = 4;
          t.exports = function(e) {
            return n(e, i);
          };
        },
        { "./_baseClone": 178 }
      ],
      270: [
        function(e, t, r) {
          t.exports = function(e) {
            return function() {
              return e;
            };
          };
        },
        {}
      ],
      271: [
        function(e, t, r) {
          var n = e("./_baseRest"),
            i = e("./eq"),
            s = e("./_isIterateeCall"),
            a = e("./keysIn"),
            o = Object.prototype,
            u = o.hasOwnProperty,
            l = n(function(e, t) {
              e = Object(e);
              var r = -1,
                n = t.length,
                l = n > 2 ? t[2] : void 0;
              for (l && s(t[0], t[1], l) && (n = 1); ++r < n; )
                for (var c = t[r], p = a(c), d = -1, h = p.length; ++d < h; ) {
                  var f = p[d],
                    m = e[f];
                  (void 0 === m || (i(m, o[f]) && !u.call(e, f))) &&
                    (e[f] = c[f]);
                }
              return e;
            });
          t.exports = l;
        },
        {
          "./_baseRest": 194,
          "./_isIterateeCall": 235,
          "./eq": 272,
          "./keysIn": 292
        }
      ],
      272: [
        function(e, t, r) {
          t.exports = function(e, t) {
            return e === t || (e != e && t != t);
          };
        },
        {}
      ],
      273: [
        function(e, t, r) {
          t.exports = function(e) {
            return e;
          };
        },
        {}
      ],
      274: [
        function(e, t, r) {
          var n = e("./_baseIndexOf"),
            i = e("./isArrayLike"),
            s = e("./isString"),
            a = e("./toInteger"),
            o = e("./values"),
            u = Math.max;
          t.exports = function(e, t, r, l) {
            (e = i(e) ? e : o(e)), (r = r && !l ? a(r) : 0);
            var c = e.length;
            return (
              r < 0 && (r = u(c + r, 0)),
              s(e) ? r <= c && e.indexOf(t, r) > -1 : !!c && n(e, t, r) > -1
            );
          };
        },
        {
          "./_baseIndexOf": 183,
          "./isArrayLike": 277,
          "./isString": 288,
          "./toInteger": 298,
          "./values": 302
        }
      ],
      275: [
        function(e, t, r) {
          var n = e("./_baseIsArguments"),
            i = e("./isObjectLike"),
            s = Object.prototype,
            a = s.hasOwnProperty,
            o = s.propertyIsEnumerable,
            u = n(
              (function() {
                return arguments;
              })()
            )
              ? n
              : function(e) {
                  return i(e) && a.call(e, "callee") && !o.call(e, "callee");
                };
          t.exports = u;
        },
        { "./_baseIsArguments": 184, "./isObjectLike": 284 }
      ],
      276: [
        function(e, t, r) {
          var n = Array.isArray;
          t.exports = n;
        },
        {}
      ],
      277: [
        function(e, t, r) {
          var n = e("./isFunction"),
            i = e("./isLength");
          t.exports = function(e) {
            return null != e && i(e.length) && !n(e);
          };
        },
        { "./isFunction": 279, "./isLength": 281 }
      ],
      278: [
        function(e, t, r) {
          var n = e("./_root"),
            i = e("./stubFalse"),
            s = "object" == typeof r && r && !r.nodeType && r,
            a = s && "object" == typeof t && t && !t.nodeType && t,
            o = a && a.exports === s ? n.Buffer : void 0,
            u = (o ? o.isBuffer : void 0) || i;
          t.exports = u;
        },
        { "./_root": 256, "./stubFalse": 296 }
      ],
      279: [
        function(e, t, r) {
          var n = e("./_baseGetTag"),
            i = e("./isObject"),
            s = "[object AsyncFunction]",
            a = "[object Function]",
            o = "[object GeneratorFunction]",
            u = "[object Proxy]";
          t.exports = function(e) {
            if (!i(e)) return !1;
            var t = n(e);
            return t == a || t == o || t == s || t == u;
          };
        },
        { "./_baseGetTag": 182, "./isObject": 283 }
      ],
      280: [
        function(e, t, r) {
          var n = e("./toInteger");
          t.exports = function(e) {
            return "number" == typeof e && e == n(e);
          };
        },
        { "./toInteger": 298 }
      ],
      281: [
        function(e, t, r) {
          var n = 9007199254740991;
          t.exports = function(e) {
            return "number" == typeof e && e > -1 && e % 1 == 0 && e <= n;
          };
        },
        {}
      ],
      282: [
        function(e, t, r) {
          var n = e("./_baseIsMap"),
            i = e("./_baseUnary"),
            s = e("./_nodeUtil"),
            a = s && s.isMap,
            o = a ? i(a) : n;
          t.exports = o;
        },
        { "./_baseIsMap": 185, "./_baseUnary": 198, "./_nodeUtil": 252 }
      ],
      283: [
        function(e, t, r) {
          t.exports = function(e) {
            var t = typeof e;
            return null != e && ("object" == t || "function" == t);
          };
        },
        {}
      ],
      284: [
        function(e, t, r) {
          t.exports = function(e) {
            return null != e && "object" == typeof e;
          };
        },
        {}
      ],
      285: [
        function(e, t, r) {
          var n = e("./_baseGetTag"),
            i = e("./_getPrototype"),
            s = e("./isObjectLike"),
            a = "[object Object]",
            o = Function.prototype,
            u = Object.prototype,
            l = o.toString,
            c = u.hasOwnProperty,
            p = l.call(Object);
          t.exports = function(e) {
            if (!s(e) || n(e) != a) return !1;
            var t = i(e);
            if (null === t) return !0;
            var r = c.call(t, "constructor") && t.constructor;
            return "function" == typeof r && r instanceof r && l.call(r) == p;
          };
        },
        { "./_baseGetTag": 182, "./_getPrototype": 220, "./isObjectLike": 284 }
      ],
      286: [
        function(e, t, r) {
          var n = e("./_baseIsRegExp"),
            i = e("./_baseUnary"),
            s = e("./_nodeUtil"),
            a = s && s.isRegExp,
            o = a ? i(a) : n;
          t.exports = o;
        },
        { "./_baseIsRegExp": 188, "./_baseUnary": 198, "./_nodeUtil": 252 }
      ],
      287: [
        function(e, t, r) {
          var n = e("./_baseIsSet"),
            i = e("./_baseUnary"),
            s = e("./_nodeUtil"),
            a = s && s.isSet,
            o = a ? i(a) : n;
          t.exports = o;
        },
        { "./_baseIsSet": 189, "./_baseUnary": 198, "./_nodeUtil": 252 }
      ],
      288: [
        function(e, t, r) {
          var n = e("./_baseGetTag"),
            i = e("./isArray"),
            s = e("./isObjectLike"),
            a = "[object String]";
          t.exports = function(e) {
            return "string" == typeof e || (!i(e) && s(e) && n(e) == a);
          };
        },
        { "./_baseGetTag": 182, "./isArray": 276, "./isObjectLike": 284 }
      ],
      289: [
        function(e, t, r) {
          var n = e("./_baseGetTag"),
            i = e("./isObjectLike"),
            s = "[object Symbol]";
          t.exports = function(e) {
            return "symbol" == typeof e || (i(e) && n(e) == s);
          };
        },
        { "./_baseGetTag": 182, "./isObjectLike": 284 }
      ],
      290: [
        function(e, t, r) {
          var n = e("./_baseIsTypedArray"),
            i = e("./_baseUnary"),
            s = e("./_nodeUtil"),
            a = s && s.isTypedArray,
            o = a ? i(a) : n;
          t.exports = o;
        },
        { "./_baseIsTypedArray": 190, "./_baseUnary": 198, "./_nodeUtil": 252 }
      ],
      291: [
        function(e, t, r) {
          var n = e("./_arrayLikeKeys"),
            i = e("./_baseKeys"),
            s = e("./isArrayLike");
          t.exports = function(e) {
            return s(e) ? n(e) : i(e);
          };
        },
        { "./_arrayLikeKeys": 170, "./_baseKeys": 191, "./isArrayLike": 277 }
      ],
      292: [
        function(e, t, r) {
          var n = e("./_arrayLikeKeys"),
            i = e("./_baseKeysIn"),
            s = e("./isArrayLike");
          t.exports = function(e) {
            return s(e) ? n(e, !0) : i(e);
          };
        },
        { "./_arrayLikeKeys": 170, "./_baseKeysIn": 192, "./isArrayLike": 277 }
      ],
      293: [
        function(e, t, r) {
          t.exports = function() {};
        },
        {}
      ],
      294: [
        function(e, t, r) {
          var n = e("./_baseRepeat"),
            i = e("./_isIterateeCall"),
            s = e("./toInteger"),
            a = e("./toString");
          t.exports = function(e, t, r) {
            return (t = (r ? i(e, t, r) : void 0 === t) ? 1 : s(t)), n(a(e), t);
          };
        },
        {
          "./_baseRepeat": 193,
          "./_isIterateeCall": 235,
          "./toInteger": 298,
          "./toString": 300
        }
      ],
      295: [
        function(e, t, r) {
          t.exports = function() {
            return [];
          };
        },
        {}
      ],
      296: [
        function(e, t, r) {
          t.exports = function() {
            return !1;
          };
        },
        {}
      ],
      297: [
        function(e, t, r) {
          var n = e("./toNumber"),
            i = 1 / 0,
            s = 1.7976931348623157e308;
          t.exports = function(e) {
            return e
              ? (e = n(e)) === i || e === -i
                ? (e < 0 ? -1 : 1) * s
                : e == e
                ? e
                : 0
              : 0 === e
              ? e
              : 0;
          };
        },
        { "./toNumber": 299 }
      ],
      298: [
        function(e, t, r) {
          var n = e("./toFinite");
          t.exports = function(e) {
            var t = n(e),
              r = t % 1;
            return t == t ? (r ? t - r : t) : 0;
          };
        },
        { "./toFinite": 297 }
      ],
      299: [
        function(e, t, r) {
          var n = e("./isObject"),
            i = e("./isSymbol"),
            s = NaN,
            a = /^\s+|\s+$/g,
            o = /^[-+]0x[0-9a-f]+$/i,
            u = /^0b[01]+$/i,
            l = /^0o[0-7]+$/i,
            c = parseInt;
          t.exports = function(e) {
            if ("number" == typeof e) return e;
            if (i(e)) return s;
            if (n(e)) {
              var t = "function" == typeof e.valueOf ? e.valueOf() : e;
              e = n(t) ? t + "" : t;
            }
            if ("string" != typeof e) return 0 === e ? e : +e;
            e = e.replace(a, "");
            var r = u.test(e);
            return r || l.test(e)
              ? c(e.slice(2), r ? 2 : 8)
              : o.test(e)
              ? s
              : +e;
          };
        },
        { "./isObject": 283, "./isSymbol": 289 }
      ],
      300: [
        function(e, t, r) {
          var n = e("./_baseToString");
          t.exports = function(e) {
            return null == e ? "" : n(e);
          };
        },
        { "./_baseToString": 197 }
      ],
      301: [
        function(e, t, r) {
          var n = e("./_baseUniq");
          t.exports = function(e) {
            return e && e.length ? n(e) : [];
          };
        },
        { "./_baseUniq": 199 }
      ],
      302: [
        function(e, t, r) {
          var n = e("./_baseValues"),
            i = e("./keys");
          t.exports = function(e) {
            return null == e ? [] : n(e, i(e));
          };
        },
        { "./_baseValues": 200, "./keys": 291 }
      ],
      303: [
        function(e, t, r) {
          var n = 1e3,
            i = 60 * n,
            s = 60 * i,
            a = 24 * s,
            o = 7 * a,
            u = 365.25 * a;
          function l(e, t, r, n) {
            var i = t >= 1.5 * r;
            return Math.round(e / r) + " " + n + (i ? "s" : "");
          }
          t.exports = function(e, t) {
            t = t || {};
            var r = typeof e;
            if ("string" === r && e.length > 0)
              return (function(e) {
                if ((e = String(e)).length > 100) return;
                var t = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
                  e
                );
                if (!t) return;
                var r = parseFloat(t[1]);
                switch ((t[2] || "ms").toLowerCase()) {
                  case "years":
                  case "year":
                  case "yrs":
                  case "yr":
                  case "y":
                    return r * u;
                  case "weeks":
                  case "week":
                  case "w":
                    return r * o;
                  case "days":
                  case "day":
                  case "d":
                    return r * a;
                  case "hours":
                  case "hour":
                  case "hrs":
                  case "hr":
                  case "h":
                    return r * s;
                  case "minutes":
                  case "minute":
                  case "mins":
                  case "min":
                  case "m":
                    return r * i;
                  case "seconds":
                  case "second":
                  case "secs":
                  case "sec":
                  case "s":
                    return r * n;
                  case "milliseconds":
                  case "millisecond":
                  case "msecs":
                  case "msec":
                  case "ms":
                    return r;
                  default:
                    return;
                }
              })(e);
            if ("number" === r && isFinite(e))
              return t.long
                ? (function(e) {
                    var t = Math.abs(e);
                    if (t >= a) return l(e, t, a, "day");
                    if (t >= s) return l(e, t, s, "hour");
                    if (t >= i) return l(e, t, i, "minute");
                    if (t >= n) return l(e, t, n, "second");
                    return e + " ms";
                  })(e)
                : (function(e) {
                    var t = Math.abs(e);
                    if (t >= a) return Math.round(e / a) + "d";
                    if (t >= s) return Math.round(e / s) + "h";
                    if (t >= i) return Math.round(e / i) + "m";
                    if (t >= n) return Math.round(e / n) + "s";
                    return e + "ms";
                  })(e);
            throw new Error(
              "val is not a non-empty string or a valid number. val=" +
                JSON.stringify(e)
            );
          };
        },
        {}
      ],
      304: [
        function(e, t, r) {
          var n = e("./util"),
            i = Object.prototype.hasOwnProperty,
            s = "undefined" != typeof Map;
          function a() {
            (this._array = []),
              (this._set = s ? new Map() : Object.create(null));
          }
          (a.fromArray = function(e, t) {
            for (var r = new a(), n = 0, i = e.length; n < i; n++)
              r.add(e[n], t);
            return r;
          }),
            (a.prototype.size = function() {
              return s
                ? this._set.size
                : Object.getOwnPropertyNames(this._set).length;
            }),
            (a.prototype.add = function(e, t) {
              var r = s ? e : n.toSetString(e),
                a = s ? this.has(e) : i.call(this._set, r),
                o = this._array.length;
              (a && !t) || this._array.push(e),
                a || (s ? this._set.set(e, o) : (this._set[r] = o));
            }),
            (a.prototype.has = function(e) {
              if (s) return this._set.has(e);
              var t = n.toSetString(e);
              return i.call(this._set, t);
            }),
            (a.prototype.indexOf = function(e) {
              if (s) {
                var t = this._set.get(e);
                if (t >= 0) return t;
              } else {
                var r = n.toSetString(e);
                if (i.call(this._set, r)) return this._set[r];
              }
              throw new Error('"' + e + '" is not in the set.');
            }),
            (a.prototype.at = function(e) {
              if (e >= 0 && e < this._array.length) return this._array[e];
              throw new Error("No element indexed by " + e);
            }),
            (a.prototype.toArray = function() {
              return this._array.slice();
            }),
            (r.ArraySet = a);
        },
        { "./util": 313 }
      ],
      305: [
        function(e, t, r) {
          var n = e("./base64");
          (r.encode = function(e) {
            var t,
              r = "",
              i = (function(e) {
                return e < 0 ? 1 + (-e << 1) : 0 + (e << 1);
              })(e);
            do {
              (t = 31 & i), (i >>>= 5) > 0 && (t |= 32), (r += n.encode(t));
            } while (i > 0);
            return r;
          }),
            (r.decode = function(e, t, r) {
              var i,
                s,
                a,
                o,
                u = e.length,
                l = 0,
                c = 0;
              do {
                if (t >= u)
                  throw new Error("Expected more digits in base 64 VLQ value.");
                if (-1 === (s = n.decode(e.charCodeAt(t++))))
                  throw new Error("Invalid base64 digit: " + e.charAt(t - 1));
                (i = !!(32 & s)), (l += (s &= 31) << c), (c += 5);
              } while (i);
              (r.value = ((o = (a = l) >> 1), 1 == (1 & a) ? -o : o)),
                (r.rest = t);
            });
        },
        { "./base64": 306 }
      ],
      306: [
        function(e, t, r) {
          var n = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split(
            ""
          );
          (r.encode = function(e) {
            if (0 <= e && e < n.length) return n[e];
            throw new TypeError("Must be between 0 and 63: " + e);
          }),
            (r.decode = function(e) {
              return 65 <= e && e <= 90
                ? e - 65
                : 97 <= e && e <= 122
                ? e - 97 + 26
                : 48 <= e && e <= 57
                ? e - 48 + 52
                : 43 == e
                ? 62
                : 47 == e
                ? 63
                : -1;
            });
        },
        {}
      ],
      307: [
        function(e, t, r) {
          (r.GREATEST_LOWER_BOUND = 1),
            (r.LEAST_UPPER_BOUND = 2),
            (r.search = function(e, t, n, i) {
              if (0 === t.length) return -1;
              var s = (function e(t, n, i, s, a, o) {
                var u = Math.floor((n - t) / 2) + t,
                  l = a(i, s[u], !0);
                return 0 === l
                  ? u
                  : l > 0
                  ? n - u > 1
                    ? e(u, n, i, s, a, o)
                    : o == r.LEAST_UPPER_BOUND
                    ? n < s.length
                      ? n
                      : -1
                    : u
                  : u - t > 1
                  ? e(t, u, i, s, a, o)
                  : o == r.LEAST_UPPER_BOUND
                  ? u
                  : t < 0
                  ? -1
                  : t;
              })(-1, t.length, e, t, n, i || r.GREATEST_LOWER_BOUND);
              if (s < 0) return -1;
              for (; s - 1 >= 0 && 0 === n(t[s], t[s - 1], !0); ) --s;
              return s;
            });
        },
        {}
      ],
      308: [
        function(e, t, r) {
          var n = e("./util");
          function i() {
            (this._array = []),
              (this._sorted = !0),
              (this._last = { generatedLine: -1, generatedColumn: 0 });
          }
          (i.prototype.unsortedForEach = function(e, t) {
            this._array.forEach(e, t);
          }),
            (i.prototype.add = function(e) {
              var t, r, i, s, a, o;
              (t = this._last),
                (r = e),
                (i = t.generatedLine),
                (s = r.generatedLine),
                (a = t.generatedColumn),
                (o = r.generatedColumn),
                s > i ||
                (s == i && o >= a) ||
                n.compareByGeneratedPositionsInflated(t, r) <= 0
                  ? ((this._last = e), this._array.push(e))
                  : ((this._sorted = !1), this._array.push(e));
            }),
            (i.prototype.toArray = function() {
              return (
                this._sorted ||
                  (this._array.sort(n.compareByGeneratedPositionsInflated),
                  (this._sorted = !0)),
                this._array
              );
            }),
            (r.MappingList = i);
        },
        { "./util": 313 }
      ],
      309: [
        function(e, t, r) {
          function n(e, t, r) {
            var n = e[t];
            (e[t] = e[r]), (e[r] = n);
          }
          function i(e, t, r, s) {
            if (r < s) {
              var a = r - 1;
              n(
                e,
                ((c = r), (p = s), Math.round(c + Math.random() * (p - c))),
                s
              );
              for (var o = e[s], u = r; u < s; u++)
                t(e[u], o) <= 0 && n(e, (a += 1), u);
              n(e, a + 1, u);
              var l = a + 1;
              i(e, t, r, l - 1), i(e, t, l + 1, s);
            }
            var c, p;
          }
          r.quickSort = function(e, t) {
            i(e, t, 0, e.length - 1);
          };
        },
        {}
      ],
      310: [
        function(e, t, r) {
          var n = e("./util"),
            i = e("./binary-search"),
            s = e("./array-set").ArraySet,
            a = e("./base64-vlq"),
            o = e("./quick-sort").quickSort;
          function u(e) {
            var t = e;
            return (
              "string" == typeof e &&
                (t = JSON.parse(e.replace(/^\)\]\}'/, ""))),
              null != t.sections ? new p(t) : new l(t)
            );
          }
          function l(e) {
            var t = e;
            "string" == typeof e && (t = JSON.parse(e.replace(/^\)\]\}'/, "")));
            var r = n.getArg(t, "version"),
              i = n.getArg(t, "sources"),
              a = n.getArg(t, "names", []),
              o = n.getArg(t, "sourceRoot", null),
              u = n.getArg(t, "sourcesContent", null),
              l = n.getArg(t, "mappings"),
              c = n.getArg(t, "file", null);
            if (r != this._version)
              throw new Error("Unsupported version: " + r);
            (i = i
              .map(String)
              .map(n.normalize)
              .map(function(e) {
                return o && n.isAbsolute(o) && n.isAbsolute(e)
                  ? n.relative(o, e)
                  : e;
              })),
              (this._names = s.fromArray(a.map(String), !0)),
              (this._sources = s.fromArray(i, !0)),
              (this.sourceRoot = o),
              (this.sourcesContent = u),
              (this._mappings = l),
              (this.file = c);
          }
          function c() {
            (this.generatedLine = 0),
              (this.generatedColumn = 0),
              (this.source = null),
              (this.originalLine = null),
              (this.originalColumn = null),
              (this.name = null);
          }
          function p(e) {
            var t = e;
            "string" == typeof e && (t = JSON.parse(e.replace(/^\)\]\}'/, "")));
            var r = n.getArg(t, "version"),
              i = n.getArg(t, "sections");
            if (r != this._version)
              throw new Error("Unsupported version: " + r);
            (this._sources = new s()), (this._names = new s());
            var a = { line: -1, column: 0 };
            this._sections = i.map(function(e) {
              if (e.url)
                throw new Error(
                  "Support for url field in sections not implemented."
                );
              var t = n.getArg(e, "offset"),
                r = n.getArg(t, "line"),
                i = n.getArg(t, "column");
              if (r < a.line || (r === a.line && i < a.column))
                throw new Error(
                  "Section offsets must be ordered and non-overlapping."
                );
              return (
                (a = t),
                {
                  generatedOffset: {
                    generatedLine: r + 1,
                    generatedColumn: i + 1
                  },
                  consumer: new u(n.getArg(e, "map"))
                }
              );
            });
          }
          (u.fromSourceMap = function(e) {
            return l.fromSourceMap(e);
          }),
            (u.prototype._version = 3),
            (u.prototype.__generatedMappings = null),
            Object.defineProperty(u.prototype, "_generatedMappings", {
              get: function() {
                return (
                  this.__generatedMappings ||
                    this._parseMappings(this._mappings, this.sourceRoot),
                  this.__generatedMappings
                );
              }
            }),
            (u.prototype.__originalMappings = null),
            Object.defineProperty(u.prototype, "_originalMappings", {
              get: function() {
                return (
                  this.__originalMappings ||
                    this._parseMappings(this._mappings, this.sourceRoot),
                  this.__originalMappings
                );
              }
            }),
            (u.prototype._charIsMappingSeparator = function(e, t) {
              var r = e.charAt(t);
              return ";" === r || "," === r;
            }),
            (u.prototype._parseMappings = function(e, t) {
              throw new Error("Subclasses must implement _parseMappings");
            }),
            (u.GENERATED_ORDER = 1),
            (u.ORIGINAL_ORDER = 2),
            (u.GREATEST_LOWER_BOUND = 1),
            (u.LEAST_UPPER_BOUND = 2),
            (u.prototype.eachMapping = function(e, t, r) {
              var i,
                s = t || null;
              switch (r || u.GENERATED_ORDER) {
                case u.GENERATED_ORDER:
                  i = this._generatedMappings;
                  break;
                case u.ORIGINAL_ORDER:
                  i = this._originalMappings;
                  break;
                default:
                  throw new Error("Unknown order of iteration.");
              }
              var a = this.sourceRoot;
              i.map(function(e) {
                var t = null === e.source ? null : this._sources.at(e.source);
                return (
                  null != t && null != a && (t = n.join(a, t)),
                  {
                    source: t,
                    generatedLine: e.generatedLine,
                    generatedColumn: e.generatedColumn,
                    originalLine: e.originalLine,
                    originalColumn: e.originalColumn,
                    name: null === e.name ? null : this._names.at(e.name)
                  }
                );
              }, this).forEach(e, s);
            }),
            (u.prototype.allGeneratedPositionsFor = function(e) {
              var t = n.getArg(e, "line"),
                r = {
                  source: n.getArg(e, "source"),
                  originalLine: t,
                  originalColumn: n.getArg(e, "column", 0)
                };
              if (
                (null != this.sourceRoot &&
                  (r.source = n.relative(this.sourceRoot, r.source)),
                !this._sources.has(r.source))
              )
                return [];
              r.source = this._sources.indexOf(r.source);
              var s = [],
                a = this._findMapping(
                  r,
                  this._originalMappings,
                  "originalLine",
                  "originalColumn",
                  n.compareByOriginalPositions,
                  i.LEAST_UPPER_BOUND
                );
              if (a >= 0) {
                var o = this._originalMappings[a];
                if (void 0 === e.column)
                  for (var u = o.originalLine; o && o.originalLine === u; )
                    s.push({
                      line: n.getArg(o, "generatedLine", null),
                      column: n.getArg(o, "generatedColumn", null),
                      lastColumn: n.getArg(o, "lastGeneratedColumn", null)
                    }),
                      (o = this._originalMappings[++a]);
                else
                  for (
                    var l = o.originalColumn;
                    o && o.originalLine === t && o.originalColumn == l;

                  )
                    s.push({
                      line: n.getArg(o, "generatedLine", null),
                      column: n.getArg(o, "generatedColumn", null),
                      lastColumn: n.getArg(o, "lastGeneratedColumn", null)
                    }),
                      (o = this._originalMappings[++a]);
              }
              return s;
            }),
            (r.SourceMapConsumer = u),
            (l.prototype = Object.create(u.prototype)),
            (l.prototype.consumer = u),
            (l.fromSourceMap = function(e) {
              var t = Object.create(l.prototype),
                r = (t._names = s.fromArray(e._names.toArray(), !0)),
                i = (t._sources = s.fromArray(e._sources.toArray(), !0));
              (t.sourceRoot = e._sourceRoot),
                (t.sourcesContent = e._generateSourcesContent(
                  t._sources.toArray(),
                  t.sourceRoot
                )),
                (t.file = e._file);
              for (
                var a = e._mappings.toArray().slice(),
                  u = (t.__generatedMappings = []),
                  p = (t.__originalMappings = []),
                  d = 0,
                  h = a.length;
                d < h;
                d++
              ) {
                var f = a[d],
                  m = new c();
                (m.generatedLine = f.generatedLine),
                  (m.generatedColumn = f.generatedColumn),
                  f.source &&
                    ((m.source = i.indexOf(f.source)),
                    (m.originalLine = f.originalLine),
                    (m.originalColumn = f.originalColumn),
                    f.name && (m.name = r.indexOf(f.name)),
                    p.push(m)),
                  u.push(m);
              }
              return o(t.__originalMappings, n.compareByOriginalPositions), t;
            }),
            (l.prototype._version = 3),
            Object.defineProperty(l.prototype, "sources", {
              get: function() {
                return this._sources.toArray().map(function(e) {
                  return null != this.sourceRoot
                    ? n.join(this.sourceRoot, e)
                    : e;
                }, this);
              }
            }),
            (l.prototype._parseMappings = function(e, t) {
              for (
                var r,
                  i,
                  s,
                  u,
                  l,
                  p = 1,
                  d = 0,
                  h = 0,
                  f = 0,
                  m = 0,
                  y = 0,
                  g = e.length,
                  b = 0,
                  v = {},
                  E = {},
                  T = [],
                  x = [];
                b < g;

              )
                if (";" === e.charAt(b)) p++, b++, (d = 0);
                else if ("," === e.charAt(b)) b++;
                else {
                  for (
                    (r = new c()).generatedLine = p, u = b;
                    u < g && !this._charIsMappingSeparator(e, u);
                    u++
                  );
                  if ((s = v[(i = e.slice(b, u))])) b += i.length;
                  else {
                    for (s = []; b < u; )
                      a.decode(e, b, E), (l = E.value), (b = E.rest), s.push(l);
                    if (2 === s.length)
                      throw new Error("Found a source, but no line and column");
                    if (3 === s.length)
                      throw new Error("Found a source and line, but no column");
                    v[i] = s;
                  }
                  (r.generatedColumn = d + s[0]),
                    (d = r.generatedColumn),
                    s.length > 1 &&
                      ((r.source = m + s[1]),
                      (m += s[1]),
                      (r.originalLine = h + s[2]),
                      (h = r.originalLine),
                      (r.originalLine += 1),
                      (r.originalColumn = f + s[3]),
                      (f = r.originalColumn),
                      s.length > 4 && ((r.name = y + s[4]), (y += s[4]))),
                    x.push(r),
                    "number" == typeof r.originalLine && T.push(r);
                }
              o(x, n.compareByGeneratedPositionsDeflated),
                (this.__generatedMappings = x),
                o(T, n.compareByOriginalPositions),
                (this.__originalMappings = T);
            }),
            (l.prototype._findMapping = function(e, t, r, n, s, a) {
              if (e[r] <= 0)
                throw new TypeError(
                  "Line must be greater than or equal to 1, got " + e[r]
                );
              if (e[n] < 0)
                throw new TypeError(
                  "Column must be greater than or equal to 0, got " + e[n]
                );
              return i.search(e, t, s, a);
            }),
            (l.prototype.computeColumnSpans = function() {
              for (var e = 0; e < this._generatedMappings.length; ++e) {
                var t = this._generatedMappings[e];
                if (e + 1 < this._generatedMappings.length) {
                  var r = this._generatedMappings[e + 1];
                  if (t.generatedLine === r.generatedLine) {
                    t.lastGeneratedColumn = r.generatedColumn - 1;
                    continue;
                  }
                }
                t.lastGeneratedColumn = 1 / 0;
              }
            }),
            (l.prototype.originalPositionFor = function(e) {
              var t = {
                  generatedLine: n.getArg(e, "line"),
                  generatedColumn: n.getArg(e, "column")
                },
                r = this._findMapping(
                  t,
                  this._generatedMappings,
                  "generatedLine",
                  "generatedColumn",
                  n.compareByGeneratedPositionsDeflated,
                  n.getArg(e, "bias", u.GREATEST_LOWER_BOUND)
                );
              if (r >= 0) {
                var i = this._generatedMappings[r];
                if (i.generatedLine === t.generatedLine) {
                  var s = n.getArg(i, "source", null);
                  null !== s &&
                    ((s = this._sources.at(s)),
                    null != this.sourceRoot &&
                      (s = n.join(this.sourceRoot, s)));
                  var a = n.getArg(i, "name", null);
                  return (
                    null !== a && (a = this._names.at(a)),
                    {
                      source: s,
                      line: n.getArg(i, "originalLine", null),
                      column: n.getArg(i, "originalColumn", null),
                      name: a
                    }
                  );
                }
              }
              return { source: null, line: null, column: null, name: null };
            }),
            (l.prototype.hasContentsOfAllSources = function() {
              return (
                !!this.sourcesContent &&
                (this.sourcesContent.length >= this._sources.size() &&
                  !this.sourcesContent.some(function(e) {
                    return null == e;
                  }))
              );
            }),
            (l.prototype.sourceContentFor = function(e, t) {
              if (!this.sourcesContent) return null;
              if (
                (null != this.sourceRoot &&
                  (e = n.relative(this.sourceRoot, e)),
                this._sources.has(e))
              )
                return this.sourcesContent[this._sources.indexOf(e)];
              var r;
              if (
                null != this.sourceRoot &&
                (r = n.urlParse(this.sourceRoot))
              ) {
                var i = e.replace(/^file:\/\//, "");
                if ("file" == r.scheme && this._sources.has(i))
                  return this.sourcesContent[this._sources.indexOf(i)];
                if ((!r.path || "/" == r.path) && this._sources.has("/" + e))
                  return this.sourcesContent[this._sources.indexOf("/" + e)];
              }
              if (t) return null;
              throw new Error('"' + e + '" is not in the SourceMap.');
            }),
            (l.prototype.generatedPositionFor = function(e) {
              var t = n.getArg(e, "source");
              if (
                (null != this.sourceRoot &&
                  (t = n.relative(this.sourceRoot, t)),
                !this._sources.has(t))
              )
                return { line: null, column: null, lastColumn: null };
              var r = {
                  source: (t = this._sources.indexOf(t)),
                  originalLine: n.getArg(e, "line"),
                  originalColumn: n.getArg(e, "column")
                },
                i = this._findMapping(
                  r,
                  this._originalMappings,
                  "originalLine",
                  "originalColumn",
                  n.compareByOriginalPositions,
                  n.getArg(e, "bias", u.GREATEST_LOWER_BOUND)
                );
              if (i >= 0) {
                var s = this._originalMappings[i];
                if (s.source === r.source)
                  return {
                    line: n.getArg(s, "generatedLine", null),
                    column: n.getArg(s, "generatedColumn", null),
                    lastColumn: n.getArg(s, "lastGeneratedColumn", null)
                  };
              }
              return { line: null, column: null, lastColumn: null };
            }),
            (r.BasicSourceMapConsumer = l),
            (p.prototype = Object.create(u.prototype)),
            (p.prototype.constructor = u),
            (p.prototype._version = 3),
            Object.defineProperty(p.prototype, "sources", {
              get: function() {
                for (var e = [], t = 0; t < this._sections.length; t++)
                  for (
                    var r = 0;
                    r < this._sections[t].consumer.sources.length;
                    r++
                  )
                    e.push(this._sections[t].consumer.sources[r]);
                return e;
              }
            }),
            (p.prototype.originalPositionFor = function(e) {
              var t = {
                  generatedLine: n.getArg(e, "line"),
                  generatedColumn: n.getArg(e, "column")
                },
                r = i.search(t, this._sections, function(e, t) {
                  var r = e.generatedLine - t.generatedOffset.generatedLine;
                  return (
                    r || e.generatedColumn - t.generatedOffset.generatedColumn
                  );
                }),
                s = this._sections[r];
              return s
                ? s.consumer.originalPositionFor({
                    line:
                      t.generatedLine - (s.generatedOffset.generatedLine - 1),
                    column:
                      t.generatedColumn -
                      (s.generatedOffset.generatedLine === t.generatedLine
                        ? s.generatedOffset.generatedColumn - 1
                        : 0),
                    bias: e.bias
                  })
                : { source: null, line: null, column: null, name: null };
            }),
            (p.prototype.hasContentsOfAllSources = function() {
              return this._sections.every(function(e) {
                return e.consumer.hasContentsOfAllSources();
              });
            }),
            (p.prototype.sourceContentFor = function(e, t) {
              for (var r = 0; r < this._sections.length; r++) {
                var n = this._sections[r].consumer.sourceContentFor(e, !0);
                if (n) return n;
              }
              if (t) return null;
              throw new Error('"' + e + '" is not in the SourceMap.');
            }),
            (p.prototype.generatedPositionFor = function(e) {
              for (var t = 0; t < this._sections.length; t++) {
                var r = this._sections[t];
                if (-1 !== r.consumer.sources.indexOf(n.getArg(e, "source"))) {
                  var i = r.consumer.generatedPositionFor(e);
                  if (i)
                    return {
                      line: i.line + (r.generatedOffset.generatedLine - 1),
                      column:
                        i.column +
                        (r.generatedOffset.generatedLine === i.line
                          ? r.generatedOffset.generatedColumn - 1
                          : 0)
                    };
                }
              }
              return { line: null, column: null };
            }),
            (p.prototype._parseMappings = function(e, t) {
              (this.__generatedMappings = []), (this.__originalMappings = []);
              for (var r = 0; r < this._sections.length; r++)
                for (
                  var i = this._sections[r],
                    s = i.consumer._generatedMappings,
                    a = 0;
                  a < s.length;
                  a++
                ) {
                  var u = s[a],
                    l = i.consumer._sources.at(u.source);
                  null !== i.consumer.sourceRoot &&
                    (l = n.join(i.consumer.sourceRoot, l)),
                    this._sources.add(l),
                    (l = this._sources.indexOf(l));
                  var c = i.consumer._names.at(u.name);
                  this._names.add(c), (c = this._names.indexOf(c));
                  var p = {
                    source: l,
                    generatedLine:
                      u.generatedLine + (i.generatedOffset.generatedLine - 1),
                    generatedColumn:
                      u.generatedColumn +
                      (i.generatedOffset.generatedLine === u.generatedLine
                        ? i.generatedOffset.generatedColumn - 1
                        : 0),
                    originalLine: u.originalLine,
                    originalColumn: u.originalColumn,
                    name: c
                  };
                  this.__generatedMappings.push(p),
                    "number" == typeof p.originalLine &&
                      this.__originalMappings.push(p);
                }
              o(
                this.__generatedMappings,
                n.compareByGeneratedPositionsDeflated
              ),
                o(this.__originalMappings, n.compareByOriginalPositions);
            }),
            (r.IndexedSourceMapConsumer = p);
        },
        {
          "./array-set": 304,
          "./base64-vlq": 305,
          "./binary-search": 307,
          "./quick-sort": 309,
          "./util": 313
        }
      ],
      311: [
        function(e, t, r) {
          var n = e("./base64-vlq"),
            i = e("./util"),
            s = e("./array-set").ArraySet,
            a = e("./mapping-list").MappingList;
          function o(e) {
            e || (e = {}),
              (this._file = i.getArg(e, "file", null)),
              (this._sourceRoot = i.getArg(e, "sourceRoot", null)),
              (this._skipValidation = i.getArg(e, "skipValidation", !1)),
              (this._sources = new s()),
              (this._names = new s()),
              (this._mappings = new a()),
              (this._sourcesContents = null);
          }
          (o.prototype._version = 3),
            (o.fromSourceMap = function(e) {
              var t = e.sourceRoot,
                r = new o({ file: e.file, sourceRoot: t });
              return (
                e.eachMapping(function(e) {
                  var n = {
                    generated: {
                      line: e.generatedLine,
                      column: e.generatedColumn
                    }
                  };
                  null != e.source &&
                    ((n.source = e.source),
                    null != t && (n.source = i.relative(t, n.source)),
                    (n.original = {
                      line: e.originalLine,
                      column: e.originalColumn
                    }),
                    null != e.name && (n.name = e.name)),
                    r.addMapping(n);
                }),
                e.sources.forEach(function(t) {
                  var n = e.sourceContentFor(t);
                  null != n && r.setSourceContent(t, n);
                }),
                r
              );
            }),
            (o.prototype.addMapping = function(e) {
              var t = i.getArg(e, "generated"),
                r = i.getArg(e, "original", null),
                n = i.getArg(e, "source", null),
                s = i.getArg(e, "name", null);
              this._skipValidation || this._validateMapping(t, r, n, s),
                null != n &&
                  ((n = String(n)),
                  this._sources.has(n) || this._sources.add(n)),
                null != s &&
                  ((s = String(s)), this._names.has(s) || this._names.add(s)),
                this._mappings.add({
                  generatedLine: t.line,
                  generatedColumn: t.column,
                  originalLine: null != r && r.line,
                  originalColumn: null != r && r.column,
                  source: n,
                  name: s
                });
            }),
            (o.prototype.setSourceContent = function(e, t) {
              var r = e;
              null != this._sourceRoot && (r = i.relative(this._sourceRoot, r)),
                null != t
                  ? (this._sourcesContents ||
                      (this._sourcesContents = Object.create(null)),
                    (this._sourcesContents[i.toSetString(r)] = t))
                  : this._sourcesContents &&
                    (delete this._sourcesContents[i.toSetString(r)],
                    0 === Object.keys(this._sourcesContents).length &&
                      (this._sourcesContents = null));
            }),
            (o.prototype.applySourceMap = function(e, t, r) {
              var n = t;
              if (null == t) {
                if (null == e.file)
                  throw new Error(
                    'SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, or the source map\'s "file" property. Both were omitted.'
                  );
                n = e.file;
              }
              var a = this._sourceRoot;
              null != a && (n = i.relative(a, n));
              var o = new s(),
                u = new s();
              this._mappings.unsortedForEach(function(t) {
                if (t.source === n && null != t.originalLine) {
                  var s = e.originalPositionFor({
                    line: t.originalLine,
                    column: t.originalColumn
                  });
                  null != s.source &&
                    ((t.source = s.source),
                    null != r && (t.source = i.join(r, t.source)),
                    null != a && (t.source = i.relative(a, t.source)),
                    (t.originalLine = s.line),
                    (t.originalColumn = s.column),
                    null != s.name && (t.name = s.name));
                }
                var l = t.source;
                null == l || o.has(l) || o.add(l);
                var c = t.name;
                null == c || u.has(c) || u.add(c);
              }, this),
                (this._sources = o),
                (this._names = u),
                e.sources.forEach(function(t) {
                  var n = e.sourceContentFor(t);
                  null != n &&
                    (null != r && (t = i.join(r, t)),
                    null != a && (t = i.relative(a, t)),
                    this.setSourceContent(t, n));
                }, this);
            }),
            (o.prototype._validateMapping = function(e, t, r, n) {
              if (t && "number" != typeof t.line && "number" != typeof t.column)
                throw new Error(
                  "original.line and original.column are not numbers -- you probably meant to omit the original mapping entirely and only map the generated position. If so, pass null for the original mapping instead of an object with empty or null values."
                );
              if (
                (!(
                  e &&
                  "line" in e &&
                  "column" in e &&
                  e.line > 0 &&
                  e.column >= 0
                ) ||
                  t ||
                  r ||
                  n) &&
                !(
                  e &&
                  "line" in e &&
                  "column" in e &&
                  t &&
                  "line" in t &&
                  "column" in t &&
                  e.line > 0 &&
                  e.column >= 0 &&
                  t.line > 0 &&
                  t.column >= 0 &&
                  r
                )
              )
                throw new Error(
                  "Invalid mapping: " +
                    JSON.stringify({
                      generated: e,
                      source: r,
                      original: t,
                      name: n
                    })
                );
            }),
            (o.prototype._serializeMappings = function() {
              for (
                var e,
                  t,
                  r,
                  s,
                  a = 0,
                  o = 1,
                  u = 0,
                  l = 0,
                  c = 0,
                  p = 0,
                  d = "",
                  h = this._mappings.toArray(),
                  f = 0,
                  m = h.length;
                f < m;
                f++
              ) {
                if (((e = ""), (t = h[f]).generatedLine !== o))
                  for (a = 0; t.generatedLine !== o; ) (e += ";"), o++;
                else if (f > 0) {
                  if (!i.compareByGeneratedPositionsInflated(t, h[f - 1]))
                    continue;
                  e += ",";
                }
                (e += n.encode(t.generatedColumn - a)),
                  (a = t.generatedColumn),
                  null != t.source &&
                    ((s = this._sources.indexOf(t.source)),
                    (e += n.encode(s - p)),
                    (p = s),
                    (e += n.encode(t.originalLine - 1 - l)),
                    (l = t.originalLine - 1),
                    (e += n.encode(t.originalColumn - u)),
                    (u = t.originalColumn),
                    null != t.name &&
                      ((r = this._names.indexOf(t.name)),
                      (e += n.encode(r - c)),
                      (c = r))),
                  (d += e);
              }
              return d;
            }),
            (o.prototype._generateSourcesContent = function(e, t) {
              return e.map(function(e) {
                if (!this._sourcesContents) return null;
                null != t && (e = i.relative(t, e));
                var r = i.toSetString(e);
                return Object.prototype.hasOwnProperty.call(
                  this._sourcesContents,
                  r
                )
                  ? this._sourcesContents[r]
                  : null;
              }, this);
            }),
            (o.prototype.toJSON = function() {
              var e = {
                version: this._version,
                sources: this._sources.toArray(),
                names: this._names.toArray(),
                mappings: this._serializeMappings()
              };
              return (
                null != this._file && (e.file = this._file),
                null != this._sourceRoot && (e.sourceRoot = this._sourceRoot),
                this._sourcesContents &&
                  (e.sourcesContent = this._generateSourcesContent(
                    e.sources,
                    e.sourceRoot
                  )),
                e
              );
            }),
            (o.prototype.toString = function() {
              return JSON.stringify(this.toJSON());
            }),
            (r.SourceMapGenerator = o);
        },
        {
          "./array-set": 304,
          "./base64-vlq": 305,
          "./mapping-list": 308,
          "./util": 313
        }
      ],
      312: [
        function(e, t, r) {
          var n = e("./source-map-generator").SourceMapGenerator,
            i = e("./util"),
            s = /(\r?\n)/,
            a = "$$$isSourceNode$$$";
          function o(e, t, r, n, i) {
            (this.children = []),
              (this.sourceContents = {}),
              (this.line = null == e ? null : e),
              (this.column = null == t ? null : t),
              (this.source = null == r ? null : r),
              (this.name = null == i ? null : i),
              (this[a] = !0),
              null != n && this.add(n);
          }
          (o.fromStringWithSourceMap = function(e, t, r) {
            var n = new o(),
              a = e.split(s),
              u = 0,
              l = function() {
                return e() + (e() || "");
                function e() {
                  return u < a.length ? a[u++] : void 0;
                }
              },
              c = 1,
              p = 0,
              d = null;
            return (
              t.eachMapping(function(e) {
                if (null !== d) {
                  if (!(c < e.generatedLine)) {
                    var t = (r = a[u]).substr(0, e.generatedColumn - p);
                    return (
                      (a[u] = r.substr(e.generatedColumn - p)),
                      (p = e.generatedColumn),
                      h(d, t),
                      void (d = e)
                    );
                  }
                  h(d, l()), c++, (p = 0);
                }
                for (; c < e.generatedLine; ) n.add(l()), c++;
                if (p < e.generatedColumn) {
                  var r = a[u];
                  n.add(r.substr(0, e.generatedColumn)),
                    (a[u] = r.substr(e.generatedColumn)),
                    (p = e.generatedColumn);
                }
                d = e;
              }, this),
              u < a.length && (d && h(d, l()), n.add(a.splice(u).join(""))),
              t.sources.forEach(function(e) {
                var s = t.sourceContentFor(e);
                null != s &&
                  (null != r && (e = i.join(r, e)), n.setSourceContent(e, s));
              }),
              n
            );
            function h(e, t) {
              if (null === e || void 0 === e.source) n.add(t);
              else {
                var s = r ? i.join(r, e.source) : e.source;
                n.add(new o(e.originalLine, e.originalColumn, s, t, e.name));
              }
            }
          }),
            (o.prototype.add = function(e) {
              if (Array.isArray(e))
                e.forEach(function(e) {
                  this.add(e);
                }, this);
              else {
                if (!e[a] && "string" != typeof e)
                  throw new TypeError(
                    "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " +
                      e
                  );
                e && this.children.push(e);
              }
              return this;
            }),
            (o.prototype.prepend = function(e) {
              if (Array.isArray(e))
                for (var t = e.length - 1; t >= 0; t--) this.prepend(e[t]);
              else {
                if (!e[a] && "string" != typeof e)
                  throw new TypeError(
                    "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " +
                      e
                  );
                this.children.unshift(e);
              }
              return this;
            }),
            (o.prototype.walk = function(e) {
              for (var t, r = 0, n = this.children.length; r < n; r++)
                (t = this.children[r])[a]
                  ? t.walk(e)
                  : "" !== t &&
                    e(t, {
                      source: this.source,
                      line: this.line,
                      column: this.column,
                      name: this.name
                    });
            }),
            (o.prototype.join = function(e) {
              var t,
                r,
                n = this.children.length;
              if (n > 0) {
                for (t = [], r = 0; r < n - 1; r++)
                  t.push(this.children[r]), t.push(e);
                t.push(this.children[r]), (this.children = t);
              }
              return this;
            }),
            (o.prototype.replaceRight = function(e, t) {
              var r = this.children[this.children.length - 1];
              return (
                r[a]
                  ? r.replaceRight(e, t)
                  : "string" == typeof r
                  ? (this.children[this.children.length - 1] = r.replace(e, t))
                  : this.children.push("".replace(e, t)),
                this
              );
            }),
            (o.prototype.setSourceContent = function(e, t) {
              this.sourceContents[i.toSetString(e)] = t;
            }),
            (o.prototype.walkSourceContents = function(e) {
              for (var t = 0, r = this.children.length; t < r; t++)
                this.children[t][a] && this.children[t].walkSourceContents(e);
              var n = Object.keys(this.sourceContents);
              for (t = 0, r = n.length; t < r; t++)
                e(i.fromSetString(n[t]), this.sourceContents[n[t]]);
            }),
            (o.prototype.toString = function() {
              var e = "";
              return (
                this.walk(function(t) {
                  e += t;
                }),
                e
              );
            }),
            (o.prototype.toStringWithSourceMap = function(e) {
              var t = { code: "", line: 1, column: 0 },
                r = new n(e),
                i = !1,
                s = null,
                a = null,
                o = null,
                u = null;
              return (
                this.walk(function(e, n) {
                  (t.code += e),
                    null !== n.source && null !== n.line && null !== n.column
                      ? ((s === n.source &&
                          a === n.line &&
                          o === n.column &&
                          u === n.name) ||
                          r.addMapping({
                            source: n.source,
                            original: { line: n.line, column: n.column },
                            generated: { line: t.line, column: t.column },
                            name: n.name
                          }),
                        (s = n.source),
                        (a = n.line),
                        (o = n.column),
                        (u = n.name),
                        (i = !0))
                      : i &&
                        (r.addMapping({
                          generated: { line: t.line, column: t.column }
                        }),
                        (s = null),
                        (i = !1));
                  for (var l = 0, c = e.length; l < c; l++)
                    10 === e.charCodeAt(l)
                      ? (t.line++,
                        (t.column = 0),
                        l + 1 === c
                          ? ((s = null), (i = !1))
                          : i &&
                            r.addMapping({
                              source: n.source,
                              original: { line: n.line, column: n.column },
                              generated: { line: t.line, column: t.column },
                              name: n.name
                            }))
                      : t.column++;
                }),
                this.walkSourceContents(function(e, t) {
                  r.setSourceContent(e, t);
                }),
                { code: t.code, map: r }
              );
            }),
            (r.SourceNode = o);
        },
        { "./source-map-generator": 311, "./util": 313 }
      ],
      313: [
        function(e, t, r) {
          r.getArg = function(e, t, r) {
            if (t in e) return e[t];
            if (3 === arguments.length) return r;
            throw new Error('"' + t + '" is a required argument.');
          };
          var n = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.]*)(?::(\d+))?(\S*)$/,
            i = /^data:.+\,.+$/;
          function s(e) {
            var t = e.match(n);
            return t
              ? { scheme: t[1], auth: t[2], host: t[3], port: t[4], path: t[5] }
              : null;
          }
          function a(e) {
            var t = "";
            return (
              e.scheme && (t += e.scheme + ":"),
              (t += "//"),
              e.auth && (t += e.auth + "@"),
              e.host && (t += e.host),
              e.port && (t += ":" + e.port),
              e.path && (t += e.path),
              t
            );
          }
          function o(e) {
            var t = e,
              n = s(e);
            if (n) {
              if (!n.path) return e;
              t = n.path;
            }
            for (
              var i,
                o = r.isAbsolute(t),
                u = t.split(/\/+/),
                l = 0,
                c = u.length - 1;
              c >= 0;
              c--
            )
              "." === (i = u[c])
                ? u.splice(c, 1)
                : ".." === i
                ? l++
                : l > 0 &&
                  ("" === i
                    ? (u.splice(c + 1, l), (l = 0))
                    : (u.splice(c, 2), l--));
            return (
              "" === (t = u.join("/")) && (t = o ? "/" : "."),
              n ? ((n.path = t), a(n)) : t
            );
          }
          (r.urlParse = s),
            (r.urlGenerate = a),
            (r.normalize = o),
            (r.join = function(e, t) {
              "" === e && (e = "."), "" === t && (t = ".");
              var r = s(t),
                n = s(e);
              if ((n && (e = n.path || "/"), r && !r.scheme))
                return n && (r.scheme = n.scheme), a(r);
              if (r || t.match(i)) return t;
              if (n && !n.host && !n.path) return (n.host = t), a(n);
              var u =
                "/" === t.charAt(0) ? t : o(e.replace(/\/+$/, "") + "/" + t);
              return n ? ((n.path = u), a(n)) : u;
            }),
            (r.isAbsolute = function(e) {
              return "/" === e.charAt(0) || !!e.match(n);
            }),
            (r.relative = function(e, t) {
              "" === e && (e = "."), (e = e.replace(/\/$/, ""));
              for (var r = 0; 0 !== t.indexOf(e + "/"); ) {
                var n = e.lastIndexOf("/");
                if (n < 0) return t;
                if ((e = e.slice(0, n)).match(/^([^\/]+:\/)?\/*$/)) return t;
                ++r;
              }
              return Array(r + 1).join("../") + t.substr(e.length + 1);
            });
          var u = !("__proto__" in Object.create(null));
          function l(e) {
            return e;
          }
          function c(e) {
            if (!e) return !1;
            var t = e.length;
            if (t < 9) return !1;
            if (
              95 !== e.charCodeAt(t - 1) ||
              95 !== e.charCodeAt(t - 2) ||
              111 !== e.charCodeAt(t - 3) ||
              116 !== e.charCodeAt(t - 4) ||
              111 !== e.charCodeAt(t - 5) ||
              114 !== e.charCodeAt(t - 6) ||
              112 !== e.charCodeAt(t - 7) ||
              95 !== e.charCodeAt(t - 8) ||
              95 !== e.charCodeAt(t - 9)
            )
              return !1;
            for (var r = t - 10; r >= 0; r--)
              if (36 !== e.charCodeAt(r)) return !1;
            return !0;
          }
          function p(e, t) {
            return e === t ? 0 : e > t ? 1 : -1;
          }
          (r.toSetString = u
            ? l
            : function(e) {
                return c(e) ? "$" + e : e;
              }),
            (r.fromSetString = u
              ? l
              : function(e) {
                  return c(e) ? e.slice(1) : e;
                }),
            (r.compareByOriginalPositions = function(e, t, r) {
              var n = e.source - t.source;
              return 0 !== n
                ? n
                : 0 != (n = e.originalLine - t.originalLine)
                ? n
                : 0 != (n = e.originalColumn - t.originalColumn) || r
                ? n
                : 0 != (n = e.generatedColumn - t.generatedColumn)
                ? n
                : 0 != (n = e.generatedLine - t.generatedLine)
                ? n
                : e.name - t.name;
            }),
            (r.compareByGeneratedPositionsDeflated = function(e, t, r) {
              var n = e.generatedLine - t.generatedLine;
              return 0 !== n
                ? n
                : 0 != (n = e.generatedColumn - t.generatedColumn) || r
                ? n
                : 0 != (n = e.source - t.source)
                ? n
                : 0 != (n = e.originalLine - t.originalLine)
                ? n
                : 0 != (n = e.originalColumn - t.originalColumn)
                ? n
                : e.name - t.name;
            }),
            (r.compareByGeneratedPositionsInflated = function(e, t) {
              var r = e.generatedLine - t.generatedLine;
              return 0 !== r
                ? r
                : 0 != (r = e.generatedColumn - t.generatedColumn)
                ? r
                : 0 !== (r = p(e.source, t.source))
                ? r
                : 0 != (r = e.originalLine - t.originalLine)
                ? r
                : 0 != (r = e.originalColumn - t.originalColumn)
                ? r
                : p(e.name, t.name);
            });
        },
        {}
      ],
      314: [
        function(e, t, r) {
          (r.SourceMapGenerator = e(
            "./lib/source-map-generator"
          ).SourceMapGenerator),
            (r.SourceMapConsumer = e(
              "./lib/source-map-consumer"
            ).SourceMapConsumer),
            (r.SourceNode = e("./lib/source-node").SourceNode);
        },
        {
          "./lib/source-map-consumer": 310,
          "./lib/source-map-generator": 311,
          "./lib/source-node": 312
        }
      ],
      315: [
        function(e, t, r) {
          "use strict";
          t.exports = { stdout: !1, stderr: !1 };
        },
        {}
      ],
      316: [
        function(e, t, r) {
          "use strict";
          let n = null;
          function i(e) {
            if (null !== n && (n.property, 1)) {
              const e = n;
              return (n = i.prototype = null), e;
            }
            return (
              (n = i.prototype = null == e ? Object.create(null) : e), new i()
            );
          }
          i(),
            (t.exports = function(e) {
              return i(e);
            });
        },
        {}
      ],
      317: [
        function(e, t, r) {
          "use strict";
          t.exports = function(e) {
            for (var t = e.length; /[\s\uFEFF\u00A0]/.test(e[t - 1]); ) t--;
            return e.slice(0, t);
          };
        },
        {}
      ],
      318: [
        function(e, t, r) {
          (function(e, n) {
            !(function(e, n) {
              "object" == typeof r && void 0 !== t
                ? n(r)
                : n(((e = e || self).VueTemplateCompiler = {}));
            })(this, function(t) {
              "use strict";
              var r = /\r?\n/g,
                i = /^\s*$/,
                s = /^(\r?\n)*[\t\s]/,
                a = function(e) {
                  if (!s.test(e)) return e;
                  for (
                    var t, n, a, u = e.split(r), l = 1 / 0, c = 0;
                    c < u.length;
                    c++
                  ) {
                    var p = u[c];
                    if (!i.test(p))
                      if (t) (n = o(p, t)) < l && (l = n);
                      else {
                        if (" " !== (a = p.charAt(0)) && "\t" !== a) return e;
                        (n = o(p, (t = a))) < l && (l = n);
                      }
                  }
                  return u
                    .map(function(e) {
                      return e.slice(l);
                    })
                    .join("\n");
                };
              function o(e, t) {
                for (var r = 0; e.charAt(r) === t; ) r++;
                return r;
              }
              var u = Object.freeze({});
              var l = Object.prototype.toString;
              function c(e) {
                return "[object Object]" === l.call(e);
              }
              function p(e, t) {
                for (
                  var r = Object.create(null), n = e.split(","), i = 0;
                  i < n.length;
                  i++
                )
                  r[n[i]] = !0;
                return t
                  ? function(e) {
                      return r[e.toLowerCase()];
                    }
                  : function(e) {
                      return r[e];
                    };
              }
              var d = p("slot,component", !0);
              p("key,ref,slot,slot-scope,is");
              var h = Object.prototype.hasOwnProperty;
              function f(e, t) {
                return h.call(e, t);
              }
              function m(e) {
                var t = Object.create(null);
                return function(r) {
                  return t[r] || (t[r] = e(r));
                };
              }
              var y = /-(\w)/g,
                g = m(function(e) {
                  return e.replace(y, function(e, t) {
                    return t ? t.toUpperCase() : "";
                  });
                }),
                b = /\B([A-Z])/g,
                v = m(function(e) {
                  return e.replace(b, "-$1").toLowerCase();
                });
              Function.prototype.bind;
              function E(e, t) {
                for (var r in t) e[r] = t[r];
                return e;
              }
              function T(e, t, r) {}
              var x = function(e, t, r) {
                return !1;
              };
              var A = p(
                  "area,base,br,col,embed,frame,hr,img,input,isindex,keygen,link,meta,param,source,track,wbr"
                ),
                S = p(
                  "colgroup,dd,dt,li,options,p,td,tfoot,th,thead,tr,source"
                ),
                D = p(
                  "address,article,aside,base,blockquote,body,caption,col,colgroup,dd,details,dialog,div,dl,dt,fieldset,figcaption,figure,footer,form,h1,h2,h3,h4,h5,h6,head,header,hgroup,hr,html,legend,li,menuitem,meta,optgroup,option,param,rp,rt,source,style,summary,tbody,td,tfoot,th,thead,title,tr,track"
                );
              function P(e, t, r, n) {
                Object.defineProperty(e, t, {
                  value: r,
                  enumerable: !!n,
                  writable: !0,
                  configurable: !0
                });
              }
              var C = /^\s*([^\s"'<>\/=]+)(?:\s*(=)\s*(?:"([^"]*)"+|'([^']*)'+|([^\s"'=<>`]+)))?/,
                w = /^\s*((?:v-[\w-]+:|@|:|#)\[[^=]+\][^\s"'<>\/=]*)(?:\s*(=)\s*(?:"([^"]*)"+|'([^']*)'+|([^\s"'=<>`]+)))?/,
                F =
                  "[a-zA-Z_][\\-\\.0-9_a-zA-Z" +
                  /a-zA-Z\u00B7\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u037D\u037F-\u1FFF\u200C-\u200D\u203F-\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD/
                    .source +
                  "]*",
                _ = "((?:" + F + "\\:)?" + F + ")",
                O = new RegExp("^<" + _),
                k = /^\s*(\/?)>/,
                I = new RegExp("^<\\/" + _ + "[^>]*>"),
                N = /^<!DOCTYPE [^>]+>/i,
                L = /^<!\--/,
                B = /^<!\[/,
                M = p("script,style,textarea", !0),
                j = {},
                R = {
                  "&lt;": "<",
                  "&gt;": ">",
                  "&quot;": '"',
                  "&amp;": "&",
                  "&#10;": "\n",
                  "&#9;": "\t",
                  "&#39;": "'"
                },
                q = /&(?:lt|gt|quot|amp|#39);/g,
                V = /&(?:lt|gt|quot|amp|#39|#10|#9);/g,
                U = p("pre,textarea", !0),
                K = function(e, t) {
                  return e && U(e) && "\n" === t[0];
                };
              function G(e, t) {
                var r = t ? V : q;
                return e.replace(r, function(e) {
                  return R[e];
                });
              }
              function W(e, t) {
                for (
                  var r,
                    n,
                    i = [],
                    s = t.expectHTML,
                    a = t.isUnaryTag || x,
                    o = t.canBeLeftOpenTag || x,
                    u = 0;
                  e;

                ) {
                  if (((r = e), n && M(n))) {
                    var l = 0,
                      c = n.toLowerCase(),
                      p =
                        j[c] ||
                        (j[c] = new RegExp(
                          "([\\s\\S]*?)(</" + c + "[^>]*>)",
                          "i"
                        )),
                      d = e.replace(p, function(e, r, n) {
                        return (
                          (l = n.length),
                          M(c) ||
                            "noscript" === c ||
                            (r = r
                              .replace(/<!\--([\s\S]*?)-->/g, "$1")
                              .replace(/<!\[CDATA\[([\s\S]*?)]]>/g, "$1")),
                          K(c, r) && (r = r.slice(1)),
                          t.chars && t.chars(r),
                          ""
                        );
                      });
                    (u += e.length - d.length), (e = d), _(c, u - l, u);
                  } else {
                    var h = e.indexOf("<");
                    if (0 === h) {
                      if (L.test(e)) {
                        var f = e.indexOf("--\x3e");
                        if (f >= 0) {
                          t.shouldKeepComment &&
                            t.comment(e.substring(4, f), u, u + f + 3),
                            S(f + 3);
                          continue;
                        }
                      }
                      if (B.test(e)) {
                        var m = e.indexOf("]>");
                        if (m >= 0) {
                          S(m + 2);
                          continue;
                        }
                      }
                      var y = e.match(N);
                      if (y) {
                        S(y[0].length);
                        continue;
                      }
                      var g = e.match(I);
                      if (g) {
                        var b = u;
                        S(g[0].length), _(g[1], b, u);
                        continue;
                      }
                      var v = P();
                      if (v) {
                        F(v), K(v.tagName, e) && S(1);
                        continue;
                      }
                    }
                    var E = void 0,
                      T = void 0,
                      A = void 0;
                    if (h >= 0) {
                      for (
                        T = e.slice(h);
                        !(
                          I.test(T) ||
                          O.test(T) ||
                          L.test(T) ||
                          B.test(T) ||
                          (A = T.indexOf("<", 1)) < 0
                        );

                      )
                        (h += A), (T = e.slice(h));
                      E = e.substring(0, h);
                    }
                    h < 0 && (E = e),
                      E && S(E.length),
                      t.chars && E && t.chars(E, u - E.length, u);
                  }
                  if (e === r) {
                    t.chars && t.chars(e),
                      !i.length &&
                        t.warn &&
                        t.warn(
                          'Mal-formatted tag at end of template: "' + e + '"',
                          { start: u + e.length }
                        );
                    break;
                  }
                }
                function S(t) {
                  (u += t), (e = e.substring(t));
                }
                function P() {
                  var t = e.match(O);
                  if (t) {
                    var r,
                      n,
                      i = { tagName: t[1], attrs: [], start: u };
                    for (
                      S(t[0].length);
                      !(r = e.match(k)) && (n = e.match(w) || e.match(C));

                    )
                      (n.start = u),
                        S(n[0].length),
                        (n.end = u),
                        i.attrs.push(n);
                    if (r)
                      return (
                        (i.unarySlash = r[1]), S(r[0].length), (i.end = u), i
                      );
                  }
                }
                function F(e) {
                  var r = e.tagName,
                    u = e.unarySlash;
                  s && ("p" === n && D(r) && _(n), o(r) && n === r && _(r));
                  for (
                    var l = a(r) || !!u,
                      c = e.attrs.length,
                      p = new Array(c),
                      d = 0;
                    d < c;
                    d++
                  ) {
                    var h = e.attrs[d],
                      f = h[3] || h[4] || h[5] || "",
                      m =
                        "a" === r && "href" === h[1]
                          ? t.shouldDecodeNewlinesForHref
                          : t.shouldDecodeNewlines;
                    (p[d] = { name: h[1], value: G(f, m) }),
                      t.outputSourceRange &&
                        ((p[d].start = h.start + h[0].match(/^\s*/).length),
                        (p[d].end = h.end));
                  }
                  l ||
                    (i.push({
                      tag: r,
                      lowerCasedTag: r.toLowerCase(),
                      attrs: p,
                      start: e.start,
                      end: e.end
                    }),
                    (n = r)),
                    t.start && t.start(r, p, l, e.start, e.end);
                }
                function _(e, r, s) {
                  var a, o;
                  if ((null == r && (r = u), null == s && (s = u), e))
                    for (
                      o = e.toLowerCase(), a = i.length - 1;
                      a >= 0 && i[a].lowerCasedTag !== o;
                      a--
                    );
                  else a = 0;
                  if (a >= 0) {
                    for (var l = i.length - 1; l >= a; l--)
                      (l > a || (!e && t.warn)) &&
                        t.warn(
                          "tag <" + i[l].tag + "> has no matching end tag.",
                          { start: i[l].start, end: i[l].end }
                        ),
                        t.end && t.end(i[l].tag, r, s);
                    (i.length = a), (n = a && i[a - 1].tag);
                  } else "br" === o ? t.start && t.start(e, [], !0, r, s) : "p" === o && (t.start && t.start(e, [], !1, r, s), t.end && t.end(e, r, s));
                }
                _();
              }
              var J = /\r?\n/g,
                X = /./g,
                $ = p("script,style,template", !0);
              var H,
                Y = "__proto__" in {},
                z = "undefined" != typeof window,
                Q =
                  "undefined" != typeof WXEnvironment &&
                  !!WXEnvironment.platform,
                Z = Q && WXEnvironment.platform.toLowerCase(),
                ee = z && window.navigator.userAgent.toLowerCase(),
                te = ee && /msie|trident/.test(ee),
                re =
                  (ee && ee.indexOf("msie 9.0"), ee && ee.indexOf("edge/") > 0),
                ne =
                  (ee && ee.indexOf("android"),
                  ee && /iphone|ipad|ipod|ios/.test(ee),
                  ee && /chrome\/\d+/.test(ee),
                  ee && /phantomjs/.test(ee),
                  ee && ee.match(/firefox\/(\d+)/),
                  {}.watch);
              if (z)
                try {
                  var ie = {};
                  Object.defineProperty(ie, "passive", { get: function() {} }),
                    window.addEventListener("test-passive", null, ie);
                } catch (e) {}
              var se = function() {
                return (
                  void 0 === H &&
                    (H =
                      !z &&
                      !Q &&
                      void 0 !== e &&
                      (e.process && "server" === e.process.env.VUE_ENV)),
                  H
                );
              };
              z && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;
              function ae(e) {
                return (
                  "function" == typeof e && /native code/.test(e.toString())
                );
              }
              var oe =
                "undefined" != typeof Symbol &&
                ae(Symbol) &&
                "undefined" != typeof Reflect &&
                ae(Reflect.ownKeys);
              "undefined" != typeof Set && ae(Set) && Set;
              var ue,
                le = [
                  "beforeCreate",
                  "created",
                  "beforeMount",
                  "mounted",
                  "beforeUpdate",
                  "updated",
                  "beforeDestroy",
                  "destroyed",
                  "activated",
                  "deactivated",
                  "errorCaptured",
                  "serverPrefetch"
                ],
                ce = {
                  optionMergeStrategies: Object.create(null),
                  silent: !1,
                  productionTip: !0,
                  devtools: !0,
                  performance: !1,
                  errorHandler: null,
                  warnHandler: null,
                  ignoredElements: [],
                  keyCodes: Object.create(null),
                  isReservedTag: x,
                  isReservedAttr: x,
                  isUnknownElement: x,
                  getTagNamespace: T,
                  parsePlatformTagName: function(e) {
                    return e;
                  },
                  mustUseProp: x,
                  async: !0,
                  _lifecycleHooks: le
                },
                pe = T,
                de = T,
                he = T,
                fe = "undefined" != typeof console,
                me = /(?:^|[-_])(\w)/g;
              (pe = function(e, t) {
                var r = t ? he(t) : "";
                fe && !ce.silent && console.error("[Vue warn]: " + e + r);
              }),
                (de = function(e, t) {
                  fe &&
                    !ce.silent &&
                    console.warn("[Vue tip]: " + e + (t ? he(t) : ""));
                }),
                (ue = function(e, t) {
                  if (e.$root === e) return "<Root>";
                  var r =
                      "function" == typeof e && null != e.cid
                        ? e.options
                        : e._isVue
                        ? e.$options || e.constructor.options
                        : e,
                    n = r.name || r._componentTag,
                    i = r.__file;
                  if (!n && i) {
                    var s = i.match(/([^\/\\]+)\.vue$/);
                    n = s && s[1];
                  }
                  return (
                    (n
                      ? "<" +
                        n
                          .replace(me, function(e) {
                            return e.toUpperCase();
                          })
                          .replace(/[-_]/g, "") +
                        ">"
                      : "<Anonymous>") + (i && !1 !== t ? " at " + i : "")
                  );
                });
              he = function(e) {
                if (e._isVue && e.$parent) {
                  for (var t = [], r = 0; e; ) {
                    if (t.length > 0) {
                      var n = t[t.length - 1];
                      if (n.constructor === e.constructor) {
                        r++, (e = e.$parent);
                        continue;
                      }
                      r > 0 && ((t[t.length - 1] = [n, r]), (r = 0));
                    }
                    t.push(e), (e = e.$parent);
                  }
                  return (
                    "\n\nfound in\n\n" +
                    t
                      .map(function(e, t) {
                        return (
                          "" +
                          (0 === t
                            ? "---\x3e "
                            : (function(e, t) {
                                for (var r = ""; t; )
                                  t % 2 == 1 && (r += e),
                                    t > 1 && (e += e),
                                    (t >>= 1);
                                return r;
                              })(" ", 5 + 2 * t)) +
                          (Array.isArray(e)
                            ? ue(e[0]) + "... (" + e[1] + " recursive calls)"
                            : ue(e))
                        );
                      })
                      .join("\n")
                  );
                }
                return "\n\n(found in " + ue(e) + ")";
              };
              var ye = 0,
                ge = function() {
                  (this.id = ye++), (this.subs = []);
                };
              (ge.prototype.addSub = function(e) {
                this.subs.push(e);
              }),
                (ge.prototype.removeSub = function(e) {
                  !(function(e, t) {
                    if (e.length) {
                      var r = e.indexOf(t);
                      if (r > -1) e.splice(r, 1);
                    }
                  })(this.subs, e);
                }),
                (ge.prototype.depend = function() {
                  ge.target && ge.target.addDep(this);
                }),
                (ge.prototype.notify = function() {
                  for (
                    var e = this.subs.slice(), t = 0, r = e.length;
                    t < r;
                    t++
                  )
                    e[t].update();
                }),
                (ge.target = null);
              var be = function(e, t, r, n, i, s, a, o) {
                  (this.tag = e),
                    (this.data = t),
                    (this.children = r),
                    (this.text = n),
                    (this.elm = i),
                    (this.ns = void 0),
                    (this.context = s),
                    (this.fnContext = void 0),
                    (this.fnOptions = void 0),
                    (this.fnScopeId = void 0),
                    (this.key = t && t.key),
                    (this.componentOptions = a),
                    (this.componentInstance = void 0),
                    (this.parent = void 0),
                    (this.raw = !1),
                    (this.isStatic = !1),
                    (this.isRootInsert = !0),
                    (this.isComment = !1),
                    (this.isCloned = !1),
                    (this.isOnce = !1),
                    (this.asyncFactory = o),
                    (this.asyncMeta = void 0),
                    (this.isAsyncPlaceholder = !1);
                },
                ve = { child: { configurable: !0 } };
              (ve.child.get = function() {
                return this.componentInstance;
              }),
                Object.defineProperties(be.prototype, ve);
              var Ee = Array.prototype,
                Te = Object.create(Ee);
              [
                "push",
                "pop",
                "shift",
                "unshift",
                "splice",
                "sort",
                "reverse"
              ].forEach(function(e) {
                var t = Ee[e];
                P(Te, e, function() {
                  for (var r = [], n = arguments.length; n--; )
                    r[n] = arguments[n];
                  var i,
                    s = t.apply(this, r),
                    a = this.__ob__;
                  switch (e) {
                    case "push":
                    case "unshift":
                      i = r;
                      break;
                    case "splice":
                      i = r.slice(2);
                  }
                  return i && a.observeArray(i), a.dep.notify(), s;
                });
              });
              var xe = Object.getOwnPropertyNames(Te),
                Ae = !0,
                Se = function(e) {
                  var t;
                  (this.value = e),
                    (this.dep = new ge()),
                    (this.vmCount = 0),
                    P(e, "__ob__", this),
                    Array.isArray(e)
                      ? (Y
                          ? ((t = Te), (e.__proto__ = t))
                          : (function(e, t, r) {
                              for (var n = 0, i = r.length; n < i; n++) {
                                var s = r[n];
                                P(e, s, t[s]);
                              }
                            })(e, Te, xe),
                        this.observeArray(e))
                      : this.walk(e);
                };
              function De(e, t) {
                var r, n;
                if (
                  !(null === (r = e) || "object" != typeof r || e instanceof be)
                )
                  return (
                    f(e, "__ob__") && e.__ob__ instanceof Se
                      ? (n = e.__ob__)
                      : Ae &&
                        !se() &&
                        (Array.isArray(e) || c(e)) &&
                        Object.isExtensible(e) &&
                        !e._isVue &&
                        (n = new Se(e)),
                    t && n && n.vmCount++,
                    n
                  );
              }
              function Pe(e, t, r, n, i) {
                var s = new ge(),
                  a = Object.getOwnPropertyDescriptor(e, t);
                if (!a || !1 !== a.configurable) {
                  var o = a && a.get,
                    u = a && a.set;
                  (o && !u) || 2 !== arguments.length || (r = e[t]);
                  var l = !i && De(r);
                  Object.defineProperty(e, t, {
                    enumerable: !0,
                    configurable: !0,
                    get: function() {
                      var t = o ? o.call(e) : r;
                      return (
                        ge.target &&
                          (s.depend(),
                          l &&
                            (l.dep.depend(),
                            Array.isArray(t) &&
                              (function e(t) {
                                for (
                                  var r = void 0, n = 0, i = t.length;
                                  n < i;
                                  n++
                                )
                                  (r = t[n]) &&
                                    r.__ob__ &&
                                    r.__ob__.dep.depend(),
                                    Array.isArray(r) && e(r);
                              })(t))),
                        t
                      );
                    },
                    set: function(t) {
                      var a = o ? o.call(e) : r;
                      t === a ||
                        (t != t && a != a) ||
                        (n && n(),
                        (o && !u) ||
                          (u ? u.call(e, t) : (r = t),
                          (l = !i && De(t)),
                          s.notify()));
                    }
                  });
                }
              }
              function Ce(e, t, r) {
                var n;
                if (
                  ((null == e ||
                    ("string" == typeof (n = e) ||
                      "number" == typeof n ||
                      "symbol" == typeof n ||
                      "boolean" == typeof n)) &&
                    pe(
                      "Cannot set reactive property on undefined, null, or primitive value: " +
                        e
                    ),
                  Array.isArray(e) &&
                    (function(e) {
                      var t = parseFloat(String(e));
                      return t >= 0 && Math.floor(t) === t && isFinite(e);
                    })(t))
                )
                  return (
                    (e.length = Math.max(e.length, t)), e.splice(t, 1, r), r
                  );
                if (t in e && !(t in Object.prototype)) return (e[t] = r), r;
                var i = e.__ob__;
                return e._isVue || (i && i.vmCount)
                  ? (pe(
                      "Avoid adding reactive properties to a Vue instance or its root $data at runtime - declare it upfront in the data option."
                    ),
                    r)
                  : i
                  ? (Pe(i.value, t, r), i.dep.notify(), r)
                  : ((e[t] = r), r);
              }
              (Se.prototype.walk = function(e) {
                for (var t = Object.keys(e), r = 0; r < t.length; r++)
                  Pe(e, t[r]);
              }),
                (Se.prototype.observeArray = function(e) {
                  for (var t = 0, r = e.length; t < r; t++) De(e[t]);
                });
              var we = ce.optionMergeStrategies;
              function Fe(e, t) {
                if (!t) return e;
                for (
                  var r,
                    n,
                    i,
                    s = oe ? Reflect.ownKeys(t) : Object.keys(t),
                    a = 0;
                  a < s.length;
                  a++
                )
                  "__ob__" !== (r = s[a]) &&
                    ((n = e[r]),
                    (i = t[r]),
                    f(e, r)
                      ? n !== i && c(n) && c(i) && Fe(n, i)
                      : Ce(e, r, i));
                return e;
              }
              function _e(e, t, r) {
                return r
                  ? function() {
                      var n = "function" == typeof t ? t.call(r, r) : t,
                        i = "function" == typeof e ? e.call(r, r) : e;
                      return n ? Fe(n, i) : i;
                    }
                  : t
                  ? e
                    ? function() {
                        return Fe(
                          "function" == typeof t ? t.call(this, this) : t,
                          "function" == typeof e ? e.call(this, this) : e
                        );
                      }
                    : t
                  : e;
              }
              function Oe(e, t) {
                var r = t ? (e ? e.concat(t) : Array.isArray(t) ? t : [t]) : e;
                return r
                  ? (function(e) {
                      for (var t = [], r = 0; r < e.length; r++)
                        -1 === t.indexOf(e[r]) && t.push(e[r]);
                      return t;
                    })(r)
                  : r;
              }
              function ke(e, t, r, n) {
                var i = Object.create(e || null);
                return t ? (Ne(n, t, r), E(i, t)) : i;
              }
              (we.el = we.propsData = function(e, t, r, n) {
                return (
                  r ||
                    pe(
                      'option "' +
                        n +
                        '" can only be used during instance creation with the `new` keyword.'
                    ),
                  Ie(e, t)
                );
              }),
                (we.data = function(e, t, r) {
                  return r
                    ? _e(e, t, r)
                    : t && "function" != typeof t
                    ? (pe(
                        'The "data" option should be a function that returns a per-instance value in component definitions.',
                        r
                      ),
                      e)
                    : _e(e, t);
                }),
                le.forEach(function(e) {
                  we[e] = Oe;
                }),
                ["component", "directive", "filter"].forEach(function(e) {
                  we[e + "s"] = ke;
                }),
                (we.watch = function(e, t, r, n) {
                  if ((e === ne && (e = void 0), t === ne && (t = void 0), !t))
                    return Object.create(e || null);
                  if ((Ne(n, t, r), !e)) return t;
                  var i = {};
                  for (var s in (E(i, e), t)) {
                    var a = i[s],
                      o = t[s];
                    a && !Array.isArray(a) && (a = [a]),
                      (i[s] = a ? a.concat(o) : Array.isArray(o) ? o : [o]);
                  }
                  return i;
                }),
                (we.props = we.methods = we.inject = we.computed = function(
                  e,
                  t,
                  r,
                  n
                ) {
                  if ((t && Ne(n, t, r), !e)) return t;
                  var i = Object.create(null);
                  return E(i, e), t && E(i, t), i;
                }),
                (we.provide = _e);
              var Ie = function(e, t) {
                return void 0 === t ? e : t;
              };
              function Ne(e, t, r) {
                c(t) ||
                  pe(
                    'Invalid value for option "' +
                      e +
                      '": expected an Object, but got ' +
                      (function(e) {
                        return l.call(e).slice(8, -1);
                      })(t) +
                      ".",
                    r
                  );
              }
              var Le = [];
              if ("undefined" != typeof Promise && ae(Promise));
              else if (
                te ||
                "undefined" == typeof MutationObserver ||
                (!ae(MutationObserver) &&
                  "[object MutationObserverConstructor]" !==
                    MutationObserver.toString())
              )
                void 0 !== n && ae(n);
              else {
                var Be = new MutationObserver(function() {
                    var e = Le.slice(0);
                    Le.length = 0;
                    for (var t = 0; t < e.length; t++) e[t]();
                  }),
                  Me = document.createTextNode(String(1));
                Be.observe(Me, { characterData: !0 });
              }
              p("style,class");
              var je = p("input,textarea,option,select,progress"),
                Re = p("contenteditable,draggable,spellcheck"),
                qe =
                  (p("events,caret,typing,plaintext-only"),
                  p(
                    "allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,default,defaultchecked,defaultmuted,defaultselected,defer,disabled,enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,required,reversed,scoped,seamless,selected,sortable,translate,truespeed,typemustmatch,visible"
                  )),
                Ve = p(
                  "html,body,base,head,link,meta,style,title,address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,menuitem,summary,content,element,shadow,template,blockquote,iframe,tfoot"
                ),
                Ue = p(
                  "svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,foreignObject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view",
                  !0
                );
              p("text,number,password,search,email,tel,url");
              var Ke = /[\w).+\-_$\]]/;
              function Ge(e) {
                var t,
                  r,
                  n,
                  i,
                  s,
                  a = !1,
                  o = !1,
                  u = !1,
                  l = !1,
                  c = 0,
                  p = 0,
                  d = 0,
                  h = 0;
                for (n = 0; n < e.length; n++)
                  if (((r = t), (t = e.charCodeAt(n)), a))
                    39 === t && 92 !== r && (a = !1);
                  else if (o) 34 === t && 92 !== r && (o = !1);
                  else if (u) 96 === t && 92 !== r && (u = !1);
                  else if (l) 47 === t && 92 !== r && (l = !1);
                  else if (
                    124 !== t ||
                    124 === e.charCodeAt(n + 1) ||
                    124 === e.charCodeAt(n - 1) ||
                    c ||
                    p ||
                    d
                  ) {
                    switch (t) {
                      case 34:
                        o = !0;
                        break;
                      case 39:
                        a = !0;
                        break;
                      case 96:
                        u = !0;
                        break;
                      case 40:
                        d++;
                        break;
                      case 41:
                        d--;
                        break;
                      case 91:
                        p++;
                        break;
                      case 93:
                        p--;
                        break;
                      case 123:
                        c++;
                        break;
                      case 125:
                        c--;
                    }
                    if (47 === t) {
                      for (
                        var f = n - 1, m = void 0;
                        f >= 0 && " " === (m = e.charAt(f));
                        f--
                      );
                      (m && Ke.test(m)) || (l = !0);
                    }
                  } else
                    void 0 === i
                      ? ((h = n + 1), (i = e.slice(0, n).trim()))
                      : y();
                function y() {
                  (s || (s = [])).push(e.slice(h, n).trim()), (h = n + 1);
                }
                if (
                  (void 0 === i ? (i = e.slice(0, n).trim()) : 0 !== h && y(),
                  s)
                )
                  for (n = 0; n < s.length; n++) i = We(i, s[n]);
                return i;
              }
              function We(e, t) {
                var r = t.indexOf("(");
                if (r < 0) return '_f("' + t + '")(' + e + ")";
                var n = t.slice(0, r),
                  i = t.slice(r + 1);
                return '_f("' + n + '")(' + e + (")" !== i ? "," + i : i);
              }
              var Je = /\{\{((?:.|\r?\n)+?)\}\}/g,
                Xe = /[-.*+?^${}()|[\]\/\\]/g,
                $e = m(function(e) {
                  var t = e[0].replace(Xe, "\\$&"),
                    r = e[1].replace(Xe, "\\$&");
                  return new RegExp(t + "((?:.|\\n)+?)" + r, "g");
                });
              function He(e, t) {
                var r = t ? $e(t) : Je;
                if (r.test(e)) {
                  for (
                    var n, i, s, a = [], o = [], u = (r.lastIndex = 0);
                    (n = r.exec(e));

                  ) {
                    (i = n.index) > u &&
                      (o.push((s = e.slice(u, i))), a.push(JSON.stringify(s)));
                    var l = Ge(n[1].trim());
                    a.push("_s(" + l + ")"),
                      o.push({ "@binding": l }),
                      (u = i + n[0].length);
                  }
                  return (
                    u < e.length &&
                      (o.push((s = e.slice(u))), a.push(JSON.stringify(s))),
                    { expression: a.join("+"), tokens: o }
                  );
                }
              }
              function Ye(e, t) {
                console.error("[Vue compiler]: " + e);
              }
              function ze(e, t) {
                return e
                  ? e
                      .map(function(e) {
                        return e[t];
                      })
                      .filter(function(e) {
                        return e;
                      })
                  : [];
              }
              function Qe(e, t, r, n, i) {
                (e.props || (e.props = [])).push(
                  ut({ name: t, value: r, dynamic: i }, n)
                ),
                  (e.plain = !1);
              }
              function Ze(e, t, r, n, i) {
                (i
                  ? e.dynamicAttrs || (e.dynamicAttrs = [])
                  : e.attrs || (e.attrs = [])
                ).push(ut({ name: t, value: r, dynamic: i }, n)),
                  (e.plain = !1);
              }
              function et(e, t, r, n) {
                (e.attrsMap[t] = r),
                  e.attrsList.push(ut({ name: t, value: r }, n));
              }
              function tt(e, t, r, n, i, s, a, o) {
                (e.directives || (e.directives = [])).push(
                  ut(
                    {
                      name: t,
                      rawName: r,
                      value: n,
                      arg: i,
                      isDynamicArg: s,
                      modifiers: a
                    },
                    o
                  )
                ),
                  (e.plain = !1);
              }
              function rt(e, t, r) {
                return r ? "_p(" + t + ',"' + e + '")' : e + t;
              }
              function nt(e, t, r, n, i, s, a, o) {
                var l;
                (n = n || u),
                  s &&
                    n.prevent &&
                    n.passive &&
                    s(
                      "passive and prevent can't be used together. Passive handler can't prevent default event.",
                      a
                    ),
                  n.right
                    ? o
                      ? (t = "(" + t + ")==='click'?'contextmenu':(" + t + ")")
                      : "click" === t && ((t = "contextmenu"), delete n.right)
                    : n.middle &&
                      (o
                        ? (t = "(" + t + ")==='click'?'mouseup':(" + t + ")")
                        : "click" === t && (t = "mouseup")),
                  n.capture && (delete n.capture, (t = rt("!", t, o))),
                  n.once && (delete n.once, (t = rt("~", t, o))),
                  n.passive && (delete n.passive, (t = rt("&", t, o))),
                  n.native
                    ? (delete n.native,
                      (l = e.nativeEvents || (e.nativeEvents = {})))
                    : (l = e.events || (e.events = {}));
                var c = ut({ value: r.trim(), dynamic: o }, a);
                n !== u && (c.modifiers = n);
                var p = l[t];
                Array.isArray(p)
                  ? i
                    ? p.unshift(c)
                    : p.push(c)
                  : (l[t] = p ? (i ? [c, p] : [p, c]) : c),
                  (e.plain = !1);
              }
              function it(e, t) {
                return (
                  e.rawAttrsMap[":" + t] ||
                  e.rawAttrsMap["v-bind:" + t] ||
                  e.rawAttrsMap[t]
                );
              }
              function st(e, t, r) {
                var n = at(e, ":" + t) || at(e, "v-bind:" + t);
                if (null != n) return Ge(n);
                if (!1 !== r) {
                  var i = at(e, t);
                  if (null != i) return JSON.stringify(i);
                }
              }
              function at(e, t, r) {
                var n;
                if (null != (n = e.attrsMap[t]))
                  for (var i = e.attrsList, s = 0, a = i.length; s < a; s++)
                    if (i[s].name === t) {
                      i.splice(s, 1);
                      break;
                    }
                return r && delete e.attrsMap[t], n;
              }
              function ot(e, t) {
                for (var r = e.attrsList, n = 0, i = r.length; n < i; n++) {
                  var s = r[n];
                  if (t.test(s.name)) return r.splice(n, 1), s;
                }
              }
              function ut(e, t) {
                return (
                  t &&
                    (null != t.start && (e.start = t.start),
                    null != t.end && (e.end = t.end)),
                  e
                );
              }
              var lt = {
                  staticKeys: ["staticClass"],
                  transformNode: function(e, t) {
                    var r = t.warn || Ye,
                      n = at(e, "class");
                    n &&
                      He(n, t.delimiters) &&
                      r(
                        'class="' +
                          n +
                          '": Interpolation inside attributes has been removed. Use v-bind or the colon shorthand instead. For example, instead of <div class="{{ val }}">, use <div :class="val">.',
                        e.rawAttrsMap.class
                      ),
                      n && (e.staticClass = JSON.stringify(n));
                    var i = st(e, "class", !1);
                    i && (e.classBinding = i);
                  },
                  genData: function(e) {
                    var t = "";
                    return (
                      e.staticClass &&
                        (t += "staticClass:" + e.staticClass + ","),
                      e.classBinding && (t += "class:" + e.classBinding + ","),
                      t
                    );
                  }
                },
                ct = m(function(e) {
                  var t = {},
                    r = /:(.+)/;
                  return (
                    e.split(/;(?![^(]*\))/g).forEach(function(e) {
                      if (e) {
                        var n = e.split(r);
                        n.length > 1 && (t[n[0].trim()] = n[1].trim());
                      }
                    }),
                    t
                  );
                });
              var pt = {
                  staticKeys: ["staticStyle"],
                  transformNode: function(e, t) {
                    var r = t.warn || Ye,
                      n = at(e, "style");
                    n &&
                      (He(n, t.delimiters) &&
                        r(
                          'style="' +
                            n +
                            '": Interpolation inside attributes has been removed. Use v-bind or the colon shorthand instead. For example, instead of <div style="{{ val }}">, use <div :style="val">.',
                          e.rawAttrsMap.style
                        ),
                      (e.staticStyle = JSON.stringify(ct(n))));
                    var i = st(e, "style", !1);
                    i && (e.styleBinding = i);
                  },
                  genData: function(e) {
                    var t = "";
                    return (
                      e.staticStyle &&
                        (t += "staticStyle:" + e.staticStyle + ","),
                      e.styleBinding &&
                        (t += "style:(" + e.styleBinding + "),"),
                      t
                    );
                  }
                },
                dt =
                  "undefined" != typeof window
                    ? window
                    : void 0 !== e
                    ? e
                    : "undefined" != typeof self
                    ? self
                    : {};
              var ht,
                ft,
                mt,
                yt,
                gt,
                bt,
                vt,
                Et =
                  ((function(e, t) {
                    !(function(r) {
                      var n = t,
                        i = e && e.exports == n && e,
                        s = "object" == typeof dt && dt;
                      (s.global !== s && s.window !== s) || (r = s);
                      var a = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g,
                        o = /[\x01-\x7F]/g,
                        u = /[\x01-\t\x0B\f\x0E-\x1F\x7F\x81\x8D\x8F\x90\x9D\xA0-\uFFFF]/g,
                        l = /<\u20D2|=\u20E5|>\u20D2|\u205F\u200A|\u219D\u0338|\u2202\u0338|\u2220\u20D2|\u2229\uFE00|\u222A\uFE00|\u223C\u20D2|\u223D\u0331|\u223E\u0333|\u2242\u0338|\u224B\u0338|\u224D\u20D2|\u224E\u0338|\u224F\u0338|\u2250\u0338|\u2261\u20E5|\u2264\u20D2|\u2265\u20D2|\u2266\u0338|\u2267\u0338|\u2268\uFE00|\u2269\uFE00|\u226A\u0338|\u226A\u20D2|\u226B\u0338|\u226B\u20D2|\u227F\u0338|\u2282\u20D2|\u2283\u20D2|\u228A\uFE00|\u228B\uFE00|\u228F\u0338|\u2290\u0338|\u2293\uFE00|\u2294\uFE00|\u22B4\u20D2|\u22B5\u20D2|\u22D8\u0338|\u22D9\u0338|\u22DA\uFE00|\u22DB\uFE00|\u22F5\u0338|\u22F9\u0338|\u2933\u0338|\u29CF\u0338|\u29D0\u0338|\u2A6D\u0338|\u2A70\u0338|\u2A7D\u0338|\u2A7E\u0338|\u2AA1\u0338|\u2AA2\u0338|\u2AAC\uFE00|\u2AAD\uFE00|\u2AAF\u0338|\u2AB0\u0338|\u2AC5\u0338|\u2AC6\u0338|\u2ACB\uFE00|\u2ACC\uFE00|\u2AFD\u20E5|[\xA0-\u0113\u0116-\u0122\u0124-\u012B\u012E-\u014D\u0150-\u017E\u0192\u01B5\u01F5\u0237\u02C6\u02C7\u02D8-\u02DD\u0311\u0391-\u03A1\u03A3-\u03A9\u03B1-\u03C9\u03D1\u03D2\u03D5\u03D6\u03DC\u03DD\u03F0\u03F1\u03F5\u03F6\u0401-\u040C\u040E-\u044F\u0451-\u045C\u045E\u045F\u2002-\u2005\u2007-\u2010\u2013-\u2016\u2018-\u201A\u201C-\u201E\u2020-\u2022\u2025\u2026\u2030-\u2035\u2039\u203A\u203E\u2041\u2043\u2044\u204F\u2057\u205F-\u2063\u20AC\u20DB\u20DC\u2102\u2105\u210A-\u2113\u2115-\u211E\u2122\u2124\u2127-\u2129\u212C\u212D\u212F-\u2131\u2133-\u2138\u2145-\u2148\u2153-\u215E\u2190-\u219B\u219D-\u21A7\u21A9-\u21AE\u21B0-\u21B3\u21B5-\u21B7\u21BA-\u21DB\u21DD\u21E4\u21E5\u21F5\u21FD-\u2205\u2207-\u2209\u220B\u220C\u220F-\u2214\u2216-\u2218\u221A\u221D-\u2238\u223A-\u2257\u2259\u225A\u225C\u225F-\u2262\u2264-\u228B\u228D-\u229B\u229D-\u22A5\u22A7-\u22B0\u22B2-\u22BB\u22BD-\u22DB\u22DE-\u22E3\u22E6-\u22F7\u22F9-\u22FE\u2305\u2306\u2308-\u2310\u2312\u2313\u2315\u2316\u231C-\u231F\u2322\u2323\u232D\u232E\u2336\u233D\u233F\u237C\u23B0\u23B1\u23B4-\u23B6\u23DC-\u23DF\u23E2\u23E7\u2423\u24C8\u2500\u2502\u250C\u2510\u2514\u2518\u251C\u2524\u252C\u2534\u253C\u2550-\u256C\u2580\u2584\u2588\u2591-\u2593\u25A1\u25AA\u25AB\u25AD\u25AE\u25B1\u25B3-\u25B5\u25B8\u25B9\u25BD-\u25BF\u25C2\u25C3\u25CA\u25CB\u25EC\u25EF\u25F8-\u25FC\u2605\u2606\u260E\u2640\u2642\u2660\u2663\u2665\u2666\u266A\u266D-\u266F\u2713\u2717\u2720\u2736\u2758\u2772\u2773\u27C8\u27C9\u27E6-\u27ED\u27F5-\u27FA\u27FC\u27FF\u2902-\u2905\u290C-\u2913\u2916\u2919-\u2920\u2923-\u292A\u2933\u2935-\u2939\u293C\u293D\u2945\u2948-\u294B\u294E-\u2976\u2978\u2979\u297B-\u297F\u2985\u2986\u298B-\u2996\u299A\u299C\u299D\u29A4-\u29B7\u29B9\u29BB\u29BC\u29BE-\u29C5\u29C9\u29CD-\u29D0\u29DC-\u29DE\u29E3-\u29E5\u29EB\u29F4\u29F6\u2A00-\u2A02\u2A04\u2A06\u2A0C\u2A0D\u2A10-\u2A17\u2A22-\u2A27\u2A29\u2A2A\u2A2D-\u2A31\u2A33-\u2A3C\u2A3F\u2A40\u2A42-\u2A4D\u2A50\u2A53-\u2A58\u2A5A-\u2A5D\u2A5F\u2A66\u2A6A\u2A6D-\u2A75\u2A77-\u2A9A\u2A9D-\u2AA2\u2AA4-\u2AB0\u2AB3-\u2AC8\u2ACB\u2ACC\u2ACF-\u2ADB\u2AE4\u2AE6-\u2AE9\u2AEB-\u2AF3\u2AFD\uFB00-\uFB04]|\uD835[\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDCCF\uDD04\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDD6B]/g,
                        c = {
                          "­": "shy",
                          "‌": "zwnj",
                          "‍": "zwj",
                          "‎": "lrm",
                          "⁣": "ic",
                          "⁢": "it",
                          "⁡": "af",
                          "‏": "rlm",
                          "​": "ZeroWidthSpace",
                          "⁠": "NoBreak",
                          "̑": "DownBreve",
                          "⃛": "tdot",
                          "⃜": "DotDot",
                          "\t": "Tab",
                          "\n": "NewLine",
                          " ": "puncsp",
                          " ": "MediumSpace",
                          " ": "thinsp",
                          " ": "hairsp",
                          " ": "emsp13",
                          " ": "ensp",
                          " ": "emsp14",
                          " ": "emsp",
                          " ": "numsp",
                          " ": "nbsp",
                          "  ": "ThickSpace",
                          "‾": "oline",
                          _: "lowbar",
                          "‐": "dash",
                          "–": "ndash",
                          "—": "mdash",
                          "―": "horbar",
                          ",": "comma",
                          ";": "semi",
                          "⁏": "bsemi",
                          ":": "colon",
                          "⩴": "Colone",
                          "!": "excl",
                          "¡": "iexcl",
                          "?": "quest",
                          "¿": "iquest",
                          ".": "period",
                          "‥": "nldr",
                          "…": "mldr",
                          "·": "middot",
                          "'": "apos",
                          "‘": "lsquo",
                          "’": "rsquo",
                          "‚": "sbquo",
                          "‹": "lsaquo",
                          "›": "rsaquo",
                          '"': "quot",
                          "“": "ldquo",
                          "”": "rdquo",
                          "„": "bdquo",
                          "«": "laquo",
                          "»": "raquo",
                          "(": "lpar",
                          ")": "rpar",
                          "[": "lsqb",
                          "]": "rsqb",
                          "{": "lcub",
                          "}": "rcub",
                          "⌈": "lceil",
                          "⌉": "rceil",
                          "⌊": "lfloor",
                          "⌋": "rfloor",
                          "⦅": "lopar",
                          "⦆": "ropar",
                          "⦋": "lbrke",
                          "⦌": "rbrke",
                          "⦍": "lbrkslu",
                          "⦎": "rbrksld",
                          "⦏": "lbrksld",
                          "⦐": "rbrkslu",
                          "⦑": "langd",
                          "⦒": "rangd",
                          "⦓": "lparlt",
                          "⦔": "rpargt",
                          "⦕": "gtlPar",
                          "⦖": "ltrPar",
                          "⟦": "lobrk",
                          "⟧": "robrk",
                          "⟨": "lang",
                          "⟩": "rang",
                          "⟪": "Lang",
                          "⟫": "Rang",
                          "⟬": "loang",
                          "⟭": "roang",
                          "❲": "lbbrk",
                          "❳": "rbbrk",
                          "‖": "Vert",
                          "§": "sect",
                          "¶": "para",
                          "@": "commat",
                          "*": "ast",
                          "/": "sol",
                          undefined: null,
                          "&": "amp",
                          "#": "num",
                          "%": "percnt",
                          "‰": "permil",
                          "‱": "pertenk",
                          "†": "dagger",
                          "‡": "Dagger",
                          "•": "bull",
                          "⁃": "hybull",
                          "′": "prime",
                          "″": "Prime",
                          "‴": "tprime",
                          "⁗": "qprime",
                          "‵": "bprime",
                          "⁁": "caret",
                          "`": "grave",
                          "´": "acute",
                          "˜": "tilde",
                          "^": "Hat",
                          "¯": "macr",
                          "˘": "breve",
                          "˙": "dot",
                          "¨": "die",
                          "˚": "ring",
                          "˝": "dblac",
                          "¸": "cedil",
                          "˛": "ogon",
                          ˆ: "circ",
                          ˇ: "caron",
                          "°": "deg",
                          "©": "copy",
                          "®": "reg",
                          "℗": "copysr",
                          "℘": "wp",
                          "℞": "rx",
                          "℧": "mho",
                          "℩": "iiota",
                          "←": "larr",
                          "↚": "nlarr",
                          "→": "rarr",
                          "↛": "nrarr",
                          "↑": "uarr",
                          "↓": "darr",
                          "↔": "harr",
                          "↮": "nharr",
                          "↕": "varr",
                          "↖": "nwarr",
                          "↗": "nearr",
                          "↘": "searr",
                          "↙": "swarr",
                          "↝": "rarrw",
                          "↝̸": "nrarrw",
                          "↞": "Larr",
                          "↟": "Uarr",
                          "↠": "Rarr",
                          "↡": "Darr",
                          "↢": "larrtl",
                          "↣": "rarrtl",
                          "↤": "mapstoleft",
                          "↥": "mapstoup",
                          "↦": "map",
                          "↧": "mapstodown",
                          "↩": "larrhk",
                          "↪": "rarrhk",
                          "↫": "larrlp",
                          "↬": "rarrlp",
                          "↭": "harrw",
                          "↰": "lsh",
                          "↱": "rsh",
                          "↲": "ldsh",
                          "↳": "rdsh",
                          "↵": "crarr",
                          "↶": "cularr",
                          "↷": "curarr",
                          "↺": "olarr",
                          "↻": "orarr",
                          "↼": "lharu",
                          "↽": "lhard",
                          "↾": "uharr",
                          "↿": "uharl",
                          "⇀": "rharu",
                          "⇁": "rhard",
                          "⇂": "dharr",
                          "⇃": "dharl",
                          "⇄": "rlarr",
                          "⇅": "udarr",
                          "⇆": "lrarr",
                          "⇇": "llarr",
                          "⇈": "uuarr",
                          "⇉": "rrarr",
                          "⇊": "ddarr",
                          "⇋": "lrhar",
                          "⇌": "rlhar",
                          "⇐": "lArr",
                          "⇍": "nlArr",
                          "⇑": "uArr",
                          "⇒": "rArr",
                          "⇏": "nrArr",
                          "⇓": "dArr",
                          "⇔": "iff",
                          "⇎": "nhArr",
                          "⇕": "vArr",
                          "⇖": "nwArr",
                          "⇗": "neArr",
                          "⇘": "seArr",
                          "⇙": "swArr",
                          "⇚": "lAarr",
                          "⇛": "rAarr",
                          "⇝": "zigrarr",
                          "⇤": "larrb",
                          "⇥": "rarrb",
                          "⇵": "duarr",
                          "⇽": "loarr",
                          "⇾": "roarr",
                          "⇿": "hoarr",
                          "∀": "forall",
                          "∁": "comp",
                          "∂": "part",
                          "∂̸": "npart",
                          "∃": "exist",
                          "∄": "nexist",
                          "∅": "empty",
                          "∇": "Del",
                          "∈": "in",
                          "∉": "notin",
                          "∋": "ni",
                          "∌": "notni",
                          "϶": "bepsi",
                          "∏": "prod",
                          "∐": "coprod",
                          "∑": "sum",
                          "+": "plus",
                          "±": "pm",
                          "÷": "div",
                          "×": "times",
                          "<": "lt",
                          "≮": "nlt",
                          "<⃒": "nvlt",
                          "=": "equals",
                          "≠": "ne",
                          "=⃥": "bne",
                          "⩵": "Equal",
                          ">": "gt",
                          "≯": "ngt",
                          ">⃒": "nvgt",
                          "¬": "not",
                          "|": "vert",
                          "¦": "brvbar",
                          "−": "minus",
                          "∓": "mp",
                          "∔": "plusdo",
                          "⁄": "frasl",
                          "∖": "setmn",
                          "∗": "lowast",
                          "∘": "compfn",
                          "√": "Sqrt",
                          "∝": "prop",
                          "∞": "infin",
                          "∟": "angrt",
                          "∠": "ang",
                          "∠⃒": "nang",
                          "∡": "angmsd",
                          "∢": "angsph",
                          "∣": "mid",
                          "∤": "nmid",
                          "∥": "par",
                          "∦": "npar",
                          "∧": "and",
                          "∨": "or",
                          "∩": "cap",
                          "∩︀": "caps",
                          "∪": "cup",
                          "∪︀": "cups",
                          "∫": "int",
                          "∬": "Int",
                          "∭": "tint",
                          "⨌": "qint",
                          "∮": "oint",
                          "∯": "Conint",
                          "∰": "Cconint",
                          "∱": "cwint",
                          "∲": "cwconint",
                          "∳": "awconint",
                          "∴": "there4",
                          "∵": "becaus",
                          "∶": "ratio",
                          "∷": "Colon",
                          "∸": "minusd",
                          "∺": "mDDot",
                          "∻": "homtht",
                          "∼": "sim",
                          "≁": "nsim",
                          "∼⃒": "nvsim",
                          "∽": "bsim",
                          "∽̱": "race",
                          "∾": "ac",
                          "∾̳": "acE",
                          "∿": "acd",
                          "≀": "wr",
                          "≂": "esim",
                          "≂̸": "nesim",
                          "≃": "sime",
                          "≄": "nsime",
                          "≅": "cong",
                          "≇": "ncong",
                          "≆": "simne",
                          "≈": "ap",
                          "≉": "nap",
                          "≊": "ape",
                          "≋": "apid",
                          "≋̸": "napid",
                          "≌": "bcong",
                          "≍": "CupCap",
                          "≭": "NotCupCap",
                          "≍⃒": "nvap",
                          "≎": "bump",
                          "≎̸": "nbump",
                          "≏": "bumpe",
                          "≏̸": "nbumpe",
                          "≐": "doteq",
                          "≐̸": "nedot",
                          "≑": "eDot",
                          "≒": "efDot",
                          "≓": "erDot",
                          "≔": "colone",
                          "≕": "ecolon",
                          "≖": "ecir",
                          "≗": "cire",
                          "≙": "wedgeq",
                          "≚": "veeeq",
                          "≜": "trie",
                          "≟": "equest",
                          "≡": "equiv",
                          "≢": "nequiv",
                          "≡⃥": "bnequiv",
                          "≤": "le",
                          "≰": "nle",
                          "≤⃒": "nvle",
                          "≥": "ge",
                          "≱": "nge",
                          "≥⃒": "nvge",
                          "≦": "lE",
                          "≦̸": "nlE",
                          "≧": "gE",
                          "≧̸": "ngE",
                          "≨︀": "lvnE",
                          "≨": "lnE",
                          "≩": "gnE",
                          "≩︀": "gvnE",
                          "≪": "ll",
                          "≪̸": "nLtv",
                          "≪⃒": "nLt",
                          "≫": "gg",
                          "≫̸": "nGtv",
                          "≫⃒": "nGt",
                          "≬": "twixt",
                          "≲": "lsim",
                          "≴": "nlsim",
                          "≳": "gsim",
                          "≵": "ngsim",
                          "≶": "lg",
                          "≸": "ntlg",
                          "≷": "gl",
                          "≹": "ntgl",
                          "≺": "pr",
                          "⊀": "npr",
                          "≻": "sc",
                          "⊁": "nsc",
                          "≼": "prcue",
                          "⋠": "nprcue",
                          "≽": "sccue",
                          "⋡": "nsccue",
                          "≾": "prsim",
                          "≿": "scsim",
                          "≿̸": "NotSucceedsTilde",
                          "⊂": "sub",
                          "⊄": "nsub",
                          "⊂⃒": "vnsub",
                          "⊃": "sup",
                          "⊅": "nsup",
                          "⊃⃒": "vnsup",
                          "⊆": "sube",
                          "⊈": "nsube",
                          "⊇": "supe",
                          "⊉": "nsupe",
                          "⊊︀": "vsubne",
                          "⊊": "subne",
                          "⊋︀": "vsupne",
                          "⊋": "supne",
                          "⊍": "cupdot",
                          "⊎": "uplus",
                          "⊏": "sqsub",
                          "⊏̸": "NotSquareSubset",
                          "⊐": "sqsup",
                          "⊐̸": "NotSquareSuperset",
                          "⊑": "sqsube",
                          "⋢": "nsqsube",
                          "⊒": "sqsupe",
                          "⋣": "nsqsupe",
                          "⊓": "sqcap",
                          "⊓︀": "sqcaps",
                          "⊔": "sqcup",
                          "⊔︀": "sqcups",
                          "⊕": "oplus",
                          "⊖": "ominus",
                          "⊗": "otimes",
                          "⊘": "osol",
                          "⊙": "odot",
                          "⊚": "ocir",
                          "⊛": "oast",
                          "⊝": "odash",
                          "⊞": "plusb",
                          "⊟": "minusb",
                          "⊠": "timesb",
                          "⊡": "sdotb",
                          "⊢": "vdash",
                          "⊬": "nvdash",
                          "⊣": "dashv",
                          "⊤": "top",
                          "⊥": "bot",
                          "⊧": "models",
                          "⊨": "vDash",
                          "⊭": "nvDash",
                          "⊩": "Vdash",
                          "⊮": "nVdash",
                          "⊪": "Vvdash",
                          "⊫": "VDash",
                          "⊯": "nVDash",
                          "⊰": "prurel",
                          "⊲": "vltri",
                          "⋪": "nltri",
                          "⊳": "vrtri",
                          "⋫": "nrtri",
                          "⊴": "ltrie",
                          "⋬": "nltrie",
                          "⊴⃒": "nvltrie",
                          "⊵": "rtrie",
                          "⋭": "nrtrie",
                          "⊵⃒": "nvrtrie",
                          "⊶": "origof",
                          "⊷": "imof",
                          "⊸": "mumap",
                          "⊹": "hercon",
                          "⊺": "intcal",
                          "⊻": "veebar",
                          "⊽": "barvee",
                          "⊾": "angrtvb",
                          "⊿": "lrtri",
                          "⋀": "Wedge",
                          "⋁": "Vee",
                          "⋂": "xcap",
                          "⋃": "xcup",
                          "⋄": "diam",
                          "⋅": "sdot",
                          "⋆": "Star",
                          "⋇": "divonx",
                          "⋈": "bowtie",
                          "⋉": "ltimes",
                          "⋊": "rtimes",
                          "⋋": "lthree",
                          "⋌": "rthree",
                          "⋍": "bsime",
                          "⋎": "cuvee",
                          "⋏": "cuwed",
                          "⋐": "Sub",
                          "⋑": "Sup",
                          "⋒": "Cap",
                          "⋓": "Cup",
                          "⋔": "fork",
                          "⋕": "epar",
                          "⋖": "ltdot",
                          "⋗": "gtdot",
                          "⋘": "Ll",
                          "⋘̸": "nLl",
                          "⋙": "Gg",
                          "⋙̸": "nGg",
                          "⋚︀": "lesg",
                          "⋚": "leg",
                          "⋛": "gel",
                          "⋛︀": "gesl",
                          "⋞": "cuepr",
                          "⋟": "cuesc",
                          "⋦": "lnsim",
                          "⋧": "gnsim",
                          "⋨": "prnsim",
                          "⋩": "scnsim",
                          "⋮": "vellip",
                          "⋯": "ctdot",
                          "⋰": "utdot",
                          "⋱": "dtdot",
                          "⋲": "disin",
                          "⋳": "isinsv",
                          "⋴": "isins",
                          "⋵": "isindot",
                          "⋵̸": "notindot",
                          "⋶": "notinvc",
                          "⋷": "notinvb",
                          "⋹": "isinE",
                          "⋹̸": "notinE",
                          "⋺": "nisd",
                          "⋻": "xnis",
                          "⋼": "nis",
                          "⋽": "notnivc",
                          "⋾": "notnivb",
                          "⌅": "barwed",
                          "⌆": "Barwed",
                          "⌌": "drcrop",
                          "⌍": "dlcrop",
                          "⌎": "urcrop",
                          "⌏": "ulcrop",
                          "⌐": "bnot",
                          "⌒": "profline",
                          "⌓": "profsurf",
                          "⌕": "telrec",
                          "⌖": "target",
                          "⌜": "ulcorn",
                          "⌝": "urcorn",
                          "⌞": "dlcorn",
                          "⌟": "drcorn",
                          "⌢": "frown",
                          "⌣": "smile",
                          "⌭": "cylcty",
                          "⌮": "profalar",
                          "⌶": "topbot",
                          "⌽": "ovbar",
                          "⌿": "solbar",
                          "⍼": "angzarr",
                          "⎰": "lmoust",
                          "⎱": "rmoust",
                          "⎴": "tbrk",
                          "⎵": "bbrk",
                          "⎶": "bbrktbrk",
                          "⏜": "OverParenthesis",
                          "⏝": "UnderParenthesis",
                          "⏞": "OverBrace",
                          "⏟": "UnderBrace",
                          "⏢": "trpezium",
                          "⏧": "elinters",
                          "␣": "blank",
                          "─": "boxh",
                          "│": "boxv",
                          "┌": "boxdr",
                          "┐": "boxdl",
                          "└": "boxur",
                          "┘": "boxul",
                          "├": "boxvr",
                          "┤": "boxvl",
                          "┬": "boxhd",
                          "┴": "boxhu",
                          "┼": "boxvh",
                          "═": "boxH",
                          "║": "boxV",
                          "╒": "boxdR",
                          "╓": "boxDr",
                          "╔": "boxDR",
                          "╕": "boxdL",
                          "╖": "boxDl",
                          "╗": "boxDL",
                          "╘": "boxuR",
                          "╙": "boxUr",
                          "╚": "boxUR",
                          "╛": "boxuL",
                          "╜": "boxUl",
                          "╝": "boxUL",
                          "╞": "boxvR",
                          "╟": "boxVr",
                          "╠": "boxVR",
                          "╡": "boxvL",
                          "╢": "boxVl",
                          "╣": "boxVL",
                          "╤": "boxHd",
                          "╥": "boxhD",
                          "╦": "boxHD",
                          "╧": "boxHu",
                          "╨": "boxhU",
                          "╩": "boxHU",
                          "╪": "boxvH",
                          "╫": "boxVh",
                          "╬": "boxVH",
                          "▀": "uhblk",
                          "▄": "lhblk",
                          "█": "block",
                          "░": "blk14",
                          "▒": "blk12",
                          "▓": "blk34",
                          "□": "squ",
                          "▪": "squf",
                          "▫": "EmptyVerySmallSquare",
                          "▭": "rect",
                          "▮": "marker",
                          "▱": "fltns",
                          "△": "xutri",
                          "▴": "utrif",
                          "▵": "utri",
                          "▸": "rtrif",
                          "▹": "rtri",
                          "▽": "xdtri",
                          "▾": "dtrif",
                          "▿": "dtri",
                          "◂": "ltrif",
                          "◃": "ltri",
                          "◊": "loz",
                          "○": "cir",
                          "◬": "tridot",
                          "◯": "xcirc",
                          "◸": "ultri",
                          "◹": "urtri",
                          "◺": "lltri",
                          "◻": "EmptySmallSquare",
                          "◼": "FilledSmallSquare",
                          "★": "starf",
                          "☆": "star",
                          "☎": "phone",
                          "♀": "female",
                          "♂": "male",
                          "♠": "spades",
                          "♣": "clubs",
                          "♥": "hearts",
                          "♦": "diams",
                          "♪": "sung",
                          "✓": "check",
                          "✗": "cross",
                          "✠": "malt",
                          "✶": "sext",
                          "❘": "VerticalSeparator",
                          "⟈": "bsolhsub",
                          "⟉": "suphsol",
                          "⟵": "xlarr",
                          "⟶": "xrarr",
                          "⟷": "xharr",
                          "⟸": "xlArr",
                          "⟹": "xrArr",
                          "⟺": "xhArr",
                          "⟼": "xmap",
                          "⟿": "dzigrarr",
                          "⤂": "nvlArr",
                          "⤃": "nvrArr",
                          "⤄": "nvHarr",
                          "⤅": "Map",
                          "⤌": "lbarr",
                          "⤍": "rbarr",
                          "⤎": "lBarr",
                          "⤏": "rBarr",
                          "⤐": "RBarr",
                          "⤑": "DDotrahd",
                          "⤒": "UpArrowBar",
                          "⤓": "DownArrowBar",
                          "⤖": "Rarrtl",
                          "⤙": "latail",
                          "⤚": "ratail",
                          "⤛": "lAtail",
                          "⤜": "rAtail",
                          "⤝": "larrfs",
                          "⤞": "rarrfs",
                          "⤟": "larrbfs",
                          "⤠": "rarrbfs",
                          "⤣": "nwarhk",
                          "⤤": "nearhk",
                          "⤥": "searhk",
                          "⤦": "swarhk",
                          "⤧": "nwnear",
                          "⤨": "toea",
                          "⤩": "tosa",
                          "⤪": "swnwar",
                          "⤳": "rarrc",
                          "⤳̸": "nrarrc",
                          "⤵": "cudarrr",
                          "⤶": "ldca",
                          "⤷": "rdca",
                          "⤸": "cudarrl",
                          "⤹": "larrpl",
                          "⤼": "curarrm",
                          "⤽": "cularrp",
                          "⥅": "rarrpl",
                          "⥈": "harrcir",
                          "⥉": "Uarrocir",
                          "⥊": "lurdshar",
                          "⥋": "ldrushar",
                          "⥎": "LeftRightVector",
                          "⥏": "RightUpDownVector",
                          "⥐": "DownLeftRightVector",
                          "⥑": "LeftUpDownVector",
                          "⥒": "LeftVectorBar",
                          "⥓": "RightVectorBar",
                          "⥔": "RightUpVectorBar",
                          "⥕": "RightDownVectorBar",
                          "⥖": "DownLeftVectorBar",
                          "⥗": "DownRightVectorBar",
                          "⥘": "LeftUpVectorBar",
                          "⥙": "LeftDownVectorBar",
                          "⥚": "LeftTeeVector",
                          "⥛": "RightTeeVector",
                          "⥜": "RightUpTeeVector",
                          "⥝": "RightDownTeeVector",
                          "⥞": "DownLeftTeeVector",
                          "⥟": "DownRightTeeVector",
                          "⥠": "LeftUpTeeVector",
                          "⥡": "LeftDownTeeVector",
                          "⥢": "lHar",
                          "⥣": "uHar",
                          "⥤": "rHar",
                          "⥥": "dHar",
                          "⥦": "luruhar",
                          "⥧": "ldrdhar",
                          "⥨": "ruluhar",
                          "⥩": "rdldhar",
                          "⥪": "lharul",
                          "⥫": "llhard",
                          "⥬": "rharul",
                          "⥭": "lrhard",
                          "⥮": "udhar",
                          "⥯": "duhar",
                          "⥰": "RoundImplies",
                          "⥱": "erarr",
                          "⥲": "simrarr",
                          "⥳": "larrsim",
                          "⥴": "rarrsim",
                          "⥵": "rarrap",
                          "⥶": "ltlarr",
                          "⥸": "gtrarr",
                          "⥹": "subrarr",
                          "⥻": "suplarr",
                          "⥼": "lfisht",
                          "⥽": "rfisht",
                          "⥾": "ufisht",
                          "⥿": "dfisht",
                          "⦚": "vzigzag",
                          "⦜": "vangrt",
                          "⦝": "angrtvbd",
                          "⦤": "ange",
                          "⦥": "range",
                          "⦦": "dwangle",
                          "⦧": "uwangle",
                          "⦨": "angmsdaa",
                          "⦩": "angmsdab",
                          "⦪": "angmsdac",
                          "⦫": "angmsdad",
                          "⦬": "angmsdae",
                          "⦭": "angmsdaf",
                          "⦮": "angmsdag",
                          "⦯": "angmsdah",
                          "⦰": "bemptyv",
                          "⦱": "demptyv",
                          "⦲": "cemptyv",
                          "⦳": "raemptyv",
                          "⦴": "laemptyv",
                          "⦵": "ohbar",
                          "⦶": "omid",
                          "⦷": "opar",
                          "⦹": "operp",
                          "⦻": "olcross",
                          "⦼": "odsold",
                          "⦾": "olcir",
                          "⦿": "ofcir",
                          "⧀": "olt",
                          "⧁": "ogt",
                          "⧂": "cirscir",
                          "⧃": "cirE",
                          "⧄": "solb",
                          "⧅": "bsolb",
                          "⧉": "boxbox",
                          "⧍": "trisb",
                          "⧎": "rtriltri",
                          "⧏": "LeftTriangleBar",
                          "⧏̸": "NotLeftTriangleBar",
                          "⧐": "RightTriangleBar",
                          "⧐̸": "NotRightTriangleBar",
                          "⧜": "iinfin",
                          "⧝": "infintie",
                          "⧞": "nvinfin",
                          "⧣": "eparsl",
                          "⧤": "smeparsl",
                          "⧥": "eqvparsl",
                          "⧫": "lozf",
                          "⧴": "RuleDelayed",
                          "⧶": "dsol",
                          "⨀": "xodot",
                          "⨁": "xoplus",
                          "⨂": "xotime",
                          "⨄": "xuplus",
                          "⨆": "xsqcup",
                          "⨍": "fpartint",
                          "⨐": "cirfnint",
                          "⨑": "awint",
                          "⨒": "rppolint",
                          "⨓": "scpolint",
                          "⨔": "npolint",
                          "⨕": "pointint",
                          "⨖": "quatint",
                          "⨗": "intlarhk",
                          "⨢": "pluscir",
                          "⨣": "plusacir",
                          "⨤": "simplus",
                          "⨥": "plusdu",
                          "⨦": "plussim",
                          "⨧": "plustwo",
                          "⨩": "mcomma",
                          "⨪": "minusdu",
                          "⨭": "loplus",
                          "⨮": "roplus",
                          "⨯": "Cross",
                          "⨰": "timesd",
                          "⨱": "timesbar",
                          "⨳": "smashp",
                          "⨴": "lotimes",
                          "⨵": "rotimes",
                          "⨶": "otimesas",
                          "⨷": "Otimes",
                          "⨸": "odiv",
                          "⨹": "triplus",
                          "⨺": "triminus",
                          "⨻": "tritime",
                          "⨼": "iprod",
                          "⨿": "amalg",
                          "⩀": "capdot",
                          "⩂": "ncup",
                          "⩃": "ncap",
                          "⩄": "capand",
                          "⩅": "cupor",
                          "⩆": "cupcap",
                          "⩇": "capcup",
                          "⩈": "cupbrcap",
                          "⩉": "capbrcup",
                          "⩊": "cupcup",
                          "⩋": "capcap",
                          "⩌": "ccups",
                          "⩍": "ccaps",
                          "⩐": "ccupssm",
                          "⩓": "And",
                          "⩔": "Or",
                          "⩕": "andand",
                          "⩖": "oror",
                          "⩗": "orslope",
                          "⩘": "andslope",
                          "⩚": "andv",
                          "⩛": "orv",
                          "⩜": "andd",
                          "⩝": "ord",
                          "⩟": "wedbar",
                          "⩦": "sdote",
                          "⩪": "simdot",
                          "⩭": "congdot",
                          "⩭̸": "ncongdot",
                          "⩮": "easter",
                          "⩯": "apacir",
                          "⩰": "apE",
                          "⩰̸": "napE",
                          "⩱": "eplus",
                          "⩲": "pluse",
                          "⩳": "Esim",
                          "⩷": "eDDot",
                          "⩸": "equivDD",
                          "⩹": "ltcir",
                          "⩺": "gtcir",
                          "⩻": "ltquest",
                          "⩼": "gtquest",
                          "⩽": "les",
                          "⩽̸": "nles",
                          "⩾": "ges",
                          "⩾̸": "nges",
                          "⩿": "lesdot",
                          "⪀": "gesdot",
                          "⪁": "lesdoto",
                          "⪂": "gesdoto",
                          "⪃": "lesdotor",
                          "⪄": "gesdotol",
                          "⪅": "lap",
                          "⪆": "gap",
                          "⪇": "lne",
                          "⪈": "gne",
                          "⪉": "lnap",
                          "⪊": "gnap",
                          "⪋": "lEg",
                          "⪌": "gEl",
                          "⪍": "lsime",
                          "⪎": "gsime",
                          "⪏": "lsimg",
                          "⪐": "gsiml",
                          "⪑": "lgE",
                          "⪒": "glE",
                          "⪓": "lesges",
                          "⪔": "gesles",
                          "⪕": "els",
                          "⪖": "egs",
                          "⪗": "elsdot",
                          "⪘": "egsdot",
                          "⪙": "el",
                          "⪚": "eg",
                          "⪝": "siml",
                          "⪞": "simg",
                          "⪟": "simlE",
                          "⪠": "simgE",
                          "⪡": "LessLess",
                          "⪡̸": "NotNestedLessLess",
                          "⪢": "GreaterGreater",
                          "⪢̸": "NotNestedGreaterGreater",
                          "⪤": "glj",
                          "⪥": "gla",
                          "⪦": "ltcc",
                          "⪧": "gtcc",
                          "⪨": "lescc",
                          "⪩": "gescc",
                          "⪪": "smt",
                          "⪫": "lat",
                          "⪬": "smte",
                          "⪬︀": "smtes",
                          "⪭": "late",
                          "⪭︀": "lates",
                          "⪮": "bumpE",
                          "⪯": "pre",
                          "⪯̸": "npre",
                          "⪰": "sce",
                          "⪰̸": "nsce",
                          "⪳": "prE",
                          "⪴": "scE",
                          "⪵": "prnE",
                          "⪶": "scnE",
                          "⪷": "prap",
                          "⪸": "scap",
                          "⪹": "prnap",
                          "⪺": "scnap",
                          "⪻": "Pr",
                          "⪼": "Sc",
                          "⪽": "subdot",
                          "⪾": "supdot",
                          "⪿": "subplus",
                          "⫀": "supplus",
                          "⫁": "submult",
                          "⫂": "supmult",
                          "⫃": "subedot",
                          "⫄": "supedot",
                          "⫅": "subE",
                          "⫅̸": "nsubE",
                          "⫆": "supE",
                          "⫆̸": "nsupE",
                          "⫇": "subsim",
                          "⫈": "supsim",
                          "⫋︀": "vsubnE",
                          "⫋": "subnE",
                          "⫌︀": "vsupnE",
                          "⫌": "supnE",
                          "⫏": "csub",
                          "⫐": "csup",
                          "⫑": "csube",
                          "⫒": "csupe",
                          "⫓": "subsup",
                          "⫔": "supsub",
                          "⫕": "subsub",
                          "⫖": "supsup",
                          "⫗": "suphsub",
                          "⫘": "supdsub",
                          "⫙": "forkv",
                          "⫚": "topfork",
                          "⫛": "mlcp",
                          "⫤": "Dashv",
                          "⫦": "Vdashl",
                          "⫧": "Barv",
                          "⫨": "vBar",
                          "⫩": "vBarv",
                          "⫫": "Vbar",
                          "⫬": "Not",
                          "⫭": "bNot",
                          "⫮": "rnmid",
                          "⫯": "cirmid",
                          "⫰": "midcir",
                          "⫱": "topcir",
                          "⫲": "nhpar",
                          "⫳": "parsim",
                          "⫽": "parsl",
                          "⫽⃥": "nparsl",
                          "♭": "flat",
                          "♮": "natur",
                          "♯": "sharp",
                          "¤": "curren",
                          "¢": "cent",
                          $: "dollar",
                          "£": "pound",
                          "¥": "yen",
                          "€": "euro",
                          "¹": "sup1",
                          "½": "half",
                          "⅓": "frac13",
                          "¼": "frac14",
                          "⅕": "frac15",
                          "⅙": "frac16",
                          "⅛": "frac18",
                          "²": "sup2",
                          "⅔": "frac23",
                          "⅖": "frac25",
                          "³": "sup3",
                          "¾": "frac34",
                          "⅗": "frac35",
                          "⅜": "frac38",
                          "⅘": "frac45",
                          "⅚": "frac56",
                          "⅝": "frac58",
                          "⅞": "frac78",
                          "𝒶": "ascr",
                          "𝕒": "aopf",
                          "𝔞": "afr",
                          "𝔸": "Aopf",
                          "𝔄": "Afr",
                          "𝒜": "Ascr",
                          ª: "ordf",
                          á: "aacute",
                          Á: "Aacute",
                          à: "agrave",
                          À: "Agrave",
                          ă: "abreve",
                          Ă: "Abreve",
                          â: "acirc",
                          Â: "Acirc",
                          å: "aring",
                          Å: "angst",
                          ä: "auml",
                          Ä: "Auml",
                          ã: "atilde",
                          Ã: "Atilde",
                          ą: "aogon",
                          Ą: "Aogon",
                          ā: "amacr",
                          Ā: "Amacr",
                          æ: "aelig",
                          Æ: "AElig",
                          "𝒷": "bscr",
                          "𝕓": "bopf",
                          "𝔟": "bfr",
                          "𝔹": "Bopf",
                          ℬ: "Bscr",
                          "𝔅": "Bfr",
                          "𝔠": "cfr",
                          "𝒸": "cscr",
                          "𝕔": "copf",
                          ℭ: "Cfr",
                          "𝒞": "Cscr",
                          ℂ: "Copf",
                          ć: "cacute",
                          Ć: "Cacute",
                          ĉ: "ccirc",
                          Ĉ: "Ccirc",
                          č: "ccaron",
                          Č: "Ccaron",
                          ċ: "cdot",
                          Ċ: "Cdot",
                          ç: "ccedil",
                          Ç: "Ccedil",
                          "℅": "incare",
                          "𝔡": "dfr",
                          ⅆ: "dd",
                          "𝕕": "dopf",
                          "𝒹": "dscr",
                          "𝒟": "Dscr",
                          "𝔇": "Dfr",
                          ⅅ: "DD",
                          "𝔻": "Dopf",
                          ď: "dcaron",
                          Ď: "Dcaron",
                          đ: "dstrok",
                          Đ: "Dstrok",
                          ð: "eth",
                          Ð: "ETH",
                          ⅇ: "ee",
                          ℯ: "escr",
                          "𝔢": "efr",
                          "𝕖": "eopf",
                          ℰ: "Escr",
                          "𝔈": "Efr",
                          "𝔼": "Eopf",
                          é: "eacute",
                          É: "Eacute",
                          è: "egrave",
                          È: "Egrave",
                          ê: "ecirc",
                          Ê: "Ecirc",
                          ě: "ecaron",
                          Ě: "Ecaron",
                          ë: "euml",
                          Ë: "Euml",
                          ė: "edot",
                          Ė: "Edot",
                          ę: "eogon",
                          Ę: "Eogon",
                          ē: "emacr",
                          Ē: "Emacr",
                          "𝔣": "ffr",
                          "𝕗": "fopf",
                          "𝒻": "fscr",
                          "𝔉": "Ffr",
                          "𝔽": "Fopf",
                          ℱ: "Fscr",
                          ﬀ: "fflig",
                          ﬃ: "ffilig",
                          ﬄ: "ffllig",
                          ﬁ: "filig",
                          fj: "fjlig",
                          ﬂ: "fllig",
                          ƒ: "fnof",
                          ℊ: "gscr",
                          "𝕘": "gopf",
                          "𝔤": "gfr",
                          "𝒢": "Gscr",
                          "𝔾": "Gopf",
                          "𝔊": "Gfr",
                          ǵ: "gacute",
                          ğ: "gbreve",
                          Ğ: "Gbreve",
                          ĝ: "gcirc",
                          Ĝ: "Gcirc",
                          ġ: "gdot",
                          Ġ: "Gdot",
                          Ģ: "Gcedil",
                          "𝔥": "hfr",
                          ℎ: "planckh",
                          "𝒽": "hscr",
                          "𝕙": "hopf",
                          ℋ: "Hscr",
                          ℌ: "Hfr",
                          ℍ: "Hopf",
                          ĥ: "hcirc",
                          Ĥ: "Hcirc",
                          ℏ: "hbar",
                          ħ: "hstrok",
                          Ħ: "Hstrok",
                          "𝕚": "iopf",
                          "𝔦": "ifr",
                          "𝒾": "iscr",
                          ⅈ: "ii",
                          "𝕀": "Iopf",
                          ℐ: "Iscr",
                          ℑ: "Im",
                          í: "iacute",
                          Í: "Iacute",
                          ì: "igrave",
                          Ì: "Igrave",
                          î: "icirc",
                          Î: "Icirc",
                          ï: "iuml",
                          Ï: "Iuml",
                          ĩ: "itilde",
                          Ĩ: "Itilde",
                          İ: "Idot",
                          į: "iogon",
                          Į: "Iogon",
                          ī: "imacr",
                          Ī: "Imacr",
                          ĳ: "ijlig",
                          Ĳ: "IJlig",
                          ı: "imath",
                          "𝒿": "jscr",
                          "𝕛": "jopf",
                          "𝔧": "jfr",
                          "𝒥": "Jscr",
                          "𝔍": "Jfr",
                          "𝕁": "Jopf",
                          ĵ: "jcirc",
                          Ĵ: "Jcirc",
                          ȷ: "jmath",
                          "𝕜": "kopf",
                          "𝓀": "kscr",
                          "𝔨": "kfr",
                          "𝒦": "Kscr",
                          "𝕂": "Kopf",
                          "𝔎": "Kfr",
                          ķ: "kcedil",
                          Ķ: "Kcedil",
                          "𝔩": "lfr",
                          "𝓁": "lscr",
                          ℓ: "ell",
                          "𝕝": "lopf",
                          ℒ: "Lscr",
                          "𝔏": "Lfr",
                          "𝕃": "Lopf",
                          ĺ: "lacute",
                          Ĺ: "Lacute",
                          ľ: "lcaron",
                          Ľ: "Lcaron",
                          ļ: "lcedil",
                          Ļ: "Lcedil",
                          ł: "lstrok",
                          Ł: "Lstrok",
                          ŀ: "lmidot",
                          Ŀ: "Lmidot",
                          "𝔪": "mfr",
                          "𝕞": "mopf",
                          "𝓂": "mscr",
                          "𝔐": "Mfr",
                          "𝕄": "Mopf",
                          ℳ: "Mscr",
                          "𝔫": "nfr",
                          "𝕟": "nopf",
                          "𝓃": "nscr",
                          ℕ: "Nopf",
                          "𝒩": "Nscr",
                          "𝔑": "Nfr",
                          ń: "nacute",
                          Ń: "Nacute",
                          ň: "ncaron",
                          Ň: "Ncaron",
                          ñ: "ntilde",
                          Ñ: "Ntilde",
                          ņ: "ncedil",
                          Ņ: "Ncedil",
                          "№": "numero",
                          ŋ: "eng",
                          Ŋ: "ENG",
                          "𝕠": "oopf",
                          "𝔬": "ofr",
                          ℴ: "oscr",
                          "𝒪": "Oscr",
                          "𝔒": "Ofr",
                          "𝕆": "Oopf",
                          º: "ordm",
                          ó: "oacute",
                          Ó: "Oacute",
                          ò: "ograve",
                          Ò: "Ograve",
                          ô: "ocirc",
                          Ô: "Ocirc",
                          ö: "ouml",
                          Ö: "Ouml",
                          ő: "odblac",
                          Ő: "Odblac",
                          õ: "otilde",
                          Õ: "Otilde",
                          ø: "oslash",
                          Ø: "Oslash",
                          ō: "omacr",
                          Ō: "Omacr",
                          œ: "oelig",
                          Œ: "OElig",
                          "𝔭": "pfr",
                          "𝓅": "pscr",
                          "𝕡": "popf",
                          ℙ: "Popf",
                          "𝔓": "Pfr",
                          "𝒫": "Pscr",
                          "𝕢": "qopf",
                          "𝔮": "qfr",
                          "𝓆": "qscr",
                          "𝒬": "Qscr",
                          "𝔔": "Qfr",
                          ℚ: "Qopf",
                          ĸ: "kgreen",
                          "𝔯": "rfr",
                          "𝕣": "ropf",
                          "𝓇": "rscr",
                          ℛ: "Rscr",
                          ℜ: "Re",
                          ℝ: "Ropf",
                          ŕ: "racute",
                          Ŕ: "Racute",
                          ř: "rcaron",
                          Ř: "Rcaron",
                          ŗ: "rcedil",
                          Ŗ: "Rcedil",
                          "𝕤": "sopf",
                          "𝓈": "sscr",
                          "𝔰": "sfr",
                          "𝕊": "Sopf",
                          "𝔖": "Sfr",
                          "𝒮": "Sscr",
                          "Ⓢ": "oS",
                          ś: "sacute",
                          Ś: "Sacute",
                          ŝ: "scirc",
                          Ŝ: "Scirc",
                          š: "scaron",
                          Š: "Scaron",
                          ş: "scedil",
                          Ş: "Scedil",
                          ß: "szlig",
                          "𝔱": "tfr",
                          "𝓉": "tscr",
                          "𝕥": "topf",
                          "𝒯": "Tscr",
                          "𝔗": "Tfr",
                          "𝕋": "Topf",
                          ť: "tcaron",
                          Ť: "Tcaron",
                          ţ: "tcedil",
                          Ţ: "Tcedil",
                          "™": "trade",
                          ŧ: "tstrok",
                          Ŧ: "Tstrok",
                          "𝓊": "uscr",
                          "𝕦": "uopf",
                          "𝔲": "ufr",
                          "𝕌": "Uopf",
                          "𝔘": "Ufr",
                          "𝒰": "Uscr",
                          ú: "uacute",
                          Ú: "Uacute",
                          ù: "ugrave",
                          Ù: "Ugrave",
                          ŭ: "ubreve",
                          Ŭ: "Ubreve",
                          û: "ucirc",
                          Û: "Ucirc",
                          ů: "uring",
                          Ů: "Uring",
                          ü: "uuml",
                          Ü: "Uuml",
                          ű: "udblac",
                          Ű: "Udblac",
                          ũ: "utilde",
                          Ũ: "Utilde",
                          ų: "uogon",
                          Ų: "Uogon",
                          ū: "umacr",
                          Ū: "Umacr",
                          "𝔳": "vfr",
                          "𝕧": "vopf",
                          "𝓋": "vscr",
                          "𝔙": "Vfr",
                          "𝕍": "Vopf",
                          "𝒱": "Vscr",
                          "𝕨": "wopf",
                          "𝓌": "wscr",
                          "𝔴": "wfr",
                          "𝒲": "Wscr",
                          "𝕎": "Wopf",
                          "𝔚": "Wfr",
                          ŵ: "wcirc",
                          Ŵ: "Wcirc",
                          "𝔵": "xfr",
                          "𝓍": "xscr",
                          "𝕩": "xopf",
                          "𝕏": "Xopf",
                          "𝔛": "Xfr",
                          "𝒳": "Xscr",
                          "𝔶": "yfr",
                          "𝓎": "yscr",
                          "𝕪": "yopf",
                          "𝒴": "Yscr",
                          "𝔜": "Yfr",
                          "𝕐": "Yopf",
                          ý: "yacute",
                          Ý: "Yacute",
                          ŷ: "ycirc",
                          Ŷ: "Ycirc",
                          ÿ: "yuml",
                          Ÿ: "Yuml",
                          "𝓏": "zscr",
                          "𝔷": "zfr",
                          "𝕫": "zopf",
                          ℨ: "Zfr",
                          ℤ: "Zopf",
                          "𝒵": "Zscr",
                          ź: "zacute",
                          Ź: "Zacute",
                          ž: "zcaron",
                          Ž: "Zcaron",
                          ż: "zdot",
                          Ż: "Zdot",
                          Ƶ: "imped",
                          þ: "thorn",
                          Þ: "THORN",
                          ŉ: "napos",
                          α: "alpha",
                          Α: "Alpha",
                          β: "beta",
                          Β: "Beta",
                          γ: "gamma",
                          Γ: "Gamma",
                          δ: "delta",
                          Δ: "Delta",
                          ε: "epsi",
                          ϵ: "epsiv",
                          Ε: "Epsilon",
                          ϝ: "gammad",
                          Ϝ: "Gammad",
                          ζ: "zeta",
                          Ζ: "Zeta",
                          η: "eta",
                          Η: "Eta",
                          θ: "theta",
                          ϑ: "thetav",
                          Θ: "Theta",
                          ι: "iota",
                          Ι: "Iota",
                          κ: "kappa",
                          ϰ: "kappav",
                          Κ: "Kappa",
                          λ: "lambda",
                          Λ: "Lambda",
                          μ: "mu",
                          µ: "micro",
                          Μ: "Mu",
                          ν: "nu",
                          Ν: "Nu",
                          ξ: "xi",
                          Ξ: "Xi",
                          ο: "omicron",
                          Ο: "Omicron",
                          π: "pi",
                          ϖ: "piv",
                          Π: "Pi",
                          ρ: "rho",
                          ϱ: "rhov",
                          Ρ: "Rho",
                          σ: "sigma",
                          Σ: "Sigma",
                          ς: "sigmaf",
                          τ: "tau",
                          Τ: "Tau",
                          υ: "upsi",
                          Υ: "Upsilon",
                          ϒ: "Upsi",
                          φ: "phi",
                          ϕ: "phiv",
                          Φ: "Phi",
                          χ: "chi",
                          Χ: "Chi",
                          ψ: "psi",
                          Ψ: "Psi",
                          ω: "omega",
                          Ω: "ohm",
                          а: "acy",
                          А: "Acy",
                          б: "bcy",
                          Б: "Bcy",
                          в: "vcy",
                          В: "Vcy",
                          г: "gcy",
                          Г: "Gcy",
                          ѓ: "gjcy",
                          Ѓ: "GJcy",
                          д: "dcy",
                          Д: "Dcy",
                          ђ: "djcy",
                          Ђ: "DJcy",
                          е: "iecy",
                          Е: "IEcy",
                          ё: "iocy",
                          Ё: "IOcy",
                          є: "jukcy",
                          Є: "Jukcy",
                          ж: "zhcy",
                          Ж: "ZHcy",
                          з: "zcy",
                          З: "Zcy",
                          ѕ: "dscy",
                          Ѕ: "DScy",
                          и: "icy",
                          И: "Icy",
                          і: "iukcy",
                          І: "Iukcy",
                          ї: "yicy",
                          Ї: "YIcy",
                          й: "jcy",
                          Й: "Jcy",
                          ј: "jsercy",
                          Ј: "Jsercy",
                          к: "kcy",
                          К: "Kcy",
                          ќ: "kjcy",
                          Ќ: "KJcy",
                          л: "lcy",
                          Л: "Lcy",
                          љ: "ljcy",
                          Љ: "LJcy",
                          м: "mcy",
                          М: "Mcy",
                          н: "ncy",
                          Н: "Ncy",
                          њ: "njcy",
                          Њ: "NJcy",
                          о: "ocy",
                          О: "Ocy",
                          п: "pcy",
                          П: "Pcy",
                          р: "rcy",
                          Р: "Rcy",
                          с: "scy",
                          С: "Scy",
                          т: "tcy",
                          Т: "Tcy",
                          ћ: "tshcy",
                          Ћ: "TSHcy",
                          у: "ucy",
                          У: "Ucy",
                          ў: "ubrcy",
                          Ў: "Ubrcy",
                          ф: "fcy",
                          Ф: "Fcy",
                          х: "khcy",
                          Х: "KHcy",
                          ц: "tscy",
                          Ц: "TScy",
                          ч: "chcy",
                          Ч: "CHcy",
                          џ: "dzcy",
                          Џ: "DZcy",
                          ш: "shcy",
                          Ш: "SHcy",
                          щ: "shchcy",
                          Щ: "SHCHcy",
                          ъ: "hardcy",
                          Ъ: "HARDcy",
                          ы: "ycy",
                          Ы: "Ycy",
                          ь: "softcy",
                          Ь: "SOFTcy",
                          э: "ecy",
                          Э: "Ecy",
                          ю: "yucy",
                          Ю: "YUcy",
                          я: "yacy",
                          Я: "YAcy",
                          ℵ: "aleph",
                          ℶ: "beth",
                          ℷ: "gimel",
                          ℸ: "daleth"
                        },
                        p = /["&'<>`]/g,
                        d = {
                          '"': "&quot;",
                          "&": "&amp;",
                          "'": "&#x27;",
                          "<": "&lt;",
                          ">": "&gt;",
                          "`": "&#x60;"
                        },
                        h = /&#(?:[xX][^a-fA-F0-9]|[^0-9xX])/,
                        f = /[\0-\x08\x0B\x0E-\x1F\x7F-\x9F\uFDD0-\uFDEF\uFFFE\uFFFF]|[\uD83F\uD87F\uD8BF\uD8FF\uD93F\uD97F\uD9BF\uD9FF\uDA3F\uDA7F\uDABF\uDAFF\uDB3F\uDB7F\uDBBF\uDBFF][\uDFFE\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/,
                        m = /&(CounterClockwiseContourIntegral|DoubleLongLeftRightArrow|ClockwiseContourIntegral|NotNestedGreaterGreater|NotSquareSupersetEqual|DiacriticalDoubleAcute|NotRightTriangleEqual|NotSucceedsSlantEqual|NotPrecedesSlantEqual|CloseCurlyDoubleQuote|NegativeVeryThinSpace|DoubleContourIntegral|FilledVerySmallSquare|CapitalDifferentialD|OpenCurlyDoubleQuote|EmptyVerySmallSquare|NestedGreaterGreater|DoubleLongRightArrow|NotLeftTriangleEqual|NotGreaterSlantEqual|ReverseUpEquilibrium|DoubleLeftRightArrow|NotSquareSubsetEqual|NotDoubleVerticalBar|RightArrowLeftArrow|NotGreaterFullEqual|NotRightTriangleBar|SquareSupersetEqual|DownLeftRightVector|DoubleLongLeftArrow|leftrightsquigarrow|LeftArrowRightArrow|NegativeMediumSpace|blacktriangleright|RightDownVectorBar|PrecedesSlantEqual|RightDoubleBracket|SucceedsSlantEqual|NotLeftTriangleBar|RightTriangleEqual|SquareIntersection|RightDownTeeVector|ReverseEquilibrium|NegativeThickSpace|longleftrightarrow|Longleftrightarrow|LongLeftRightArrow|DownRightTeeVector|DownRightVectorBar|GreaterSlantEqual|SquareSubsetEqual|LeftDownVectorBar|LeftDoubleBracket|VerticalSeparator|rightleftharpoons|NotGreaterGreater|NotSquareSuperset|blacktriangleleft|blacktriangledown|NegativeThinSpace|LeftDownTeeVector|NotLessSlantEqual|leftrightharpoons|DoubleUpDownArrow|DoubleVerticalBar|LeftTriangleEqual|FilledSmallSquare|twoheadrightarrow|NotNestedLessLess|DownLeftTeeVector|DownLeftVectorBar|RightAngleBracket|NotTildeFullEqual|NotReverseElement|RightUpDownVector|DiacriticalTilde|NotSucceedsTilde|circlearrowright|NotPrecedesEqual|rightharpoondown|DoubleRightArrow|NotSucceedsEqual|NonBreakingSpace|NotRightTriangle|LessEqualGreater|RightUpTeeVector|LeftAngleBracket|GreaterFullEqual|DownArrowUpArrow|RightUpVectorBar|twoheadleftarrow|GreaterEqualLess|downharpoonright|RightTriangleBar|ntrianglerighteq|NotSupersetEqual|LeftUpDownVector|DiacriticalAcute|rightrightarrows|vartriangleright|UpArrowDownArrow|DiacriticalGrave|UnderParenthesis|EmptySmallSquare|LeftUpVectorBar|leftrightarrows|DownRightVector|downharpoonleft|trianglerighteq|ShortRightArrow|OverParenthesis|DoubleLeftArrow|DoubleDownArrow|NotSquareSubset|bigtriangledown|ntrianglelefteq|UpperRightArrow|curvearrowright|vartriangleleft|NotLeftTriangle|nleftrightarrow|LowerRightArrow|NotHumpDownHump|NotGreaterTilde|rightthreetimes|LeftUpTeeVector|NotGreaterEqual|straightepsilon|LeftTriangleBar|rightsquigarrow|ContourIntegral|rightleftarrows|CloseCurlyQuote|RightDownVector|LeftRightVector|nLeftrightarrow|leftharpoondown|circlearrowleft|SquareSuperset|OpenCurlyQuote|hookrightarrow|HorizontalLine|DiacriticalDot|NotLessGreater|ntriangleright|DoubleRightTee|InvisibleComma|InvisibleTimes|LowerLeftArrow|DownLeftVector|NotSubsetEqual|curvearrowleft|trianglelefteq|NotVerticalBar|TildeFullEqual|downdownarrows|NotGreaterLess|RightTeeVector|ZeroWidthSpace|looparrowright|LongRightArrow|doublebarwedge|ShortLeftArrow|ShortDownArrow|RightVectorBar|GreaterGreater|ReverseElement|rightharpoonup|LessSlantEqual|leftthreetimes|upharpoonright|rightarrowtail|LeftDownVector|Longrightarrow|NestedLessLess|UpperLeftArrow|nshortparallel|leftleftarrows|leftrightarrow|Leftrightarrow|LeftRightArrow|longrightarrow|upharpoonleft|RightArrowBar|ApplyFunction|LeftTeeVector|leftarrowtail|NotEqualTilde|varsubsetneqq|varsupsetneqq|RightTeeArrow|SucceedsEqual|SucceedsTilde|LeftVectorBar|SupersetEqual|hookleftarrow|DifferentialD|VerticalTilde|VeryThinSpace|blacktriangle|bigtriangleup|LessFullEqual|divideontimes|leftharpoonup|UpEquilibrium|ntriangleleft|RightTriangle|measuredangle|shortparallel|longleftarrow|Longleftarrow|LongLeftArrow|DoubleLeftTee|Poincareplane|PrecedesEqual|triangleright|DoubleUpArrow|RightUpVector|fallingdotseq|looparrowleft|PrecedesTilde|NotTildeEqual|NotTildeTilde|smallsetminus|Proportional|triangleleft|triangledown|UnderBracket|NotHumpEqual|exponentiale|ExponentialE|NotLessTilde|HilbertSpace|RightCeiling|blacklozenge|varsupsetneq|HumpDownHump|GreaterEqual|VerticalLine|LeftTeeArrow|NotLessEqual|DownTeeArrow|LeftTriangle|varsubsetneq|Intersection|NotCongruent|DownArrowBar|LeftUpVector|LeftArrowBar|risingdotseq|GreaterTilde|RoundImplies|SquareSubset|ShortUpArrow|NotSuperset|quaternions|precnapprox|backepsilon|preccurlyeq|OverBracket|blacksquare|MediumSpace|VerticalBar|circledcirc|circleddash|CircleMinus|CircleTimes|LessGreater|curlyeqprec|curlyeqsucc|diamondsuit|UpDownArrow|Updownarrow|RuleDelayed|Rrightarrow|updownarrow|RightVector|nRightarrow|nrightarrow|eqslantless|LeftCeiling|Equilibrium|SmallCircle|expectation|NotSucceeds|thickapprox|GreaterLess|SquareUnion|NotPrecedes|NotLessLess|straightphi|succnapprox|succcurlyeq|SubsetEqual|sqsupseteq|Proportion|Laplacetrf|ImaginaryI|supsetneqq|NotGreater|gtreqqless|NotElement|ThickSpace|TildeEqual|TildeTilde|Fouriertrf|rmoustache|EqualTilde|eqslantgtr|UnderBrace|LeftVector|UpArrowBar|nLeftarrow|nsubseteqq|subsetneqq|nsupseteqq|nleftarrow|succapprox|lessapprox|UpTeeArrow|upuparrows|curlywedge|lesseqqgtr|varepsilon|varnothing|RightFloor|complement|CirclePlus|sqsubseteq|Lleftarrow|circledast|RightArrow|Rightarrow|rightarrow|lmoustache|Bernoullis|precapprox|mapstoleft|mapstodown|longmapsto|dotsquare|downarrow|DoubleDot|nsubseteq|supsetneq|leftarrow|nsupseteq|subsetneq|ThinSpace|ngeqslant|subseteqq|HumpEqual|NotSubset|triangleq|NotCupCap|lesseqgtr|heartsuit|TripleDot|Leftarrow|Coproduct|Congruent|varpropto|complexes|gvertneqq|LeftArrow|LessTilde|supseteqq|MinusPlus|CircleDot|nleqslant|NotExists|gtreqless|nparallel|UnionPlus|LeftFloor|checkmark|CenterDot|centerdot|Mellintrf|gtrapprox|bigotimes|OverBrace|spadesuit|therefore|pitchfork|rationals|PlusMinus|Backslash|Therefore|DownBreve|backsimeq|backprime|DownArrow|nshortmid|Downarrow|lvertneqq|eqvparsl|imagline|imagpart|infintie|integers|Integral|intercal|LessLess|Uarrocir|intlarhk|sqsupset|angmsdaf|sqsubset|llcorner|vartheta|cupbrcap|lnapprox|Superset|SuchThat|succnsim|succneqq|angmsdag|biguplus|curlyvee|trpezium|Succeeds|NotTilde|bigwedge|angmsdah|angrtvbd|triminus|cwconint|fpartint|lrcorner|smeparsl|subseteq|urcorner|lurdshar|laemptyv|DDotrahd|approxeq|ldrushar|awconint|mapstoup|backcong|shortmid|triangle|geqslant|gesdotol|timesbar|circledR|circledS|setminus|multimap|naturals|scpolint|ncongdot|RightTee|boxminus|gnapprox|boxtimes|andslope|thicksim|angmsdaa|varsigma|cirfnint|rtriltri|angmsdab|rppolint|angmsdac|barwedge|drbkarow|clubsuit|thetasym|bsolhsub|capbrcup|dzigrarr|doteqdot|DotEqual|dotminus|UnderBar|NotEqual|realpart|otimesas|ulcorner|hksearow|hkswarow|parallel|PartialD|elinters|emptyset|plusacir|bbrktbrk|angmsdad|pointint|bigoplus|angmsdae|Precedes|bigsqcup|varkappa|notindot|supseteq|precneqq|precnsim|profalar|profline|profsurf|leqslant|lesdotor|raemptyv|subplus|notnivb|notnivc|subrarr|zigrarr|vzigzag|submult|subedot|Element|between|cirscir|larrbfs|larrsim|lotimes|lbrksld|lbrkslu|lozenge|ldrdhar|dbkarow|bigcirc|epsilon|simrarr|simplus|ltquest|Epsilon|luruhar|gtquest|maltese|npolint|eqcolon|npreceq|bigodot|ddagger|gtrless|bnequiv|harrcir|ddotseq|equivDD|backsim|demptyv|nsqsube|nsqsupe|Upsilon|nsubset|upsilon|minusdu|nsucceq|swarrow|nsupset|coloneq|searrow|boxplus|napprox|natural|asympeq|alefsym|congdot|nearrow|bigstar|diamond|supplus|tritime|LeftTee|nvinfin|triplus|NewLine|nvltrie|nvrtrie|nwarrow|nexists|Diamond|ruluhar|Implies|supmult|angzarr|suplarr|suphsub|questeq|because|digamma|Because|olcross|bemptyv|omicron|Omicron|rotimes|NoBreak|intprod|angrtvb|orderof|uwangle|suphsol|lesdoto|orslope|DownTee|realine|cudarrl|rdldhar|OverBar|supedot|lessdot|supdsub|topfork|succsim|rbrkslu|rbrksld|pertenk|cudarrr|isindot|planckh|lessgtr|pluscir|gesdoto|plussim|plustwo|lesssim|cularrp|rarrsim|Cayleys|notinva|notinvb|notinvc|UpArrow|Uparrow|uparrow|NotLess|dwangle|precsim|Product|curarrm|Cconint|dotplus|rarrbfs|ccupssm|Cedilla|cemptyv|notniva|quatint|frac35|frac38|frac45|frac56|frac58|frac78|tridot|xoplus|gacute|gammad|Gammad|lfisht|lfloor|bigcup|sqsupe|gbreve|Gbreve|lharul|sqsube|sqcups|Gcedil|apacir|llhard|lmidot|Lmidot|lmoust|andand|sqcaps|approx|Abreve|spades|circeq|tprime|divide|topcir|Assign|topbot|gesdot|divonx|xuplus|timesd|gesles|atilde|solbar|SOFTcy|loplus|timesb|lowast|lowbar|dlcorn|dlcrop|softcy|dollar|lparlt|thksim|lrhard|Atilde|lsaquo|smashp|bigvee|thinsp|wreath|bkarow|lsquor|lstrok|Lstrok|lthree|ltimes|ltlarr|DotDot|simdot|ltrPar|weierp|xsqcup|angmsd|sigmav|sigmaf|zeetrf|Zcaron|zcaron|mapsto|vsupne|thetav|cirmid|marker|mcomma|Zacute|vsubnE|there4|gtlPar|vsubne|bottom|gtrarr|SHCHcy|shchcy|midast|midcir|middot|minusb|minusd|gtrdot|bowtie|sfrown|mnplus|models|colone|seswar|Colone|mstpos|searhk|gtrsim|nacute|Nacute|boxbox|telrec|hairsp|Tcedil|nbumpe|scnsim|ncaron|Ncaron|ncedil|Ncedil|hamilt|Scedil|nearhk|hardcy|HARDcy|tcedil|Tcaron|commat|nequiv|nesear|tcaron|target|hearts|nexist|varrho|scedil|Scaron|scaron|hellip|Sacute|sacute|hercon|swnwar|compfn|rtimes|rthree|rsquor|rsaquo|zacute|wedgeq|homtht|barvee|barwed|Barwed|rpargt|horbar|conint|swarhk|roplus|nltrie|hslash|hstrok|Hstrok|rmoust|Conint|bprime|hybull|hyphen|iacute|Iacute|supsup|supsub|supsim|varphi|coprod|brvbar|agrave|Supset|supset|igrave|Igrave|notinE|Agrave|iiiint|iinfin|copysr|wedbar|Verbar|vangrt|becaus|incare|verbar|inodot|bullet|drcorn|intcal|drcrop|cularr|vellip|Utilde|bumpeq|cupcap|dstrok|Dstrok|CupCap|cupcup|cupdot|eacute|Eacute|supdot|iquest|easter|ecaron|Ecaron|ecolon|isinsv|utilde|itilde|Itilde|curarr|succeq|Bumpeq|cacute|ulcrop|nparsl|Cacute|nprcue|egrave|Egrave|nrarrc|nrarrw|subsup|subsub|nrtrie|jsercy|nsccue|Jsercy|kappav|kcedil|Kcedil|subsim|ulcorn|nsimeq|egsdot|veebar|kgreen|capand|elsdot|Subset|subset|curren|aacute|lacute|Lacute|emptyv|ntilde|Ntilde|lagran|lambda|Lambda|capcap|Ugrave|langle|subdot|emsp13|numero|emsp14|nvdash|nvDash|nVdash|nVDash|ugrave|ufisht|nvHarr|larrfs|nvlArr|larrhk|larrlp|larrpl|nvrArr|Udblac|nwarhk|larrtl|nwnear|oacute|Oacute|latail|lAtail|sstarf|lbrace|odblac|Odblac|lbrack|udblac|odsold|eparsl|lcaron|Lcaron|ograve|Ograve|lcedil|Lcedil|Aacute|ssmile|ssetmn|squarf|ldquor|capcup|ominus|cylcty|rharul|eqcirc|dagger|rfloor|rfisht|Dagger|daleth|equals|origof|capdot|equest|dcaron|Dcaron|rdquor|oslash|Oslash|otilde|Otilde|otimes|Otimes|urcrop|Ubreve|ubreve|Yacute|Uacute|uacute|Rcedil|rcedil|urcorn|parsim|Rcaron|Vdashl|rcaron|Tstrok|percnt|period|permil|Exists|yacute|rbrack|rbrace|phmmat|ccaron|Ccaron|planck|ccedil|plankv|tstrok|female|plusdo|plusdu|ffilig|plusmn|ffllig|Ccedil|rAtail|dfisht|bernou|ratail|Rarrtl|rarrtl|angsph|rarrpl|rarrlp|rarrhk|xwedge|xotime|forall|ForAll|Vvdash|vsupnE|preceq|bigcap|frac12|frac13|frac14|primes|rarrfs|prnsim|frac15|Square|frac16|square|lesdot|frac18|frac23|propto|prurel|rarrap|rangle|puncsp|frac25|Racute|qprime|racute|lesges|frac34|abreve|AElig|eqsim|utdot|setmn|urtri|Equal|Uring|seArr|uring|searr|dashv|Dashv|mumap|nabla|iogon|Iogon|sdote|sdotb|scsim|napid|napos|equiv|natur|Acirc|dblac|erarr|nbump|iprod|erDot|ucirc|awint|esdot|angrt|ncong|isinE|scnap|Scirc|scirc|ndash|isins|Ubrcy|nearr|neArr|isinv|nedot|ubrcy|acute|Ycirc|iukcy|Iukcy|xutri|nesim|caret|jcirc|Jcirc|caron|twixt|ddarr|sccue|exist|jmath|sbquo|ngeqq|angst|ccaps|lceil|ngsim|UpTee|delta|Delta|rtrif|nharr|nhArr|nhpar|rtrie|jukcy|Jukcy|kappa|rsquo|Kappa|nlarr|nlArr|TSHcy|rrarr|aogon|Aogon|fflig|xrarr|tshcy|ccirc|nleqq|filig|upsih|nless|dharl|nlsim|fjlig|ropar|nltri|dharr|robrk|roarr|fllig|fltns|roang|rnmid|subnE|subne|lAarr|trisb|Ccirc|acirc|ccups|blank|VDash|forkv|Vdash|langd|cedil|blk12|blk14|laquo|strns|diams|notin|vDash|larrb|blk34|block|disin|uplus|vdash|vBarv|aelig|starf|Wedge|check|xrArr|lates|lbarr|lBarr|notni|lbbrk|bcong|frasl|lbrke|frown|vrtri|vprop|vnsup|gamma|Gamma|wedge|xodot|bdquo|srarr|doteq|ldquo|boxdl|boxdL|gcirc|Gcirc|boxDl|boxDL|boxdr|boxdR|boxDr|TRADE|trade|rlhar|boxDR|vnsub|npart|vltri|rlarr|boxhd|boxhD|nprec|gescc|nrarr|nrArr|boxHd|boxHD|boxhu|boxhU|nrtri|boxHu|clubs|boxHU|times|colon|Colon|gimel|xlArr|Tilde|nsime|tilde|nsmid|nspar|THORN|thorn|xlarr|nsube|nsubE|thkap|xhArr|comma|nsucc|boxul|boxuL|nsupe|nsupE|gneqq|gnsim|boxUl|boxUL|grave|boxur|boxuR|boxUr|boxUR|lescc|angle|bepsi|boxvh|varpi|boxvH|numsp|Theta|gsime|gsiml|theta|boxVh|boxVH|boxvl|gtcir|gtdot|boxvL|boxVl|boxVL|crarr|cross|Cross|nvsim|boxvr|nwarr|nwArr|sqsup|dtdot|Uogon|lhard|lharu|dtrif|ocirc|Ocirc|lhblk|duarr|odash|sqsub|Hacek|sqcup|llarr|duhar|oelig|OElig|ofcir|boxvR|uogon|lltri|boxVr|csube|uuarr|ohbar|csupe|ctdot|olarr|olcir|harrw|oline|sqcap|omacr|Omacr|omega|Omega|boxVR|aleph|lneqq|lnsim|loang|loarr|rharu|lobrk|hcirc|operp|oplus|rhard|Hcirc|orarr|Union|order|ecirc|Ecirc|cuepr|szlig|cuesc|breve|reals|eDDot|Breve|hoarr|lopar|utrif|rdquo|Umacr|umacr|efDot|swArr|ultri|alpha|rceil|ovbar|swarr|Wcirc|wcirc|smtes|smile|bsemi|lrarr|aring|parsl|lrhar|bsime|uhblk|lrtri|cupor|Aring|uharr|uharl|slarr|rbrke|bsolb|lsime|rbbrk|RBarr|lsimg|phone|rBarr|rbarr|icirc|lsquo|Icirc|emacr|Emacr|ratio|simne|plusb|simlE|simgE|simeq|pluse|ltcir|ltdot|empty|xharr|xdtri|iexcl|Alpha|ltrie|rarrw|pound|ltrif|xcirc|bumpe|prcue|bumpE|asymp|amacr|cuvee|Sigma|sigma|iiint|udhar|iiota|ijlig|IJlig|supnE|imacr|Imacr|prime|Prime|image|prnap|eogon|Eogon|rarrc|mdash|mDDot|cuwed|imath|supne|imped|Amacr|udarr|prsim|micro|rarrb|cwint|raquo|infin|eplus|range|rangd|Ucirc|radic|minus|amalg|veeeq|rAarr|epsiv|ycirc|quest|sharp|quot|zwnj|Qscr|race|qscr|Qopf|qopf|qint|rang|Rang|Zscr|zscr|Zopf|zopf|rarr|rArr|Rarr|Pscr|pscr|prop|prod|prnE|prec|ZHcy|zhcy|prap|Zeta|zeta|Popf|popf|Zdot|plus|zdot|Yuml|yuml|phiv|YUcy|yucy|Yscr|yscr|perp|Yopf|yopf|part|para|YIcy|Ouml|rcub|yicy|YAcy|rdca|ouml|osol|Oscr|rdsh|yacy|real|oscr|xvee|andd|rect|andv|Xscr|oror|ordm|ordf|xscr|ange|aopf|Aopf|rHar|Xopf|opar|Oopf|xopf|xnis|rhov|oopf|omid|xmap|oint|apid|apos|ogon|ascr|Ascr|odot|odiv|xcup|xcap|ocir|oast|nvlt|nvle|nvgt|nvge|nvap|Wscr|wscr|auml|ntlg|ntgl|nsup|nsub|nsim|Nscr|nscr|nsce|Wopf|ring|npre|wopf|npar|Auml|Barv|bbrk|Nopf|nopf|nmid|nLtv|beta|ropf|Ropf|Beta|beth|nles|rpar|nleq|bnot|bNot|nldr|NJcy|rscr|Rscr|Vscr|vscr|rsqb|njcy|bopf|nisd|Bopf|rtri|Vopf|nGtv|ngtr|vopf|boxh|boxH|boxv|nges|ngeq|boxV|bscr|scap|Bscr|bsim|Vert|vert|bsol|bull|bump|caps|cdot|ncup|scnE|ncap|nbsp|napE|Cdot|cent|sdot|Vbar|nang|vBar|chcy|Mscr|mscr|sect|semi|CHcy|Mopf|mopf|sext|circ|cire|mldr|mlcp|cirE|comp|shcy|SHcy|vArr|varr|cong|copf|Copf|copy|COPY|malt|male|macr|lvnE|cscr|ltri|sime|ltcc|simg|Cscr|siml|csub|Uuml|lsqb|lsim|uuml|csup|Lscr|lscr|utri|smid|lpar|cups|smte|lozf|darr|Lopf|Uscr|solb|lopf|sopf|Sopf|lneq|uscr|spar|dArr|lnap|Darr|dash|Sqrt|LJcy|ljcy|lHar|dHar|Upsi|upsi|diam|lesg|djcy|DJcy|leqq|dopf|Dopf|dscr|Dscr|dscy|ldsh|ldca|squf|DScy|sscr|Sscr|dsol|lcub|late|star|Star|Uopf|Larr|lArr|larr|uopf|dtri|dzcy|sube|subE|Lang|lang|Kscr|kscr|Kopf|kopf|KJcy|kjcy|KHcy|khcy|DZcy|ecir|edot|eDot|Jscr|jscr|succ|Jopf|jopf|Edot|uHar|emsp|ensp|Iuml|iuml|eopf|isin|Iscr|iscr|Eopf|epar|sung|epsi|escr|sup1|sup2|sup3|Iota|iota|supe|supE|Iopf|iopf|IOcy|iocy|Escr|esim|Esim|imof|Uarr|QUOT|uArr|uarr|euml|IEcy|iecy|Idot|Euml|euro|excl|Hscr|hscr|Hopf|hopf|TScy|tscy|Tscr|hbar|tscr|flat|tbrk|fnof|hArr|harr|half|fopf|Fopf|tdot|gvnE|fork|trie|gtcc|fscr|Fscr|gdot|gsim|Gscr|gscr|Gopf|gopf|gneq|Gdot|tosa|gnap|Topf|topf|geqq|toea|GJcy|gjcy|tint|gesl|mid|Sfr|ggg|top|ges|gla|glE|glj|geq|gne|gEl|gel|gnE|Gcy|gcy|gap|Tfr|tfr|Tcy|tcy|Hat|Tau|Ffr|tau|Tab|hfr|Hfr|ffr|Fcy|fcy|icy|Icy|iff|ETH|eth|ifr|Ifr|Eta|eta|int|Int|Sup|sup|ucy|Ucy|Sum|sum|jcy|ENG|ufr|Ufr|eng|Jcy|jfr|els|ell|egs|Efr|efr|Jfr|uml|kcy|Kcy|Ecy|ecy|kfr|Kfr|lap|Sub|sub|lat|lcy|Lcy|leg|Dot|dot|lEg|leq|les|squ|div|die|lfr|Lfr|lgE|Dfr|dfr|Del|deg|Dcy|dcy|lne|lnE|sol|loz|smt|Cup|lrm|cup|lsh|Lsh|sim|shy|map|Map|mcy|Mcy|mfr|Mfr|mho|gfr|Gfr|sfr|cir|Chi|chi|nap|Cfr|vcy|Vcy|cfr|Scy|scy|ncy|Ncy|vee|Vee|Cap|cap|nfr|scE|sce|Nfr|nge|ngE|nGg|vfr|Vfr|ngt|bot|nGt|nis|niv|Rsh|rsh|nle|nlE|bne|Bfr|bfr|nLl|nlt|nLt|Bcy|bcy|not|Not|rlm|wfr|Wfr|npr|nsc|num|ocy|ast|Ocy|ofr|xfr|Xfr|Ofr|ogt|ohm|apE|olt|Rho|ape|rho|Rfr|rfr|ord|REG|ang|reg|orv|And|and|AMP|Rcy|amp|Afr|ycy|Ycy|yen|yfr|Yfr|rcy|par|pcy|Pcy|pfr|Pfr|phi|Phi|afr|Acy|acy|zcy|Zcy|piv|acE|acd|zfr|Zfr|pre|prE|psi|Psi|qfr|Qfr|zwj|Or|ge|Gg|gt|gg|el|oS|lt|Lt|LT|Re|lg|gl|eg|ne|Im|it|le|DD|wp|wr|nu|Nu|dd|lE|Sc|sc|pi|Pi|ee|af|ll|Ll|rx|gE|xi|pm|Xi|ic|pr|Pr|in|ni|mp|mu|ac|Mu|or|ap|Gt|GT|ii);|&(Aacute|Agrave|Atilde|Ccedil|Eacute|Egrave|Iacute|Igrave|Ntilde|Oacute|Ograve|Oslash|Otilde|Uacute|Ugrave|Yacute|aacute|agrave|atilde|brvbar|ccedil|curren|divide|eacute|egrave|frac12|frac14|frac34|iacute|igrave|iquest|middot|ntilde|oacute|ograve|oslash|otilde|plusmn|uacute|ugrave|yacute|AElig|Acirc|Aring|Ecirc|Icirc|Ocirc|THORN|Ucirc|acirc|acute|aelig|aring|cedil|ecirc|icirc|iexcl|laquo|micro|ocirc|pound|raquo|szlig|thorn|times|ucirc|Auml|COPY|Euml|Iuml|Ouml|QUOT|Uuml|auml|cent|copy|euml|iuml|macr|nbsp|ordf|ordm|ouml|para|quot|sect|sup1|sup2|sup3|uuml|yuml|AMP|ETH|REG|amp|deg|eth|not|reg|shy|uml|yen|GT|LT|gt|lt)(?!;)([=a-zA-Z0-9]?)|&#([0-9]+)(;?)|&#[xX]([a-fA-F0-9]+)(;?)|&([0-9a-zA-Z]+)/g,
                        y = {
                          aacute: "á",
                          Aacute: "Á",
                          abreve: "ă",
                          Abreve: "Ă",
                          ac: "∾",
                          acd: "∿",
                          acE: "∾̳",
                          acirc: "â",
                          Acirc: "Â",
                          acute: "´",
                          acy: "а",
                          Acy: "А",
                          aelig: "æ",
                          AElig: "Æ",
                          af: "⁡",
                          afr: "𝔞",
                          Afr: "𝔄",
                          agrave: "à",
                          Agrave: "À",
                          alefsym: "ℵ",
                          aleph: "ℵ",
                          alpha: "α",
                          Alpha: "Α",
                          amacr: "ā",
                          Amacr: "Ā",
                          amalg: "⨿",
                          amp: "&",
                          AMP: "&",
                          and: "∧",
                          And: "⩓",
                          andand: "⩕",
                          andd: "⩜",
                          andslope: "⩘",
                          andv: "⩚",
                          ang: "∠",
                          ange: "⦤",
                          angle: "∠",
                          angmsd: "∡",
                          angmsdaa: "⦨",
                          angmsdab: "⦩",
                          angmsdac: "⦪",
                          angmsdad: "⦫",
                          angmsdae: "⦬",
                          angmsdaf: "⦭",
                          angmsdag: "⦮",
                          angmsdah: "⦯",
                          angrt: "∟",
                          angrtvb: "⊾",
                          angrtvbd: "⦝",
                          angsph: "∢",
                          angst: "Å",
                          angzarr: "⍼",
                          aogon: "ą",
                          Aogon: "Ą",
                          aopf: "𝕒",
                          Aopf: "𝔸",
                          ap: "≈",
                          apacir: "⩯",
                          ape: "≊",
                          apE: "⩰",
                          apid: "≋",
                          apos: "'",
                          ApplyFunction: "⁡",
                          approx: "≈",
                          approxeq: "≊",
                          aring: "å",
                          Aring: "Å",
                          ascr: "𝒶",
                          Ascr: "𝒜",
                          Assign: "≔",
                          ast: "*",
                          asymp: "≈",
                          asympeq: "≍",
                          atilde: "ã",
                          Atilde: "Ã",
                          auml: "ä",
                          Auml: "Ä",
                          awconint: "∳",
                          awint: "⨑",
                          backcong: "≌",
                          backepsilon: "϶",
                          backprime: "‵",
                          backsim: "∽",
                          backsimeq: "⋍",
                          Backslash: "∖",
                          Barv: "⫧",
                          barvee: "⊽",
                          barwed: "⌅",
                          Barwed: "⌆",
                          barwedge: "⌅",
                          bbrk: "⎵",
                          bbrktbrk: "⎶",
                          bcong: "≌",
                          bcy: "б",
                          Bcy: "Б",
                          bdquo: "„",
                          becaus: "∵",
                          because: "∵",
                          Because: "∵",
                          bemptyv: "⦰",
                          bepsi: "϶",
                          bernou: "ℬ",
                          Bernoullis: "ℬ",
                          beta: "β",
                          Beta: "Β",
                          beth: "ℶ",
                          between: "≬",
                          bfr: "𝔟",
                          Bfr: "𝔅",
                          bigcap: "⋂",
                          bigcirc: "◯",
                          bigcup: "⋃",
                          bigodot: "⨀",
                          bigoplus: "⨁",
                          bigotimes: "⨂",
                          bigsqcup: "⨆",
                          bigstar: "★",
                          bigtriangledown: "▽",
                          bigtriangleup: "△",
                          biguplus: "⨄",
                          bigvee: "⋁",
                          bigwedge: "⋀",
                          bkarow: "⤍",
                          blacklozenge: "⧫",
                          blacksquare: "▪",
                          blacktriangle: "▴",
                          blacktriangledown: "▾",
                          blacktriangleleft: "◂",
                          blacktriangleright: "▸",
                          blank: "␣",
                          blk12: "▒",
                          blk14: "░",
                          blk34: "▓",
                          block: "█",
                          bne: "=⃥",
                          bnequiv: "≡⃥",
                          bnot: "⌐",
                          bNot: "⫭",
                          bopf: "𝕓",
                          Bopf: "𝔹",
                          bot: "⊥",
                          bottom: "⊥",
                          bowtie: "⋈",
                          boxbox: "⧉",
                          boxdl: "┐",
                          boxdL: "╕",
                          boxDl: "╖",
                          boxDL: "╗",
                          boxdr: "┌",
                          boxdR: "╒",
                          boxDr: "╓",
                          boxDR: "╔",
                          boxh: "─",
                          boxH: "═",
                          boxhd: "┬",
                          boxhD: "╥",
                          boxHd: "╤",
                          boxHD: "╦",
                          boxhu: "┴",
                          boxhU: "╨",
                          boxHu: "╧",
                          boxHU: "╩",
                          boxminus: "⊟",
                          boxplus: "⊞",
                          boxtimes: "⊠",
                          boxul: "┘",
                          boxuL: "╛",
                          boxUl: "╜",
                          boxUL: "╝",
                          boxur: "└",
                          boxuR: "╘",
                          boxUr: "╙",
                          boxUR: "╚",
                          boxv: "│",
                          boxV: "║",
                          boxvh: "┼",
                          boxvH: "╪",
                          boxVh: "╫",
                          boxVH: "╬",
                          boxvl: "┤",
                          boxvL: "╡",
                          boxVl: "╢",
                          boxVL: "╣",
                          boxvr: "├",
                          boxvR: "╞",
                          boxVr: "╟",
                          boxVR: "╠",
                          bprime: "‵",
                          breve: "˘",
                          Breve: "˘",
                          brvbar: "¦",
                          bscr: "𝒷",
                          Bscr: "ℬ",
                          bsemi: "⁏",
                          bsim: "∽",
                          bsime: "⋍",
                          bsol: "\\",
                          bsolb: "⧅",
                          bsolhsub: "⟈",
                          bull: "•",
                          bullet: "•",
                          bump: "≎",
                          bumpe: "≏",
                          bumpE: "⪮",
                          bumpeq: "≏",
                          Bumpeq: "≎",
                          cacute: "ć",
                          Cacute: "Ć",
                          cap: "∩",
                          Cap: "⋒",
                          capand: "⩄",
                          capbrcup: "⩉",
                          capcap: "⩋",
                          capcup: "⩇",
                          capdot: "⩀",
                          CapitalDifferentialD: "ⅅ",
                          caps: "∩︀",
                          caret: "⁁",
                          caron: "ˇ",
                          Cayleys: "ℭ",
                          ccaps: "⩍",
                          ccaron: "č",
                          Ccaron: "Č",
                          ccedil: "ç",
                          Ccedil: "Ç",
                          ccirc: "ĉ",
                          Ccirc: "Ĉ",
                          Cconint: "∰",
                          ccups: "⩌",
                          ccupssm: "⩐",
                          cdot: "ċ",
                          Cdot: "Ċ",
                          cedil: "¸",
                          Cedilla: "¸",
                          cemptyv: "⦲",
                          cent: "¢",
                          centerdot: "·",
                          CenterDot: "·",
                          cfr: "𝔠",
                          Cfr: "ℭ",
                          chcy: "ч",
                          CHcy: "Ч",
                          check: "✓",
                          checkmark: "✓",
                          chi: "χ",
                          Chi: "Χ",
                          cir: "○",
                          circ: "ˆ",
                          circeq: "≗",
                          circlearrowleft: "↺",
                          circlearrowright: "↻",
                          circledast: "⊛",
                          circledcirc: "⊚",
                          circleddash: "⊝",
                          CircleDot: "⊙",
                          circledR: "®",
                          circledS: "Ⓢ",
                          CircleMinus: "⊖",
                          CirclePlus: "⊕",
                          CircleTimes: "⊗",
                          cire: "≗",
                          cirE: "⧃",
                          cirfnint: "⨐",
                          cirmid: "⫯",
                          cirscir: "⧂",
                          ClockwiseContourIntegral: "∲",
                          CloseCurlyDoubleQuote: "”",
                          CloseCurlyQuote: "’",
                          clubs: "♣",
                          clubsuit: "♣",
                          colon: ":",
                          Colon: "∷",
                          colone: "≔",
                          Colone: "⩴",
                          coloneq: "≔",
                          comma: ",",
                          commat: "@",
                          comp: "∁",
                          compfn: "∘",
                          complement: "∁",
                          complexes: "ℂ",
                          cong: "≅",
                          congdot: "⩭",
                          Congruent: "≡",
                          conint: "∮",
                          Conint: "∯",
                          ContourIntegral: "∮",
                          copf: "𝕔",
                          Copf: "ℂ",
                          coprod: "∐",
                          Coproduct: "∐",
                          copy: "©",
                          COPY: "©",
                          copysr: "℗",
                          CounterClockwiseContourIntegral: "∳",
                          crarr: "↵",
                          cross: "✗",
                          Cross: "⨯",
                          cscr: "𝒸",
                          Cscr: "𝒞",
                          csub: "⫏",
                          csube: "⫑",
                          csup: "⫐",
                          csupe: "⫒",
                          ctdot: "⋯",
                          cudarrl: "⤸",
                          cudarrr: "⤵",
                          cuepr: "⋞",
                          cuesc: "⋟",
                          cularr: "↶",
                          cularrp: "⤽",
                          cup: "∪",
                          Cup: "⋓",
                          cupbrcap: "⩈",
                          cupcap: "⩆",
                          CupCap: "≍",
                          cupcup: "⩊",
                          cupdot: "⊍",
                          cupor: "⩅",
                          cups: "∪︀",
                          curarr: "↷",
                          curarrm: "⤼",
                          curlyeqprec: "⋞",
                          curlyeqsucc: "⋟",
                          curlyvee: "⋎",
                          curlywedge: "⋏",
                          curren: "¤",
                          curvearrowleft: "↶",
                          curvearrowright: "↷",
                          cuvee: "⋎",
                          cuwed: "⋏",
                          cwconint: "∲",
                          cwint: "∱",
                          cylcty: "⌭",
                          dagger: "†",
                          Dagger: "‡",
                          daleth: "ℸ",
                          darr: "↓",
                          dArr: "⇓",
                          Darr: "↡",
                          dash: "‐",
                          dashv: "⊣",
                          Dashv: "⫤",
                          dbkarow: "⤏",
                          dblac: "˝",
                          dcaron: "ď",
                          Dcaron: "Ď",
                          dcy: "д",
                          Dcy: "Д",
                          dd: "ⅆ",
                          DD: "ⅅ",
                          ddagger: "‡",
                          ddarr: "⇊",
                          DDotrahd: "⤑",
                          ddotseq: "⩷",
                          deg: "°",
                          Del: "∇",
                          delta: "δ",
                          Delta: "Δ",
                          demptyv: "⦱",
                          dfisht: "⥿",
                          dfr: "𝔡",
                          Dfr: "𝔇",
                          dHar: "⥥",
                          dharl: "⇃",
                          dharr: "⇂",
                          DiacriticalAcute: "´",
                          DiacriticalDot: "˙",
                          DiacriticalDoubleAcute: "˝",
                          DiacriticalGrave: "`",
                          DiacriticalTilde: "˜",
                          diam: "⋄",
                          diamond: "⋄",
                          Diamond: "⋄",
                          diamondsuit: "♦",
                          diams: "♦",
                          die: "¨",
                          DifferentialD: "ⅆ",
                          digamma: "ϝ",
                          disin: "⋲",
                          div: "÷",
                          divide: "÷",
                          divideontimes: "⋇",
                          divonx: "⋇",
                          djcy: "ђ",
                          DJcy: "Ђ",
                          dlcorn: "⌞",
                          dlcrop: "⌍",
                          dollar: "$",
                          dopf: "𝕕",
                          Dopf: "𝔻",
                          dot: "˙",
                          Dot: "¨",
                          DotDot: "⃜",
                          doteq: "≐",
                          doteqdot: "≑",
                          DotEqual: "≐",
                          dotminus: "∸",
                          dotplus: "∔",
                          dotsquare: "⊡",
                          doublebarwedge: "⌆",
                          DoubleContourIntegral: "∯",
                          DoubleDot: "¨",
                          DoubleDownArrow: "⇓",
                          DoubleLeftArrow: "⇐",
                          DoubleLeftRightArrow: "⇔",
                          DoubleLeftTee: "⫤",
                          DoubleLongLeftArrow: "⟸",
                          DoubleLongLeftRightArrow: "⟺",
                          DoubleLongRightArrow: "⟹",
                          DoubleRightArrow: "⇒",
                          DoubleRightTee: "⊨",
                          DoubleUpArrow: "⇑",
                          DoubleUpDownArrow: "⇕",
                          DoubleVerticalBar: "∥",
                          downarrow: "↓",
                          Downarrow: "⇓",
                          DownArrow: "↓",
                          DownArrowBar: "⤓",
                          DownArrowUpArrow: "⇵",
                          DownBreve: "̑",
                          downdownarrows: "⇊",
                          downharpoonleft: "⇃",
                          downharpoonright: "⇂",
                          DownLeftRightVector: "⥐",
                          DownLeftTeeVector: "⥞",
                          DownLeftVector: "↽",
                          DownLeftVectorBar: "⥖",
                          DownRightTeeVector: "⥟",
                          DownRightVector: "⇁",
                          DownRightVectorBar: "⥗",
                          DownTee: "⊤",
                          DownTeeArrow: "↧",
                          drbkarow: "⤐",
                          drcorn: "⌟",
                          drcrop: "⌌",
                          dscr: "𝒹",
                          Dscr: "𝒟",
                          dscy: "ѕ",
                          DScy: "Ѕ",
                          dsol: "⧶",
                          dstrok: "đ",
                          Dstrok: "Đ",
                          dtdot: "⋱",
                          dtri: "▿",
                          dtrif: "▾",
                          duarr: "⇵",
                          duhar: "⥯",
                          dwangle: "⦦",
                          dzcy: "џ",
                          DZcy: "Џ",
                          dzigrarr: "⟿",
                          eacute: "é",
                          Eacute: "É",
                          easter: "⩮",
                          ecaron: "ě",
                          Ecaron: "Ě",
                          ecir: "≖",
                          ecirc: "ê",
                          Ecirc: "Ê",
                          ecolon: "≕",
                          ecy: "э",
                          Ecy: "Э",
                          eDDot: "⩷",
                          edot: "ė",
                          eDot: "≑",
                          Edot: "Ė",
                          ee: "ⅇ",
                          efDot: "≒",
                          efr: "𝔢",
                          Efr: "𝔈",
                          eg: "⪚",
                          egrave: "è",
                          Egrave: "È",
                          egs: "⪖",
                          egsdot: "⪘",
                          el: "⪙",
                          Element: "∈",
                          elinters: "⏧",
                          ell: "ℓ",
                          els: "⪕",
                          elsdot: "⪗",
                          emacr: "ē",
                          Emacr: "Ē",
                          empty: "∅",
                          emptyset: "∅",
                          EmptySmallSquare: "◻",
                          emptyv: "∅",
                          EmptyVerySmallSquare: "▫",
                          emsp: " ",
                          emsp13: " ",
                          emsp14: " ",
                          eng: "ŋ",
                          ENG: "Ŋ",
                          ensp: " ",
                          eogon: "ę",
                          Eogon: "Ę",
                          eopf: "𝕖",
                          Eopf: "𝔼",
                          epar: "⋕",
                          eparsl: "⧣",
                          eplus: "⩱",
                          epsi: "ε",
                          epsilon: "ε",
                          Epsilon: "Ε",
                          epsiv: "ϵ",
                          eqcirc: "≖",
                          eqcolon: "≕",
                          eqsim: "≂",
                          eqslantgtr: "⪖",
                          eqslantless: "⪕",
                          Equal: "⩵",
                          equals: "=",
                          EqualTilde: "≂",
                          equest: "≟",
                          Equilibrium: "⇌",
                          equiv: "≡",
                          equivDD: "⩸",
                          eqvparsl: "⧥",
                          erarr: "⥱",
                          erDot: "≓",
                          escr: "ℯ",
                          Escr: "ℰ",
                          esdot: "≐",
                          esim: "≂",
                          Esim: "⩳",
                          eta: "η",
                          Eta: "Η",
                          eth: "ð",
                          ETH: "Ð",
                          euml: "ë",
                          Euml: "Ë",
                          euro: "€",
                          excl: "!",
                          exist: "∃",
                          Exists: "∃",
                          expectation: "ℰ",
                          exponentiale: "ⅇ",
                          ExponentialE: "ⅇ",
                          fallingdotseq: "≒",
                          fcy: "ф",
                          Fcy: "Ф",
                          female: "♀",
                          ffilig: "ﬃ",
                          fflig: "ﬀ",
                          ffllig: "ﬄ",
                          ffr: "𝔣",
                          Ffr: "𝔉",
                          filig: "ﬁ",
                          FilledSmallSquare: "◼",
                          FilledVerySmallSquare: "▪",
                          fjlig: "fj",
                          flat: "♭",
                          fllig: "ﬂ",
                          fltns: "▱",
                          fnof: "ƒ",
                          fopf: "𝕗",
                          Fopf: "𝔽",
                          forall: "∀",
                          ForAll: "∀",
                          fork: "⋔",
                          forkv: "⫙",
                          Fouriertrf: "ℱ",
                          fpartint: "⨍",
                          frac12: "½",
                          frac13: "⅓",
                          frac14: "¼",
                          frac15: "⅕",
                          frac16: "⅙",
                          frac18: "⅛",
                          frac23: "⅔",
                          frac25: "⅖",
                          frac34: "¾",
                          frac35: "⅗",
                          frac38: "⅜",
                          frac45: "⅘",
                          frac56: "⅚",
                          frac58: "⅝",
                          frac78: "⅞",
                          frasl: "⁄",
                          frown: "⌢",
                          fscr: "𝒻",
                          Fscr: "ℱ",
                          gacute: "ǵ",
                          gamma: "γ",
                          Gamma: "Γ",
                          gammad: "ϝ",
                          Gammad: "Ϝ",
                          gap: "⪆",
                          gbreve: "ğ",
                          Gbreve: "Ğ",
                          Gcedil: "Ģ",
                          gcirc: "ĝ",
                          Gcirc: "Ĝ",
                          gcy: "г",
                          Gcy: "Г",
                          gdot: "ġ",
                          Gdot: "Ġ",
                          ge: "≥",
                          gE: "≧",
                          gel: "⋛",
                          gEl: "⪌",
                          geq: "≥",
                          geqq: "≧",
                          geqslant: "⩾",
                          ges: "⩾",
                          gescc: "⪩",
                          gesdot: "⪀",
                          gesdoto: "⪂",
                          gesdotol: "⪄",
                          gesl: "⋛︀",
                          gesles: "⪔",
                          gfr: "𝔤",
                          Gfr: "𝔊",
                          gg: "≫",
                          Gg: "⋙",
                          ggg: "⋙",
                          gimel: "ℷ",
                          gjcy: "ѓ",
                          GJcy: "Ѓ",
                          gl: "≷",
                          gla: "⪥",
                          glE: "⪒",
                          glj: "⪤",
                          gnap: "⪊",
                          gnapprox: "⪊",
                          gne: "⪈",
                          gnE: "≩",
                          gneq: "⪈",
                          gneqq: "≩",
                          gnsim: "⋧",
                          gopf: "𝕘",
                          Gopf: "𝔾",
                          grave: "`",
                          GreaterEqual: "≥",
                          GreaterEqualLess: "⋛",
                          GreaterFullEqual: "≧",
                          GreaterGreater: "⪢",
                          GreaterLess: "≷",
                          GreaterSlantEqual: "⩾",
                          GreaterTilde: "≳",
                          gscr: "ℊ",
                          Gscr: "𝒢",
                          gsim: "≳",
                          gsime: "⪎",
                          gsiml: "⪐",
                          gt: ">",
                          Gt: "≫",
                          GT: ">",
                          gtcc: "⪧",
                          gtcir: "⩺",
                          gtdot: "⋗",
                          gtlPar: "⦕",
                          gtquest: "⩼",
                          gtrapprox: "⪆",
                          gtrarr: "⥸",
                          gtrdot: "⋗",
                          gtreqless: "⋛",
                          gtreqqless: "⪌",
                          gtrless: "≷",
                          gtrsim: "≳",
                          gvertneqq: "≩︀",
                          gvnE: "≩︀",
                          Hacek: "ˇ",
                          hairsp: " ",
                          half: "½",
                          hamilt: "ℋ",
                          hardcy: "ъ",
                          HARDcy: "Ъ",
                          harr: "↔",
                          hArr: "⇔",
                          harrcir: "⥈",
                          harrw: "↭",
                          Hat: "^",
                          hbar: "ℏ",
                          hcirc: "ĥ",
                          Hcirc: "Ĥ",
                          hearts: "♥",
                          heartsuit: "♥",
                          hellip: "…",
                          hercon: "⊹",
                          hfr: "𝔥",
                          Hfr: "ℌ",
                          HilbertSpace: "ℋ",
                          hksearow: "⤥",
                          hkswarow: "⤦",
                          hoarr: "⇿",
                          homtht: "∻",
                          hookleftarrow: "↩",
                          hookrightarrow: "↪",
                          hopf: "𝕙",
                          Hopf: "ℍ",
                          horbar: "―",
                          HorizontalLine: "─",
                          hscr: "𝒽",
                          Hscr: "ℋ",
                          hslash: "ℏ",
                          hstrok: "ħ",
                          Hstrok: "Ħ",
                          HumpDownHump: "≎",
                          HumpEqual: "≏",
                          hybull: "⁃",
                          hyphen: "‐",
                          iacute: "í",
                          Iacute: "Í",
                          ic: "⁣",
                          icirc: "î",
                          Icirc: "Î",
                          icy: "и",
                          Icy: "И",
                          Idot: "İ",
                          iecy: "е",
                          IEcy: "Е",
                          iexcl: "¡",
                          iff: "⇔",
                          ifr: "𝔦",
                          Ifr: "ℑ",
                          igrave: "ì",
                          Igrave: "Ì",
                          ii: "ⅈ",
                          iiiint: "⨌",
                          iiint: "∭",
                          iinfin: "⧜",
                          iiota: "℩",
                          ijlig: "ĳ",
                          IJlig: "Ĳ",
                          Im: "ℑ",
                          imacr: "ī",
                          Imacr: "Ī",
                          image: "ℑ",
                          ImaginaryI: "ⅈ",
                          imagline: "ℐ",
                          imagpart: "ℑ",
                          imath: "ı",
                          imof: "⊷",
                          imped: "Ƶ",
                          Implies: "⇒",
                          in: "∈",
                          incare: "℅",
                          infin: "∞",
                          infintie: "⧝",
                          inodot: "ı",
                          int: "∫",
                          Int: "∬",
                          intcal: "⊺",
                          integers: "ℤ",
                          Integral: "∫",
                          intercal: "⊺",
                          Intersection: "⋂",
                          intlarhk: "⨗",
                          intprod: "⨼",
                          InvisibleComma: "⁣",
                          InvisibleTimes: "⁢",
                          iocy: "ё",
                          IOcy: "Ё",
                          iogon: "į",
                          Iogon: "Į",
                          iopf: "𝕚",
                          Iopf: "𝕀",
                          iota: "ι",
                          Iota: "Ι",
                          iprod: "⨼",
                          iquest: "¿",
                          iscr: "𝒾",
                          Iscr: "ℐ",
                          isin: "∈",
                          isindot: "⋵",
                          isinE: "⋹",
                          isins: "⋴",
                          isinsv: "⋳",
                          isinv: "∈",
                          it: "⁢",
                          itilde: "ĩ",
                          Itilde: "Ĩ",
                          iukcy: "і",
                          Iukcy: "І",
                          iuml: "ï",
                          Iuml: "Ï",
                          jcirc: "ĵ",
                          Jcirc: "Ĵ",
                          jcy: "й",
                          Jcy: "Й",
                          jfr: "𝔧",
                          Jfr: "𝔍",
                          jmath: "ȷ",
                          jopf: "𝕛",
                          Jopf: "𝕁",
                          jscr: "𝒿",
                          Jscr: "𝒥",
                          jsercy: "ј",
                          Jsercy: "Ј",
                          jukcy: "є",
                          Jukcy: "Є",
                          kappa: "κ",
                          Kappa: "Κ",
                          kappav: "ϰ",
                          kcedil: "ķ",
                          Kcedil: "Ķ",
                          kcy: "к",
                          Kcy: "К",
                          kfr: "𝔨",
                          Kfr: "𝔎",
                          kgreen: "ĸ",
                          khcy: "х",
                          KHcy: "Х",
                          kjcy: "ќ",
                          KJcy: "Ќ",
                          kopf: "𝕜",
                          Kopf: "𝕂",
                          kscr: "𝓀",
                          Kscr: "𝒦",
                          lAarr: "⇚",
                          lacute: "ĺ",
                          Lacute: "Ĺ",
                          laemptyv: "⦴",
                          lagran: "ℒ",
                          lambda: "λ",
                          Lambda: "Λ",
                          lang: "⟨",
                          Lang: "⟪",
                          langd: "⦑",
                          langle: "⟨",
                          lap: "⪅",
                          Laplacetrf: "ℒ",
                          laquo: "«",
                          larr: "←",
                          lArr: "⇐",
                          Larr: "↞",
                          larrb: "⇤",
                          larrbfs: "⤟",
                          larrfs: "⤝",
                          larrhk: "↩",
                          larrlp: "↫",
                          larrpl: "⤹",
                          larrsim: "⥳",
                          larrtl: "↢",
                          lat: "⪫",
                          latail: "⤙",
                          lAtail: "⤛",
                          late: "⪭",
                          lates: "⪭︀",
                          lbarr: "⤌",
                          lBarr: "⤎",
                          lbbrk: "❲",
                          lbrace: "{",
                          lbrack: "[",
                          lbrke: "⦋",
                          lbrksld: "⦏",
                          lbrkslu: "⦍",
                          lcaron: "ľ",
                          Lcaron: "Ľ",
                          lcedil: "ļ",
                          Lcedil: "Ļ",
                          lceil: "⌈",
                          lcub: "{",
                          lcy: "л",
                          Lcy: "Л",
                          ldca: "⤶",
                          ldquo: "“",
                          ldquor: "„",
                          ldrdhar: "⥧",
                          ldrushar: "⥋",
                          ldsh: "↲",
                          le: "≤",
                          lE: "≦",
                          LeftAngleBracket: "⟨",
                          leftarrow: "←",
                          Leftarrow: "⇐",
                          LeftArrow: "←",
                          LeftArrowBar: "⇤",
                          LeftArrowRightArrow: "⇆",
                          leftarrowtail: "↢",
                          LeftCeiling: "⌈",
                          LeftDoubleBracket: "⟦",
                          LeftDownTeeVector: "⥡",
                          LeftDownVector: "⇃",
                          LeftDownVectorBar: "⥙",
                          LeftFloor: "⌊",
                          leftharpoondown: "↽",
                          leftharpoonup: "↼",
                          leftleftarrows: "⇇",
                          leftrightarrow: "↔",
                          Leftrightarrow: "⇔",
                          LeftRightArrow: "↔",
                          leftrightarrows: "⇆",
                          leftrightharpoons: "⇋",
                          leftrightsquigarrow: "↭",
                          LeftRightVector: "⥎",
                          LeftTee: "⊣",
                          LeftTeeArrow: "↤",
                          LeftTeeVector: "⥚",
                          leftthreetimes: "⋋",
                          LeftTriangle: "⊲",
                          LeftTriangleBar: "⧏",
                          LeftTriangleEqual: "⊴",
                          LeftUpDownVector: "⥑",
                          LeftUpTeeVector: "⥠",
                          LeftUpVector: "↿",
                          LeftUpVectorBar: "⥘",
                          LeftVector: "↼",
                          LeftVectorBar: "⥒",
                          leg: "⋚",
                          lEg: "⪋",
                          leq: "≤",
                          leqq: "≦",
                          leqslant: "⩽",
                          les: "⩽",
                          lescc: "⪨",
                          lesdot: "⩿",
                          lesdoto: "⪁",
                          lesdotor: "⪃",
                          lesg: "⋚︀",
                          lesges: "⪓",
                          lessapprox: "⪅",
                          lessdot: "⋖",
                          lesseqgtr: "⋚",
                          lesseqqgtr: "⪋",
                          LessEqualGreater: "⋚",
                          LessFullEqual: "≦",
                          LessGreater: "≶",
                          lessgtr: "≶",
                          LessLess: "⪡",
                          lesssim: "≲",
                          LessSlantEqual: "⩽",
                          LessTilde: "≲",
                          lfisht: "⥼",
                          lfloor: "⌊",
                          lfr: "𝔩",
                          Lfr: "𝔏",
                          lg: "≶",
                          lgE: "⪑",
                          lHar: "⥢",
                          lhard: "↽",
                          lharu: "↼",
                          lharul: "⥪",
                          lhblk: "▄",
                          ljcy: "љ",
                          LJcy: "Љ",
                          ll: "≪",
                          Ll: "⋘",
                          llarr: "⇇",
                          llcorner: "⌞",
                          Lleftarrow: "⇚",
                          llhard: "⥫",
                          lltri: "◺",
                          lmidot: "ŀ",
                          Lmidot: "Ŀ",
                          lmoust: "⎰",
                          lmoustache: "⎰",
                          lnap: "⪉",
                          lnapprox: "⪉",
                          lne: "⪇",
                          lnE: "≨",
                          lneq: "⪇",
                          lneqq: "≨",
                          lnsim: "⋦",
                          loang: "⟬",
                          loarr: "⇽",
                          lobrk: "⟦",
                          longleftarrow: "⟵",
                          Longleftarrow: "⟸",
                          LongLeftArrow: "⟵",
                          longleftrightarrow: "⟷",
                          Longleftrightarrow: "⟺",
                          LongLeftRightArrow: "⟷",
                          longmapsto: "⟼",
                          longrightarrow: "⟶",
                          Longrightarrow: "⟹",
                          LongRightArrow: "⟶",
                          looparrowleft: "↫",
                          looparrowright: "↬",
                          lopar: "⦅",
                          lopf: "𝕝",
                          Lopf: "𝕃",
                          loplus: "⨭",
                          lotimes: "⨴",
                          lowast: "∗",
                          lowbar: "_",
                          LowerLeftArrow: "↙",
                          LowerRightArrow: "↘",
                          loz: "◊",
                          lozenge: "◊",
                          lozf: "⧫",
                          lpar: "(",
                          lparlt: "⦓",
                          lrarr: "⇆",
                          lrcorner: "⌟",
                          lrhar: "⇋",
                          lrhard: "⥭",
                          lrm: "‎",
                          lrtri: "⊿",
                          lsaquo: "‹",
                          lscr: "𝓁",
                          Lscr: "ℒ",
                          lsh: "↰",
                          Lsh: "↰",
                          lsim: "≲",
                          lsime: "⪍",
                          lsimg: "⪏",
                          lsqb: "[",
                          lsquo: "‘",
                          lsquor: "‚",
                          lstrok: "ł",
                          Lstrok: "Ł",
                          lt: "<",
                          Lt: "≪",
                          LT: "<",
                          ltcc: "⪦",
                          ltcir: "⩹",
                          ltdot: "⋖",
                          lthree: "⋋",
                          ltimes: "⋉",
                          ltlarr: "⥶",
                          ltquest: "⩻",
                          ltri: "◃",
                          ltrie: "⊴",
                          ltrif: "◂",
                          ltrPar: "⦖",
                          lurdshar: "⥊",
                          luruhar: "⥦",
                          lvertneqq: "≨︀",
                          lvnE: "≨︀",
                          macr: "¯",
                          male: "♂",
                          malt: "✠",
                          maltese: "✠",
                          map: "↦",
                          Map: "⤅",
                          mapsto: "↦",
                          mapstodown: "↧",
                          mapstoleft: "↤",
                          mapstoup: "↥",
                          marker: "▮",
                          mcomma: "⨩",
                          mcy: "м",
                          Mcy: "М",
                          mdash: "—",
                          mDDot: "∺",
                          measuredangle: "∡",
                          MediumSpace: " ",
                          Mellintrf: "ℳ",
                          mfr: "𝔪",
                          Mfr: "𝔐",
                          mho: "℧",
                          micro: "µ",
                          mid: "∣",
                          midast: "*",
                          midcir: "⫰",
                          middot: "·",
                          minus: "−",
                          minusb: "⊟",
                          minusd: "∸",
                          minusdu: "⨪",
                          MinusPlus: "∓",
                          mlcp: "⫛",
                          mldr: "…",
                          mnplus: "∓",
                          models: "⊧",
                          mopf: "𝕞",
                          Mopf: "𝕄",
                          mp: "∓",
                          mscr: "𝓂",
                          Mscr: "ℳ",
                          mstpos: "∾",
                          mu: "μ",
                          Mu: "Μ",
                          multimap: "⊸",
                          mumap: "⊸",
                          nabla: "∇",
                          nacute: "ń",
                          Nacute: "Ń",
                          nang: "∠⃒",
                          nap: "≉",
                          napE: "⩰̸",
                          napid: "≋̸",
                          napos: "ŉ",
                          napprox: "≉",
                          natur: "♮",
                          natural: "♮",
                          naturals: "ℕ",
                          nbsp: " ",
                          nbump: "≎̸",
                          nbumpe: "≏̸",
                          ncap: "⩃",
                          ncaron: "ň",
                          Ncaron: "Ň",
                          ncedil: "ņ",
                          Ncedil: "Ņ",
                          ncong: "≇",
                          ncongdot: "⩭̸",
                          ncup: "⩂",
                          ncy: "н",
                          Ncy: "Н",
                          ndash: "–",
                          ne: "≠",
                          nearhk: "⤤",
                          nearr: "↗",
                          neArr: "⇗",
                          nearrow: "↗",
                          nedot: "≐̸",
                          NegativeMediumSpace: "​",
                          NegativeThickSpace: "​",
                          NegativeThinSpace: "​",
                          NegativeVeryThinSpace: "​",
                          nequiv: "≢",
                          nesear: "⤨",
                          nesim: "≂̸",
                          NestedGreaterGreater: "≫",
                          NestedLessLess: "≪",
                          NewLine: "\n",
                          nexist: "∄",
                          nexists: "∄",
                          nfr: "𝔫",
                          Nfr: "𝔑",
                          nge: "≱",
                          ngE: "≧̸",
                          ngeq: "≱",
                          ngeqq: "≧̸",
                          ngeqslant: "⩾̸",
                          nges: "⩾̸",
                          nGg: "⋙̸",
                          ngsim: "≵",
                          ngt: "≯",
                          nGt: "≫⃒",
                          ngtr: "≯",
                          nGtv: "≫̸",
                          nharr: "↮",
                          nhArr: "⇎",
                          nhpar: "⫲",
                          ni: "∋",
                          nis: "⋼",
                          nisd: "⋺",
                          niv: "∋",
                          njcy: "њ",
                          NJcy: "Њ",
                          nlarr: "↚",
                          nlArr: "⇍",
                          nldr: "‥",
                          nle: "≰",
                          nlE: "≦̸",
                          nleftarrow: "↚",
                          nLeftarrow: "⇍",
                          nleftrightarrow: "↮",
                          nLeftrightarrow: "⇎",
                          nleq: "≰",
                          nleqq: "≦̸",
                          nleqslant: "⩽̸",
                          nles: "⩽̸",
                          nless: "≮",
                          nLl: "⋘̸",
                          nlsim: "≴",
                          nlt: "≮",
                          nLt: "≪⃒",
                          nltri: "⋪",
                          nltrie: "⋬",
                          nLtv: "≪̸",
                          nmid: "∤",
                          NoBreak: "⁠",
                          NonBreakingSpace: " ",
                          nopf: "𝕟",
                          Nopf: "ℕ",
                          not: "¬",
                          Not: "⫬",
                          NotCongruent: "≢",
                          NotCupCap: "≭",
                          NotDoubleVerticalBar: "∦",
                          NotElement: "∉",
                          NotEqual: "≠",
                          NotEqualTilde: "≂̸",
                          NotExists: "∄",
                          NotGreater: "≯",
                          NotGreaterEqual: "≱",
                          NotGreaterFullEqual: "≧̸",
                          NotGreaterGreater: "≫̸",
                          NotGreaterLess: "≹",
                          NotGreaterSlantEqual: "⩾̸",
                          NotGreaterTilde: "≵",
                          NotHumpDownHump: "≎̸",
                          NotHumpEqual: "≏̸",
                          notin: "∉",
                          notindot: "⋵̸",
                          notinE: "⋹̸",
                          notinva: "∉",
                          notinvb: "⋷",
                          notinvc: "⋶",
                          NotLeftTriangle: "⋪",
                          NotLeftTriangleBar: "⧏̸",
                          NotLeftTriangleEqual: "⋬",
                          NotLess: "≮",
                          NotLessEqual: "≰",
                          NotLessGreater: "≸",
                          NotLessLess: "≪̸",
                          NotLessSlantEqual: "⩽̸",
                          NotLessTilde: "≴",
                          NotNestedGreaterGreater: "⪢̸",
                          NotNestedLessLess: "⪡̸",
                          notni: "∌",
                          notniva: "∌",
                          notnivb: "⋾",
                          notnivc: "⋽",
                          NotPrecedes: "⊀",
                          NotPrecedesEqual: "⪯̸",
                          NotPrecedesSlantEqual: "⋠",
                          NotReverseElement: "∌",
                          NotRightTriangle: "⋫",
                          NotRightTriangleBar: "⧐̸",
                          NotRightTriangleEqual: "⋭",
                          NotSquareSubset: "⊏̸",
                          NotSquareSubsetEqual: "⋢",
                          NotSquareSuperset: "⊐̸",
                          NotSquareSupersetEqual: "⋣",
                          NotSubset: "⊂⃒",
                          NotSubsetEqual: "⊈",
                          NotSucceeds: "⊁",
                          NotSucceedsEqual: "⪰̸",
                          NotSucceedsSlantEqual: "⋡",
                          NotSucceedsTilde: "≿̸",
                          NotSuperset: "⊃⃒",
                          NotSupersetEqual: "⊉",
                          NotTilde: "≁",
                          NotTildeEqual: "≄",
                          NotTildeFullEqual: "≇",
                          NotTildeTilde: "≉",
                          NotVerticalBar: "∤",
                          npar: "∦",
                          nparallel: "∦",
                          nparsl: "⫽⃥",
                          npart: "∂̸",
                          npolint: "⨔",
                          npr: "⊀",
                          nprcue: "⋠",
                          npre: "⪯̸",
                          nprec: "⊀",
                          npreceq: "⪯̸",
                          nrarr: "↛",
                          nrArr: "⇏",
                          nrarrc: "⤳̸",
                          nrarrw: "↝̸",
                          nrightarrow: "↛",
                          nRightarrow: "⇏",
                          nrtri: "⋫",
                          nrtrie: "⋭",
                          nsc: "⊁",
                          nsccue: "⋡",
                          nsce: "⪰̸",
                          nscr: "𝓃",
                          Nscr: "𝒩",
                          nshortmid: "∤",
                          nshortparallel: "∦",
                          nsim: "≁",
                          nsime: "≄",
                          nsimeq: "≄",
                          nsmid: "∤",
                          nspar: "∦",
                          nsqsube: "⋢",
                          nsqsupe: "⋣",
                          nsub: "⊄",
                          nsube: "⊈",
                          nsubE: "⫅̸",
                          nsubset: "⊂⃒",
                          nsubseteq: "⊈",
                          nsubseteqq: "⫅̸",
                          nsucc: "⊁",
                          nsucceq: "⪰̸",
                          nsup: "⊅",
                          nsupe: "⊉",
                          nsupE: "⫆̸",
                          nsupset: "⊃⃒",
                          nsupseteq: "⊉",
                          nsupseteqq: "⫆̸",
                          ntgl: "≹",
                          ntilde: "ñ",
                          Ntilde: "Ñ",
                          ntlg: "≸",
                          ntriangleleft: "⋪",
                          ntrianglelefteq: "⋬",
                          ntriangleright: "⋫",
                          ntrianglerighteq: "⋭",
                          nu: "ν",
                          Nu: "Ν",
                          num: "#",
                          numero: "№",
                          numsp: " ",
                          nvap: "≍⃒",
                          nvdash: "⊬",
                          nvDash: "⊭",
                          nVdash: "⊮",
                          nVDash: "⊯",
                          nvge: "≥⃒",
                          nvgt: ">⃒",
                          nvHarr: "⤄",
                          nvinfin: "⧞",
                          nvlArr: "⤂",
                          nvle: "≤⃒",
                          nvlt: "<⃒",
                          nvltrie: "⊴⃒",
                          nvrArr: "⤃",
                          nvrtrie: "⊵⃒",
                          nvsim: "∼⃒",
                          nwarhk: "⤣",
                          nwarr: "↖",
                          nwArr: "⇖",
                          nwarrow: "↖",
                          nwnear: "⤧",
                          oacute: "ó",
                          Oacute: "Ó",
                          oast: "⊛",
                          ocir: "⊚",
                          ocirc: "ô",
                          Ocirc: "Ô",
                          ocy: "о",
                          Ocy: "О",
                          odash: "⊝",
                          odblac: "ő",
                          Odblac: "Ő",
                          odiv: "⨸",
                          odot: "⊙",
                          odsold: "⦼",
                          oelig: "œ",
                          OElig: "Œ",
                          ofcir: "⦿",
                          ofr: "𝔬",
                          Ofr: "𝔒",
                          ogon: "˛",
                          ograve: "ò",
                          Ograve: "Ò",
                          ogt: "⧁",
                          ohbar: "⦵",
                          ohm: "Ω",
                          oint: "∮",
                          olarr: "↺",
                          olcir: "⦾",
                          olcross: "⦻",
                          oline: "‾",
                          olt: "⧀",
                          omacr: "ō",
                          Omacr: "Ō",
                          omega: "ω",
                          Omega: "Ω",
                          omicron: "ο",
                          Omicron: "Ο",
                          omid: "⦶",
                          ominus: "⊖",
                          oopf: "𝕠",
                          Oopf: "𝕆",
                          opar: "⦷",
                          OpenCurlyDoubleQuote: "“",
                          OpenCurlyQuote: "‘",
                          operp: "⦹",
                          oplus: "⊕",
                          or: "∨",
                          Or: "⩔",
                          orarr: "↻",
                          ord: "⩝",
                          order: "ℴ",
                          orderof: "ℴ",
                          ordf: "ª",
                          ordm: "º",
                          origof: "⊶",
                          oror: "⩖",
                          orslope: "⩗",
                          orv: "⩛",
                          oS: "Ⓢ",
                          oscr: "ℴ",
                          Oscr: "𝒪",
                          oslash: "ø",
                          Oslash: "Ø",
                          osol: "⊘",
                          otilde: "õ",
                          Otilde: "Õ",
                          otimes: "⊗",
                          Otimes: "⨷",
                          otimesas: "⨶",
                          ouml: "ö",
                          Ouml: "Ö",
                          ovbar: "⌽",
                          OverBar: "‾",
                          OverBrace: "⏞",
                          OverBracket: "⎴",
                          OverParenthesis: "⏜",
                          par: "∥",
                          para: "¶",
                          parallel: "∥",
                          parsim: "⫳",
                          parsl: "⫽",
                          part: "∂",
                          PartialD: "∂",
                          pcy: "п",
                          Pcy: "П",
                          percnt: "%",
                          period: ".",
                          permil: "‰",
                          perp: "⊥",
                          pertenk: "‱",
                          pfr: "𝔭",
                          Pfr: "𝔓",
                          phi: "φ",
                          Phi: "Φ",
                          phiv: "ϕ",
                          phmmat: "ℳ",
                          phone: "☎",
                          pi: "π",
                          Pi: "Π",
                          pitchfork: "⋔",
                          piv: "ϖ",
                          planck: "ℏ",
                          planckh: "ℎ",
                          plankv: "ℏ",
                          plus: "+",
                          plusacir: "⨣",
                          plusb: "⊞",
                          pluscir: "⨢",
                          plusdo: "∔",
                          plusdu: "⨥",
                          pluse: "⩲",
                          PlusMinus: "±",
                          plusmn: "±",
                          plussim: "⨦",
                          plustwo: "⨧",
                          pm: "±",
                          Poincareplane: "ℌ",
                          pointint: "⨕",
                          popf: "𝕡",
                          Popf: "ℙ",
                          pound: "£",
                          pr: "≺",
                          Pr: "⪻",
                          prap: "⪷",
                          prcue: "≼",
                          pre: "⪯",
                          prE: "⪳",
                          prec: "≺",
                          precapprox: "⪷",
                          preccurlyeq: "≼",
                          Precedes: "≺",
                          PrecedesEqual: "⪯",
                          PrecedesSlantEqual: "≼",
                          PrecedesTilde: "≾",
                          preceq: "⪯",
                          precnapprox: "⪹",
                          precneqq: "⪵",
                          precnsim: "⋨",
                          precsim: "≾",
                          prime: "′",
                          Prime: "″",
                          primes: "ℙ",
                          prnap: "⪹",
                          prnE: "⪵",
                          prnsim: "⋨",
                          prod: "∏",
                          Product: "∏",
                          profalar: "⌮",
                          profline: "⌒",
                          profsurf: "⌓",
                          prop: "∝",
                          Proportion: "∷",
                          Proportional: "∝",
                          propto: "∝",
                          prsim: "≾",
                          prurel: "⊰",
                          pscr: "𝓅",
                          Pscr: "𝒫",
                          psi: "ψ",
                          Psi: "Ψ",
                          puncsp: " ",
                          qfr: "𝔮",
                          Qfr: "𝔔",
                          qint: "⨌",
                          qopf: "𝕢",
                          Qopf: "ℚ",
                          qprime: "⁗",
                          qscr: "𝓆",
                          Qscr: "𝒬",
                          quaternions: "ℍ",
                          quatint: "⨖",
                          quest: "?",
                          questeq: "≟",
                          quot: '"',
                          QUOT: '"',
                          rAarr: "⇛",
                          race: "∽̱",
                          racute: "ŕ",
                          Racute: "Ŕ",
                          radic: "√",
                          raemptyv: "⦳",
                          rang: "⟩",
                          Rang: "⟫",
                          rangd: "⦒",
                          range: "⦥",
                          rangle: "⟩",
                          raquo: "»",
                          rarr: "→",
                          rArr: "⇒",
                          Rarr: "↠",
                          rarrap: "⥵",
                          rarrb: "⇥",
                          rarrbfs: "⤠",
                          rarrc: "⤳",
                          rarrfs: "⤞",
                          rarrhk: "↪",
                          rarrlp: "↬",
                          rarrpl: "⥅",
                          rarrsim: "⥴",
                          rarrtl: "↣",
                          Rarrtl: "⤖",
                          rarrw: "↝",
                          ratail: "⤚",
                          rAtail: "⤜",
                          ratio: "∶",
                          rationals: "ℚ",
                          rbarr: "⤍",
                          rBarr: "⤏",
                          RBarr: "⤐",
                          rbbrk: "❳",
                          rbrace: "}",
                          rbrack: "]",
                          rbrke: "⦌",
                          rbrksld: "⦎",
                          rbrkslu: "⦐",
                          rcaron: "ř",
                          Rcaron: "Ř",
                          rcedil: "ŗ",
                          Rcedil: "Ŗ",
                          rceil: "⌉",
                          rcub: "}",
                          rcy: "р",
                          Rcy: "Р",
                          rdca: "⤷",
                          rdldhar: "⥩",
                          rdquo: "”",
                          rdquor: "”",
                          rdsh: "↳",
                          Re: "ℜ",
                          real: "ℜ",
                          realine: "ℛ",
                          realpart: "ℜ",
                          reals: "ℝ",
                          rect: "▭",
                          reg: "®",
                          REG: "®",
                          ReverseElement: "∋",
                          ReverseEquilibrium: "⇋",
                          ReverseUpEquilibrium: "⥯",
                          rfisht: "⥽",
                          rfloor: "⌋",
                          rfr: "𝔯",
                          Rfr: "ℜ",
                          rHar: "⥤",
                          rhard: "⇁",
                          rharu: "⇀",
                          rharul: "⥬",
                          rho: "ρ",
                          Rho: "Ρ",
                          rhov: "ϱ",
                          RightAngleBracket: "⟩",
                          rightarrow: "→",
                          Rightarrow: "⇒",
                          RightArrow: "→",
                          RightArrowBar: "⇥",
                          RightArrowLeftArrow: "⇄",
                          rightarrowtail: "↣",
                          RightCeiling: "⌉",
                          RightDoubleBracket: "⟧",
                          RightDownTeeVector: "⥝",
                          RightDownVector: "⇂",
                          RightDownVectorBar: "⥕",
                          RightFloor: "⌋",
                          rightharpoondown: "⇁",
                          rightharpoonup: "⇀",
                          rightleftarrows: "⇄",
                          rightleftharpoons: "⇌",
                          rightrightarrows: "⇉",
                          rightsquigarrow: "↝",
                          RightTee: "⊢",
                          RightTeeArrow: "↦",
                          RightTeeVector: "⥛",
                          rightthreetimes: "⋌",
                          RightTriangle: "⊳",
                          RightTriangleBar: "⧐",
                          RightTriangleEqual: "⊵",
                          RightUpDownVector: "⥏",
                          RightUpTeeVector: "⥜",
                          RightUpVector: "↾",
                          RightUpVectorBar: "⥔",
                          RightVector: "⇀",
                          RightVectorBar: "⥓",
                          ring: "˚",
                          risingdotseq: "≓",
                          rlarr: "⇄",
                          rlhar: "⇌",
                          rlm: "‏",
                          rmoust: "⎱",
                          rmoustache: "⎱",
                          rnmid: "⫮",
                          roang: "⟭",
                          roarr: "⇾",
                          robrk: "⟧",
                          ropar: "⦆",
                          ropf: "𝕣",
                          Ropf: "ℝ",
                          roplus: "⨮",
                          rotimes: "⨵",
                          RoundImplies: "⥰",
                          rpar: ")",
                          rpargt: "⦔",
                          rppolint: "⨒",
                          rrarr: "⇉",
                          Rrightarrow: "⇛",
                          rsaquo: "›",
                          rscr: "𝓇",
                          Rscr: "ℛ",
                          rsh: "↱",
                          Rsh: "↱",
                          rsqb: "]",
                          rsquo: "’",
                          rsquor: "’",
                          rthree: "⋌",
                          rtimes: "⋊",
                          rtri: "▹",
                          rtrie: "⊵",
                          rtrif: "▸",
                          rtriltri: "⧎",
                          RuleDelayed: "⧴",
                          ruluhar: "⥨",
                          rx: "℞",
                          sacute: "ś",
                          Sacute: "Ś",
                          sbquo: "‚",
                          sc: "≻",
                          Sc: "⪼",
                          scap: "⪸",
                          scaron: "š",
                          Scaron: "Š",
                          sccue: "≽",
                          sce: "⪰",
                          scE: "⪴",
                          scedil: "ş",
                          Scedil: "Ş",
                          scirc: "ŝ",
                          Scirc: "Ŝ",
                          scnap: "⪺",
                          scnE: "⪶",
                          scnsim: "⋩",
                          scpolint: "⨓",
                          scsim: "≿",
                          scy: "с",
                          Scy: "С",
                          sdot: "⋅",
                          sdotb: "⊡",
                          sdote: "⩦",
                          searhk: "⤥",
                          searr: "↘",
                          seArr: "⇘",
                          searrow: "↘",
                          sect: "§",
                          semi: ";",
                          seswar: "⤩",
                          setminus: "∖",
                          setmn: "∖",
                          sext: "✶",
                          sfr: "𝔰",
                          Sfr: "𝔖",
                          sfrown: "⌢",
                          sharp: "♯",
                          shchcy: "щ",
                          SHCHcy: "Щ",
                          shcy: "ш",
                          SHcy: "Ш",
                          ShortDownArrow: "↓",
                          ShortLeftArrow: "←",
                          shortmid: "∣",
                          shortparallel: "∥",
                          ShortRightArrow: "→",
                          ShortUpArrow: "↑",
                          shy: "­",
                          sigma: "σ",
                          Sigma: "Σ",
                          sigmaf: "ς",
                          sigmav: "ς",
                          sim: "∼",
                          simdot: "⩪",
                          sime: "≃",
                          simeq: "≃",
                          simg: "⪞",
                          simgE: "⪠",
                          siml: "⪝",
                          simlE: "⪟",
                          simne: "≆",
                          simplus: "⨤",
                          simrarr: "⥲",
                          slarr: "←",
                          SmallCircle: "∘",
                          smallsetminus: "∖",
                          smashp: "⨳",
                          smeparsl: "⧤",
                          smid: "∣",
                          smile: "⌣",
                          smt: "⪪",
                          smte: "⪬",
                          smtes: "⪬︀",
                          softcy: "ь",
                          SOFTcy: "Ь",
                          sol: "/",
                          solb: "⧄",
                          solbar: "⌿",
                          sopf: "𝕤",
                          Sopf: "𝕊",
                          spades: "♠",
                          spadesuit: "♠",
                          spar: "∥",
                          sqcap: "⊓",
                          sqcaps: "⊓︀",
                          sqcup: "⊔",
                          sqcups: "⊔︀",
                          Sqrt: "√",
                          sqsub: "⊏",
                          sqsube: "⊑",
                          sqsubset: "⊏",
                          sqsubseteq: "⊑",
                          sqsup: "⊐",
                          sqsupe: "⊒",
                          sqsupset: "⊐",
                          sqsupseteq: "⊒",
                          squ: "□",
                          square: "□",
                          Square: "□",
                          SquareIntersection: "⊓",
                          SquareSubset: "⊏",
                          SquareSubsetEqual: "⊑",
                          SquareSuperset: "⊐",
                          SquareSupersetEqual: "⊒",
                          SquareUnion: "⊔",
                          squarf: "▪",
                          squf: "▪",
                          srarr: "→",
                          sscr: "𝓈",
                          Sscr: "𝒮",
                          ssetmn: "∖",
                          ssmile: "⌣",
                          sstarf: "⋆",
                          star: "☆",
                          Star: "⋆",
                          starf: "★",
                          straightepsilon: "ϵ",
                          straightphi: "ϕ",
                          strns: "¯",
                          sub: "⊂",
                          Sub: "⋐",
                          subdot: "⪽",
                          sube: "⊆",
                          subE: "⫅",
                          subedot: "⫃",
                          submult: "⫁",
                          subne: "⊊",
                          subnE: "⫋",
                          subplus: "⪿",
                          subrarr: "⥹",
                          subset: "⊂",
                          Subset: "⋐",
                          subseteq: "⊆",
                          subseteqq: "⫅",
                          SubsetEqual: "⊆",
                          subsetneq: "⊊",
                          subsetneqq: "⫋",
                          subsim: "⫇",
                          subsub: "⫕",
                          subsup: "⫓",
                          succ: "≻",
                          succapprox: "⪸",
                          succcurlyeq: "≽",
                          Succeeds: "≻",
                          SucceedsEqual: "⪰",
                          SucceedsSlantEqual: "≽",
                          SucceedsTilde: "≿",
                          succeq: "⪰",
                          succnapprox: "⪺",
                          succneqq: "⪶",
                          succnsim: "⋩",
                          succsim: "≿",
                          SuchThat: "∋",
                          sum: "∑",
                          Sum: "∑",
                          sung: "♪",
                          sup: "⊃",
                          Sup: "⋑",
                          sup1: "¹",
                          sup2: "²",
                          sup3: "³",
                          supdot: "⪾",
                          supdsub: "⫘",
                          supe: "⊇",
                          supE: "⫆",
                          supedot: "⫄",
                          Superset: "⊃",
                          SupersetEqual: "⊇",
                          suphsol: "⟉",
                          suphsub: "⫗",
                          suplarr: "⥻",
                          supmult: "⫂",
                          supne: "⊋",
                          supnE: "⫌",
                          supplus: "⫀",
                          supset: "⊃",
                          Supset: "⋑",
                          supseteq: "⊇",
                          supseteqq: "⫆",
                          supsetneq: "⊋",
                          supsetneqq: "⫌",
                          supsim: "⫈",
                          supsub: "⫔",
                          supsup: "⫖",
                          swarhk: "⤦",
                          swarr: "↙",
                          swArr: "⇙",
                          swarrow: "↙",
                          swnwar: "⤪",
                          szlig: "ß",
                          Tab: "\t",
                          target: "⌖",
                          tau: "τ",
                          Tau: "Τ",
                          tbrk: "⎴",
                          tcaron: "ť",
                          Tcaron: "Ť",
                          tcedil: "ţ",
                          Tcedil: "Ţ",
                          tcy: "т",
                          Tcy: "Т",
                          tdot: "⃛",
                          telrec: "⌕",
                          tfr: "𝔱",
                          Tfr: "𝔗",
                          there4: "∴",
                          therefore: "∴",
                          Therefore: "∴",
                          theta: "θ",
                          Theta: "Θ",
                          thetasym: "ϑ",
                          thetav: "ϑ",
                          thickapprox: "≈",
                          thicksim: "∼",
                          ThickSpace: "  ",
                          thinsp: " ",
                          ThinSpace: " ",
                          thkap: "≈",
                          thksim: "∼",
                          thorn: "þ",
                          THORN: "Þ",
                          tilde: "˜",
                          Tilde: "∼",
                          TildeEqual: "≃",
                          TildeFullEqual: "≅",
                          TildeTilde: "≈",
                          times: "×",
                          timesb: "⊠",
                          timesbar: "⨱",
                          timesd: "⨰",
                          tint: "∭",
                          toea: "⤨",
                          top: "⊤",
                          topbot: "⌶",
                          topcir: "⫱",
                          topf: "𝕥",
                          Topf: "𝕋",
                          topfork: "⫚",
                          tosa: "⤩",
                          tprime: "‴",
                          trade: "™",
                          TRADE: "™",
                          triangle: "▵",
                          triangledown: "▿",
                          triangleleft: "◃",
                          trianglelefteq: "⊴",
                          triangleq: "≜",
                          triangleright: "▹",
                          trianglerighteq: "⊵",
                          tridot: "◬",
                          trie: "≜",
                          triminus: "⨺",
                          TripleDot: "⃛",
                          triplus: "⨹",
                          trisb: "⧍",
                          tritime: "⨻",
                          trpezium: "⏢",
                          tscr: "𝓉",
                          Tscr: "𝒯",
                          tscy: "ц",
                          TScy: "Ц",
                          tshcy: "ћ",
                          TSHcy: "Ћ",
                          tstrok: "ŧ",
                          Tstrok: "Ŧ",
                          twixt: "≬",
                          twoheadleftarrow: "↞",
                          twoheadrightarrow: "↠",
                          uacute: "ú",
                          Uacute: "Ú",
                          uarr: "↑",
                          uArr: "⇑",
                          Uarr: "↟",
                          Uarrocir: "⥉",
                          ubrcy: "ў",
                          Ubrcy: "Ў",
                          ubreve: "ŭ",
                          Ubreve: "Ŭ",
                          ucirc: "û",
                          Ucirc: "Û",
                          ucy: "у",
                          Ucy: "У",
                          udarr: "⇅",
                          udblac: "ű",
                          Udblac: "Ű",
                          udhar: "⥮",
                          ufisht: "⥾",
                          ufr: "𝔲",
                          Ufr: "𝔘",
                          ugrave: "ù",
                          Ugrave: "Ù",
                          uHar: "⥣",
                          uharl: "↿",
                          uharr: "↾",
                          uhblk: "▀",
                          ulcorn: "⌜",
                          ulcorner: "⌜",
                          ulcrop: "⌏",
                          ultri: "◸",
                          umacr: "ū",
                          Umacr: "Ū",
                          uml: "¨",
                          UnderBar: "_",
                          UnderBrace: "⏟",
                          UnderBracket: "⎵",
                          UnderParenthesis: "⏝",
                          Union: "⋃",
                          UnionPlus: "⊎",
                          uogon: "ų",
                          Uogon: "Ų",
                          uopf: "𝕦",
                          Uopf: "𝕌",
                          uparrow: "↑",
                          Uparrow: "⇑",
                          UpArrow: "↑",
                          UpArrowBar: "⤒",
                          UpArrowDownArrow: "⇅",
                          updownarrow: "↕",
                          Updownarrow: "⇕",
                          UpDownArrow: "↕",
                          UpEquilibrium: "⥮",
                          upharpoonleft: "↿",
                          upharpoonright: "↾",
                          uplus: "⊎",
                          UpperLeftArrow: "↖",
                          UpperRightArrow: "↗",
                          upsi: "υ",
                          Upsi: "ϒ",
                          upsih: "ϒ",
                          upsilon: "υ",
                          Upsilon: "Υ",
                          UpTee: "⊥",
                          UpTeeArrow: "↥",
                          upuparrows: "⇈",
                          urcorn: "⌝",
                          urcorner: "⌝",
                          urcrop: "⌎",
                          uring: "ů",
                          Uring: "Ů",
                          urtri: "◹",
                          uscr: "𝓊",
                          Uscr: "𝒰",
                          utdot: "⋰",
                          utilde: "ũ",
                          Utilde: "Ũ",
                          utri: "▵",
                          utrif: "▴",
                          uuarr: "⇈",
                          uuml: "ü",
                          Uuml: "Ü",
                          uwangle: "⦧",
                          vangrt: "⦜",
                          varepsilon: "ϵ",
                          varkappa: "ϰ",
                          varnothing: "∅",
                          varphi: "ϕ",
                          varpi: "ϖ",
                          varpropto: "∝",
                          varr: "↕",
                          vArr: "⇕",
                          varrho: "ϱ",
                          varsigma: "ς",
                          varsubsetneq: "⊊︀",
                          varsubsetneqq: "⫋︀",
                          varsupsetneq: "⊋︀",
                          varsupsetneqq: "⫌︀",
                          vartheta: "ϑ",
                          vartriangleleft: "⊲",
                          vartriangleright: "⊳",
                          vBar: "⫨",
                          Vbar: "⫫",
                          vBarv: "⫩",
                          vcy: "в",
                          Vcy: "В",
                          vdash: "⊢",
                          vDash: "⊨",
                          Vdash: "⊩",
                          VDash: "⊫",
                          Vdashl: "⫦",
                          vee: "∨",
                          Vee: "⋁",
                          veebar: "⊻",
                          veeeq: "≚",
                          vellip: "⋮",
                          verbar: "|",
                          Verbar: "‖",
                          vert: "|",
                          Vert: "‖",
                          VerticalBar: "∣",
                          VerticalLine: "|",
                          VerticalSeparator: "❘",
                          VerticalTilde: "≀",
                          VeryThinSpace: " ",
                          vfr: "𝔳",
                          Vfr: "𝔙",
                          vltri: "⊲",
                          vnsub: "⊂⃒",
                          vnsup: "⊃⃒",
                          vopf: "𝕧",
                          Vopf: "𝕍",
                          vprop: "∝",
                          vrtri: "⊳",
                          vscr: "𝓋",
                          Vscr: "𝒱",
                          vsubne: "⊊︀",
                          vsubnE: "⫋︀",
                          vsupne: "⊋︀",
                          vsupnE: "⫌︀",
                          Vvdash: "⊪",
                          vzigzag: "⦚",
                          wcirc: "ŵ",
                          Wcirc: "Ŵ",
                          wedbar: "⩟",
                          wedge: "∧",
                          Wedge: "⋀",
                          wedgeq: "≙",
                          weierp: "℘",
                          wfr: "𝔴",
                          Wfr: "𝔚",
                          wopf: "𝕨",
                          Wopf: "𝕎",
                          wp: "℘",
                          wr: "≀",
                          wreath: "≀",
                          wscr: "𝓌",
                          Wscr: "𝒲",
                          xcap: "⋂",
                          xcirc: "◯",
                          xcup: "⋃",
                          xdtri: "▽",
                          xfr: "𝔵",
                          Xfr: "𝔛",
                          xharr: "⟷",
                          xhArr: "⟺",
                          xi: "ξ",
                          Xi: "Ξ",
                          xlarr: "⟵",
                          xlArr: "⟸",
                          xmap: "⟼",
                          xnis: "⋻",
                          xodot: "⨀",
                          xopf: "𝕩",
                          Xopf: "𝕏",
                          xoplus: "⨁",
                          xotime: "⨂",
                          xrarr: "⟶",
                          xrArr: "⟹",
                          xscr: "𝓍",
                          Xscr: "𝒳",
                          xsqcup: "⨆",
                          xuplus: "⨄",
                          xutri: "△",
                          xvee: "⋁",
                          xwedge: "⋀",
                          yacute: "ý",
                          Yacute: "Ý",
                          yacy: "я",
                          YAcy: "Я",
                          ycirc: "ŷ",
                          Ycirc: "Ŷ",
                          ycy: "ы",
                          Ycy: "Ы",
                          yen: "¥",
                          yfr: "𝔶",
                          Yfr: "𝔜",
                          yicy: "ї",
                          YIcy: "Ї",
                          yopf: "𝕪",
                          Yopf: "𝕐",
                          yscr: "𝓎",
                          Yscr: "𝒴",
                          yucy: "ю",
                          YUcy: "Ю",
                          yuml: "ÿ",
                          Yuml: "Ÿ",
                          zacute: "ź",
                          Zacute: "Ź",
                          zcaron: "ž",
                          Zcaron: "Ž",
                          zcy: "з",
                          Zcy: "З",
                          zdot: "ż",
                          Zdot: "Ż",
                          zeetrf: "ℨ",
                          ZeroWidthSpace: "​",
                          zeta: "ζ",
                          Zeta: "Ζ",
                          zfr: "𝔷",
                          Zfr: "ℨ",
                          zhcy: "ж",
                          ZHcy: "Ж",
                          zigrarr: "⇝",
                          zopf: "𝕫",
                          Zopf: "ℤ",
                          zscr: "𝓏",
                          Zscr: "𝒵",
                          zwj: "‍",
                          zwnj: "‌"
                        },
                        g = {
                          aacute: "á",
                          Aacute: "Á",
                          acirc: "â",
                          Acirc: "Â",
                          acute: "´",
                          aelig: "æ",
                          AElig: "Æ",
                          agrave: "à",
                          Agrave: "À",
                          amp: "&",
                          AMP: "&",
                          aring: "å",
                          Aring: "Å",
                          atilde: "ã",
                          Atilde: "Ã",
                          auml: "ä",
                          Auml: "Ä",
                          brvbar: "¦",
                          ccedil: "ç",
                          Ccedil: "Ç",
                          cedil: "¸",
                          cent: "¢",
                          copy: "©",
                          COPY: "©",
                          curren: "¤",
                          deg: "°",
                          divide: "÷",
                          eacute: "é",
                          Eacute: "É",
                          ecirc: "ê",
                          Ecirc: "Ê",
                          egrave: "è",
                          Egrave: "È",
                          eth: "ð",
                          ETH: "Ð",
                          euml: "ë",
                          Euml: "Ë",
                          frac12: "½",
                          frac14: "¼",
                          frac34: "¾",
                          gt: ">",
                          GT: ">",
                          iacute: "í",
                          Iacute: "Í",
                          icirc: "î",
                          Icirc: "Î",
                          iexcl: "¡",
                          igrave: "ì",
                          Igrave: "Ì",
                          iquest: "¿",
                          iuml: "ï",
                          Iuml: "Ï",
                          laquo: "«",
                          lt: "<",
                          LT: "<",
                          macr: "¯",
                          micro: "µ",
                          middot: "·",
                          nbsp: " ",
                          not: "¬",
                          ntilde: "ñ",
                          Ntilde: "Ñ",
                          oacute: "ó",
                          Oacute: "Ó",
                          ocirc: "ô",
                          Ocirc: "Ô",
                          ograve: "ò",
                          Ograve: "Ò",
                          ordf: "ª",
                          ordm: "º",
                          oslash: "ø",
                          Oslash: "Ø",
                          otilde: "õ",
                          Otilde: "Õ",
                          ouml: "ö",
                          Ouml: "Ö",
                          para: "¶",
                          plusmn: "±",
                          pound: "£",
                          quot: '"',
                          QUOT: '"',
                          raquo: "»",
                          reg: "®",
                          REG: "®",
                          sect: "§",
                          shy: "­",
                          sup1: "¹",
                          sup2: "²",
                          sup3: "³",
                          szlig: "ß",
                          thorn: "þ",
                          THORN: "Þ",
                          times: "×",
                          uacute: "ú",
                          Uacute: "Ú",
                          ucirc: "û",
                          Ucirc: "Û",
                          ugrave: "ù",
                          Ugrave: "Ù",
                          uml: "¨",
                          uuml: "ü",
                          Uuml: "Ü",
                          yacute: "ý",
                          Yacute: "Ý",
                          yen: "¥",
                          yuml: "ÿ"
                        },
                        b = {
                          0: "�",
                          128: "€",
                          130: "‚",
                          131: "ƒ",
                          132: "„",
                          133: "…",
                          134: "†",
                          135: "‡",
                          136: "ˆ",
                          137: "‰",
                          138: "Š",
                          139: "‹",
                          140: "Œ",
                          142: "Ž",
                          145: "‘",
                          146: "’",
                          147: "“",
                          148: "”",
                          149: "•",
                          150: "–",
                          151: "—",
                          152: "˜",
                          153: "™",
                          154: "š",
                          155: "›",
                          156: "œ",
                          158: "ž",
                          159: "Ÿ"
                        },
                        v = [
                          1,
                          2,
                          3,
                          4,
                          5,
                          6,
                          7,
                          8,
                          11,
                          13,
                          14,
                          15,
                          16,
                          17,
                          18,
                          19,
                          20,
                          21,
                          22,
                          23,
                          24,
                          25,
                          26,
                          27,
                          28,
                          29,
                          30,
                          31,
                          127,
                          128,
                          129,
                          130,
                          131,
                          132,
                          133,
                          134,
                          135,
                          136,
                          137,
                          138,
                          139,
                          140,
                          141,
                          142,
                          143,
                          144,
                          145,
                          146,
                          147,
                          148,
                          149,
                          150,
                          151,
                          152,
                          153,
                          154,
                          155,
                          156,
                          157,
                          158,
                          159,
                          64976,
                          64977,
                          64978,
                          64979,
                          64980,
                          64981,
                          64982,
                          64983,
                          64984,
                          64985,
                          64986,
                          64987,
                          64988,
                          64989,
                          64990,
                          64991,
                          64992,
                          64993,
                          64994,
                          64995,
                          64996,
                          64997,
                          64998,
                          64999,
                          65e3,
                          65001,
                          65002,
                          65003,
                          65004,
                          65005,
                          65006,
                          65007,
                          65534,
                          65535,
                          131070,
                          131071,
                          196606,
                          196607,
                          262142,
                          262143,
                          327678,
                          327679,
                          393214,
                          393215,
                          458750,
                          458751,
                          524286,
                          524287,
                          589822,
                          589823,
                          655358,
                          655359,
                          720894,
                          720895,
                          786430,
                          786431,
                          851966,
                          851967,
                          917502,
                          917503,
                          983038,
                          983039,
                          1048574,
                          1048575,
                          1114110,
                          1114111
                        ],
                        E = String.fromCharCode,
                        T = {}.hasOwnProperty,
                        x = function(e, t) {
                          return T.call(e, t);
                        },
                        A = function(e, t) {
                          if (!e) return t;
                          var r,
                            n = {};
                          for (r in t) n[r] = x(e, r) ? e[r] : t[r];
                          return n;
                        },
                        S = function(e, t) {
                          var r = "";
                          return (e >= 55296 && e <= 57343) || e > 1114111
                            ? (t &&
                                C(
                                  "character reference outside the permissible Unicode range"
                                ),
                              "�")
                            : x(b, e)
                            ? (t && C("disallowed character reference"), b[e])
                            : (t &&
                                (function(e, t) {
                                  for (var r = -1, n = e.length; ++r < n; )
                                    if (e[r] == t) return !0;
                                  return !1;
                                })(v, e) &&
                                C("disallowed character reference"),
                              e > 65535 &&
                                ((r += E(
                                  (((e -= 65536) >>> 10) & 1023) | 55296
                                )),
                                (e = 56320 | (1023 & e))),
                              (r += E(e)));
                        },
                        D = function(e) {
                          return "&#x" + e.toString(16).toUpperCase() + ";";
                        },
                        P = function(e) {
                          return "&#" + e + ";";
                        },
                        C = function(e) {
                          throw Error("Parse error: " + e);
                        },
                        w = function(e, t) {
                          (t = A(t, w.options)).strict &&
                            f.test(e) &&
                            C("forbidden code point");
                          var r = t.encodeEverything,
                            n = t.useNamedReferences,
                            i = t.allowUnsafeSymbols,
                            s = t.decimal ? P : D,
                            d = function(e) {
                              return s(e.charCodeAt(0));
                            };
                          return (
                            r
                              ? ((e = e.replace(o, function(e) {
                                  return n && x(c, e) ? "&" + c[e] + ";" : d(e);
                                })),
                                n &&
                                  (e = e
                                    .replace(/&gt;\u20D2/g, "&nvgt;")
                                    .replace(/&lt;\u20D2/g, "&nvlt;")
                                    .replace(/&#x66;&#x6A;/g, "&fjlig;")),
                                n &&
                                  (e = e.replace(l, function(e) {
                                    return "&" + c[e] + ";";
                                  })))
                              : n
                              ? (i ||
                                  (e = e.replace(p, function(e) {
                                    return "&" + c[e] + ";";
                                  })),
                                (e = (e = e
                                  .replace(/&gt;\u20D2/g, "&nvgt;")
                                  .replace(/&lt;\u20D2/g, "&nvlt;")).replace(
                                  l,
                                  function(e) {
                                    return "&" + c[e] + ";";
                                  }
                                )))
                              : i || (e = e.replace(p, d)),
                            e
                              .replace(a, function(e) {
                                var t = e.charCodeAt(0),
                                  r = e.charCodeAt(1);
                                return s(
                                  1024 * (t - 55296) + r - 56320 + 65536
                                );
                              })
                              .replace(u, d)
                          );
                        };
                      w.options = {
                        allowUnsafeSymbols: !1,
                        encodeEverything: !1,
                        strict: !1,
                        useNamedReferences: !1,
                        decimal: !1
                      };
                      var F = function(e, t) {
                        var r = (t = A(t, F.options)).strict;
                        return (
                          r && h.test(e) && C("malformed character reference"),
                          e.replace(m, function(e, n, i, s, a, o, u, l, c) {
                            var p, d, h, f, m, b;
                            return n
                              ? y[(m = n)]
                              : i
                              ? ((m = i),
                                (b = s) && t.isAttributeValue
                                  ? (r &&
                                      "=" == b &&
                                      C(
                                        "`&` did not start a character reference"
                                      ),
                                    e)
                                  : (r &&
                                      C(
                                        "named character reference was not terminated by a semicolon"
                                      ),
                                    g[m] + (b || "")))
                              : a
                              ? ((h = a),
                                (d = o),
                                r &&
                                  !d &&
                                  C(
                                    "character reference was not terminated by a semicolon"
                                  ),
                                (p = parseInt(h, 10)),
                                S(p, r))
                              : u
                              ? ((f = u),
                                (d = l),
                                r &&
                                  !d &&
                                  C(
                                    "character reference was not terminated by a semicolon"
                                  ),
                                (p = parseInt(f, 16)),
                                S(p, r))
                              : (r &&
                                  C(
                                    "named character reference was not terminated by a semicolon"
                                  ),
                                e);
                          })
                        );
                      };
                      F.options = { isAttributeValue: !1, strict: !1 };
                      var _ = {
                        version: "1.2.0",
                        encode: w,
                        decode: F,
                        escape: function(e) {
                          return e.replace(p, function(e) {
                            return d[e];
                          });
                        },
                        unescape: F
                      };
                      if (n && !n.nodeType)
                        if (i) i.exports = _;
                        else for (var O in _) x(_, O) && (n[O] = _[O]);
                      else r.he = _;
                    })(dt);
                  })((ht = { exports: {} }), ht.exports),
                  ht.exports);
              function Tt(e, t, r) {
                var n = r || {},
                  i = n.number,
                  s = "$$v";
                n.trim && (s = "(typeof $$v === 'string'? $$v.trim(): $$v)"),
                  i && (s = "_n(" + s + ")");
                var a = xt(t, s);
                e.model = {
                  value: "(" + t + ")",
                  expression: JSON.stringify(t),
                  callback: "function ($$v) {" + a + "}"
                };
              }
              function xt(e, t) {
                var r = (function(e) {
                  if (
                    ((e = e.trim()),
                    (ft = e.length),
                    e.indexOf("[") < 0 || e.lastIndexOf("]") < ft - 1)
                  )
                    return (gt = e.lastIndexOf(".")) > -1
                      ? {
                          exp: e.slice(0, gt),
                          key: '"' + e.slice(gt + 1) + '"'
                        }
                      : { exp: e, key: null };
                  (mt = e), (gt = bt = vt = 0);
                  for (; !St(); )
                    Dt((yt = At())) ? Ct(yt) : 91 === yt && Pt(yt);
                  return { exp: e.slice(0, bt), key: e.slice(bt + 1, vt) };
                })(e);
                return null === r.key
                  ? e + "=" + t
                  : "$set(" + r.exp + ", " + r.key + ", " + t + ")";
              }
              function At() {
                return mt.charCodeAt(++gt);
              }
              function St() {
                return gt >= ft;
              }
              function Dt(e) {
                return 34 === e || 39 === e;
              }
              function Pt(e) {
                var t = 1;
                for (bt = gt; !St(); )
                  if (Dt((e = At()))) Ct(e);
                  else if ((91 === e && t++, 93 === e && t--, 0 === t)) {
                    vt = gt;
                    break;
                  }
              }
              function Ct(e) {
                for (var t = e; !St() && (e = At()) !== t; );
              }
              var wt,
                Ft,
                _t,
                Ot,
                kt,
                It,
                Nt,
                Lt,
                Bt,
                Mt = /^@|^v-on:/,
                jt = /^v-|^@|^:/,
                Rt = /([\s\S]*?)\s+(?:in|of)\s+([\s\S]*)/,
                qt = /,([^,\}\]]*)(?:,([^,\}\]]*))?$/,
                Vt = /^\(|\)$/g,
                Ut = /^\[.*\]$/,
                Kt = /:(.*)$/,
                Gt = /^:|^\.|^v-bind:/,
                Wt = /\.[^.\]]+(?=[^\]]*$)/g,
                Jt = /^v-slot(:|$)|^#/,
                Xt = /[\r\n]/,
                $t = /\s+/g,
                Ht = /[\s"'<>\/=]/,
                Yt = m(Et.decode),
                zt = "_empty_";
              function Qt(e, t, r) {
                return {
                  type: 1,
                  tag: e,
                  attrsList: t,
                  attrsMap: sr(t),
                  rawAttrsMap: {},
                  parent: r,
                  children: []
                };
              }
              function Zt(e, t) {
                (wt = t.warn || Ye),
                  (It = t.isPreTag || x),
                  (Nt = t.mustUseProp || x),
                  (Lt = t.getTagNamespace || x);
                var r = t.isReservedTag || x;
                (Bt = function(e) {
                  return !!e.component || !r(e.tag);
                }),
                  (_t = ze(t.modules, "transformNode")),
                  (Ot = ze(t.modules, "preTransformNode")),
                  (kt = ze(t.modules, "postTransformNode")),
                  (Ft = t.delimiters);
                var n,
                  i,
                  s = [],
                  a = !1 !== t.preserveWhitespace,
                  o = t.whitespace,
                  u = !1,
                  l = !1,
                  c = !1;
                function p(e, t) {
                  c || ((c = !0), wt(e, t));
                }
                function d(e) {
                  if (
                    (h(e),
                    u || e.processed || (e = er(e, t)),
                    s.length ||
                      e === n ||
                      (n.if && (e.elseif || e.else)
                        ? (f(e), rr(n, { exp: e.elseif, block: e }))
                        : p(
                            "Component template should contain exactly one root element. If you are using v-if on multiple elements, use v-else-if to chain them instead.",
                            { start: e.start }
                          )),
                    i && !e.forbidden)
                  )
                    if (e.elseif || e.else)
                      (a = e),
                        (o = (function(e) {
                          var t = e.length;
                          for (; t--; ) {
                            if (1 === e[t].type) return e[t];
                            " " !== e[t].text &&
                              wt(
                                'text "' +
                                  e[t].text.trim() +
                                  '" between v-if and v-else(-if) will be ignored.',
                                e[t]
                              ),
                              e.pop();
                          }
                        })(i.children)) && o.if
                          ? rr(o, { exp: a.elseif, block: a })
                          : wt(
                              "v-" +
                                (a.elseif
                                  ? 'else-if="' + a.elseif + '"'
                                  : "else") +
                                " used on element <" +
                                a.tag +
                                "> without corresponding v-if.",
                              a.rawAttrsMap[a.elseif ? "v-else-if" : "v-else"]
                            );
                    else {
                      if (e.slotScope) {
                        var r = e.slotTarget || '"default"';
                        (i.scopedSlots || (i.scopedSlots = {}))[r] = e;
                      }
                      i.children.push(e), (e.parent = i);
                    }
                  var a, o;
                  (e.children = e.children.filter(function(e) {
                    return !e.slotScope;
                  })),
                    h(e),
                    e.pre && (u = !1),
                    It(e.tag) && (l = !1);
                  for (var c = 0; c < kt.length; c++) kt[c](e, t);
                }
                function h(e) {
                  if (!l)
                    for (
                      var t;
                      (t = e.children[e.children.length - 1]) &&
                      3 === t.type &&
                      " " === t.text;

                    )
                      e.children.pop();
                }
                function f(e) {
                  ("slot" !== e.tag && "template" !== e.tag) ||
                    p(
                      "Cannot use <" +
                        e.tag +
                        "> as component root element because it may contain multiple nodes.",
                      { start: e.start }
                    ),
                    e.attrsMap.hasOwnProperty("v-for") &&
                      p(
                        "Cannot use v-for on stateful component root element because it renders multiple elements.",
                        e.rawAttrsMap["v-for"]
                      );
                }
                return (
                  W(e, {
                    warn: wt,
                    expectHTML: t.expectHTML,
                    isUnaryTag: t.isUnaryTag,
                    canBeLeftOpenTag: t.canBeLeftOpenTag,
                    shouldDecodeNewlines: t.shouldDecodeNewlines,
                    shouldDecodeNewlinesForHref: t.shouldDecodeNewlinesForHref,
                    shouldKeepComment: t.comments,
                    outputSourceRange: t.outputSourceRange,
                    start: function(e, r, a, o, c) {
                      var p = (i && i.ns) || Lt(e);
                      te &&
                        "svg" === p &&
                        (r = (function(e) {
                          for (var t = [], r = 0; r < e.length; r++) {
                            var n = e[r];
                            ar.test(n.name) ||
                              ((n.name = n.name.replace(or, "")), t.push(n));
                          }
                          return t;
                        })(r));
                      var h,
                        m = Qt(e, r, i);
                      p && (m.ns = p),
                        t.outputSourceRange &&
                          ((m.start = o),
                          (m.end = c),
                          (m.rawAttrsMap = m.attrsList.reduce(function(e, t) {
                            return (e[t.name] = t), e;
                          }, {}))),
                        r.forEach(function(e) {
                          Ht.test(e.name) &&
                            wt(
                              "Invalid dynamic argument expression: attribute names cannot contain spaces, quotes, <, >, / or =.",
                              {
                                start: e.start + e.name.indexOf("["),
                                end: e.start + e.name.length
                              }
                            );
                        }),
                        ("style" !== (h = m).tag &&
                          ("script" !== h.tag ||
                            (h.attrsMap.type &&
                              "text/javascript" !== h.attrsMap.type))) ||
                          se() ||
                          ((m.forbidden = !0),
                          wt(
                            "Templates should only be responsible for mapping the state to the UI. Avoid placing tags with side-effects in your templates, such as <" +
                              e +
                              ">, as they will not be parsed.",
                            { start: m.start }
                          ));
                      for (var y = 0; y < Ot.length; y++) m = Ot[y](m, t) || m;
                      u ||
                        (!(function(e) {
                          null != at(e, "v-pre") && (e.pre = !0);
                        })(m),
                        m.pre && (u = !0)),
                        It(m.tag) && (l = !0),
                        u
                          ? (function(e) {
                              var t = e.attrsList,
                                r = t.length;
                              if (r)
                                for (
                                  var n = (e.attrs = new Array(r)), i = 0;
                                  i < r;
                                  i++
                                )
                                  (n[i] = {
                                    name: t[i].name,
                                    value: JSON.stringify(t[i].value)
                                  }),
                                    null != t[i].start &&
                                      ((n[i].start = t[i].start),
                                      (n[i].end = t[i].end));
                              else e.pre || (e.plain = !0);
                            })(m)
                          : m.processed ||
                            (tr(m),
                            (function(e) {
                              var t = at(e, "v-if");
                              if (t) (e.if = t), rr(e, { exp: t, block: e });
                              else {
                                null != at(e, "v-else") && (e.else = !0);
                                var r = at(e, "v-else-if");
                                r && (e.elseif = r);
                              }
                            })(m),
                            (function(e) {
                              null != at(e, "v-once") && (e.once = !0);
                            })(m)),
                        n || f((n = m)),
                        a ? d(m) : ((i = m), s.push(m));
                    },
                    end: function(e, r, n) {
                      var a = s[s.length - 1];
                      (s.length -= 1),
                        (i = s[s.length - 1]),
                        t.outputSourceRange && (a.end = n),
                        d(a);
                    },
                    chars: function(r, n, s) {
                      if (i) {
                        if (
                          !te ||
                          "textarea" !== i.tag ||
                          i.attrsMap.placeholder !== r
                        ) {
                          var c,
                            d,
                            h,
                            f = i.children;
                          if (
                            (r =
                              l || r.trim()
                                ? "script" === (c = i).tag || "style" === c.tag
                                  ? r
                                  : Yt(r)
                                : f.length
                                ? o
                                  ? "condense" === o && Xt.test(r)
                                    ? ""
                                    : " "
                                  : a
                                  ? " "
                                  : ""
                                : "")
                          )
                            l || "condense" !== o || (r = r.replace($t, " ")),
                              !u && " " !== r && (d = He(r, Ft))
                                ? (h = {
                                    type: 2,
                                    expression: d.expression,
                                    tokens: d.tokens,
                                    text: r
                                  })
                                : (" " === r &&
                                    f.length &&
                                    " " === f[f.length - 1].text) ||
                                  (h = { type: 3, text: r }),
                              h &&
                                (t.outputSourceRange &&
                                  ((h.start = n), (h.end = s)),
                                f.push(h));
                        }
                      } else
                        r === e
                          ? p(
                              "Component template requires a root element, rather than just text.",
                              { start: n }
                            )
                          : (r = r.trim()) &&
                            p(
                              'text "' +
                                r +
                                '" outside root element will be ignored.',
                              { start: n }
                            );
                    },
                    comment: function(e, r, n) {
                      if (i) {
                        var s = { type: 3, text: e, isComment: !0 };
                        t.outputSourceRange && ((s.start = r), (s.end = n)),
                          i.children.push(s);
                      }
                    }
                  }),
                  n
                );
              }
              function er(e, t) {
                var r, n;
                !(function(e) {
                  var t = st(e, "key");
                  if (t) {
                    if (
                      ("template" === e.tag &&
                        wt(
                          "<template> cannot be keyed. Place the key on real elements instead.",
                          it(e, "key")
                        ),
                      e.for)
                    ) {
                      var r = e.iterator2 || e.iterator1,
                        n = e.parent;
                      r &&
                        r === t &&
                        n &&
                        "transition-group" === n.tag &&
                        wt(
                          "Do not use v-for index as key on <transition-group> children, this is the same as not using keys.",
                          it(e, "key"),
                          !0
                        );
                    }
                    e.key = t;
                  }
                })(e),
                  (e.plain = !e.key && !e.scopedSlots && !e.attrsList.length),
                  (n = st((r = e), "ref")) &&
                    ((r.ref = n),
                    (r.refInFor = (function(e) {
                      for (var t = e; t; ) {
                        if (void 0 !== t.for) return !0;
                        t = t.parent;
                      }
                      return !1;
                    })(r))),
                  (function(e) {
                    var t;
                    "template" === e.tag
                      ? ((t = at(e, "scope")) &&
                          wt(
                            'the "scope" attribute for scoped slots have been deprecated and replaced by "slot-scope" since 2.5. The new "slot-scope" attribute can also be used on plain elements in addition to <template> to denote scoped slots.',
                            e.rawAttrsMap.scope,
                            !0
                          ),
                        (e.slotScope = t || at(e, "slot-scope")))
                      : (t = at(e, "slot-scope")) &&
                        (e.attrsMap["v-for"] &&
                          wt(
                            "Ambiguous combined usage of slot-scope and v-for on <" +
                              e.tag +
                              "> (v-for takes higher priority). Use a wrapper <template> for the scoped slot to make it clearer.",
                            e.rawAttrsMap["slot-scope"],
                            !0
                          ),
                        (e.slotScope = t));
                    var r = st(e, "slot");
                    r &&
                      ((e.slotTarget = '""' === r ? '"default"' : r),
                      (e.slotTargetDynamic = !(
                        !e.attrsMap[":slot"] && !e.attrsMap["v-bind:slot"]
                      )),
                      "template" === e.tag ||
                        e.slotScope ||
                        Ze(e, "slot", r, it(e, "slot")));
                    if ("template" === e.tag) {
                      var n = ot(e, Jt);
                      if (n) {
                        (e.slotTarget || e.slotScope) &&
                          wt(
                            "Unexpected mixed usage of different slot syntaxes.",
                            e
                          ),
                          e.parent &&
                            !Bt(e.parent) &&
                            wt(
                              "<template v-slot> can only appear at the root level inside the receiving the component",
                              e
                            );
                        var i = nr(n),
                          s = i.name,
                          a = i.dynamic;
                        (e.slotTarget = s),
                          (e.slotTargetDynamic = a),
                          (e.slotScope = n.value || zt);
                      }
                    } else {
                      var o = ot(e, Jt);
                      if (o) {
                        Bt(e) ||
                          wt(
                            "v-slot can only be used on components or <template>.",
                            o
                          ),
                          (e.slotScope || e.slotTarget) &&
                            wt(
                              "Unexpected mixed usage of different slot syntaxes.",
                              e
                            ),
                          e.scopedSlots &&
                            wt(
                              "To avoid scope ambiguity, the default slot should also use <template> syntax when there are other named slots.",
                              o
                            );
                        var u = e.scopedSlots || (e.scopedSlots = {}),
                          l = nr(o),
                          c = l.name,
                          p = l.dynamic,
                          d = (u[c] = Qt("template", [], e));
                        (d.slotTarget = c),
                          (d.slotTargetDynamic = p),
                          (d.children = e.children.filter(function(e) {
                            if (!e.slotScope) return (e.parent = d), !0;
                          })),
                          (d.slotScope = o.value || zt),
                          (e.children = []),
                          (e.plain = !1);
                      }
                    }
                  })(e),
                  (function(e) {
                    "slot" === e.tag &&
                      ((e.slotName = st(e, "name")),
                      e.key &&
                        wt(
                          "`key` does not work on <slot> because slots are abstract outlets and can possibly expand into multiple elements. Use the key on a wrapping element instead.",
                          it(e, "key")
                        ));
                  })(e),
                  (function(e) {
                    var t;
                    (t = st(e, "is")) && (e.component = t);
                    null != at(e, "inline-template") && (e.inlineTemplate = !0);
                  })(e);
                for (var i = 0; i < _t.length; i++) e = _t[i](e, t) || e;
                return (
                  (function(e) {
                    var t,
                      r,
                      n,
                      i,
                      s,
                      a,
                      o,
                      u,
                      l = e.attrsList;
                    for (t = 0, r = l.length; t < r; t++)
                      if (((n = i = l[t].name), (s = l[t].value), jt.test(n)))
                        if (
                          ((e.hasBindings = !0),
                          (a = ir(n.replace(jt, ""))) &&
                            (n = n.replace(Wt, "")),
                          Gt.test(n))
                        )
                          (n = n.replace(Gt, "")),
                            (s = Ge(s)),
                            (u = Ut.test(n)) && (n = n.slice(1, -1)),
                            0 === s.trim().length &&
                              wt(
                                'The value for a v-bind expression cannot be empty. Found in "v-bind:' +
                                  n +
                                  '"'
                              ),
                            a &&
                              (a.prop &&
                                !u &&
                                "innerHtml" === (n = g(n)) &&
                                (n = "innerHTML"),
                              a.camel && !u && (n = g(n)),
                              a.sync &&
                                ((o = xt(s, "$event")),
                                u
                                  ? nt(
                                      e,
                                      '"update:"+(' + n + ")",
                                      o,
                                      null,
                                      !1,
                                      wt,
                                      l[t],
                                      !0
                                    )
                                  : (nt(
                                      e,
                                      "update:" + g(n),
                                      o,
                                      null,
                                      !1,
                                      wt,
                                      l[t]
                                    ),
                                    v(n) !== g(n) &&
                                      nt(
                                        e,
                                        "update:" + v(n),
                                        o,
                                        null,
                                        !1,
                                        wt,
                                        l[t]
                                      )))),
                            (a && a.prop) ||
                            (!e.component && Nt(e.tag, e.attrsMap.type, n))
                              ? Qe(e, n, s, l[t], u)
                              : Ze(e, n, s, l[t], u);
                        else if (Mt.test(n))
                          (n = n.replace(Mt, "")),
                            (u = Ut.test(n)) && (n = n.slice(1, -1)),
                            nt(e, n, s, a, !1, wt, l[t], u);
                        else {
                          var c = (n = n.replace(jt, "")).match(Kt),
                            p = c && c[1];
                          (u = !1),
                            p &&
                              ((n = n.slice(0, -(p.length + 1))),
                              Ut.test(p) && ((p = p.slice(1, -1)), (u = !0))),
                            tt(e, n, i, s, p, u, a, l[t]),
                            "model" === n && ur(e, s);
                        }
                      else {
                        var d = He(s, Ft);
                        d &&
                          wt(
                            n +
                              '="' +
                              s +
                              '": Interpolation inside attributes has been removed. Use v-bind or the colon shorthand instead. For example, instead of <div id="{{ val }}">, use <div :id="val">.',
                            l[t]
                          ),
                          Ze(e, n, JSON.stringify(s), l[t]),
                          !e.component &&
                            "muted" === n &&
                            Nt(e.tag, e.attrsMap.type, n) &&
                            Qe(e, n, "true", l[t]);
                      }
                  })(e),
                  e
                );
              }
              function tr(e) {
                var t;
                if ((t = at(e, "v-for"))) {
                  var r = (function(e) {
                    var t = e.match(Rt);
                    if (!t) return;
                    var r = {};
                    r.for = t[2].trim();
                    var n = t[1].trim().replace(Vt, ""),
                      i = n.match(qt);
                    i
                      ? ((r.alias = n.replace(qt, "").trim()),
                        (r.iterator1 = i[1].trim()),
                        i[2] && (r.iterator2 = i[2].trim()))
                      : (r.alias = n);
                    return r;
                  })(t);
                  r
                    ? E(e, r)
                    : wt(
                        "Invalid v-for expression: " + t,
                        e.rawAttrsMap["v-for"]
                      );
                }
              }
              function rr(e, t) {
                e.ifConditions || (e.ifConditions = []), e.ifConditions.push(t);
              }
              function nr(e) {
                var t = e.name.replace(Jt, "");
                return (
                  t ||
                    ("#" !== e.name[0]
                      ? (t = "default")
                      : wt("v-slot shorthand syntax requires a slot name.", e)),
                  Ut.test(t)
                    ? { name: t.slice(1, -1), dynamic: !0 }
                    : { name: '"' + t + '"', dynamic: !1 }
                );
              }
              function ir(e) {
                var t = e.match(Wt);
                if (t) {
                  var r = {};
                  return (
                    t.forEach(function(e) {
                      r[e.slice(1)] = !0;
                    }),
                    r
                  );
                }
              }
              function sr(e) {
                for (var t = {}, r = 0, n = e.length; r < n; r++)
                  !t[e[r].name] ||
                    te ||
                    re ||
                    wt("duplicate attribute: " + e[r].name, e[r]),
                    (t[e[r].name] = e[r].value);
                return t;
              }
              var ar = /^xmlns:NS\d+/,
                or = /^NS\d+:/;
              function ur(e, t) {
                for (var r = e; r; )
                  r.for &&
                    r.alias === t &&
                    wt(
                      "<" +
                        e.tag +
                        ' v-model="' +
                        t +
                        '">: You are binding v-model directly to a v-for iteration alias. This will not be able to modify the v-for source array because writing to the alias is like modifying a function local variable. Consider using an array of objects and use v-model on an object property instead.',
                      e.rawAttrsMap["v-model"]
                    ),
                    (r = r.parent);
              }
              function lr(e) {
                return Qt(e.tag, e.attrsList.slice(), e.parent);
              }
              var cr,
                pr = [
                  lt,
                  pt,
                  {
                    preTransformNode: function(e, t) {
                      if ("input" === e.tag) {
                        var r,
                          n = e.attrsMap;
                        if (!n["v-model"]) return;
                        if (
                          ((n[":type"] || n["v-bind:type"]) &&
                            (r = st(e, "type")),
                          n.type ||
                            r ||
                            !n["v-bind"] ||
                            (r = "(" + n["v-bind"] + ").type"),
                          r)
                        ) {
                          var i = at(e, "v-if", !0),
                            s = i ? "&&(" + i + ")" : "",
                            a = null != at(e, "v-else", !0),
                            o = at(e, "v-else-if", !0),
                            u = lr(e);
                          tr(u),
                            et(u, "type", "checkbox"),
                            er(u, t),
                            (u.processed = !0),
                            (u.if = "(" + r + ")==='checkbox'" + s),
                            rr(u, { exp: u.if, block: u });
                          var l = lr(e);
                          at(l, "v-for", !0),
                            et(l, "type", "radio"),
                            er(l, t),
                            rr(u, {
                              exp: "(" + r + ")==='radio'" + s,
                              block: l
                            });
                          var c = lr(e);
                          return (
                            at(c, "v-for", !0),
                            et(c, ":type", r),
                            er(c, t),
                            rr(u, { exp: i, block: c }),
                            a ? (u.else = !0) : o && (u.elseif = o),
                            u
                          );
                        }
                      }
                    }
                  }
                ],
                dr = "__r";
              var hr,
                fr,
                mr = {
                  expectHTML: !0,
                  modules: pr,
                  directives: {
                    model: function(e, t, r) {
                      cr = r;
                      var n = t.value,
                        i = t.modifiers,
                        s = e.tag,
                        a = e.attrsMap.type;
                      if (
                        ("input" === s &&
                          "file" === a &&
                          cr(
                            "<" +
                              e.tag +
                              ' v-model="' +
                              n +
                              '" type="file">:\nFile inputs are read only. Use a v-on:change listener instead.',
                            e.rawAttrsMap["v-model"]
                          ),
                        e.component)
                      )
                        return Tt(e, n, i), !1;
                      if ("select" === s)
                        !(function(e, t, r) {
                          var n =
                            'var $$selectedVal = Array.prototype.filter.call($event.target.options,function(o){return o.selected}).map(function(o){var val = "_value" in o ? o._value : o.value;return ' +
                            (r && r.number ? "_n(val)" : "val") +
                            "});";
                          (n =
                            n +
                            " " +
                            xt(
                              t,
                              "$event.target.multiple ? $$selectedVal : $$selectedVal[0]"
                            )),
                            nt(e, "change", n, null, !0);
                        })(e, n, i);
                      else if ("input" === s && "checkbox" === a)
                        !(function(e, t, r) {
                          var n = r && r.number,
                            i = st(e, "value") || "null",
                            s = st(e, "true-value") || "true",
                            a = st(e, "false-value") || "false";
                          Qe(
                            e,
                            "checked",
                            "Array.isArray(" +
                              t +
                              ")?_i(" +
                              t +
                              "," +
                              i +
                              ")>-1" +
                              ("true" === s
                                ? ":(" + t + ")"
                                : ":_q(" + t + "," + s + ")")
                          ),
                            nt(
                              e,
                              "change",
                              "var $$a=" +
                                t +
                                ",$$el=$event.target,$$c=$$el.checked?(" +
                                s +
                                "):(" +
                                a +
                                ");if(Array.isArray($$a)){var $$v=" +
                                (n ? "_n(" + i + ")" : i) +
                                ",$$i=_i($$a,$$v);if($$el.checked){$$i<0&&(" +
                                xt(t, "$$a.concat([$$v])") +
                                ")}else{$$i>-1&&(" +
                                xt(
                                  t,
                                  "$$a.slice(0,$$i).concat($$a.slice($$i+1))"
                                ) +
                                ")}}else{" +
                                xt(t, "$$c") +
                                "}",
                              null,
                              !0
                            );
                        })(e, n, i);
                      else if ("input" === s && "radio" === a)
                        !(function(e, t, r) {
                          var n = r && r.number,
                            i = st(e, "value") || "null";
                          Qe(
                            e,
                            "checked",
                            "_q(" +
                              t +
                              "," +
                              (i = n ? "_n(" + i + ")" : i) +
                              ")"
                          ),
                            nt(e, "change", xt(t, i), null, !0);
                        })(e, n, i);
                      else {
                        if ("input" !== s && "textarea" !== s)
                          return Tt(e, n, i), !1;
                        !(function(e, t, r) {
                          var n = e.attrsMap.type,
                            i =
                              e.attrsMap["v-bind:value"] ||
                              e.attrsMap[":value"],
                            s =
                              e.attrsMap["v-bind:type"] || e.attrsMap[":type"];
                          if (i && !s) {
                            var a = e.attrsMap["v-bind:value"]
                              ? "v-bind:value"
                              : ":value";
                            cr(
                              a +
                                '="' +
                                i +
                                '" conflicts with v-model on the same element because the latter already expands to a value binding internally',
                              e.rawAttrsMap[a]
                            );
                          }
                          var o = r || {},
                            u = o.lazy,
                            l = o.number,
                            c = o.trim,
                            p = !u && "range" !== n,
                            d = u ? "change" : "range" === n ? dr : "input",
                            h = "$event.target.value";
                          c && (h = "$event.target.value.trim()"),
                            l && (h = "_n(" + h + ")");
                          var f = xt(t, h);
                          p && (f = "if($event.target.composing)return;" + f),
                            Qe(e, "value", "(" + t + ")"),
                            nt(e, d, f, null, !0),
                            (c || l) && nt(e, "blur", "$forceUpdate()");
                        })(e, n, i);
                      }
                      return !0;
                    },
                    text: function(e, t) {
                      t.value && Qe(e, "textContent", "_s(" + t.value + ")", t);
                    },
                    html: function(e, t) {
                      t.value && Qe(e, "innerHTML", "_s(" + t.value + ")", t);
                    }
                  },
                  isPreTag: function(e) {
                    return "pre" === e;
                  },
                  isUnaryTag: A,
                  mustUseProp: function(e, t, r) {
                    return (
                      ("value" === r && je(e) && "button" !== t) ||
                      ("selected" === r && "option" === e) ||
                      ("checked" === r && "input" === e) ||
                      ("muted" === r && "video" === e)
                    );
                  },
                  canBeLeftOpenTag: S,
                  isReservedTag: function(e) {
                    return Ve(e) || Ue(e);
                  },
                  getTagNamespace: function(e) {
                    return Ue(e) ? "svg" : "math" === e ? "math" : void 0;
                  },
                  staticKeys: (function(e) {
                    return e
                      .reduce(function(e, t) {
                        return e.concat(t.staticKeys || []);
                      }, [])
                      .join(",");
                  })(pr)
                },
                yr = m(function(e) {
                  return p(
                    "type,tag,attrsList,attrsMap,plain,parent,children,attrs,start,end,rawAttrsMap" +
                      (e ? "," + e : "")
                  );
                });
              function gr(e, t) {
                e &&
                  ((hr = yr(t.staticKeys || "")),
                  (fr = t.isReservedTag || x),
                  (function e(t) {
                    t.static = (function(e) {
                      if (2 === e.type) return !1;
                      if (3 === e.type) return !0;
                      return !(
                        !e.pre &&
                        (e.hasBindings ||
                          e.if ||
                          e.for ||
                          d(e.tag) ||
                          !fr(e.tag) ||
                          (function(e) {
                            for (; e.parent; ) {
                              if ("template" !== (e = e.parent).tag) return !1;
                              if (e.for) return !0;
                            }
                            return !1;
                          })(e) ||
                          !Object.keys(e).every(hr))
                      );
                    })(t);
                    if (1 === t.type) {
                      if (
                        !fr(t.tag) &&
                        "slot" !== t.tag &&
                        null == t.attrsMap["inline-template"]
                      )
                        return;
                      for (var r = 0, n = t.children.length; r < n; r++) {
                        var i = t.children[r];
                        e(i), i.static || (t.static = !1);
                      }
                      if (t.ifConditions)
                        for (var s = 1, a = t.ifConditions.length; s < a; s++) {
                          var o = t.ifConditions[s].block;
                          e(o), o.static || (t.static = !1);
                        }
                    }
                  })(e),
                  (function e(t, r) {
                    if (1 === t.type) {
                      if (
                        ((t.static || t.once) && (t.staticInFor = r),
                        t.static &&
                          t.children.length &&
                          (1 !== t.children.length || 3 !== t.children[0].type))
                      )
                        return void (t.staticRoot = !0);
                      if (((t.staticRoot = !1), t.children))
                        for (var n = 0, i = t.children.length; n < i; n++)
                          e(t.children[n], r || !!t.for);
                      if (t.ifConditions)
                        for (var s = 1, a = t.ifConditions.length; s < a; s++)
                          e(t.ifConditions[s].block, r);
                    }
                  })(e, !1));
              }
              var br = /^([\w$_]+|\([^)]*?\))\s*=>|^function\s*(?:[\w$]+)?\s*\(/,
                vr = /\([^)]*?\);*$/,
                Er = /^[A-Za-z_$][\w$]*(?:\.[A-Za-z_$][\w$]*|\['[^']*?']|\["[^"]*?"]|\[\d+]|\[[A-Za-z_$][\w$]*])*$/,
                Tr = {
                  esc: 27,
                  tab: 9,
                  enter: 13,
                  space: 32,
                  up: 38,
                  left: 37,
                  right: 39,
                  down: 40,
                  delete: [8, 46]
                },
                xr = {
                  esc: ["Esc", "Escape"],
                  tab: "Tab",
                  enter: "Enter",
                  space: [" ", "Spacebar"],
                  up: ["Up", "ArrowUp"],
                  left: ["Left", "ArrowLeft"],
                  right: ["Right", "ArrowRight"],
                  down: ["Down", "ArrowDown"],
                  delete: ["Backspace", "Delete", "Del"]
                },
                Ar = function(e) {
                  return "if(" + e + ")return null;";
                },
                Sr = {
                  stop: "$event.stopPropagation();",
                  prevent: "$event.preventDefault();",
                  self: Ar("$event.target !== $event.currentTarget"),
                  ctrl: Ar("!$event.ctrlKey"),
                  shift: Ar("!$event.shiftKey"),
                  alt: Ar("!$event.altKey"),
                  meta: Ar("!$event.metaKey"),
                  left: Ar("'button' in $event && $event.button !== 0"),
                  middle: Ar("'button' in $event && $event.button !== 1"),
                  right: Ar("'button' in $event && $event.button !== 2")
                };
              function Dr(e, t) {
                var r = t ? "nativeOn:" : "on:",
                  n = "",
                  i = "";
                for (var s in e) {
                  var a = Pr(e[s]);
                  e[s] && e[s].dynamic
                    ? (i += s + "," + a + ",")
                    : (n += '"' + s + '":' + a + ",");
                }
                return (
                  (n = "{" + n.slice(0, -1) + "}"),
                  i ? r + "_d(" + n + ",[" + i.slice(0, -1) + "])" : r + n
                );
              }
              function Pr(e) {
                if (!e) return "function(){}";
                if (Array.isArray(e))
                  return (
                    "[" +
                    e
                      .map(function(e) {
                        return Pr(e);
                      })
                      .join(",") +
                    "]"
                  );
                var t = Er.test(e.value),
                  r = br.test(e.value),
                  n = Er.test(e.value.replace(vr, ""));
                if (e.modifiers) {
                  var i = "",
                    s = "",
                    a = [];
                  for (var o in e.modifiers)
                    if (Sr[o]) (s += Sr[o]), Tr[o] && a.push(o);
                    else if ("exact" === o) {
                      var u = e.modifiers;
                      s += Ar(
                        ["ctrl", "shift", "alt", "meta"]
                          .filter(function(e) {
                            return !u[e];
                          })
                          .map(function(e) {
                            return "$event." + e + "Key";
                          })
                          .join("||")
                      );
                    } else a.push(o);
                  return (
                    a.length &&
                      (i += (function(e) {
                        return (
                          "if(!$event.type.indexOf('key')&&" +
                          e.map(Cr).join("&&") +
                          ")return null;"
                        );
                      })(a)),
                    s && (i += s),
                    "function($event){" +
                      i +
                      (t
                        ? "return " + e.value + "($event)"
                        : r
                        ? "return (" + e.value + ")($event)"
                        : n
                        ? "return " + e.value
                        : e.value) +
                      "}"
                  );
                }
                return t || r
                  ? e.value
                  : "function($event){" +
                      (n ? "return " + e.value : e.value) +
                      "}";
              }
              function Cr(e) {
                var t = parseInt(e, 10);
                if (t) return "$event.keyCode!==" + t;
                var r = Tr[e],
                  n = xr[e];
                return (
                  "_k($event.keyCode," +
                  JSON.stringify(e) +
                  "," +
                  JSON.stringify(r) +
                  ",$event.key," +
                  JSON.stringify(n) +
                  ")"
                );
              }
              var wr = {
                  on: function(e, t) {
                    t.modifiers &&
                      pe("v-on without argument does not support modifiers."),
                      (e.wrapListeners = function(e) {
                        return "_g(" + e + "," + t.value + ")";
                      });
                  },
                  bind: function(e, t) {
                    e.wrapData = function(r) {
                      return (
                        "_b(" +
                        r +
                        ",'" +
                        e.tag +
                        "'," +
                        t.value +
                        "," +
                        (t.modifiers && t.modifiers.prop ? "true" : "false") +
                        (t.modifiers && t.modifiers.sync ? ",true" : "") +
                        ")"
                      );
                    };
                  },
                  cloak: T
                },
                Fr = function(e) {
                  (this.options = e),
                    (this.warn = e.warn || Ye),
                    (this.transforms = ze(e.modules, "transformCode")),
                    (this.dataGenFns = ze(e.modules, "genData")),
                    (this.directives = E(E({}, wr), e.directives));
                  var t = e.isReservedTag || x;
                  (this.maybeComponent = function(e) {
                    return !!e.component || !t(e.tag);
                  }),
                    (this.onceId = 0),
                    (this.staticRenderFns = []),
                    (this.pre = !1);
                };
              function _r(e, t) {
                var r = new Fr(t);
                return {
                  render:
                    "with(this){return " + (e ? Or(e, r) : '_c("div")') + "}",
                  staticRenderFns: r.staticRenderFns
                };
              }
              function Or(e, t) {
                if (
                  (e.parent && (e.pre = e.pre || e.parent.pre),
                  e.staticRoot && !e.staticProcessed)
                )
                  return kr(e, t);
                if (e.once && !e.onceProcessed) return Ir(e, t);
                if (e.for && !e.forProcessed) return Lr(e, t);
                if (e.if && !e.ifProcessed) return Nr(e, t);
                if ("template" !== e.tag || e.slotTarget || t.pre) {
                  if ("slot" === e.tag)
                    return (function(e, t) {
                      var r = e.slotName || '"default"',
                        n = Rr(e, t),
                        i = "_t(" + r + (n ? "," + n : ""),
                        s =
                          e.attrs || e.dynamicAttrs
                            ? Kr(
                                (e.attrs || [])
                                  .concat(e.dynamicAttrs || [])
                                  .map(function(e) {
                                    return {
                                      name: g(e.name),
                                      value: e.value,
                                      dynamic: e.dynamic
                                    };
                                  })
                              )
                            : null,
                        a = e.attrsMap["v-bind"];
                      (!s && !a) || n || (i += ",null");
                      s && (i += "," + s);
                      a && (i += (s ? "" : ",null") + "," + a);
                      return i + ")";
                    })(e, t);
                  var r;
                  if (e.component)
                    r = (function(e, t, r) {
                      var n = t.inlineTemplate ? null : Rr(t, r, !0);
                      return (
                        "_c(" + e + "," + Br(t, r) + (n ? "," + n : "") + ")"
                      );
                    })(e.component, e, t);
                  else {
                    var n;
                    (!e.plain || (e.pre && t.maybeComponent(e))) &&
                      (n = Br(e, t));
                    var i = e.inlineTemplate ? null : Rr(e, t, !0);
                    r =
                      "_c('" +
                      e.tag +
                      "'" +
                      (n ? "," + n : "") +
                      (i ? "," + i : "") +
                      ")";
                  }
                  for (var s = 0; s < t.transforms.length; s++)
                    r = t.transforms[s](e, r);
                  return r;
                }
                return Rr(e, t) || "void 0";
              }
              function kr(e, t) {
                e.staticProcessed = !0;
                var r = t.pre;
                return (
                  e.pre && (t.pre = e.pre),
                  t.staticRenderFns.push("with(this){return " + Or(e, t) + "}"),
                  (t.pre = r),
                  "_m(" +
                    (t.staticRenderFns.length - 1) +
                    (e.staticInFor ? ",true" : "") +
                    ")"
                );
              }
              function Ir(e, t) {
                if (((e.onceProcessed = !0), e.if && !e.ifProcessed))
                  return Nr(e, t);
                if (e.staticInFor) {
                  for (var r = "", n = e.parent; n; ) {
                    if (n.for) {
                      r = n.key;
                      break;
                    }
                    n = n.parent;
                  }
                  return r
                    ? "_o(" + Or(e, t) + "," + t.onceId++ + "," + r + ")"
                    : (t.warn(
                        "v-once can only be used inside v-for that is keyed. ",
                        e.rawAttrsMap["v-once"]
                      ),
                      Or(e, t));
                }
                return kr(e, t);
              }
              function Nr(e, t, r, n) {
                return (
                  (e.ifProcessed = !0),
                  (function e(t, r, n, i) {
                    if (!t.length) return i || "_e()";
                    var s = t.shift();
                    return s.exp
                      ? "(" + s.exp + ")?" + a(s.block) + ":" + e(t, r, n, i)
                      : "" + a(s.block);
                    function a(e) {
                      return n ? n(e, r) : e.once ? Ir(e, r) : Or(e, r);
                    }
                  })(e.ifConditions.slice(), t, r, n)
                );
              }
              function Lr(e, t, r, n) {
                var i = e.for,
                  s = e.alias,
                  a = e.iterator1 ? "," + e.iterator1 : "",
                  o = e.iterator2 ? "," + e.iterator2 : "";
                return (
                  t.maybeComponent(e) &&
                    "slot" !== e.tag &&
                    "template" !== e.tag &&
                    !e.key &&
                    t.warn(
                      "<" +
                        e.tag +
                        ' v-for="' +
                        s +
                        " in " +
                        i +
                        '">: component lists rendered with v-for should have explicit keys. See https://vuejs.org/guide/list.html#key for more info.',
                      e.rawAttrsMap["v-for"],
                      !0
                    ),
                  (e.forProcessed = !0),
                  (n || "_l") +
                    "((" +
                    i +
                    "),function(" +
                    s +
                    a +
                    o +
                    "){return " +
                    (r || Or)(e, t) +
                    "})"
                );
              }
              function Br(e, t) {
                var r = "{",
                  n = (function(e, t) {
                    var r = e.directives;
                    if (!r) return;
                    var n,
                      i,
                      s,
                      a,
                      o = "directives:[",
                      u = !1;
                    for (n = 0, i = r.length; n < i; n++) {
                      (s = r[n]), (a = !0);
                      var l = t.directives[s.name];
                      l && (a = !!l(e, s, t.warn)),
                        a &&
                          ((u = !0),
                          (o +=
                            '{name:"' +
                            s.name +
                            '",rawName:"' +
                            s.rawName +
                            '"' +
                            (s.value
                              ? ",value:(" +
                                s.value +
                                "),expression:" +
                                JSON.stringify(s.value)
                              : "") +
                            (s.arg
                              ? ",arg:" +
                                (s.isDynamicArg ? s.arg : '"' + s.arg + '"')
                              : "") +
                            (s.modifiers
                              ? ",modifiers:" + JSON.stringify(s.modifiers)
                              : "") +
                            "},"));
                    }
                    if (u) return o.slice(0, -1) + "]";
                  })(e, t);
                n && (r += n + ","),
                  e.key && (r += "key:" + e.key + ","),
                  e.ref && (r += "ref:" + e.ref + ","),
                  e.refInFor && (r += "refInFor:true,"),
                  e.pre && (r += "pre:true,"),
                  e.component && (r += 'tag:"' + e.tag + '",');
                for (var i = 0; i < t.dataGenFns.length; i++)
                  r += t.dataGenFns[i](e);
                if (
                  (e.attrs && (r += "attrs:" + Kr(e.attrs) + ","),
                  e.props && (r += "domProps:" + Kr(e.props) + ","),
                  e.events && (r += Dr(e.events, !1) + ","),
                  e.nativeEvents && (r += Dr(e.nativeEvents, !0) + ","),
                  e.slotTarget &&
                    !e.slotScope &&
                    (r += "slot:" + e.slotTarget + ","),
                  e.scopedSlots &&
                    (r +=
                      (function(e, t, r) {
                        var n =
                            e.for ||
                            Object.keys(t).some(function(e) {
                              var r = t[e];
                              return (
                                r.slotTargetDynamic || r.if || r.for || Mr(r)
                              );
                            }),
                          i = !!e.if;
                        if (!n)
                          for (var s = e.parent; s; ) {
                            if ((s.slotScope && s.slotScope !== zt) || s.for) {
                              n = !0;
                              break;
                            }
                            s.if && (i = !0), (s = s.parent);
                          }
                        var a = Object.keys(t)
                          .map(function(e) {
                            return jr(t[e], r);
                          })
                          .join(",");
                        return (
                          "scopedSlots:_u([" +
                          a +
                          "]" +
                          (n ? ",null,true" : "") +
                          (!n && i
                            ? ",null,false," +
                              (function(e) {
                                var t = 5381,
                                  r = e.length;
                                for (; r; ) t = (33 * t) ^ e.charCodeAt(--r);
                                return t >>> 0;
                              })(a)
                            : "") +
                          ")"
                        );
                      })(e, e.scopedSlots, t) + ","),
                  e.model &&
                    (r +=
                      "model:{value:" +
                      e.model.value +
                      ",callback:" +
                      e.model.callback +
                      ",expression:" +
                      e.model.expression +
                      "},"),
                  e.inlineTemplate)
                ) {
                  var s = (function(e, t) {
                    var r = e.children[0];
                    (1 === e.children.length && 1 === r.type) ||
                      t.warn(
                        "Inline-template components must have exactly one child element.",
                        { start: e.start }
                      );
                    if (r && 1 === r.type) {
                      var n = _r(r, t.options);
                      return (
                        "inlineTemplate:{render:function(){" +
                        n.render +
                        "},staticRenderFns:[" +
                        n.staticRenderFns
                          .map(function(e) {
                            return "function(){" + e + "}";
                          })
                          .join(",") +
                        "]}"
                      );
                    }
                  })(e, t);
                  s && (r += s + ",");
                }
                return (
                  (r = r.replace(/,$/, "") + "}"),
                  e.dynamicAttrs &&
                    (r =
                      "_b(" +
                      r +
                      ',"' +
                      e.tag +
                      '",' +
                      Kr(e.dynamicAttrs) +
                      ")"),
                  e.wrapData && (r = e.wrapData(r)),
                  e.wrapListeners && (r = e.wrapListeners(r)),
                  r
                );
              }
              function Mr(e) {
                return (
                  1 === e.type && ("slot" === e.tag || e.children.some(Mr))
                );
              }
              function jr(e, t) {
                var r = e.attrsMap["slot-scope"];
                if (e.if && !e.ifProcessed && !r) return Nr(e, t, jr, "null");
                if (e.for && !e.forProcessed) return Lr(e, t, jr);
                var n = e.slotScope === zt ? "" : String(e.slotScope),
                  i =
                    "function(" +
                    n +
                    "){return " +
                    ("template" === e.tag
                      ? e.if && r
                        ? "(" +
                          e.if +
                          ")?" +
                          (Rr(e, t) || "undefined") +
                          ":undefined"
                        : Rr(e, t) || "undefined"
                      : Or(e, t)) +
                    "}",
                  s = n ? "" : ",proxy:true";
                return (
                  "{key:" + (e.slotTarget || '"default"') + ",fn:" + i + s + "}"
                );
              }
              function Rr(e, t, r, n, i) {
                var s = e.children;
                if (s.length) {
                  var a = s[0];
                  if (
                    1 === s.length &&
                    a.for &&
                    "template" !== a.tag &&
                    "slot" !== a.tag
                  ) {
                    var o = r ? (t.maybeComponent(a) ? ",1" : ",0") : "";
                    return "" + (n || Or)(a, t) + o;
                  }
                  var u = r
                      ? (function(e, t) {
                          for (var r = 0, n = 0; n < e.length; n++) {
                            var i = e[n];
                            if (1 === i.type) {
                              if (
                                qr(i) ||
                                (i.ifConditions &&
                                  i.ifConditions.some(function(e) {
                                    return qr(e.block);
                                  }))
                              ) {
                                r = 2;
                                break;
                              }
                              (t(i) ||
                                (i.ifConditions &&
                                  i.ifConditions.some(function(e) {
                                    return t(e.block);
                                  }))) &&
                                (r = 1);
                            }
                          }
                          return r;
                        })(s, t.maybeComponent)
                      : 0,
                    l = i || Vr;
                  return (
                    "[" +
                    s
                      .map(function(e) {
                        return l(e, t);
                      })
                      .join(",") +
                    "]" +
                    (u ? "," + u : "")
                  );
                }
              }
              function qr(e) {
                return (
                  void 0 !== e.for || "template" === e.tag || "slot" === e.tag
                );
              }
              function Vr(e, t) {
                return 1 === e.type
                  ? Or(e, t)
                  : 3 === e.type && e.isComment
                  ? ((r = e), "_e(" + JSON.stringify(r.text) + ")")
                  : Ur(e);
                var r;
              }
              function Ur(e) {
                return (
                  "_v(" +
                  (2 === e.type ? e.expression : Gr(JSON.stringify(e.text))) +
                  ")"
                );
              }
              function Kr(e) {
                for (var t = "", r = "", n = 0; n < e.length; n++) {
                  var i = e[n],
                    s = Gr(i.value);
                  i.dynamic
                    ? (r += i.name + "," + s + ",")
                    : (t += '"' + i.name + '":' + s + ",");
                }
                return (
                  (t = "{" + t.slice(0, -1) + "}"),
                  r ? "_d(" + t + ",[" + r.slice(0, -1) + "])" : t
                );
              }
              function Gr(e) {
                return e
                  .replace(/\u2028/g, "\\u2028")
                  .replace(/\u2029/g, "\\u2029");
              }
              var Wr = new RegExp(
                  "\\b" +
                    "do,if,for,let,new,try,var,case,else,with,await,break,catch,class,const,super,throw,while,yield,delete,export,import,return,switch,default,extends,finally,continue,debugger,function,arguments"
                      .split(",")
                      .join("\\b|\\b") +
                    "\\b"
                ),
                Jr = new RegExp(
                  "\\b" +
                    "delete,typeof,void"
                      .split(",")
                      .join("\\s*\\([^\\)]*\\)|\\b") +
                    "\\s*\\([^\\)]*\\)"
                ),
                Xr = /'(?:[^'\\]|\\.)*'|"(?:[^"\\]|\\.)*"|`(?:[^`\\]|\\.)*\$\{|\}(?:[^`\\]|\\.)*`|`(?:[^`\\]|\\.)*`/g;
              function $r(e, t) {
                e &&
                  (function e(t, r) {
                    if (1 === t.type) {
                      for (var n in t.attrsMap)
                        if (jt.test(n)) {
                          var i = t.attrsMap[n];
                          if (i) {
                            var s = t.rawAttrsMap[n];
                            "v-for" === n
                              ? Yr(t, 'v-for="' + i + '"', r, s)
                              : Mt.test(n)
                              ? Hr(i, n + '="' + i + '"', r, s)
                              : Qr(i, n + '="' + i + '"', r, s);
                          }
                        }
                      if (t.children)
                        for (var a = 0; a < t.children.length; a++)
                          e(t.children[a], r);
                    } else 2 === t.type && Qr(t.expression, t.text, r, t);
                  })(e, t);
              }
              function Hr(e, t, r, n) {
                var i = e.replace(Xr, ""),
                  s = i.match(Jr);
                s &&
                  "$" !== i.charAt(s.index - 1) &&
                  r(
                    'avoid using JavaScript unary operator as property name: "' +
                      s[0] +
                      '" in expression ' +
                      t.trim(),
                    n
                  ),
                  Qr(e, t, r, n);
              }
              function Yr(e, t, r, n) {
                Qr(e.for || "", t, r, n),
                  zr(e.alias, "v-for alias", t, r, n),
                  zr(e.iterator1, "v-for iterator", t, r, n),
                  zr(e.iterator2, "v-for iterator", t, r, n);
              }
              function zr(e, t, r, n, i) {
                if ("string" == typeof e)
                  try {
                    new Function("var " + e + "=_");
                  } catch (s) {
                    n(
                      "invalid " +
                        t +
                        ' "' +
                        e +
                        '" in expression: ' +
                        r.trim(),
                      i
                    );
                  }
              }
              function Qr(e, t, r, n) {
                try {
                  new Function("return " + e);
                } catch (s) {
                  var i = e.replace(Xr, "").match(Wr);
                  r(
                    i
                      ? 'avoid using JavaScript keyword as property name: "' +
                          i[0] +
                          '"\n  Raw expression: ' +
                          t.trim()
                      : "invalid expression: " +
                          s.message +
                          " in\n\n    " +
                          e +
                          "\n\n  Raw expression: " +
                          t.trim() +
                          "\n",
                    n
                  );
                }
              }
              var Zr = 2;
              function en(e, t, r) {
                void 0 === t && (t = 0), void 0 === r && (r = e.length);
                for (
                  var n = e.split(/\r?\n/), i = 0, s = [], a = 0;
                  a < n.length;
                  a++
                )
                  if ((i += n[a].length + 1) >= t) {
                    for (var o = a - Zr; o <= a + Zr || r > i; o++)
                      if (!(o < 0 || o >= n.length)) {
                        s.push(
                          "" +
                            (o + 1) +
                            tn(" ", 3 - String(o + 1).length) +
                            "|  " +
                            n[o]
                        );
                        var u = n[o].length;
                        if (o === a) {
                          var l = t - (i - u) + 1,
                            c = r > i ? u - l : r - t;
                          s.push("   |  " + tn(" ", l) + tn("^", c));
                        } else if (o > a) {
                          if (r > i) {
                            var p = Math.min(r - i, u);
                            s.push("   |  " + tn("^", p));
                          }
                          i += u + 1;
                        }
                      }
                    break;
                  }
                return s.join("\n");
              }
              function tn(e, t) {
                var r = "";
                if (t > 0)
                  for (; 1 & t && (r += e), !((t >>>= 1) <= 0); ) e += e;
                return r;
              }
              function rn(e, t) {
                try {
                  return new Function(e);
                } catch (r) {
                  return t.push({ err: r, code: e }), T;
                }
              }
              function nn(e) {
                var t = Object.create(null);
                return function(r, n, i) {
                  var s = (n = E({}, n)).warn || pe;
                  delete n.warn;
                  try {
                    new Function("return 1");
                  } catch (e) {
                    e.toString().match(/unsafe-eval|CSP/) &&
                      s(
                        "It seems you are using the standalone build of Vue.js in an environment with Content Security Policy that prohibits unsafe-eval. The template compiler cannot work in this environment. Consider relaxing the policy to allow unsafe-eval or pre-compiling your templates into render functions."
                      );
                  }
                  var a = n.delimiters ? String(n.delimiters) + r : r;
                  if (t[a]) return t[a];
                  var o = e(r, n);
                  o.errors &&
                    o.errors.length &&
                    (n.outputSourceRange
                      ? o.errors.forEach(function(e) {
                          s(
                            "Error compiling template:\n\n" +
                              e.msg +
                              "\n\n" +
                              en(r, e.start, e.end),
                            i
                          );
                        })
                      : s(
                          "Error compiling template:\n\n" +
                            r +
                            "\n\n" +
                            o.errors
                              .map(function(e) {
                                return "- " + e;
                              })
                              .join("\n") +
                            "\n",
                          i
                        )),
                    o.tips &&
                      o.tips.length &&
                      (n.outputSourceRange
                        ? o.tips.forEach(function(e) {
                            return de(e.msg, i);
                          })
                        : o.tips.forEach(function(e) {
                            return de(e, i);
                          }));
                  var u = {},
                    l = [];
                  return (
                    (u.render = rn(o.render, l)),
                    (u.staticRenderFns = o.staticRenderFns.map(function(e) {
                      return rn(e, l);
                    })),
                    (o.errors && o.errors.length) ||
                      !l.length ||
                      s(
                        "Failed to generate render function:\n\n" +
                          l
                            .map(function(e) {
                              var t = e.err,
                                r = e.code;
                              return t.toString() + " in\n\n" + r + "\n";
                            })
                            .join("\n"),
                        i
                      ),
                    (t[a] = u)
                  );
                };
              }
              function sn(e) {
                return function(t) {
                  function r(r, n) {
                    var i = Object.create(t),
                      s = [],
                      a = [],
                      o = function(e, t, r) {
                        (r ? a : s).push(e);
                      };
                    if (n) {
                      if (n.outputSourceRange) {
                        var u = r.match(/^\s*/)[0].length;
                        o = function(e, t, r) {
                          var n = { msg: e };
                          t &&
                            (null != t.start && (n.start = t.start + u),
                            null != t.end && (n.end = t.end + u)),
                            (r ? a : s).push(n);
                        };
                      }
                      for (var l in (n.modules &&
                        (i.modules = (t.modules || []).concat(n.modules)),
                      n.directives &&
                        (i.directives = E(
                          Object.create(t.directives || null),
                          n.directives
                        )),
                      n))
                        "modules" !== l && "directives" !== l && (i[l] = n[l]);
                    }
                    i.warn = o;
                    var c = e(r.trim(), i);
                    return $r(c.ast, o), (c.errors = s), (c.tips = a), c;
                  }
                  return { compile: r, compileToFunctions: nn(r) };
                };
              }
              var an = sn(function(e, t) {
                  var r = Zt(e.trim(), t);
                  !1 !== t.optimize && gr(r, t);
                  var n = _r(r, t);
                  return {
                    ast: r,
                    render: n.render,
                    staticRenderFns: n.staticRenderFns
                  };
                })(mr),
                on = an.compile,
                un = an.compileToFunctions,
                ln = p(
                  "accept,accept-charset,accesskey,action,align,alt,async,autocomplete,autofocus,autoplay,autosave,bgcolor,border,buffered,challenge,charset,checked,cite,class,code,codebase,color,cols,colspan,content,http-equiv,name,contenteditable,contextmenu,controls,coords,data,datetime,default,defer,dir,dirname,disabled,download,draggable,dropzone,enctype,method,for,form,formaction,headers,height,hidden,high,href,hreflang,http-equiv,icon,id,ismap,itemprop,keytype,kind,label,lang,language,list,loop,low,manifest,max,maxlength,media,method,GET,POST,min,multiple,email,file,muted,name,novalidate,open,optimum,pattern,ping,placeholder,poster,preload,radiogroup,readonly,rel,required,reversed,rows,rowspan,sandbox,scope,scoped,seamless,selected,shape,size,type,text,password,sizes,span,spellcheck,src,srcdoc,srclang,srcset,start,step,style,summary,tabindex,target,title,type,usemap,value,width,wrap"
                ),
                cn = function(e) {
                  return (
                    ln(e) ||
                    0 === e.indexOf("data-") ||
                    0 === e.indexOf("aria-")
                  );
                },
                pn = {
                  acceptCharset: "accept-charset",
                  className: "class",
                  htmlFor: "for",
                  httpEquiv: "http-equiv"
                },
                dn = { "<": "&lt;", ">": "&gt;", '"': "&quot;", "&": "&amp;" };
              function hn(e) {
                return dn[e] || e;
              }
              var fn = /^"(?:[^"\\]|\\.)*"$|^'(?:[^'\\]|\\.)*'$/;
              function mn(e, t) {
                return fn.test(t)
                  ? ((t = t.replace(/^'|'$/g, '"')),
                    Re(e) && '"false"' !== t && (t = '"true"'),
                    {
                      type: En,
                      value: qe(e)
                        ? " " + e + '="' + e + '"'
                        : '""' === t
                        ? " " + e
                        : " " + e + '="' + JSON.parse(t) + '"'
                    })
                  : {
                      type: xn,
                      value: "_ssrAttr(" + JSON.stringify(e) + "," + t + ")"
                    };
              }
              var yn,
                gn = { FALSE: 0, FULL: 1, SELF: 2, CHILDREN: 3, PARTIAL: 4 };
              function bn(e, t) {
                e &&
                  ((yn = t.isReservedTag || x),
                  (function e(t, r) {
                    if (
                      (function(e) {
                        if (2 === e.type || 3 === e.type) return !1;
                        return (
                          d(e.tag) ||
                          !yn(e.tag) ||
                          !!e.component ||
                          (function(e) {
                            return (
                              1 === e.type &&
                              "select" === e.tag &&
                              null != e.directives &&
                              e.directives.some(function(e) {
                                return "model" === e.name;
                              })
                            );
                          })(e)
                        );
                      })(t)
                    )
                      return void (t.ssrOptimizability = gn.FALSE);
                    var n =
                      r ||
                      (function(e) {
                        return (
                          1 === e.type &&
                          e.directives &&
                          e.directives.some(function(e) {
                            return !vn(e.name);
                          })
                        );
                      })(t);
                    var i = function(e) {
                      e.ssrOptimizability !== gn.FULL &&
                        (t.ssrOptimizability = n ? gn.PARTIAL : gn.SELF);
                    };
                    n && (t.ssrOptimizability = gn.CHILDREN);
                    if (1 === t.type) {
                      for (var s = 0, a = t.children.length; s < a; s++) {
                        var o = t.children[s];
                        e(o), i(o);
                      }
                      if (t.ifConditions)
                        for (var u = 1, l = t.ifConditions.length; u < l; u++) {
                          var c = t.ifConditions[u].block;
                          e(c, r), i(c);
                        }
                      null == t.ssrOptimizability ||
                      (!r && (t.attrsMap["v-html"] || t.attrsMap["v-text"]))
                        ? (t.ssrOptimizability = gn.FULL)
                        : (t.children = (function(e) {
                            for (
                              var t = e.children,
                                r = [],
                                n = [],
                                i = function() {
                                  n.length &&
                                    r.push({
                                      type: 1,
                                      parent: e,
                                      tag: "template",
                                      attrsList: [],
                                      attrsMap: {},
                                      rawAttrsMap: {},
                                      children: n,
                                      ssrOptimizability: gn.FULL
                                    }),
                                    (n = []);
                                },
                                s = 0;
                              s < t.length;
                              s++
                            ) {
                              var a = t[s];
                              a.ssrOptimizability === gn.FULL
                                ? n.push(a)
                                : (i(), r.push(a));
                            }
                            return i(), r;
                          })(t));
                    } else t.ssrOptimizability = gn.FULL;
                  })(e, !0));
              }
              var vn = p("text,html,show,on,bind,model,pre,cloak,once");
              var En = 0,
                Tn = 1,
                xn = 2;
              function An(e, t) {
                if (e.for && !e.forProcessed) return Lr(e, t, An);
                if (e.if && !e.ifProcessed) return Nr(e, t, An);
                if ("template" === e.tag && !e.slotTarget)
                  return e.ssrOptimizability === gn.FULL
                    ? Cn(e, t)
                    : Dn(e, t) || "void 0";
                switch (e.ssrOptimizability) {
                  case gn.FULL:
                    return (function(e, t) {
                      return "_ssrNode(" + wn(e, t) + ")";
                    })(e, t);
                  case gn.SELF:
                    return (function(e, t) {
                      var r = Dn(e, t, !0);
                      return (
                        "_ssrNode(" +
                        kn(_n(e, t)) +
                        ',"</' +
                        e.tag +
                        '>"' +
                        (r ? "," + r : "") +
                        ")"
                      );
                    })(e, t);
                  case gn.CHILDREN:
                    return Sn(e, t, !0);
                  case gn.PARTIAL:
                    return Sn(e, t, !1);
                  default:
                    return Or(e, t);
                }
              }
              function Sn(e, t, r) {
                var n = e.plain ? void 0 : Br(e, t),
                  i = r ? "[" + Cn(e, t) + "]" : Dn(e, t, !0);
                return (
                  "_c('" +
                  e.tag +
                  "'" +
                  (n ? "," + n : "") +
                  (i ? "," + i : "") +
                  ")"
                );
              }
              function Dn(e, t, r) {
                return Rr(e, t, r, An, Pn);
              }
              function Pn(e, t) {
                return 1 === e.type ? An(e, t) : Ur(e);
              }
              function Cn(e, t) {
                return e.children.length
                  ? "_ssrNode(" + kn(On(e, t)) + ")"
                  : "";
              }
              function wn(e, t) {
                return "(" + kn(Fn(e, t)) + ")";
              }
              function Fn(e, t) {
                if (e.for && !e.forProcessed)
                  return (
                    (e.forProcessed = !0),
                    [{ type: xn, value: Lr(e, t, wn, "_ssrList") }]
                  );
                if (e.if && !e.ifProcessed)
                  return (
                    (e.ifProcessed = !0),
                    [{ type: xn, value: Nr(e, t, wn, '"\x3c!----\x3e"') }]
                  );
                if ("template" === e.tag) return On(e, t);
                var r = _n(e, t),
                  n = On(e, t),
                  i = t.options.isUnaryTag,
                  s =
                    i && i(e.tag)
                      ? []
                      : [{ type: En, value: "</" + e.tag + ">" }];
                return r.concat(n, s);
              }
              function _n(e, t) {
                var r;
                !(function(e, t) {
                  if (e.directives)
                    for (var r = 0; r < e.directives.length; r++) {
                      var n = e.directives[r];
                      if ("model" === n.name) {
                        t.directives.model(e, n, t.warn),
                          "textarea" === e.tag &&
                            e.props &&
                            (e.props = e.props.filter(function(e) {
                              return "value" !== e.name;
                            }));
                        break;
                      }
                    }
                })(e, t);
                var n,
                  i,
                  s,
                  a,
                  o,
                  u,
                  l = [{ type: En, value: "<" + e.tag }];
                return (
                  e.attrs &&
                    l.push.apply(
                      l,
                      e.attrs.map(function(e) {
                        return mn(e.name, e.value);
                      })
                    ),
                  e.props &&
                    l.push.apply(
                      l,
                      (function(e, t) {
                        var r = [];
                        return (
                          e.forEach(function(e) {
                            var n = e.name,
                              i = e.value;
                            (n = pn[n] || n.toLowerCase()),
                              !cn(n) ||
                                (t &&
                                  t.some(function(e) {
                                    return e.name === n;
                                  })) ||
                                r.push(mn(n, i));
                          }),
                          r
                        );
                      })(e.props, e.attrs)
                    ),
                  (r = e.attrsMap["v-bind"]) &&
                    l.push({ type: xn, value: "_ssrAttrs(" + r + ")" }),
                  (r = e.attrsMap["v-bind.prop"]) &&
                    l.push({ type: xn, value: "_ssrDOMProps(" + r + ")" }),
                  (e.staticClass || e.classBinding) &&
                    l.push.apply(
                      l,
                      ((n = e.staticClass),
                      (i = e.classBinding),
                      n && !i
                        ? [
                            {
                              type: En,
                              value: ' class="' + JSON.parse(n) + '"'
                            }
                          ]
                        : [
                            {
                              type: xn,
                              value:
                                "_ssrClass(" +
                                (n || "null") +
                                "," +
                                (i || "null") +
                                ")"
                            }
                          ])
                    ),
                  (e.staticStyle || e.styleBinding || e.attrsMap["v-show"]) &&
                    l.push.apply(
                      l,
                      ((s = e.attrsMap.style),
                      (a = e.staticStyle),
                      (o = e.styleBinding),
                      (u = e.attrsMap["v-show"]),
                      !s || o || u
                        ? [
                            {
                              type: xn,
                              value:
                                "_ssrStyle(" +
                                (a || "null") +
                                "," +
                                (o || "null") +
                                ", " +
                                (u
                                  ? "{ display: (" + u + ") ? '' : 'none' }"
                                  : "null") +
                                ")"
                            }
                          ]
                        : [{ type: En, value: " style=" + JSON.stringify(s) }])
                    ),
                  t.options.scopeId &&
                    l.push({ type: En, value: " " + t.options.scopeId }),
                  l.push({ type: En, value: ">" }),
                  l
                );
              }
              function On(e, t) {
                var r;
                return (r = e.attrsMap["v-html"])
                  ? [{ type: xn, value: "_s(" + r + ")" }]
                  : (r = e.attrsMap["v-text"])
                  ? [{ type: Tn, value: "_s(" + r + ")" }]
                  : "textarea" === e.tag && (r = e.attrsMap["v-model"])
                  ? [{ type: Tn, value: "_s(" + r + ")" }]
                  : e.children
                  ? (function(e, t) {
                      for (var r = [], n = 0; n < e.length; n++) {
                        var i = e[n];
                        if (1 === i.type) r.push.apply(r, Fn(i, t));
                        else if (2 === i.type)
                          r.push({ type: Tn, value: i.expression });
                        else if (3 === i.type) {
                          var s = i.text.replace(/[<>"&]/g, hn);
                          i.isComment && (s = "\x3c!--" + s + "--\x3e"),
                            r.push({ type: En, value: s });
                        }
                      }
                      return r;
                    })(e.children, t)
                  : [];
              }
              function kn(e) {
                for (
                  var t = [],
                    r = "",
                    n = function() {
                      r && (t.push(JSON.stringify(r)), (r = ""));
                    },
                    i = 0;
                  i < e.length;
                  i++
                ) {
                  var s = e[i];
                  s.type === En
                    ? (r += s.value)
                    : s.type === Tn
                    ? (n(), t.push("_ssrEscape(" + s.value + ")"))
                    : s.type === xn && (n(), t.push("(" + s.value + ")"));
                }
                return n(), t.join("+");
              }
              var In = sn(function(e, t) {
                  var r = Zt(e.trim(), t);
                  bn(r, t);
                  var n = (function(e, t) {
                    var r = new Fr(t);
                    return {
                      render:
                        "with(this){return " +
                        (e ? An(e, r) : '_c("div")') +
                        "}",
                      staticRenderFns: r.staticRenderFns
                    };
                  })(r, t);
                  return {
                    ast: r,
                    render: n.render,
                    staticRenderFns: n.staticRenderFns
                  };
                })(mr),
                Nn = In.compile,
                Ln = In.compileToFunctions;
              (t.parseComponent = function(e, t) {
                void 0 === t && (t = {});
                var r = {
                    template: null,
                    script: null,
                    styles: [],
                    customBlocks: [],
                    errors: []
                  },
                  n = 0,
                  i = null,
                  s = function(e) {
                    r.errors.push(e);
                  };
                return (
                  t.outputSourceRange &&
                    (s = function(e, t) {
                      var n = { msg: e };
                      null != t.start && (n.start = t.start),
                        null != t.end && (n.end = t.end),
                        r.errors.push(n);
                    }),
                  W(e, {
                    warn: s,
                    start: function(e, t, s, a, o) {
                      0 === n &&
                        ((i = {
                          type: e,
                          content: "",
                          start: o,
                          attrs: t.reduce(function(e, t) {
                            var r = t.name,
                              n = t.value;
                            return (e[r] = n || !0), e;
                          }, {})
                        }),
                        $(e)
                          ? ((function(e, t) {
                              for (var r = 0; r < t.length; r++) {
                                var n = t[r];
                                "lang" === n.name && (e.lang = n.value),
                                  "scoped" === n.name && (e.scoped = !0),
                                  "module" === n.name &&
                                    (e.module = n.value || !0),
                                  "src" === n.name && (e.src = n.value);
                              }
                            })(i, t),
                            "style" === e ? r.styles.push(i) : (r[e] = i))
                          : r.customBlocks.push(i)),
                        s || n++;
                    },
                    end: function(r, s) {
                      if (1 === n && i) {
                        i.end = s;
                        var o = e.slice(i.start, i.end);
                        !1 !== t.deindent && (o = a(o)),
                          "template" !== i.type &&
                            t.pad &&
                            (o =
                              (function(t, r) {
                                if ("space" === r)
                                  return e.slice(0, t.start).replace(X, " ");
                                var n = e.slice(0, t.start).split(J).length,
                                  i =
                                    "script" !== t.type || t.lang
                                      ? "\n"
                                      : "//\n";
                                return Array(n).join(i);
                              })(i, t.pad) + o),
                          (i.content = o),
                          (i = null);
                      }
                      n--;
                    },
                    outputSourceRange: t.outputSourceRange
                  }),
                  r
                );
              }),
                (t.compile = on),
                (t.compileToFunctions = un),
                (t.ssrCompile = Nn),
                (t.ssrCompileToFunctions = Ln),
                (t.generateCodeFrame = en),
                Object.defineProperty(t, "__esModule", { value: !0 });
            });
          }.call(
            this,
            "undefined" != typeof global
              ? global
              : "undefined" != typeof self
              ? self
              : "undefined" != typeof window
              ? window
              : {},
            e("timers").setImmediate
          ));
        },
        { timers: 332 }
      ],
      319: [
        function(e, t, r) {
          (function(t) {
            const n = e("@babel/traverse").default,
              i = e("@babel/types"),
              { log: s } = e("./utils"),
              a = e("./vue-props"),
              o = e("./vue-computed");
            (r.initProps = function(e, r) {
              n(e, {
                Program(e) {
                  const r = e.node.body;
                  let n = 0;
                  for (let e = 0; e < r.length; e++) {
                    const t = r[e];
                    i.isExportDefaultDeclaration(t) && n++;
                  }
                  if (n > 1 || !n) {
                    s(
                      `${
                        n ? "Only one" : "Must hava one"
                      } export default declaration in youe vue component file`
                    ),
                      t.exit();
                  }
                },
                ObjectProperty(e) {
                  const t = e.parentPath.parent,
                    n = e.node.key.name;
                  t &&
                    i.isExportDefaultDeclaration(t) &&
                    ("name" === n
                      ? i.isStringLiteral(e.node.value)
                        ? (r.name = e.node.value.value)
                        : s(
                            "The value of name prop should be a string literal."
                          )
                      : "props" === n && (a(e, r), e.stop()));
                }
              });
            }),
              (r.initData = function(e, t) {
                n(e, {
                  ObjectMethod(e) {
                    const r = e.parentPath.parent,
                      n = e.node.key.name;
                    if (r && i.isExportDefaultDeclaration(r) && "data" === n) {
                      const r = e.node.body.body;
                      t.data._statements = [].concat(r);
                      let n = {};
                      r.forEach(e => {
                        i.isReturnStatement(e) && (n = e.argument.properties);
                      }),
                        n.forEach(e => {
                          t.data[e.key.name] = e.value;
                        }),
                        e.stop();
                    }
                  }
                });
              }),
              (r.initComputed = function(e, t) {
                n(e, {
                  ObjectProperty(e) {
                    const r = e.parentPath.parent,
                      n = e.node.key.name;
                    r &&
                      i.isExportDefaultDeclaration(r) &&
                      "computed" === n &&
                      (o(e, t), e.stop());
                  }
                });
              }),
              (r.initComponents = function(e, t) {
                n(e, {
                  ObjectProperty(e) {
                    const r = e.parentPath.parent,
                      n = e.node.key.name;
                    if (
                      r &&
                      i.isExportDefaultDeclaration(r) &&
                      "components" === n
                    ) {
                      e.node.value.properties.forEach(e => {
                        t.components[e.key.name] = e.value.name;
                      }),
                        e.stop();
                    }
                  }
                });
              });
          }.call(this, e("_process")));
        },
        {
          "./utils": 326,
          "./vue-computed": 328,
          "./vue-props": 329,
          "@babel/traverse": 37,
          "@babel/types": 100,
          _process: 331
        }
      ],
      320: [
        function(e, t, r) {
          const n = e("@babel/types"),
            { genDefaultProps: i, genPropTypes: s } =
              (e("chalk"), e("./utils"));
          (r.genImports = function(e, t, r) {
            const i = e.node.body,
              s = n.importDeclaration(
                [
                  n.importDefaultSpecifier(n.identifier("React")),
                  n.importSpecifier(
                    n.identifier("Component"),
                    n.identifier("Component")
                  )
                ],
                n.stringLiteral("react")
              );
            if (Object.keys(r.props).length) {
              const e = n.importDeclaration(
                [n.importDefaultSpecifier(n.identifier("PropTypes"))],
                n.stringLiteral("prop-types")
              );
              t.imports.push(e);
            }
            t.imports.push(s), t.imports.forEach(e => i.unshift(e));
          }),
            (r.genConstructor = function(e, t) {
              const r = e.node.body,
                i = [
                  n.expressionStatement(
                    n.callExpression(n.super(), [n.identifier("props")])
                  )
                ];
              t.data._statements &&
                t.data._statements.forEach(e => {
                  if (n.isReturnStatement(e)) {
                    e.argument.properties.forEach(e => {
                      n.isMemberExpression(e.value) &&
                        (e.value = n.memberExpression(
                          n.identifier("props"),
                          n.identifier(e.value.property.name)
                        ));
                    }),
                      i.push(
                        n.expressionStatement(
                          n.assignmentExpression(
                            "=",
                            n.memberExpression(
                              n.thisExpression(),
                              n.identifier("state")
                            ),
                            e.argument
                          )
                        )
                      );
                  } else i.push(e);
                });
              const s = n.classMethod(
                "constructor",
                n.identifier("constructor"),
                [n.identifier("props")],
                n.blockStatement(i)
              );
              r.push(s);
            }),
            (r.genStaticProps = function(e, t) {
              const r = t.props,
                n = e.node.body;
              Object.keys(r).length && (n.push(s(r)), n.push(i(r)));
            }),
            (r.genClassMethods = function(e, t) {
              const r = e.node.body,
                n = t.classMethods;
              Object.keys(n).length &&
                Object.keys(n).forEach(e => {
                  r.push(n[e]);
                });
            });
        },
        { "./utils": 326, "@babel/types": 100, chalk: 136 }
      ],
      321: [
        function(e, t, r) {
          const n = e("@babel/types"),
            { getNextJSXElment: i } = e("./sfc-ast-helpers"),
            { log: s, getIdentifier: a } = e("../utils"),
            o = e("./event-map");
          (r.handleIfDirective = function(e, t, r) {
            const s = e.parentPath.parentPath,
              o = (s.node.children, i(s)),
              u = r.computeds[t]
                ? n.identifier(t)
                : n.memberExpression(
                    n.memberExpression(n.thisExpression(), a(r, t)),
                    n.identifier(t)
                  );
            s.replaceWith(
              n.jSXExpressionContainer(
                n.conditionalExpression(u, s.node, o || n.nullLiteral())
              )
            ),
              e.remove();
          }),
            (r.handleShowDirective = function(e, t, r) {
              const i = r.computeds[t]
                ? n.identifier(t)
                : n.memberExpression(
                    n.memberExpression(n.thisExpression(), a(r, t)),
                    n.identifier(t)
                  );
              e.replaceWith(
                n.jSXAttribute(
                  n.jSXIdentifier("style"),
                  n.jSXExpressionContainer(
                    n.objectExpression([
                      n.objectProperty(
                        n.identifier("display"),
                        n.conditionalExpression(
                          i,
                          n.stringLiteral("block"),
                          n.stringLiteral("none")
                        )
                      )
                    ])
                  )
                )
              );
            }),
            (r.handleOnDirective = function(e, t, r) {
              const i = o[t];
              i
                ? e.replaceWith(
                    n.jSXAttribute(
                      n.jSXIdentifier(i),
                      n.jSXExpressionContainer(
                        n.memberExpression(n.thisExpression(), n.identifier(r))
                      )
                    )
                  )
                : s("Not support event name");
            }),
            (r.handleBindDirective = function(e, t, r, i) {
              i.computeds[r]
                ? e.replaceWith(
                    n.jSXAttribute(
                      n.jSXIdentifier(t),
                      n.jSXExpressionContainer(n.identifier(r))
                    )
                  )
                : e.replaceWith(
                    n.jSXAttribute(
                      n.jSXIdentifier(t),
                      n.jSXExpressionContainer(
                        n.memberExpression(
                          n.memberExpression(n.thisExpression(), a(i, r)),
                          n.identifier(r)
                        )
                      )
                    )
                  );
            }),
            (r.handleForDirective = function(e, t, r, i) {
              const s = e.parentPath.parentPath,
                o = s.node.children,
                u = s.node.openingElement.name.name,
                l = t.split(/\s+?in\s+?/),
                c = l[1].trim(),
                p = l[0]
                  .replace("(", "")
                  .replace(")", "")
                  .split(","),
                d = [];
              p.forEach(e => {
                r.push(e.trim()), d.push(n.identifier(e.trim()));
              });
              const h = i.computeds[c]
                ? n.identifier(c)
                : n.memberExpression(
                    n.memberExpression(n.thisExpression(), a(i, t)),
                    n.identifier(c)
                  );
              s.replaceWith(
                n.jSXExpressionContainer(
                  n.callExpression(n.memberExpression(h, n.identifier("map")), [
                    n.arrowFunctionExpression(
                      d,
                      n.blockStatement([
                        n.returnStatement(
                          n.jSXElement(
                            n.jSXOpeningElement(n.jSXIdentifier(u), [
                              n.jSXAttribute(
                                n.jSXIdentifier("key"),
                                n.jSXExpressionContainer(n.identifier("index"))
                              )
                            ]),
                            n.jSXClosingElement(n.jSXIdentifier(u)),
                            o
                          )
                        )
                      ])
                    )
                  ])
                )
              );
            }),
            (r.handleTextDirective = function(e, t, r) {
              const i = e.parentPath.parentPath;
              r.computeds[t]
                ? i.node.children.push(
                    n.jSXExpressionContainer(
                      n.callExpression(
                        n.memberExpression(
                          n.identifier(t),
                          n.identifier("replace")
                        ),
                        [n.regExpLiteral("<[^>]+>", "g"), n.stringLiteral("")]
                      )
                    )
                  )
                : i.node.children.push(
                    n.jSXExpressionContainer(
                      n.callExpression(
                        n.memberExpression(
                          n.memberExpression(
                            n.memberExpression(n.thisExpression(), a(r, t)),
                            n.identifier(t)
                          ),
                          n.identifier("replace")
                        ),
                        [n.regExpLiteral("<[^>]+>", "g"), n.stringLiteral("")]
                      )
                    )
                  );
            }),
            (r.handleHTMLDirective = function(e, t, r) {
              const i = r.computeds[t]
                ? n.identifier(t)
                : n.memberExpression(
                    n.memberExpression(n.thisExpression(), a(r, t)),
                    n.identifier(t)
                  );
              e.replaceWith(
                n.jSXAttribute(
                  n.jSXIdentifier("dangerouslySetInnerHTML"),
                  n.jSXExpressionContainer(
                    n.objectExpression([
                      n.objectProperty(n.identifier("__html"), i)
                    ])
                  )
                )
              );
            });
        },
        {
          "../utils": 326,
          "./event-map": 322,
          "./sfc-ast-helpers": 324,
          "@babel/types": 100
        }
      ],
      322: [
        function(e, t, r) {
          t.exports = {
            click: "onClick",
            dblclick: "onDoubleClick",
            abort: "onAbort",
            change: "onChange",
            input: "onInput",
            error: "onError",
            focus: "onFocus",
            blur: "onBlur",
            keydown: "onKeyDown",
            keyup: "onKeyUp",
            keypress: "onKeyPress",
            load: "onLoad",
            mousedown: "onMouseDown",
            mouseup: "onMouseUp",
            mousemove: "onMouseMove",
            mouseenter: "onMouseEnter",
            mouseleave: "onMouseLeave",
            mouseout: "onMouseOut",
            mouseover: "onMouseOver",
            reset: "onReset",
            resize: "onResize",
            select: "onSelect",
            submit: "onSubmit",
            unload: "onUnload",
            drag: "onDrag",
            dragend: "onDragEnd",
            dragenter: "onDragEnter",
            dragexit: "onDragExit",
            dragleave: "onDragLeave",
            dragover: "onDragOver",
            dragstart: "onDragStart",
            drop: "onDrop",
            touchstart: "onTouchStart",
            touchend: "onTouchEnd",
            touchcancel: "onTouchCancel",
            touchmove: "onTouchMove"
          };
        },
        {}
      ],
      323: [
        function(e, t, r) {
          const n = e("@babel/parser"),
            i = e("@babel/types"),
            s = e("@babel/traverse").default,
            { log: a, getIdentifier: o } = e("../utils"),
            {
              handleIfDirective: u,
              handleShowDirective: l,
              handleOnDirective: c,
              handleForDirective: p,
              handleTextDirective: d,
              handleHTMLDirective: h,
              handleBindDirective: f
            } = e("./directives");
          t.exports = function(e, t) {
            let r = null;
            const m = [],
              y = n.parse(e, { sourceType: "module", plugins: ["jsx"] });
            return (
              s(y, {
                ExpressionStatement: {
                  enter(e) {},
                  exit(e) {
                    r = e.node.expression;
                  }
                },
                JSXAttribute(e) {
                  const r = e.node,
                    n = r.value.value;
                  r.name &&
                    ("class" !== r.name.name
                      ? "v-if" === r.name.name
                        ? u(e, n, t)
                        : "v-show" === r.name.name
                        ? l(e, n, t)
                        : i.isJSXNamespacedName(r.name)
                        ? "v-on" === r.name.namespace.name
                          ? c(e, r.name.name.name, n)
                          : "v-bind" === r.name.namespace.name &&
                            f(e, r.name.name.name, n, t)
                        : "v-for" === r.name.name
                        ? p(e, n, m, t)
                        : "v-text" === r.name.name
                        ? (d(e, n, t), e.remove())
                        : "v-html" === r.name.name && h(e, n, t)
                      : e.replaceWith(
                          i.jSXAttribute(i.jSXIdentifier("className"), r.value)
                        ));
                },
                JSXExpressionContainer(e) {
                  const r = e.node.expression,
                    n = r.name;
                  i.isBinaryExpression(r)
                    ? a(
                        "[vue-to-react]: Maybe you are using filter expression, but vtr is not supports it."
                      )
                    : t.computeds[n] ||
                      (n &&
                        !m.includes(n) &&
                        e.container &&
                        e.replaceWith(
                          i.jSXExpressionContainer(
                            i.memberExpression(
                              i.memberExpression(i.thisExpression(), o(t, n)),
                              i.identifier(n)
                            )
                          )
                        ));
                }
              }),
              r
            );
          };
        },
        {
          "../utils": 326,
          "./directives": 321,
          "@babel/parser": 25,
          "@babel/traverse": 37,
          "@babel/types": 100
        }
      ],
      324: [
        function(e, t, r) {
          const n = e("@babel/types");
          (r.getNextJSXElment = function(e) {
            let t = null;
            for (let r = e.key + 1; ; r++) {
              const i = e.getSibling(r);
              if (!i.node) break;
              if (n.isJSXElement(i.node)) {
                (t = i.node),
                  i.traverse({
                    JSXAttribute(e) {
                      "v-else" === e.node.name.name && e.remove();
                    }
                  }),
                  i.remove();
                break;
              }
            }
            return t;
          }),
            (r.genSFCRenderMethod = function(e, t, r) {
              const i = Object.keys(t.computeds);
              let s = [];
              i.length &&
                i.forEach(e => {
                  const r = t.computeds[e];
                  s = s.concat(r._statements);
                }),
                (s = s.concat(n.returnStatement(r)));
              const a = n.classMethod(
                "method",
                n.identifier("render"),
                [],
                n.blockStatement(s)
              );
              e.node.body.push(a);
            });
        },
        { "@babel/types": 100 }
      ],
      325: [
        function(e, t, r) {
          const n = e("@babel/parser"),
            i = e("@babel/traverse").default,
            s = e("@babel/generator").default,
            a = e("@babel/types"),
            o = e("vue-template-compiler"),
            {
              initProps: u,
              initData: l,
              initComputed: c,
              initComponents: p
            } = e("./collect-state"),
            { parseName: d, log: h, parseComponentName: f } = e("./utils"),
            {
              genImports: m,
              genConstructor: y,
              genStaticProps: g,
              genClassMethods: b
            } = e("./react-ast-helpers"),
            {
              collectVueProps: v,
              handleCycleMethods: E,
              handleGeneralMethods: T
            } = e("./vue-ast-helpers"),
            { genSFCRenderMethod: x } = e("./sfc/sfc-ast-helpers"),
            A = e("./sfc/index"),
            S = {
              name: void 0,
              data: {},
              props: {},
              computeds: {},
              components: {}
            },
            D = {
              created: "componentWillMount",
              mounted: "componentDidMount",
              updated: "componentDidUpdate",
              beforeDestroy: "componentWillUnmount",
              errorCaptured: "componentDidCatch",
              render: "render"
            },
            P = { imports: [], classMethods: {} };
          t.exports = function(e, t) {
            const r = (function(e, t) {
                if (t) {
                  const t = o.parseComponent(e, { pad: "line" });
                  return {
                    template: t.template.content
                      .replace(/{{/g, "{")
                      .replace(/}}/g, "}"),
                    js: t.script.content.replace(/\/\//g, "")
                  };
                }
                return { template: null, js: e };
              })(e, t),
              v = n.parse(r.js, {
                sourceType: "module",
                plugins: t ? [] : ["jsx"]
              });
            u(v, S),
              l(v, S),
              c(v, S),
              p(v, S),
              i(v, {
                ImportDeclaration(e) {
                  P.imports.push(e.node);
                },
                ObjectMethod(e) {
                  const r = e.node.key.name;
                  if (
                    e.parentPath.parent.key &&
                    "methods" === e.parentPath.parent.key.name
                  )
                    T(e, P, S, r);
                  else if (D[r]) E(e, P, S, r, D[r], t);
                  else {
                    if ("data" === r || S.computeds[r]) return;
                    h(`The ${r} method maybe be not support now`);
                  }
                }
              });
            let C = null;
            t && (C = A(r.template, S));
            const w = `export default class ${d(S.name)} extends Component {}`,
              F = n.parse(w, { sourceType: "module" });
            i(F, {
              Program(e) {
                m(e, P, S);
              },
              ClassBody(e) {
                y(e, S), g(e, S), b(e, P), t && x(e, S, C);
              }
            }),
              t &&
                i(F, {
                  ClassMethod(e) {
                    "render" === e.node.key.name &&
                      e.traverse({
                        JSXIdentifier(e) {
                          if (
                            a.isJSXClosingElement(e.parent) ||
                            a.isJSXOpeningElement(e.parent)
                          ) {
                            const t = e.node,
                              r =
                                S.components[t.name] || S.components[f(t.name)];
                            r && (e.replaceWith(a.jSXIdentifier(r)), e.stop());
                          }
                        }
                      });
                  }
                });
            const { code: _ } = s(F, { quotes: "single", retainLines: !0 });
            return _;
          };
        },
        {
          "./collect-state": 319,
          "./react-ast-helpers": 320,
          "./sfc/index": 323,
          "./sfc/sfc-ast-helpers": 324,
          "./utils": 326,
          "./vue-ast-helpers": 327,
          "@babel/generator": 15,
          "@babel/parser": 25,
          "@babel/traverse": 37,
          "@babel/types": 100,
          "vue-template-compiler": 318
        }
      ],
      326: [
        function(e, t, r) {
          const n = e("@babel/types"),
            i = e("chalk");
          (r.parseName = function(e) {
            const t = (e = e || "my-react-compoennt").toLowerCase().split("-");
            let r = "";
            return (
              t.forEach(e => {
                (e = e[0].toUpperCase() + e.substr(1)), (r += e);
              }),
              r
            );
          }),
            (r.parseComponentName = function(e) {
              if (e) {
                return e
                  .split("-")
                  .map(e => e[0].toUpperCase() + e.substr(1))
                  .join("");
              }
            }),
            (r.log = function(e, t = "error") {
              if ("error" === t)
                return console.log(i.red(`[vue-to-react]: ${e}`));
              console.log(i.green(e));
            }),
            (r.getIdentifier = function(e, t) {
              return e.data[t] ? n.identifier("state") : n.identifier("props");
            }),
            (r.genPropTypes = function(e) {
              const t = [],
                r = Object.keys(e);
              for (let i = 0, s = r.length; i < s; i++) {
                const s = r[i],
                  a = e[s],
                  o = n.identifier(s);
                let u = n.memberExpression(
                  n.identifier("PropTypes"),
                  n.identifier("any")
                );
                if ("typesOfArray" === a.type || "array" === a.type)
                  if ("typesOfArray" === a.type) {
                    const e = [];
                    a.value.forEach(t => {
                      e.push(
                        n.memberExpression(
                          n.identifier("PropTypes"),
                          n.identifier(t)
                        )
                      );
                    }),
                      (u = n.callExpression(
                        n.memberExpression(
                          n.identifier("PropTypes"),
                          n.identifier("oneOfType")
                        ),
                        [n.arrayExpression(e)]
                      ));
                  } else
                    u = a.required
                      ? n.memberExpression(
                          n.memberExpression(
                            n.identifier("PropTypes"),
                            n.identifier("array")
                          ),
                          n.identifier("isRequired")
                        )
                      : n.memberExpression(
                          n.identifier("PropTypes"),
                          n.identifier("array")
                        );
                else if (a.validator) {
                  const e = n.callExpression(
                    n.memberExpression(
                      n.identifier("PropTypes"),
                      n.identifier("oneOf")
                    ),
                    [n.arrayExpression(a.validator.elements)]
                  );
                  u = a.required
                    ? n.memberExpression(e, n.identifier("isRequired"))
                    : e;
                } else
                  u = a.required
                    ? n.memberExpression(
                        n.memberExpression(
                          n.identifier("PropTypes"),
                          n.identifier(a.type)
                        ),
                        n.identifier("isRequired")
                      )
                    : n.memberExpression(
                        n.identifier("PropTypes"),
                        n.identifier(a.type)
                      );
                t.push(n.objectProperty(o, u));
              }
              return n.classProperty(
                n.identifier("static propTypes"),
                n.objectExpression(t),
                null,
                []
              );
            }),
            (r.genDefaultProps = function(e) {
              const t = [],
                r = Object.keys(e).filter(t => void 0 !== e[t].value);
              for (let i = 0, s = r.length; i < s; i++) {
                const s = r[i],
                  a = e[s],
                  o = n.identifier(s);
                let u = n.stringLiteral("error");
                if ("typesOfArray" === a.type) {
                  const e = typeof a.defaultValue;
                  if ("undefined" === e) continue;
                  {
                    const t = a.defaultValue;
                    u =
                      "number" === e
                        ? n.numericLiteral(Number(t))
                        : "string" === e
                        ? n.stringLiteral(t)
                        : n.booleanLiteral(t);
                  }
                } else if ("array" === a.type)
                  u = n.arrayExpression(a.value.elements);
                else if ("object" === a.type)
                  u = n.objectExpression(a.value.properties);
                else
                  switch (a.type) {
                    case "string":
                      u = n.stringLiteral(a.value);
                      break;
                    case "boolean":
                      u = n.booleanLiteral(a.value);
                      break;
                    case "number":
                      u = n.numericLiteral(Number(a.value));
                  }
                t.push(n.objectProperty(o, u));
              }
              return n.classProperty(
                n.identifier("static defaultProps"),
                n.objectExpression(t),
                null,
                []
              );
            });
        },
        { "@babel/types": 100, chalk: 136 }
      ],
      327: [
        function(e, t, r) {
          const n = e("@babel/types"),
            { log: i, getIdentifier: s } = e("./utils"),
            a = {
              VariableDeclaration(e) {
                e.node.declarations.forEach(e => {
                  if (n.isMemberExpression(e.init)) {
                    const t = e.init.property.name;
                    e.init.object = n.memberExpression(
                      n.thisExpression(),
                      s(this.state, t)
                    );
                  }
                }),
                  this.blocks.push(e.node);
              },
              ExpressionStatement(e) {
                const t = e.node.expression;
                if (n.isAssignmentExpression(t)) {
                  const r = t.right,
                    i = t.left.property;
                  e.node.expression = n.callExpression(
                    n.memberExpression(
                      n.thisExpression(),
                      n.identifier("setState")
                    ),
                    [n.objectExpression([n.objectProperty(i, r)])]
                  );
                }
                n.isCallExpression(t) &&
                  !n.isThisExpression(t.callee.object) &&
                  e.traverse(
                    {
                      ThisExpression(e) {
                        const t = e.parent.property.name;
                        e.replaceWith(
                          n.memberExpression(
                            n.thisExpression(),
                            s(this.state, t)
                          )
                        ),
                          e.stop();
                      }
                    },
                    { state: this.state }
                  ),
                  this.blocks.push(e.node);
              },
              ReturnStatement(e) {
                e.traverse(
                  {
                    ThisExpression(e) {
                      const t = e.parent.property.name;
                      e.replaceWith(
                        n.memberExpression(n.thisExpression(), s(this.state, t))
                      ),
                        e.stop();
                    }
                  },
                  { state: this.state }
                ),
                  this.blocks.push(e.node);
              }
            };
          function o(e, t, r) {
            e.node.body;
            const i = [];
            let s = [];
            return (
              "componentDidCatch" === r &&
                (s = [n.identifier("error"), n.identifier("info")]),
              e.traverse(a, { blocks: i, state: t }),
              n.classMethod("method", n.identifier(r), s, n.blockStatement(i))
            );
          }
          function u(e, t, r) {
            r.data[t] || r.props[t]
              ? e.replaceWith(n.memberExpression(n.thisExpression(), s(r, t)))
              : e.parentPath.replaceWith(n.identifier(t)),
              e.stop();
          }
          (r.handleCycleMethods = function(e, t, r, s, a, l) {
            if ("render" === s) {
              if (l) return;
              t.classMethods[a] = (function(e, t, r) {
                e.node.params.length &&
                  i(
                    "\n            Maybe you will call $createElement or h method in your render, but react does not support it.\n            And it's maybe cause some unknown error in transforming\n        "
                  ),
                  e.traverse({
                    ThisExpression(e) {
                      const r = e.parentPath.parentPath.parent;
                      (n.isExpressionStatement(r) ||
                        n.isVariableDeclaration(r) ||
                        n.isBlockStatement(r) ||
                        n.isJSXElement(r) ||
                        n.isCallExpression(r) ||
                        (n.isJSXAttribute(r) &&
                          !r.name.name.startsWith("on"))) &&
                        u(e, e.parent.property.name, t);
                    },
                    JSXAttribute(e) {
                      const r = e.node;
                      if (
                        ("class" === r.name.name &&
                          e.replaceWith(
                            n.jSXAttribute(
                              n.jSXIdentifier("className"),
                              r.value
                            )
                          ),
                        "domPropsInnerHTML" === r.name.name)
                      ) {
                        const i = r.value;
                        if (n.isLiteral(i))
                          e.replaceWith(
                            n.jSXAttribute(
                              n.jSXIdentifier("dangerouslySetInnerHTML"),
                              n.jSXExpressionContainer(
                                n.objectExpression([
                                  n.objectProperty(
                                    n.identifier("__html"),
                                    r.value
                                  )
                                ])
                              )
                            )
                          );
                        else if (n.isJSXExpressionContainer(i)) {
                          const r = i.expression;
                          n.isMemberExpression(r) &&
                            e.traverse({
                              ThisExpression(e) {
                                u(e, e.parent.property.name, t);
                              }
                            }),
                            e.replaceWith(
                              n.jSXAttribute(
                                n.jSXIdentifier("dangerouslySetInnerHTML"),
                                n.jSXExpressionContainer(
                                  n.objectExpression([
                                    n.objectProperty(n.identifier("__html"), r)
                                  ])
                                )
                              )
                            );
                        }
                      }
                    }
                  });
                let s = [];
                const a = Object.keys(t.computeds);
                return (
                  a.length &&
                    a.forEach(e => {
                      const r = t.computeds[e];
                      s = s.concat(r._statements);
                    }),
                  (s = s.concat(e.node.body.body)),
                  n.classMethod(
                    "method",
                    n.identifier(r),
                    [],
                    n.blockStatement(s)
                  )
                );
              })(e, r, s);
            } else t.classMethods[a] = o(e, r, a);
          }),
            (r.handleGeneralMethods = function(e, t, r, n) {
              t.classMethods[n] = o(e, r, n);
            });
        },
        { "./utils": 326, "@babel/types": 100 }
      ],
      328: [
        function(e, t, r) {
          const n = e("@babel/types"),
            { getIdentifier: i, log: s } = (e("chalk"), e("./utils")),
            a = {
              VariableDeclaration(e) {
                e.node.declarations.forEach(e => {
                  if (n.isMemberExpression(e.init)) {
                    const t = e.init.property.name;
                    e.init.object = n.memberExpression(
                      n.thisExpression(),
                      i(this.state, t)
                    );
                  }
                }),
                  this.statements.push(e.node);
              },
              ExpressionStatement(e) {
                const t = e.node.expression;
                if (
                  (n.isCallExpression(t) &&
                    !n.isThisExpression(t.callee.object) &&
                    e.traverse(
                      {
                        ThisExpression(e) {
                          const t = e.parent.property.name;
                          e.replaceWith(
                            n.memberExpression(
                              n.thisExpression(),
                              i(this.state, t)
                            )
                          ),
                            e.stop();
                        }
                      },
                      { state: this.state }
                    ),
                  n.isAssignmentExpression(t))
                )
                  return s(`Don't do assignment in ${this.key} computed prop`);
                this.statements.push(e.node);
              },
              ReturnStatement(e) {
                e.traverse(
                  {
                    ThisExpression(e) {
                      const t = e.parent.property.name;
                      e.replaceWith(
                        n.memberExpression(n.thisExpression(), i(this.state, t))
                      ),
                        e.stop();
                    }
                  },
                  { state: this.state }
                );
                const t = n.variableDeclaration("const", [
                  n.variableDeclarator(n.identifier(this.key), e.node.argument)
                ]);
                this.statements.push(t);
              }
            };
          t.exports = function(e, t) {
            const r = e.node.value.properties,
              n = e.node.key.name;
            r.length &&
              e.traverse({
                ObjectMethod(e) {
                  const r = e.parentPath.parent;
                  if (r.key && r.key.name === n) {
                    const r = e.node.key.name;
                    if (!t.computeds[r]) {
                      e.node.key.name;
                      const n = [];
                      e.traverse(a, { statements: n, state: t, key: r }),
                        (t.computeds[r] = { _statements: n });
                    }
                  }
                }
              });
          };
        },
        { "./utils": 326, "@babel/types": 100, chalk: 136 }
      ],
      329: [
        function(e, t, r) {
          const n = e("@babel/types"),
            { log: i } = (e("chalk"), e("./utils")),
            s = {
              ObjectProperty(e) {
                const t = e.parentPath.parent.key;
                if (t && t.name === this.childKey) {
                  const t = e.node.key,
                    r = e.node.value;
                  if ("type" === t.name)
                    if (n.isIdentifier(r))
                      this.state.props[
                        this.childKey
                      ].type = r.name.toLowerCase();
                    else if (n.isArrayExpression(r)) {
                      const e = [];
                      r.elements.forEach(t => {
                        e.push(t.name.toLowerCase());
                      }),
                        e.length ||
                          i(
                            `Providing a type for the ${this.childKey} prop is a good practice.`
                          ),
                        (this.state.props[this.childKey].type =
                          e.length > 1
                            ? "typesOfArray"
                            : e[0]
                            ? e[0].toLowerCase()
                            : e),
                        (this.state.props[this.childKey].value =
                          e.length > 1 ? e : e[0] ? e[0] : e);
                    } else
                      i(
                        `The type in ${this.childKey} prop only supports identifier or array expression, eg: Boolean, [String]`
                      );
                  n.isLiteral(r) &&
                    ("default" === t.name &&
                      ("typesOfArray" === this.state.props[this.childKey].type
                        ? (this.state.props[this.childKey].defaultValue =
                            r.value)
                        : (this.state.props[this.childKey].value = r.value)),
                    "required" === t.name &&
                      (this.state.props[this.childKey].required = r.value));
                }
              },
              ArrowFunctionExpression(e) {
                const t = e.parentPath.parentPath.parent.key;
                if (t && t.name === this.childKey) {
                  const t = e.node.body;
                  if (n.isArrayExpression(t))
                    this.state.props[this.childKey].value = t;
                  else if (n.isBlockStatement(t)) {
                    const e = t.body;
                    1 === e.length &&
                      n.isReturnStatement(e[0]) &&
                      (this.state.props[this.childKey].value = e[0].argument);
                  }
                  e.parent.key &&
                    "validator" === e.parent.key.name &&
                    e.traverse(
                      {
                        ArrayExpression(e) {
                          this.state.props[this.childKey].validator = e.node;
                        }
                      },
                      { state: this.state, childKey: this.childKey }
                    );
                }
              }
            };
          t.exports = function(e, t) {
            const r = e.node.value.properties,
              a = e.node.key.name;
            r.length &&
              e.traverse({
                ObjectProperty(r) {
                  const o = r.parentPath.parent;
                  if (o.key && o.key.name === a) {
                    const a = r.node,
                      o = a.key.name,
                      u = a.value;
                    if (!t.props[o])
                      if (n.isArrayExpression(u)) {
                        const e = [];
                        u.elements.forEach(t => {
                          e.push(t.name.toLowerCase());
                        }),
                          (t.props[o] = {
                            type:
                              e.length > 1
                                ? "typesOfArray"
                                : e[0]
                                ? e[0].toLowerCase()
                                : e,
                            value: e.length > 1 ? e : e[0] ? e[0] : e,
                            required: !1,
                            validator: !1
                          });
                      } else
                        n.isObjectExpression(u)
                          ? ((t.props[o] = {
                              type: "",
                              value: void 0,
                              required: !1,
                              validator: !1
                            }),
                            e.traverse(s, { state: t, childKey: o }))
                          : n.isIdentifier(u)
                          ? (t.props[o] = {
                              type: u.name.toLowerCase(),
                              value: void 0,
                              required: !1,
                              validator: !1
                            })
                          : i(
                              `Not supports expression for the ${this.childKey} prop in props.`
                            );
                  }
                }
              });
          };
        },
        { "./utils": 326, "@babel/types": 100, chalk: 136 }
      ],
      330: [
        function(e, t, r) {
          function n(e) {
            return (
              !!e.constructor &&
              "function" == typeof e.constructor.isBuffer &&
              e.constructor.isBuffer(e)
            );
          }
          t.exports = function(e) {
            return (
              null != e &&
              (n(e) ||
                (function(e) {
                  return (
                    "function" == typeof e.readFloatLE &&
                    "function" == typeof e.slice &&
                    n(e.slice(0, 0))
                  );
                })(e) ||
                !!e._isBuffer)
            );
          };
        },
        {}
      ],
      331: [
        function(e, t, r) {
          var n,
            i,
            s = (t.exports = {});
          function a() {
            throw new Error("setTimeout has not been defined");
          }
          function o() {
            throw new Error("clearTimeout has not been defined");
          }
          function u(e) {
            if (n === setTimeout) return setTimeout(e, 0);
            if ((n === a || !n) && setTimeout)
              return (n = setTimeout), setTimeout(e, 0);
            try {
              return n(e, 0);
            } catch (t) {
              try {
                return n.call(null, e, 0);
              } catch (t) {
                return n.call(this, e, 0);
              }
            }
          }
          !(function() {
            try {
              n = "function" == typeof setTimeout ? setTimeout : a;
            } catch (e) {
              n = a;
            }
            try {
              i = "function" == typeof clearTimeout ? clearTimeout : o;
            } catch (e) {
              i = o;
            }
          })();
          var l,
            c = [],
            p = !1,
            d = -1;
          function h() {
            p &&
              l &&
              ((p = !1),
              l.length ? (c = l.concat(c)) : (d = -1),
              c.length && f());
          }
          function f() {
            if (!p) {
              var e = u(h);
              p = !0;
              for (var t = c.length; t; ) {
                for (l = c, c = []; ++d < t; ) l && l[d].run();
                (d = -1), (t = c.length);
              }
              (l = null),
                (p = !1),
                (function(e) {
                  if (i === clearTimeout) return clearTimeout(e);
                  if ((i === o || !i) && clearTimeout)
                    return (i = clearTimeout), clearTimeout(e);
                  try {
                    i(e);
                  } catch (t) {
                    try {
                      return i.call(null, e);
                    } catch (t) {
                      return i.call(this, e);
                    }
                  }
                })(e);
            }
          }
          function m(e, t) {
            (this.fun = e), (this.array = t);
          }
          function y() {}
          (s.nextTick = function(e) {
            var t = new Array(arguments.length - 1);
            if (arguments.length > 1)
              for (var r = 1; r < arguments.length; r++)
                t[r - 1] = arguments[r];
            c.push(new m(e, t)), 1 !== c.length || p || u(f);
          }),
            (m.prototype.run = function() {
              this.fun.apply(null, this.array);
            }),
            (s.title = "browser"),
            (s.browser = !0),
            (s.env = {}),
            (s.argv = []),
            (s.version = ""),
            (s.versions = {}),
            (s.on = y),
            (s.addListener = y),
            (s.once = y),
            (s.off = y),
            (s.removeListener = y),
            (s.removeAllListeners = y),
            (s.emit = y),
            (s.prependListener = y),
            (s.prependOnceListener = y),
            (s.listeners = function(e) {
              return [];
            }),
            (s.binding = function(e) {
              throw new Error("process.binding is not supported");
            }),
            (s.cwd = function() {
              return "/";
            }),
            (s.chdir = function(e) {
              throw new Error("process.chdir is not supported");
            }),
            (s.umask = function() {
              return 0;
            });
        },
        {}
      ],
      332: [
        function(e, t, r) {
          (function(t, n) {
            var i = e("process/browser.js").nextTick,
              s = Function.prototype.apply,
              a = Array.prototype.slice,
              o = {},
              u = 0;
            function l(e, t) {
              (this._id = e), (this._clearFn = t);
            }
            (r.setTimeout = function() {
              return new l(s.call(setTimeout, window, arguments), clearTimeout);
            }),
              (r.setInterval = function() {
                return new l(
                  s.call(setInterval, window, arguments),
                  clearInterval
                );
              }),
              (r.clearTimeout = r.clearInterval = function(e) {
                e.close();
              }),
              (l.prototype.unref = l.prototype.ref = function() {}),
              (l.prototype.close = function() {
                this._clearFn.call(window, this._id);
              }),
              (r.enroll = function(e, t) {
                clearTimeout(e._idleTimeoutId), (e._idleTimeout = t);
              }),
              (r.unenroll = function(e) {
                clearTimeout(e._idleTimeoutId), (e._idleTimeout = -1);
              }),
              (r._unrefActive = r.active = function(e) {
                clearTimeout(e._idleTimeoutId);
                var t = e._idleTimeout;
                t >= 0 &&
                  (e._idleTimeoutId = setTimeout(function() {
                    e._onTimeout && e._onTimeout();
                  }, t));
              }),
              (r.setImmediate =
                "function" == typeof t
                  ? t
                  : function(e) {
                      var t = u++,
                        n = !(arguments.length < 2) && a.call(arguments, 1);
                      return (
                        (o[t] = !0),
                        i(function() {
                          o[t] &&
                            (n ? e.apply(null, n) : e.call(null),
                            r.clearImmediate(t));
                        }),
                        t
                      );
                    }),
              (r.clearImmediate =
                "function" == typeof n
                  ? n
                  : function(e) {
                      delete o[e];
                    });
          }.call(this, e("timers").setImmediate, e("timers").clearImmediate));
        },
        { "process/browser.js": 331, timers: 332 }
      ]
    },
    {},
    [325]
  )(325);
});
